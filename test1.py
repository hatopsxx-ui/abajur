# -*- coding: utf-8 -*-



st_path=r'C:\STMOD'
new_path = st_path.replace("\\", "/")
st_path = new_path
st_cur_server='test'
language='TR'
extPath='G:\Data\Win32\loc'
pid='13260'
setpin=None
isGF = 0
stlevel=5
username=''
password=''
directLogin=0
ingameChannel=1
selectCharSlot=0
clientSlot=1
def find_string(string_to_search, substring):
	string_to_search_no_spaces = string_to_search.replace(" ", "").lower()
	substring_no_spaces = substring.replace(" ", "").lower()
	return string_to_search_no_spaces.find(substring_no_spaces) != -1
def open_file(filename, mode):
	if find_string(st_cur_server, "Eos"):
		try:
			import system
			return system.old_open(filename, mode)
		except:
			pass
	else:
		return open(filename, mode)
_chr = chr
uiToolTip = 0
uiFishGame = 0
uiCommonCaptcha = 0
uiMiniGameFishEvent = 0
thread = 0
game = 0
newPythonList = ["Invision", "everin", "velia", "kronius", "nextworld", "landofheroes","solaris"]
x64PythonList = ["SoW2", "Secret of World", "Sancy", "Zemia", "lucerna", "veshia","next2play","rhodium"]
try:
	any
except NameError:
	def any(iterable):
		for element in iterable:
			if element:
				return 1
		return 0
def formatNumber(n):
	s = str(int(n))
	parts = []
	while s:
		parts.insert(0, s[-3:])
		s = s[:-3]
	return ".".join(parts)
try:
	enumerate
except NameError:
	def enumerate(sequence, start=0):
		result = []
		i = start
		for elem in sequence:
			result.append((i, elem))
			i += 1
		return result
try:
	set
except NameError:

	class _MiniSet(dict):
		def __init__(self, iterable=None):
			dict.__init__(self)
			if iterable:
				for x in iterable:
					self[x] = True
		def add(self, x):
			self[x] = True
		def __iter__(self):
			return iter(self.keys())
		__contains__ = dict.__contains__
		__repr__	 = lambda self: 'set(%r)' % self.keys()
	def set(iterable=None):
		return _MiniSet(iterable)
except TypeError:
	def set(iterable):
		result = {}
		for item in iterable:
			result[item] = None
		return result.keys()
try:
	all
except NameError:
	def all(iterable):
		for item in iterable:
			if not item:
				return False
		return True
foundx64PythonList = any([find_string(st_cur_server, server) for server in x64PythonList])
foundNewPythonList = any([find_string(st_cur_server, server) for server in newPythonList])
def has_attribute(obj, attribute_name):
	return hasattr(obj, attribute_name)
if foundx64PythonList:
	import app
	import player as playerDefault
	import wndMgr
	import ui
	import os
	import chat, player, pygame, chrmgr, math, chr, sys, time, background, mouseModule, guild, effect, item, localeInfo, dbg, uiCommon, grp, textTail, game, uiToolTip, nonplayer, event
	import quest, shop, uiCharacter, uiTip, safebox
	import skill
	net2 = pygame.net.netStream
	from pygame.app import appInst
	from pygame.player import playerInst
	from pygame.net import netStream as net
	from pygame.item import ItemPosition
	from pygame.item import MakeItemPosition
	class PlayerWrapper:
		def __init__(self, player_instance):
			self.player_instance = player_instance
	
		
		
		def __getattr__(self, attr):
			if hasattr(self.player_instance, attr):
				return getattr(self.player_instance, attr)
			elif hasattr(playerDefault, attr):
				return getattr(playerDefault, attr)
			isDbg = 0
			if isDbg:
				msg("'PlayerWrapper' object has no attribute '{}'".format(attr))
			return None
	
	player = PlayerWrapper(pygame.player.playerInst())
	player.GetStatus = player.GetPoint
	player.GetItemIndex = playerDefault.GetItemIndex
	
	player.SetTarget = playerDefault.SetTarget
	player.GetItemIndex = playerDefault.GetItemIndex
	player.GetItemMetinSocket = playerDefault.GetItemMetinSocket
	player.INVENTORY_PAGE_SIZE = playerDefault.INVENTORY_PAGE_SIZE
	player.INVENTORY_PAGE_COUNT = playerDefault.INVENTORY_PAGE_COUNT
	player.GetItemCount = playerDefault.GetItemCount
	player.GetStatus = player.GetPoint
	player.HP = playerDefault.HP
	player.MAX_HP = playerDefault.MAX_HP
	player.SP = playerDefault.SP
	player.MAX_SP = playerDefault.MAX_SP
	player.EXP = playerDefault.EXP
	player.NEXT_EXP = playerDefault.NEXT_EXP
	player.LEVEL = playerDefault.LEVEL
	player.GetMainCharacterName = playerDefault.GetMainCharacterName
	player.RequestUseLocalQuickSlot = playerDefault.RequestUseLocalQuickSlot
	player.GetMainCharacterPosition = playerDefault.GetMainCharacterPosition
	player.SendDragonSoulRefine = playerDefault.SendDragonSoulRefine
	player.GetCharacterDistance = playerDefault.GetCharacterDistance
	player.SetSingleDIKKeyState = playerDefault.SetSingleDIKKeyState
	player.DIR_UP = playerDefault.DIR_UP
	player.IsSkillCoolTime = playerDefault.IsSkillCoolTime
	player.IsSkillActive = playerDefault.IsSkillActive
	player.IsMountingHorse = playerDefault.IsMountingHorse
	player.DRAGON_SOUL_PAGE_SIZE = playerDefault.DRAGON_SOUL_PAGE_SIZE
	player.DRAGON_SOUL_INVENTORY = playerDefault.DRAGON_SOUL_INVENTORY
	player.DS_SUB_HEADER_DO_UPGRADE = playerDefault.DS_SUB_HEADER_DO_UPGRADE
	
	
	
	wndMgr.SetHorizontalAlign = wndMgr.SetWindowHorizontalAlign
	wndMgr.SetVerticalAlign = wndMgr.SetWindowVerticalAlign
	wndMgr.TEXT_HORIZONTAL_ALIGN_CENTER = wndMgr.HORIZONTAL_ALIGN_CENTER
	wndMgr.TEXT_HORIZONTAL_ALIGN_LEFT = wndMgr.HORIZONTAL_ALIGN_LEFT
	wndMgr.TEXT_HORIZONTAL_ALIGN_RIGHT = wndMgr.HORIZONTAL_ALIGN_RIGHT
	wndMgr.TEXT_VERTICAL_ALIGN_TOP = wndMgr.VERTICAL_ALIGN_TOP
	wndMgr.TEXT_VERTICAL_ALIGN_CENTER = wndMgr.VERTICAL_ALIGN_CENTER
	wndMgr.TEXT_VERTICAL_ALIGN_BOTTOM = wndMgr.VERTICAL_ALIGN_BOTTOM
	
	# Update specific network functions based on server
	def setup_network_functions(app_instance, net_instance, net2_instance, server):
		if find_string(server, "lucerna") or find_string(server, "next2play"):
			
			new_name = 'NewNet'
			if hasattr(appInst, 'GetNet'):
				original_method = getattr(appInst, 'GetNet')
				setattr(appInst, new_name, original_method)
				delattr(appInst, 'GetNet')
			net_instance.DirectEnter = app_instance.NewNet().ConnectGameServer
			setattr(net2_instance, 'IsConnect', net_instance.IsGamePhase)
			# Bind new methods for custom server
			new_net = app_instance.NewNet()
			
		else:
			net_instance.DirectEnter = app_instance.GetNet().ConnectGameServer
			setattr(net2_instance, 'IsConnect', net_instance.IsGamePhase)
			# Bind default methods
			new_net = app_instance.GetNet()
		
	
		# Map common functions
		functions_to_map = [
			"SendOnClickPacket", "LogOutGame", "IsGamePhase", "IsConnect",
			"SendAnswerMakeGuildPacket", "SendGuildOfferPacket", "SendChatPacket",
			"SendItemMovePacket", "SendRefinePacket", "GetMainActorRace",
			"GetMainActorSkillGroup", "SendItemDestroyPacket", "SendGiveItemPacket",
			"SendShopSellPacket", "SendShopBuyPacket", "SendShopEndPacket", "SendWhisperPacket"
		]
		for func in functions_to_map:
			setattr(net_instance, func, getattr(new_net, func, None))
	
	setup_network_functions(appInst.instance(), net, net2, st_cur_server)
	app.Exit = appInst.instance().Exit
	# Chat and mouse module constants
	chat.CHAT_TYPE_TALKING = 0
	chat.CHAT_TYPE_SHOUT = 6
	mouseModule.mouseController.GetAttachedSlotNumber = mouseModule.mouseController.GetRealAttachedSlotNumber
	
elif find_string(st_cur_server, "kronius") or find_string(st_cur_server, "metin2sg") or find_string(st_cur_server, "poltia"):
	import app
	import wndMgr
	import ui
	try:
		import pygame,locale
	except:
		pass
	import chat,player,chrmgr,math,chr,sys,time,os,background,mouseModule,guild,effect,item,localeInfo,dbg,uiCommon,grp,textTail,game,uiToolTip,nonplayer,event
	import quest,shop,uiCharacter,uiTip,safebox,net
	import skill
	import random
	import exchange
	import os,pack,ime
	
elif find_string(st_cur_server, "sepherion"):
	import esipMod
	import binascii
	net = __import__(esipMod.getImp(binascii.hexlify("net")))
	app = __import__(esipMod.getImp(binascii.hexlify("app")))
	chrmgr = __import__(esipMod.getImp(binascii.hexlify("chrmgr")))
	chr = __import__(esipMod.getImp(binascii.hexlify("chr")))
	player = __import__(esipMod.getImp(binascii.hexlify("player")))
	import wndMgr
	import ui
	import chat,math,sys,time,background,mouseModule,guild,effect,item,localeInfo,dbg,uiCommon,grp,textTail,game,uiToolTip,nonplayer,event
	import quest,shop,uiCharacter,uiTip,safebox
	import skill
	import random
	import exchange
	import os,pack,ime
elif find_string(st_cur_server, "ledania"):
	import sys,time,os
	
	# Your existing function-to-module mapping.
	function_to_module = {
		'MBF_ATTACK': 'player',
		'DeleteInstanceByFade': 'chr',
		'GetNameByVID': 'chr',
		'SendBlackJackDrawPacket': 'net',
		'DisconnectUploader': 'net',
		'DirectEnter': 'net',
		'VK_X': 'app',
		'SetTwoHandedWeaponAttSpeedDecreaseValue': 'app',
		'DIK_X': 'app',
		'CursorImage': 'mouseModule',
		'mouseController': 'mouseModule',
		'AppendChat': 'chat',
		'ArrangeShowingChat': 'chat',
		'EnableSlotCoverImage': 'wndMgr',
		'AppendRequirementSignImage': 'wndMgr',
		'DeattachIcon': 'wndMgr',
		'GetCurrentMapName': 'background',
		'SetEmoticon': 'chrmgr',
		'GetAliasSockets': 'item',
		'ITEM_TYPE_POLYMORPH': 'item',
		'ArrangeTextTail': 'textTail',
		'SkillToolTip': 'uiToolTip',
		'GetGradeByVID': 'nonplayer',
		'GameWindow': 'game',
		'IsSoftwareCursor': 'systemSetting',
		'SelectAnswer': 'event',
		'ENVIRONMENT_NIGHT': 'constInfo',
		'SaveScreenShot': 'grp',
		'SetAroundCamera': 'grp',
		'GenerateFromHandle': 'grpImage',
		'LogBox': 'dbg',
		'DisableCaptureInput': 'ime',
		'GetSkillName': 'skill',
		'Exist': 'pack',
		'SetGeneralMotions': 'playerSettingModule',
		'PlaySound': 'snd',
		'IsOpen': 'shop',
		'SHOP_SLOT_COUNT': 'shop',
		'APP_TITLE': 'locale',
		'CharacterWindow': 'uiCharacter',
		'IsAtlas': 'miniMap',
		'InputDialog': 'uiCommon',
		'factorial': 'math',
		'BigBoard': 'uiTip',
		'AtlasWindow': 'uiMiniMap',
		'MARKADDR_DICT': 'serverInfo',
		'AniImageBox': 'ui',
		'SAFEBOX_PAGE_SIZE': 'safebox',
		'CreateEffect': 'effect',
		'GetQuestCount': 'quest',
		'AUTH_ADD_MEMBER': 'guild',
		'GetExceptionString': 'exception',
		'O_APPEND': 'os',
		'WRAPPER_ASSIGNMENTS': 'functools',
		'CaptchaDialog': 'captcha',
		'ChatLine': 'uichat',
		'InventoryWindow': 'uiinventory',
		'StopFishMovement': 'fishing',
		'SelectCharacterWindow': 'introSelect',
		'LoadingWindow': 'introLoading',
		'MainStream': 'networkModule',
		'CreateCharacterWindow': 'introCreate',
		'LoginWindow': 'introLogin',
		'SelectEmpireWindow': 'introEmpire',
		'uniform': 'random',
		'format_exception': 'traceback',
		'GetElkFromSelf': 'exchange',
		'InstancesList': 'eXLib',
		'FishGameWindow': 'uiFishGame',
		'CaptchaEkran': 'uiCommonCaptcha',
		'CaptchaScreen': 'uiCommonCaptcha',
		'PrivateShopBuilder': 'uiPrivateShopBuilder',
		'TOOLTIP_APPLY_ATTBONUS_HUMAN': 'localeInfo',
		'MiniGameFish': 'uiMiniGameFishEvent',
		'start_new_thread': 'thread',
		'Interface': 'interfaceModule',
		'DeliveryItem': 'biolog',
		'SendProvidesMaterialRequest': 'biologist',
		'RunMainScript': 'system',
	}
	
	
	modules_key = sys.modules.keys()
	modules_dic = sys.modules
	built_in = sys.builtin_module_names
	
	found_mod_objs = {}
	
	for mod in modules_key:
		if mod not in built_in:
	
			mod_obj = modules_dic.get(mod)
			if mod_obj is None:
				continue
	
			funcs = dir(mod_obj)
			for func in funcs:
				if func in function_to_module:
					expected_mod_name = function_to_module[func]
					if expected_mod_name not in found_mod_objs:
						found_mod_objs[expected_mod_name] = mod_obj
	
	for expected_mod_name in found_mod_objs:
		globals()[expected_mod_name] = found_mod_objs[expected_mod_name]
else:
	def HasArguments(module, attrlist):
		for attr in attrlist:
			if hasattr(module, attr):
				return attr
			prefixed_attr = 'myth01734' + attr
			if hasattr(module, prefixed_attr):
				return prefixed_attr
		return None
	import sys, time
	for modulename, module in iter(sys.modules.items()):
		if HasArguments(module, ['clock']):time = module
		if HasArguments(module, ['MBF_ATTACK']):player = module
		if find_string(st_cur_server, "portugalia"):
			if HasArguments(module, ['DeleteInstanceByFade']):chr = module		
		else:
			if HasArguments(module, ['GetNameByVID']):chr = module
		if find_string(st_cur_server, "Rubinum") or find_string(st_cur_server, "saphirus") or find_string(st_cur_server, "m2classic"):
			if HasArguments(module, ['SendBlackJackDrawPacket']):net = module
		elif find_string(st_cur_server, "oficial"):
			if HasArguments(module, ['DisconnectUploader']):net = module
		else:
			if HasArguments(module, ['DirectEnter']):net = module
		if find_string(st_cur_server, "land of heroes"):
			if HasArguments(module, ['VK_X']):app = module
		elif find_string(st_cur_server, "atheria"):
			if HasArguments(module, ['VK_X']):app = module
		elif find_string(st_cur_server, "oficial"):
			if HasArguments(module, ['SetTwoHandedWeaponAttSpeedDecreaseValue']):app = module
		else:
			if HasArguments(module, ['DIK_X']):app = module
		if find_string(st_cur_server, "Nw2Online") or find_string(st_cur_server, "nextworld"):
			if HasArguments(module, ['CursorImage']):mouseModule = module
		else:
			if HasArguments(module, ['mouseController']):mouseModule = module
		if find_string(st_cur_server, "nextworld"):
			if HasArguments(module, ['AppendChat']):chat = module
		else:
			if HasArguments(module, ['ArrangeShowingChat']):chat = module
		if find_string(st_cur_server, "Metin2BR"):
			if HasArguments(module, ['EnableSlotCoverImage']):wndMgr = module
		elif isGF:
			if HasArguments(module, ['AppendRequirementSignImage']):wndMgr = module
		else:
			if HasArguments(module, ['DeattachIcon']):wndMgr = module
		if HasArguments(module, ['GetCurrentMapName']):background = module
		if find_string(st_cur_server, "oficial"):
			import caracteru as chrmgr
		else:
			if HasArguments(module, ['SetEmoticon']):chrmgr = module
		if find_string(st_cur_server, "Eos"):
			if HasArguments(module, ['GetAliasSockets']):item = module
		else:
			if HasArguments(module, ['ITEM_TYPE_POLYMORPH']):item = module
		if HasArguments(module, ['ArrangeTextTail']):textTail = module
		if HasArguments(module, ['SkillToolTip']):uiToolTip = module
		if HasArguments(module, ['GetGradeByVID']):nonplayer = module
		if HasArguments(module, ['GameWindow']):game = module
		if HasArguments(module, ['IsSoftwareCursor']):systemSetting = module
		if HasArguments(module, ['SelectAnswer']):event = module
		if HasArguments(module, ['ENVIRONMENT_NIGHT']):constInfo = module
		if HasArguments(module, ['SaveScreenShot', 'SetAroundCamera']):grp = module
		if HasArguments(module, ['GenerateFromHandle']):grpImage = module
		if HasArguments(module, ['LogBox']):dbg = module
		if HasArguments(module, ['DisableCaptureInput']):ime = module
		if find_string(st_cur_server, "metin2sg"):
			import skill
		else:
			if HasArguments(module, ['GetSkillName']):skill = module
		if HasArguments(module, ['Exist']):pack = module
		if HasArguments(module, ['SetGeneralMotions']):playerSettingModule = module
		if HasArguments(module, ['PlaySound']):snd = module
		if isGF:
			if HasArguments(module, ['SHOP_SLOT_COUNT']):shop = module
		else:
			if HasArguments(module, ['IsOpen']):shop = module
		if HasArguments(module, ['APP_TITLE']):locale = module
		if HasArguments(module, ['CharacterWindow']):uiCharacter = module
		if HasArguments(module, ['IsAtlas']):miniMap = module
		if HasArguments(module, ['InputDialog']):uiCommon = module
		if HasArguments(module, ['factorial']):math = module
		if HasArguments(module, ['BigBoard']):uiTip = module
		if HasArguments(module, ['AtlasWindow']):uiMiniMap = module
		if HasArguments(module, ['MARKADDR_DICT']):serverInfo = module
		if find_string(st_cur_server, "Mt2Mester") and st_cur_server.find("Mt2MesterNext") == -1:
			if HasArguments(module, ['GetServerColorHex']):ui = module
		else:
			if HasArguments(module, ['AniImageBox']):ui = module
		if HasArguments(module, ['SAFEBOX_PAGE_SIZE']):safebox = module
		if HasArguments(module, ['CreateEffect']):effect = module
		if HasArguments(module, ['GetQuestCount']):quest = module
		if HasArguments(module, ['AUTH_ADD_MEMBER']):guild = module
		if HasArguments(module, ['GetExceptionString']):exception = module
		if HasArguments(module, ['O_APPEND']):os = module
		if HasArguments(module, ['WRAPPER_ASSIGNMENTS']):functools = module
		if HasArguments(module, ['CaptchaDialog']):captcha = module
		if HasArguments(module, ['ChatLine']):uichat = module
		if HasArguments(module, ['InventoryWindow']):uiinventory = module
		if HasArguments(module, ['StopFishMovement']):fishing = module
		if HasArguments(module, ['SelectCharacterWindow']):introSelect = module
		if HasArguments(module, ['LoadingWindow']):introLoading = module
		if HasArguments(module, ['MainStream']):networkModule = module
		if HasArguments(module, ['CreateCharacterWindow']):introCreate = module
		if HasArguments(module, ['LoginWindow']):introLogin = module
		if HasArguments(module, ['SelectEmpireWindow']):introEmpire = module
		if HasArguments(module, ['uniform']):random = module
		if HasArguments(module, ['ArrangeTextTail']):textTail = module
		if HasArguments(module, ['format_exception']):traceback = module
		if HasArguments(module, ['GetElkFromSelf']):exchange = module
		if HasArguments(module, ['InstancesList']):eXLib = module
		if HasArguments(module, ['FishGameWindow']):uiFishGame = module
		if HasArguments(module, ['CaptchaEkran']):uiCommonCaptcha = module
		if HasArguments(module, ['CaptchaScreen']):uiCommonCaptcha = module
		if HasArguments(module, ['PrivateShopBuilder']):uiPrivateShopBuilder = module
		if HasArguments(module, ['TOOLTIP_APPLY_ATTBONUS_HUMAN']):localeInfo = module
		if HasArguments(module, ['MiniGameFish']):uiMiniGameFishEvent = module
		if HasArguments(module, ['start_new_thread']):thread = module
		if HasArguments(module, ['Interface']):interfaceModule = module
		if HasArguments(module, ['DeliveryItem']):biolog = module
		if HasArguments(module, ['SendProvidesMaterialRequest']):biologist = module
		if HasArguments(module, ['RunMainScript']):system = module
		
if find_string(st_cur_server, "ironju"):
	if hasattr(system, 'OriginalSendChat'):
		net.SendChatPacket = system.OriginalSendChat
		
autoRemoveWalk = 0
try:
	if hasattr(constInfo, 'GetReg'):
		try:
			import uisecurity,lightwork
			autoRemoveWalk = 1
		except:
			pass
except:
	pass
def log_message(message):
	log_file = open_file("logfile.log", "a")
	log_file.write("[%s] %s\n" % (time.strftime("%Y-%m-%d %H:%M:%S"), message))
	log_file.close()
	
class AutoLogger(type):
	def __new__(cls, name, bases, dct):
		for attr_name, attr_value in dct.items():
			if callable(attr_value):
				def make_wrapper(method):
					def wrapper(self, *args, **kwargs):
						frame = sys._getframe(1)
						file_name = frame.f_code.co_filename
						line_number = frame.f_lineno
	
						log_message(
							"Called: %s.%s from %s:%d with args: %s, kwargs: %s" % (
								self.__class__.__name__,
								method.__name__,
								file_name,
								line_number,
								args,
								kwargs
							)
						)
						result = method(self, *args, **kwargs)
						log_message(
							"Returned: %s from %s.%s" % (
								result,
								self.__class__.__name__,
								method.__name__
							)
						)
						return result
					return wrapper
	
				dct[attr_name] = make_wrapper(attr_value)
		return super(AutoLogger, cls).__new__(cls, name, bases, dct)
def profiler(frame, event, arg):
	if event != "call":
		return
	
	code = frame.f_code
	function_name = code.co_name
	file_name = code.co_filename
	line_number = frame.f_lineno
	caller_frame = frame.f_back
	if caller_frame:
		caller_code = caller_frame.f_code
		caller_name = caller_code.co_name
		caller_file = caller_code.co_filename
		caller_line = caller_frame.f_lineno
		caller_info = "from %s function from %s:%d" % (caller_name, caller_file, caller_line)
	else:
		caller_info = "with no caller context"
	log_message("Called: %s %s" % (function_name, caller_info))
isDebug = 1
doHex = 1
if find_string(st_cur_server, "LegendofMetin"):
	isDebug = 0
try:
	current_dir = os.getcwd()
	files = os.listdir(current_dir)
	latest_file = None
	latest_time = 0
	for f in files:
		file_path = os.path.join(current_dir, f)
		if os.path.isfile(file_path):
			mod_time = os.path.getmtime(file_path)
			if mod_time > latest_time:
				latest_time = mod_time
				latest_file = f
	if latest_file:
		script_name = latest_file 
		if script_name == "st":
			doHex = 0
	if find_string("F:/st", st_path):
		doHex = 0
except:
	pass
def encrypt(data):
	try:
		key = "_z,Bzi8k1.Nc:7/q_aNz_y,0_LQtqS"
		key_length = len(key)
		result = []
		
		
		for i in range(len(data)):
			
			if isinstance(data[i], str):
				byte = ord(data[i])
			else:
				byte = data[i]
			xor_byte = byte ^ ord(key[i % key_length])
			result.append("%02x" % xor_byte)
		
		return "".join(result)
	except:
		return None
def decrypt(hex_data):
	key = "_z,Bzi8k1.Nc:7/q_aNz_y,0_LQtqS"
	key_length = len(key)
	result = []
	
	if " -> " in hex_data:
		hex_data = hex_data.split(" -> ", 1)[1]
	
	hex_data = hex_data.strip()
	
	if len(hex_data) % 2 != 0:
		return "[Error] Invalid hex length"
	
	try:
	
		data = [int(hex_data[i:i+2], 16) for i in range(0, len(hex_data), 2)]
	
		for i in range(len(data)):
			xor_byte = data[i] ^ ord(key[i % key_length])
			result.append(chr(xor_byte))
	
		return "".join(result)
	except ValueError:
		return "[Error] Invalid hex data"
if isDebug:
	# __metaclass__ = AutoLogger
	# sys.setprofile(profiler)
	import sys
	import traceback
	def handle_exception(exc_type, exc_value, exc_traceback):
		current_time = time.strftime("%y/%m/%d %H:%M", time.localtime(int(app.GetGlobalTimeStamp())))
		error_message = "".join(traceback.format_exception(exc_type, exc_value, exc_traceback))
		log_message = "%s :: %s" % (current_time, error_message)
		logFile = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + 'errorLog.log'
		f = open_file(str(logFile), 'a')
		
		if doHex:
			time_string = time.strftime("%d.%m.%Y, %H:%M:%S")
			f.write(time_string + " -> " + encrypt(str(log_message)) + '\n')
		else:
			f.write(log_message + '\n')
		f.close()
	
	sys.excepthook = handle_exception
else:
	try:
		sys.excepthook = sys.__excepthook__
	except:
		pass
if isGF:
	try:
		import eXLib
	except:
		pass
	if not 'eXLib' in globals():
		dbg.LogBox("An error occured!\n\nOnly inject \x53\x54\x4d\x6f\x64 before logging in (Inject, wait for the 'Load \x53\x54\x4d\x6f\x64' button to pop-up, wait ~10 seconds, then log in.\n\n\nPlease restart the client,\n\x53\x54\x4d\x6f\x64 cannot work correctly with current state.", "\x53\x54\x4d\x6f\x64")
		
	
	def SetSingleDIKKeyState(key,state):
		if state == 1:
			player.OnKeyDown(key)
		else:
			player.OnKeyUp(key)
	
	def SetAttackKeyState(state):
		if state == 1:
			player.OnKeyDown(app.DIK_SPACE)
		else:
			player.OnKeyUp(app.DIK_SPACE)
	
	setattr(chr, 'GetPixelPosition', eXLib.GetPixelPosition)
	setattr(chr, 'MoveToDestPosition', eXLib.MoveToDestPosition)
	setattr(player, 'SetSingleDIKKeyState', SetSingleDIKKeyState)
	setattr(player, 'SetAttackKeyState', SetAttackKeyState)
		
if foundx64PythonList:
	movplable = 'moveable'
else:
	movplable = 'movable'
	
def HasInstance(vid):
	if find_string(st_cur_server, "mein"):
		return 1
	else:
		return chr.HasInstance(vid)
	
if find_string(st_cur_server, "honor"):
	net.SendExchangeAcceptPacket = net.SendExchangeAcceptPacket_Module	
if find_string(st_cur_server, "loranda"):
	player.SetSingleDIKKeyState = player.SetSingleDIKKeyStateNew
try:
	if hasattr(player, 'GMCI'):
		player.GetTargetVID = player.GTV
		player.GetMainCharacterIndex = player.GMCI
		player.GetStatus = player.GST
		player.GetRace = player.GR
		chr.GetRace = chr.GR
		chr.IsGameMaster = chr.IGM
		chr.MoveToDestPosition = chr.MTDP
		chr.SetPixelPosition = chr.SPP
except:
	pass
if find_string(st_cur_server, "SurvivoM2"):
	player_functions = [
		'ClearTarget', 'ClickSkillSlot', 'ComboAttack', 'GetCharacterDistance', 'GetCheque',
		'GetEXP', 'GetElk', 'GetGem', 'GetGlobalQuickSlot', 'GetGuildID', 'GetGuildName',
		'GetISellItemPrice', 'GetItemAttribute', 'GetItemCount', 'GetItemCountByVnum',
		'GetItemFlags', 'GetItemGrade', 'GetItemIndex', 'GetItemLink', 'GetItemMetinSocket',
		'GetItemSealDate', 'GetItemSubTypeBySlot', 'GetItemTransmutation', 'GetItemTypeBySlot',
		'GetItemUnSealLeftTime', 'GetJob', 'GetLevel', 'GetLocalQuickSlot', 'GetMainCharacterIndex',
		'GetMainCharacterName', 'GetMainCharacterPosition', 'GetMoney', 'GetMouseFunc', 'GetName',
		'GetPKMode', 'GetPartyMemberAffects', 'GetPartyMemberHPPercentage', 'GetPartyMemberState',
		'GetPlayTime', 'GetQuickPage', 'GetRace', 'GetSkillCoolTime', 'GetSkillCurrentEfficientPercentage',
		'GetSkillGrade', 'GetSkillIndex', 'GetSkillLevel', 'GetSkillNextEfficientPercentage',
		'GetSkillSlotIndex', 'GetStatus', 'GetTargetVID', 'HP', 'HP_RECOVERY', 'HT',
		'HasMobilePhoneNumber', 'HasOfflineShop', 'HidePlayer', 'INVENTORY', 'INVENTORY_PAGE_COLUMN',
		'INVENTORY_PAGE_COUNT', 'INVENTORY_PAGE_ROW', 'INVENTORY_PAGE_SIZE', 'INVENTORY_SLOT_COUNT',
		'IQ', 'ITEM_CHEQUE', 'ITEM_MONEY', 'IsActingEmotion', 'IsAntiFlagBySlot', 'IsAvailableBeltInventoryCell',
		'IsBeltInventorySlot', 'IsCantFightInstance', 'IsChallengeInstance', 'IsCostumeSlot', 'IsDSEquipmentSlot',
		'IsEquipmentSlot', 'IsEquippingBelt', 'IsGiftBoxInventorySlot', 'IsInSafeArea', 'IsMainCharacterIndex',
		'IsMountingHorse', 'IsObserverMode', 'IsOpenPrivateShop', 'IsPVPInstance', 'IsPartyLeader',
		'IsPartyLeaderByPID', 'IsPartyMember', 'IsRefineGradeScroll', 'IsRevengeInstance', 'IsSameEmpire',
		'IsSameItemVnum', 'IsSkillActive', 'IsSkillBookInventorySlot', 'IsSkillCoolTime', 'IsStoneInventorySlot',
		'IsUpgradeItemsInventorySlot', 'IsValuableItem', 'LocalQuickSlotIndexToGlobalQuickSlotIndex',
		'MoveItem', 'OpenCharacterMenu', 'PickCloseItem', 'PickCloseItemVector', 'RegisterCacheEffect',
		'RegisterEffect', 'RegisterEmotionIcon', 'RemovePartyMember', 'RemoveQuickSlotByValue', 'Render',
		'RequestAddLocalQuickSlot', 'RequestAddToEmptyLocalQuickSlot', 'RequestDeleteGlobalQuickSlot',
		'RequestMoveGlobalQuickSlotToLocalQuickSlot', 'RequestUseLocalQuickSlot', 'ResetCameraRotation',
		'SendClickItemPacket', 'SendDragonSoulRefine', 'SetAttackKeyState', 'SetAutoCameraRotationSpeed',
		'SetAutoPotionInfo', 'SetGameWindow', 'SetItemAttribute', 'SetItemCount', 'SetItemData',
		'SetItemMetinSocket', 'SetMainCharacterIndex', 'SetMouseFunc', 'SetMouseMiddleButtonState',
		'SetMouseState', 'SetPlayTime', 'SetQuickCameraMode', 'SetQuickPage', 'SetSingleDIKKeyState',
		'SetSkill', 'SetStatus', 'SetTarget','MAX_HP','HP','HP_RECOVERY','LEVEL'
	]
	for func_name in player_functions:
		prefixed_func_name = 'myth01734' + func_name
		if hasattr(player, prefixed_func_name):
			setattr(player, func_name, getattr(player, prefixed_func_name))
try:
	Pick = textTail.Pick
except:
	pass
def selectItem(idx):
	if find_string(st_cur_server, "oficial"):
		return item.SelectareItem(98, 16, 888, idx)
	else:
		return item.SelectItem(idx)
		
def setTarget(vid):
	try:
		
		player.SetTarget(int(vid))
	except:
		pass
		
def sendRefinePacket(slot, type, *args):
	if find_string(st_cur_server, "zenit"):
		net.SendRefinePacket(1, slot, type)
	else:
		net.SendRefinePacket(slot, type, args)
		
def clickPacket(vid):
	if find_string(st_cur_server, "oficial"):
		return net.SendOnClickPacket(vid, oficialARG)
	else:
		return net.SendOnClickPacket(vid)
def SendWhisper(name, msg):
	global isGF
	if isGF:
		net.SendWhisperPacket(name, msg, 9)
	elif find_string(st_cur_server, "calliope"):
		CH_NOW = net.GetServerInfo()
		CH = CH_NOW[-4:]
		if constInfo.selected_server == 2:
			if chat.CheckName(name) == 1 and chat.CheckLine(msg.replace(" ", "")) == 1:
				net.SendWhisper(name, "|cFF75FF33[SV2]Lv" + str(player.GetStatus(player.LEVEL)) + "|r" + CH + " : " + msg)
				constInfo.whisper_allow = 1
			else:
				if CH != "eral":
					net.SendWhisperPacket(name, "|cFF75FF33[SV2]Lv" + str(player.GetStatus(player.LEVEL)) + "|r" + CH + " : " + msg)
				else:
					net.SendWhisperPacket(name, "|cFF75FF33[SV2]Lv" + str(player.GetStatus(player.LEVEL)) + "|r" + " CH1" + " : " + msg)				
		else:
			if chat.CheckName(name) == 1 and chat.CheckLine(msg.replace(" ", "")) == 1:
				net.SendWhisper(name, "|cFF75FF33[SV1]Lv" + str(player.GetStatus(player.LEVEL)) + "|r" + CH + " : " + msg)
				constInfo.whisper_allow = 1
			else:
				if CH != "eral":
					net.SendWhisperPacket(name, "|cFF75FF33[SV1]Lv" + str(player.GetStatus(player.LEVEL)) + "|r" + CH + " : " + msg)
				else:
					net.SendWhisperPacket(name, "|cFF75FF33[SV1]Lv" + str(player.GetStatus(player.LEVEL)) + "|r" + " CH1" + " : " + msg)
	else:
		net.SendWhisperPacket(name, msg)
def getCamRot():
	global isGF
	if isGF:
		return app.GetCamera()[2]
	else:
		if hasattr(app, 'GetCameraRotation'):
			return app.GetCameraRotation()
		else:
			if hasattr(app, 'GetCamera'):
				return app.GetCamera()[2]
excludeItem = 0
itemFirst = 1
blockItems = 1
pickRange = 2500
time_Settings_pickUpTimer = 0
whRange = 2500
whSpeed = 333
whMonsters = 15
wallhack = 0
avoidPlayers = 1
metinType = 2
playerType = 6
oreType = 1
npcType = 1
mobType = 0
if find_string(st_cur_server, "enyro") or find_string(st_cur_server, "lunor"):
	metinType += 1
	playerType += 1
	oreType += 1
	npcType += 1
	mobType += 1
prev_key_states = {}
def getKeyCode(key):
	if hasattr(app, 'DIK_' + key):
		return getattr(app, 'DIK_' + key)
	elif hasattr(app, 'VK_' + key):
		return getattr(app, 'VK_' + key)
	return None
oldPython = 0	
try:
	if sys.version_info < (2, 3):
		exec("True = 1 == 1")
		exec("False = not True")
		oldPython = 1
	else:
		oldPython = 0
except:
	pass
def isKeyPress(key):
	global prev_key_states
	
	key_code = getKeyCode(key)
	# msg(key_code)
	if key_code is None:
		return False
	
	is_pressed = app.IsPressed(key_code)
	if is_pressed and not prev_key_states.get(key_code, False):
		prev_key_states[key_code] = is_pressed
		return True
	prev_key_states[key_code] = is_pressed
	return False
	
def isKeyPressed(key):
	if hasattr(app, 'DIK_' + key):
		return app.IsPressed(getattr(app, 'DIK_' + key))
	elif hasattr(app, 'VK_' + key):
		return app.IsPressed(getattr(app, 'VK_' + key))
	else:
		return False
	
def appKey(key):
	if hasattr(app, 'DIK_' + key):
		return getattr(app, 'DIK_' + key)
	elif hasattr(app, 'VK_' + key):
		return getattr(app, 'VK_' + key)
	else:
		return False
try:
	def msg(asd):
		global streamer
		if streamer == 0:
			txt = str(asd)
			if "PANIC: Enabled!" in txt:
				return chat.AppendChat(3, "|cffFF4444PANIC: ON")
			elif "PANIC: Disabled!" in txt:
				return chat.AppendChat(3, "|cff44FF44PANIC: OFF")
except:
	pass
if find_string(st_cur_server, "Star2") or find_string(st_cur_server, "arthur"):
	chr.SetPixelPosition = chr.SetPixelHikocan
if find_string(st_cur_server, "WoM2"):
	try:
		net.SendOnClickPacket = player.SendOnClickActorPacket
	except:
		pass
		
if find_string(st_cur_server, "Esenn"):
	try:
		net.SendShopSellPacketNew = net.SendItemDropSellPacket
		net.SendShopSellPacket = net.SendItemDropSellPacket
	except:
		pass
if find_string(st_cur_server, "Rohan"):
	try:
		import wndMgr
	except:
		pass
		
newPython = 0	
try:
	if sys.version_info > (2, 8):
		newPython = 1
	else:
		newPython = 0
except:
	pass	
try:
	import serverInfo
except:
	pass
if oldPython:
	try:
		import math
	except:
		pass
try:
	sorted
except NameError:
	def sorted(iterable, key=None, reverse=False):
		sorted_list = list(iterable)
		if key is not None:
			sorted_list.sort(lambda a, b: cmp(key(a), key(b)))
		else:
			sorted_list.sort()
		
		if reverse:
			sorted_list.reverse()
		
		return sorted_list
	
try:
	def string_contains(str1, str2):
		if sys.version_info < (2, 7):
			return str1.find(str2) != -1
		else:
			return str1 in str2
except:
	pass
try:
	def map_contains(str1, str2):
		if sys.version_info < (2, 7):
			return str2.find(str1) != -1
		else:
			return str1 in str2
except:
	pass
if find_string(st_cur_server, "Nw2Online") or find_string(st_cur_server, "nextworld"):
	ymir = 'd:/worktree/'
else:
	ymir = 'd:/ymir work/'
if find_string(st_cur_server, "nextworld"):
	playerMark = "d:/worktree/ui/minimap/playermark.slc"
else:
	playerMark = ymir + 'ui/minimap/playermark.sub'
	
	
if foundNewPythonList:
	class Lang:
		def __init__(self, language):
			self.language = language
			self.translations = {}
			self.load_locale_file()
		def __getattr__(self, attr):
			return self.get_translation(attr)
		def load_locale_file(self):
			lang_file = st_path + "\\Data\\Languages\\%s_PYTHON.txt" % (self.language)
			try:
				file = open_file(lang_file, "r+")
				content = file.read()
				file.close()
				lines = content.splitlines()
			except IOError:
				dbg.LogBox("Move \x53\x54\x4d\x6f\x64 folder to other path, such as \x43\x3a\x5c\x53\x54\x4d\x6f\x64\nBecause your current path contains special characters.", "Language Error")
				return
			for line in lines:
				tokens = line.split('=')
				if len(tokens) >= 2:
					key = tokens[0].strip()
					value = tokens[1].strip()
					self.translations[key] = value
		def get_translation(self, key):
			return self.translations.get(key, key)
	lang = Lang(language)
else:
	class lang:
		def LoadLocaleFile(srcFileName, localeDict):
			try:
				lines = open_file(srcFileName, "r+").readlines()
			except IOError:
				dbg.LogBox("Move \x53\x54\x4d\x6f\x64 folder to other path, such as \x43\x3a\x5c\x53\x54\x4d\x6f\x64\nBecause your current path contains special characters.", "Language Error")
				app.Abort()
			for line in lines:
				tokens = line[:-1].split("=")
				if len(tokens) >= 2:
					localeDict[tokens[0]] = tokens[1]			
				else:
					print(len(tokens), lines.index(line), line)
		LoadLocaleFile(st_path + "\\Data\\Languages\\%s_PYTHON.txt" % language, locals())
try:
	def IsARABIC():
		if find_string(st_cur_server, "metin3"):
			return False
		else:
			if string_contains('ae', app.GetLocalePath()):
				return True
			return False
except:
	try:
		__IS_ARABIC = "locale/ae" == app.GetLocalePath()
		def IsARABIC():
			global __IS_ARABIC
			return __IS_ARABIC
	except:
		pass
if find_string(st_cur_server, "SG"):
	try:
		import item, player, game, net
	except:
		pass
currentStatus = None
try:
	if hasattr(net, 'GetMainActorEmpire35'):
		net.Disconnect = net.Disconnect36
		net.GetEmpireID = net.GetEmpireID35
		net.GetMainActorEmpire = net.GetMainActorEmpire35
		net.GetMainActorRace = net.GetMainActorRace35
		net.GetMainActorVID = net.GetMainActorVID35
		net.GetServerInfo = net.GetServerInfo34
		net.IsConnect = net.IsConnect36
		net.SendCharacterPositionPacket = net.SendCharacterPositionPacket36
		net.SendGiveItemPacket = net.SendGiveItemPacket36
		net.SendGoldDropPacketNew = net.SendGoldDropPacketNew36
		net.GetMainActorSkillGroup = net.GetMainActorSkillGroup35
		net.SendChatPacket = net.SendChatPacket36
		net.SendGiveItemPacket = net.SendGiveItemPacket36
		net.SendItemDestroyPacket = net.SendItemDestroyPacket36
		net.SendItemDropPacket = net.SendItemDropPacket36
		net.SendItemDropPacketNew = net.SendItemDropPacketNew36
		net.SendItemMovePacket = net.SendItemMovePacket36
		net.SendItemPickUpPacket = net.SendItemPickUpPacket36
		net.SendItemUsePacket = net.SendItemUsePacket36
		net.SendItemUseToItemPacket = net.SendItemUseToItemPacket36
		net.SendWhisperPacket = net.SendWhisperPacket36
		item.GetIconImage = item.GetIconImage99
		item.GetIconImageFileName = item.GetIconImageFileName99
		item.GetItemName = item.GetItemName99
		item.GetItemSize = item.GetItemSize99
		item.GetItemSubType = item.GetItemSubType99
		item.GetItemType = item.GetItemType99
		item.GetVnum = item.GetVnum99
		item.SelectItem = item.SelectItem99
		player.GetMainCharacterIndex = player.GetMainCharacterIndex21
		player.GetMainCharacterName = player.GetMainCharacterName21
		player.GetMainCharacterPosition = player.GetMainCharacterPosition21
		player.GetName = player.GetName21
		player.GetSkillCoolTime = player.GetSkillCoolTime23
		player.GetStatus = player.GetStatus23
		player.GetTargetVID = player.GetTargetVID24
		player.IsSkillActive = player.IsSkillActive23
		player.IsSkillCoolTime = player.IsSkillCoolTime23
		player.SendDragonSoulRefine = player.SendDragonSoulRefine24
		player.GetEXP = player.GetEXP23
		player.GetRace = player.GetRace21
		chat.AppendChat = chat.AppendChat33
		chr.GetInstanceType = chr.GetInstanceType11
		chr.GetName = chr.GetName11
		chr.GetNameByVID = chr.GetNameByVID11
		chr.GetPixelPosition = chr.GetPixelPosition11
		chr.GetRace = chr.GetRace11
		chr.GetVirtualNumber = chr.GetVirtualNumber11
		chr.HasInstance = chr.HasInstance11
		chr.IsEnemy = chr.IsEnemy11
		chr.MoveToDestPosition = chr.MoveToDestPosition11
		chr.SelectInstance = chr.SelectInstance11
		chr.SetAttackSpeed = chr.SetAttackSpeed11
		chr.SetMoveSpeed = chr.SetMoveSpeed11
		chr.SetPixelPosition = chr.SetPixelPosition11
except:
	pass
key1 = False
key2 = False
key3 = False
key4 = False
keyf1 = False
keyf2 = False
keyf3 = False
keyf4 = False
dungeonState = False
if find_string(st_cur_server, "Revenant") or find_string(st_cur_server, "melorin"):
	large1 = ymir + 'ui/public/Large_Button_01.png'
	large2 = ymir + 'ui/public/Large_Button_02.png'
	large3 = ymir + 'ui/public/Large_Button_03.png'
	if find_string(st_cur_server, "melorin"):
		middle1 = ymir + 'ui/public/Middle_Button_01.png'
		middle2 = ymir + 'ui/public/Middle_Button_02.png'
		middle3 = ymir + 'ui/public/Middle_Button_03.png'
	else:
		middle1 = ymir + 'ui/public/middle_button_01.sub'
		middle2 = ymir + 'ui/public/middle_button_02.sub'
		middle3 = ymir + 'ui/public/middle_button_03.sub'
	small1 = ymir + 'ui/public/Small_Button_01.png'
	small2 = ymir + 'ui/public/Small_Button_02.png'
	small3 = ymir + 'ui/public/Small_Button_03.png'
	tablarge1 = ymir + 'ui/public/Large_Button_01.png'
	tablarge2 = ymir + 'ui/public/Large_Button_02.png'
	tablarge3 = ymir + 'ui/public/Large_Button_03.png'
	slot_base = ymir + 'ui/public/Slot_Base.sub'
	qmark1 = ymir + 'ui/pattern/q_mark_01.tga'
	qmark2 = ymir + 'ui/pattern/q_mark_02.tga'
	close1 = ymir + 'ui/public/close_button_01.sub'
	close2 = ymir + 'ui/public/close_button_02.sub'
	close3 = ymir + 'ui/public/close_button_03.sub'
	refresh1 = ymir + 'ui/game/guild/refresh_button_01.sub'
	refresh2 = ymir + 'ui/game/guild/refresh_button_02.sub'
	refresh3 = ymir + 'ui/game/guild/refresh_button_03.sub'
	plus1 = ymir + 'ui/game/windows/btn_plus_up.sub'
	plus2 = ymir + 'ui/game/windows/btn_plus_over.sub'
	plus3 = ymir + 'ui/game/windows/btn_plus_down.sub'
	minus1 = ymir + 'ui/game/windows/btn_minus_up.sub'
	minus2 = ymir + 'ui/game/windows/btn_minus_over.sub'
	minus3 = ymir + 'ui/game/windows/btn_minus_down.sub'
	xmall1 = ymir + 'ui/public/xsmall_button_01.sub'
	xmall2 = ymir + 'ui/public/xsmall_button_02.sub'
	xmall3 = ymir + 'ui/public/xsmall_button_03.sub'
elif find_string(st_cur_server, "Nw2Online") or find_string(st_cur_server, "aronix"):
	large1 = st_path + '/Data/rascal2/img/buttons/large1.tga'
	large2 = st_path + '/Data/rascal2/img/buttons/large2.tga'
	large3 = st_path + '/Data/rascal2/img/buttons/large3.tga'
	middle1 = st_path + '/Data/rascal2/img/buttons/middle1.tga'
	middle2 = st_path + '/Data/rascal2/img/buttons/middle2.tga'
	middle3 = st_path + '/Data/rascal2/img/buttons/middle3.tga'
	small1 = st_path + '/Data/rascal2/img/buttons/small1.tga'
	small2 = st_path + '/Data/rascal2/img/buttons/small2.tga'
	small3 = st_path + '/Data/rascal2/img/buttons/small3.tga'
	tablarge1 = st_path + '/Data/rascal2/img/buttons/tab1.tga'
	tablarge2 = st_path + '/Data/rascal2/img/buttons/tab2.tga'
	tablarge3 = st_path + '/Data/rascal2/img/buttons/tab3.tga'
	slot_base = st_path + '/Data/rascal2/img/buttons/slot_base.tga'
	qmark1 = st_path + '/Data/rascal2/img/buttons/q_mark_01.tga'
	qmark2 = st_path + '/Data/rascal2/img/buttons/q_mark_02.tga'
	close1 = st_path + '/Data/rascal2/img/buttons/close1.tga'
	close2 = st_path + '/Data/rascal2/img/buttons/close2.tga'
	close3 = st_path + '/Data/rascal2/img/buttons/close3.tga'
	refresh1 = st_path + '/Data/rascal2/img/buttons/refresh1.tga'
	refresh2 = st_path + '/Data/rascal2/img/buttons/refresh2.tga'
	refresh3 = st_path + '/Data/rascal2/img/buttons/refresh3.tga'
	plus1 = st_path + '/Data/rascal2/img/buttons/plus1.tga'
	plus2 = st_path + '/Data/rascal2/img/buttons/plus2.tga'
	plus3 = st_path + '/Data/rascal2/img/buttons/plus3.tga'
	minus1 = st_path + '/Data/rascal2/img/buttons/minus1.tga'
	minus2 = st_path + '/Data/rascal2/img/buttons/minus2.tga'
	minus3 = st_path + '/Data/rascal2/img/buttons/minus3.tga'
	xmall1 = st_path + '/Data/rascal2/img/buttons/xmall1.tga'
	xmall2 = st_path + '/Data/rascal2/img/buttons/xmall2.tga'
	xmall3 = st_path + '/Data/rascal2/img/buttons/xmall3.tga'
elif find_string(st_cur_server, "nextworld"):
	large1 = 'd:/worktree/ui/_ui_nextworld2/public/large_button_01.slc'
	large2 = 'd:/worktree/ui/_ui_nextworld2/public/large_button_02.slc'
	large3 = 'd:/worktree/ui/_ui_nextworld2/public/large_button_03.slc'
	middle1 = 'd:/worktree/ui/_ui_nextworld2/public/middle_button_01.slc'
	middle2 = 'd:/worktree/ui/_ui_nextworld2/public/middle_button_02.slc'
	middle3 = 'd:/worktree/ui/_ui_nextworld2/public/middle_button_03.slc'
	small1 = 'd:/worktree/ui/_ui_nextworld2/public/small_button_01.slc'
	small2 = 'd:/worktree/ui/_ui_nextworld2/public/small_button_02.slc'
	small3 = 'd:/worktree/ui/_ui_nextworld2/public/small_button_03.slc'
	tablarge1 = 'd:/worktree/ui/_ui_nextworld2/public/large_button_01.slc'
	tablarge2 = 'd:/worktree/ui/_ui_nextworld2/public/large_button_02.slc'
	tablarge3 = 'd:/worktree/ui/_ui_nextworld2/public/large_button_03.slc'
	qmark1 = "d:/worktree/ui/_ui_nextworld2/public/checkbox_small_base.slc"
	qmark2 = "d:/worktree/ui/_ui_nextworld2/public/checkbox_small_base.slc"
	close1 = 'd:/worktree/ui/_ui_nextworld2/public/close_button_01.slc'
	close2 = 'd:/worktree/ui/_ui_nextworld2/public/close_button_02.slc'
	close3 = 'd:/worktree/ui/_ui_nextworld2/public/close_button_03.slc'
	refresh1 = small1
	refresh2 = small2
	refresh3 = small3
	plus1 = "d:/worktree/ui/_ui_nextworld2/public/checkbox_small_base.slc"
	plus2 = "d:/worktree/ui/_ui_nextworld2/public/checkbox_small_base.slc"
	plus3 = "d:/worktree/ui/_ui_nextworld2/public/checkbox_small_base.slc"
	minus1 = 'd:/worktree/ui/_ui_nextworld2/public/checkbox_small_base.slc'
	minus2 = 'd:/worktree/ui/_ui_nextworld2/public/checkbox_small_base.slc'
	minus3 = 'd:/worktree/ui/_ui_nextworld2/public/checkbox_small_base.slc'
	xmall1 = small1
	xmall2 = small2
	xmall3 = small3
	slot_base = "d:/worktree/ui/_ui_nextworld2/public/slot_base.slc"
else:
	if find_string(st_cur_server, "atheria"):
		large1 = ymir + 'ui/public/middle_button_01.sub'
		large2 = ymir + 'ui/public/middle_button_02.sub'
		large3 = ymir + 'ui/public/middle_button_03.sub'
	else:
		large1 = ymir + 'ui/public/large_button_01.sub'
		large2 = ymir + 'ui/public/large_button_02.sub'
		large3 = ymir + 'ui/public/large_button_03.sub'
		
	if find_string(st_cur_server, "melia"):
		middle1 = 'd:/ymir work/ui/game/option/option_button_thin_norm.tga'
		middle2 = 'd:/ymir work/ui/game/option/option_button_thin_hover.tga'
		middle3 = 'd:/ymir work/ui/game/option/option_button_thin_down.tga'
	else:
		middle1 = ymir + 'ui/public/middle_button_01.sub'
		middle2 = ymir + 'ui/public/middle_button_02.sub'
		middle3 = ymir + 'ui/public/middle_button_03.sub'
	if find_string(st_cur_server, "atheria"):
		small1 = ymir + 'ui/public/middle_button_01.sub'
		small2 = ymir + 'ui/public/middle_button_02.sub'
		small3 = ymir + 'ui/public/middle_button_03.sub'
	elif find_string(st_cur_server, "melia"):
		small1 = 'd:/ymir work/buttons/butonmic1.tga'
		small2 = 'd:/ymir work/buttons/butonmic2.tga'
		small3 = 'd:/ymir work/buttons/butonmic3.tga'
	else:
		small1 = ymir + 'ui/public/small_button_01.sub'
		small2 = ymir + 'ui/public/small_button_02.sub'
		small3 = ymir + 'ui/public/small_button_03.sub'
	if find_string(st_cur_server, "Alaska") or find_string(st_cur_server, "alestia"):
		tablarge1 = ymir + 'ui/public/large_button_01.sub'
		tablarge2 = ymir + 'ui/public/large_button_02.sub'
		tablarge3 = ymir + 'ui/public/large_button_03.sub'
	elif find_string(st_cur_server, "atheria"):
		tablarge1 = ymir + 'ui/public/middle_button_01.sub'
		tablarge2 = ymir + 'ui/public/middle_button_02.sub'
		tablarge3 = ymir + 'ui/public/middle_button_03.sub'
	else:
		tablarge1 = ymir + 'ui/game/windows/tab_button_large_01.sub'
		tablarge2 = ymir + 'ui/game/windows/tab_button_large_02.sub'
		tablarge3 = ymir + 'ui/game/windows/tab_button_large_03.sub'
	if find_string(st_cur_server, "zaris") or find_string(st_cur_server, "hunter") or find_string(st_cur_server, "arezzo"):
		
		close1 = st_path + '/Data/rascal2/img/buttons/close1.tga'
		close2 = st_path + '/Data/rascal2/img/buttons/close2.tga'
		close3 = st_path + '/Data/rascal2/img/buttons/close3.tga'
	else:
	
		close1 = ymir + 'ui/public/close_button_01.sub'
		close2 = ymir + 'ui/public/close_button_02.sub'
		close3 = ymir + 'ui/public/close_button_03.sub'
	if find_string(st_cur_server, "dark") or find_string(st_cur_server, "wom") or find_string(st_cur_server, "velium") or find_string(st_cur_server, "attomey") or find_string(st_cur_server, "remastered") or find_string(st_cur_server, "optimize"):
		qmark1 = 'rascal2/img/buttons/q_mark_01.tga'
		qmark2 = 'rascal2/img/buttons/q_mark_02.tga'
	else:
		qmark1 = ymir + 'ui/pattern/q_mark_01.tga'
		qmark2 = ymir + 'ui/pattern/q_mark_02.tga'
	
	if find_string(st_cur_server, "luminus"):
		refresh1 = ymir + 'ui/public/close_button_01.sub'
		refresh2 = ymir + 'ui/public/close_button_02.sub'
		refresh3 = ymir + 'ui/public/close_button_03.sub'
	else:
		refresh1 = ymir + 'ui/game/guild/refresh_button_01.sub'
		refresh2 = ymir + 'ui/game/guild/refresh_button_02.sub'
		refresh3 = ymir + 'ui/game/guild/refresh_button_03.sub'
	plus1 = ymir + 'ui/game/windows/btn_plus_up.sub'
	plus2 = ymir + 'ui/game/windows/btn_plus_over.sub'
	plus3 = ymir + 'ui/game/windows/btn_plus_down.sub'
	minus1 = ymir + 'ui/game/windows/btn_minus_up.sub'
	minus2 = ymir + 'ui/game/windows/btn_minus_over.sub'
	minus3 = ymir + 'ui/game/windows/btn_minus_down.sub'
	xmall1 = ymir + 'ui/public/xsmall_button_01.sub'
	xmall2 = ymir + 'ui/public/xsmall_button_02.sub'
	xmall3 = ymir + 'ui/public/xsmall_button_03.sub'
	slot_base = "d:/ymir work/ui/public/Slot_Base.sub"

def DeattachObject():
	try:
		if st_cur_server.find("Nw2Online")!=-1 or find_string(st_cur_server, "nextworld"):
			x = mouseModule.mouseController()
			return x.Detach()
		else:
			return mouseModule.mouseController.DeattachObject()
	except:
		pass
def isAttached():
	try:
		if st_cur_server.find("Nw2Online")!=-1 or find_string(st_cur_server, "nextworld"):
			x = mouseModule.mouseController()
			return True
		else:
			return mouseModule.mouseController.isAttached()
	except:
		pass
def GetAttachedType():
	try:
		if st_cur_server.find("Nw2Online")!=-1 or find_string(st_cur_server, "nextworld"):
			x = mouseModule.mouseController()
			return x.GetAttachType()
		else:
			return mouseModule.mouseController.GetAttachedType()
	except:
		pass
def GetAttachedSlotNumber():
	try:
		if st_cur_server.find("Nw2Online")!=-1 or find_string(st_cur_server, "nextworld"):
			x = mouseModule.mouseController()
			return x.GetAttachSlotIndex()
		else:
			return mouseModule.mouseController.GetAttachedSlotNumber()
	except:
		pass
def GetAttachedItemIndex():
	try:
		if st_cur_server.find("Nw2Online")!=-1 or find_string(st_cur_server, "nextworld"):
			x = mouseModule.mouseController()
			return x.GetAttachItemIndex()
			# return mouseModule.mouseController.GetAttachItemIndex()
		else:
			return mouseModule.mouseController.GetAttachedItemIndex()
	except:
		pass
manualVidRange = 0
buff1SkillUsage = 0
buff2SkillUsage = 0
buff3SkillUsage = 0
followTargetStatus = 0
BuffBotState = 0
pickSpeed = 0.1
fish_state = 0
initialColorSeed = 0
originalRace = 0
canChangeCH = 0
tempVid = 0
skillBotState = 0
rangedMobber = 0
canMove = 0
receivedMessage = 0
isConnecting = 0
quitGameIfGMPM = 0
playBeepSound = 0
tempCurChannel = 0
tempNextChannel = 0
beepIfPM = 0
metin_nonDetect = ""
canRefreshList = 1
autoReply = 0
movement = 0
useQuestion = 1
repeatMessage = 0
canUseVid = 0
canSearch = 0
targetVID_Start = 0
targetVID_End = 0
restartCounter = 0
antiban_state = 0
DistanceToNext = 0
SetAttackTime = 0
canSearchPlayerVids = 0
sellItemsFunction = 0
vidsListEnd1 = []
antiBantargetVID_Start = 0
antiBantargetVID_End = 0
antiBanrestartCounter = 0
antiBanplayerDetected = 0
antiBancanScan = 0
antiBanrestartCountPD = 0
baitUsed = 0
slot_item_split = 0
id_item_split = 0
hookedUser = ''
fishCheck = 0
tempRelogBotTime = 0
tempQuitTime = 0
tempStopTime = 0
tempRelogTime = 0
rangeX = 0
rangeY = 0
mobsVids = 500
metinsVids = 5000
bossVids = 500
oreVids = 500
playerVids = 500
canTeleportHP = 0
destroying_boss_check = 0
boss_state = "Find boss"
pickup_whitelist=[]
attachedSlot_Vnum = 0
SELL_attachedSlot_Vnum = 0
Mobber_ID = 0
useItemsVNUMS = [0,0,0,0,0,0,0,0,0]
SELL_useItemsVNUMS = [0,0,0,0,0,0,0,0,0]
UseItems_Slot = 0
Slot_refine = 0
elixirItem = 0
elixirItems = 0
bioItemReset = 0
haveToGoBack = 0
count_scanners = 0
try:
	GetMapName = background.GetCurrentMapName
except:
	pass
metin_choosed_VID = 0
array_metins_found = []
array_players_found = []
list_vid_last = []
attackingList = ['Normal','Rotation']
if isGF:
	refineList = ['Blacksmith','Scroll of Blessing','Magic Metal','Special item']
else:
	refineList = ['Blacksmith','Guild Blacksmith','Scroll of Blessing','Magic Metal','DT','Special item']
energyList = ['Method 1','Method 2']
LocationList = ['Map1 Blue','Map1 Yellow','Map1 Red']
priorityList = ['Metins first','Bosses first']
saveLoadSettings = ['Character name','Server']
spamColorList = ['Random','Normal','Green','Red','Yellow','Pink','Brown','Golden','Violet','Blue','Orange','Black','Gray']
try:
	if hasattr(chat, 'CHAT_TYPE_SHOUT_TRADE'):
		spamTypeList = ['Chat','Shout','PM','Merchant']
	else:
		spamTypeList = ['Chat','Shout','PM']
except:
	pass
curPlayerX=0
curPlayerY=0
maxThreshhold=0
try:
	import game
except:
	pass
if find_string(st_cur_server, "Rodnia"):
	SLOTS = 6
	SLOTS_PER_PAGE = 45
elif foundx64PythonList:
	SLOTS = 5
	SLOTS_PER_PAGE = 45
else:
	try:
		SLOTS = getattr(player, 'GetExtendInvenMax', lambda: None)()
		if hasattr(player, 'GetExtendInvenMax') and callable(player.GetExtendInvenMax) and player.GetExtendInvenMax() > 0:
			SLOTS = player.GetExtendInvenMax()
		else:
			SLOTS = player.INVENTORY_PAGE_SIZE * player.INVENTORY_PAGE_COUNT
		SLOTS_PER_PAGE = player.INVENTORY_PAGE_SIZE
	except:
		try:
			SLOTS = player.INVENTORY_SLOT_COUNT
			SLOTS_PER_PAGE = player.INVENTORY_PAGE_SIZE
		except:
			SLOTS = 45
			SLOTS_PER_PAGE = 4
Book_Reader_Book_ID = 0
Book_Reader_Book_Slot = 0
Book_Reader_Status = 0
Bait_Alternative_ID = 0
SW_Alternative_ID = 0
Item_User_ID = 0
select_item_toGiveID = 0
exo_id = 0
ss_id = 0
cc_id = 0
defaultRot = 0
zen_id = 0
cc_id = 0
exo_slot = 0
ss_slot = 0
cc_slot = 0
zen_slot = 0
special_itemID = 0
select_stonetoitemID = 0
select_stonetoitemIndex = 0
select_stoneID = 0
select_stoneSlotID = 0
select_brokenstone = 0
select_brokenstoneSlot = 0
select_item_refineID = 0
select_item_refineCount = 0
Item_User_Status = 0
Items_Slots = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Items_VNUM = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
rotatie = 0
SCAN_START = 1
SCAN_END = 1000000
endscan = 400000
BOARD_SIZE_X = 400
BOARD_SIZE_Y = 450
state = 'stop'
switchMetin = 0
farmEnable = 0
tempTime = 0
bioBotStatus = 0
playerList, gmList, antibanList = [], [], []
try:
	import os
except:
	pass
def getCallBackWithArg(func, arg):
	return lambda: func(arg)
STATE_NONE = 0
STATE_CHANGING_CHANNEL = 1
if foundx64PythonList:
	try:
		from pygame.net import GetServerInfo
		serverxInfo = GetServerInfo()
	except:
		pass
else:
	try:
		serverxInfo = net.GetServerInfo()
	except:
		pass
	
def GetCurrentServer():
	try:
		return serverxInfo.split(',')[0]
	except:
		return 0
def GetCurrentChannel():
	try:
		if find_string(st_cur_server, "melorin"):
			return int(serverxInfo.split(',')[1][4:])
		else:
			return int(serverxInfo.split(',')[1][3:])
	except:
		return 1
tempTimeAttack = 0
stucked = 0
canUseHorse = 0
playerRide = 0
found_stones = []
farmbot_state = "Searching"
farm_state = "Search"
bossIds=[192,193,191,194,394,591,534,533,691,2191,1901,791,1304,2307,2206,2091,3091,3190,3191,3290,3291,3390,3490,3491,3596,3691,3790,3791,3890,3891,3902,3911,3912,3913,4272,2491,2492,2493,2494,2495,1093,1094,1095,1091,2092,2093,2094,2291,2306,2307,6191,6192,6408,6091,6405]
miningList=(lang.MINING_DIAMOND,lang.MINING_AMBER,lang.MINING_FOSSIL,lang.MINING_COPPER,lang.MINING_SILVER,lang.MINING_GOLD,lang.MINING_JADE,lang.MINING_EBONY,lang.MINING_CLAMS,lang.MINING_WHITE_GOLD,lang.MINING_CRYSTAL,lang.MINING_AMETHYST,lang.MINING_HEAVEN_TEARS,lang.MINING_SOUL_CRYSTAL,lang.MINING_RUBY,lang.MINING_GARNET,lang.MINING_EMERALD,lang.MINING_SAPPHIRE,lang.MINING_TOURMALINE,lang.MINING_EVERYTHING,lang.MINING_CUSTOM)
goToNpcWay=['Teleporting']
def determine_path_modes(server_name):
	global isGF,autoRemoveWalk
	try:
		walk_list_disabled = [
			"LandOfHeroes", "Land Of Heroes", "Metin2BR", "Elysium",
			"LegendofMetin", "Anthology2", "all4game", "thaloria", "darksouls","global2","zenara","aorim"
		]
	
		base_modes = ["Hybrid", "Teleporting"]
		camera_modes = base_modes[:]
		camera_modes.append("Camera movement")
		for disabled_server in walk_list_disabled:
			if find_string(st_cur_server, disabled_server) or autoRemoveWalk == 1:
				if hasattr(player, 'SetSingleDIKKeyState'):
					return camera_modes
				return base_modes
	
		if hasattr(chr, 'MoveToDestPosition'):
			walking_modes = ["Walking"] + base_modes
			if hasattr(player, 'SetSingleDIKKeyState'):
				walking_camera_modes = walking_modes[:]
				walking_camera_modes.append("Camera movement")
				return walking_camera_modes
			return walking_modes
		
		if hasattr(player, 'SetSingleDIKKeyState'):
			return camera_modes
		return base_modes
	except:
		base_modes = ["Walking", "Hybrid", "Teleporting", "Camera movement"]
		return base_modes
path_modes = determine_path_modes(st_cur_server)
goToMetinWay = path_modes
SlotSBAvailable = []
statuDict = []
BonusIDList=('Skill damage','Average damage')
boss_list = []
metin_list = []
autologin_state=0
zoom_state=0
gm_state=0
player_state=0
playerDetected=0
registeredVID=0
exp_state=0
dews_state=0
restart_state=0
state_fantom=0
red_state=0
red_e_state=0
blue_state=0
blue_e_state=0
day_state=0
night_state=0
oneh_state=0
twoh_state=0
speed_state=0
vit_state=0
int_state=0
str_state=0
dex_state=0
p1_state=0
p2_state=0
p3_state=0
p4_state=0
p5_state=0
p6_state=0
farm1_state=0
farm2_state=0
mining_state=0
pick1_state=0
pick2_state=0
lvl_state=0
lockTarget=0
lockTargetVid=0
attack_state=0
moblock_state=0
item_user_state=0
hotkey_state=0
one_hit_state=0
capes_state=0
fishbot_state = 'stop'
sk1_state=0
sk2_state=0
sk3_state=0
sk4_state=0
sk5_state=0
sk6_state=0
str_body_state=0
energy_state = 'stop'
mine_state = 'stop'
metinX=0
metinY=0
oreX=0
oreY=0
oreVid=0
curLoc=0
setMountVnum=0
setMountVnumFarm=0
setMountVnumFarmSlot=0
armorVal=0
xFishbot_KillFishes=0
xFishbot_OpenClams=0
xFishbot_SellFish=0
xFishbot_SellHair=0
xFishbot_SwitchArmor=0
xFishbot_SellMinnow=0
xFishbot_SellCrap=0
xFishbot_UpgradeRod=0
xFishbot_Cancel_Animation=0
xFishbot_DisableQuests=0
xFishbot_FishernumVnum=0
xFishbot_DefaultShopIndex=0
xFishbot_BuyBait=0
xFishbot_BuyBaitShopIndex=0
xFishbot_BuyBaitQ=0
xFishbot_Bait_Minnow=0
xFishbot_Bait_Other=0
xFishbot_Bait_Worm=0
xFishbot_Bait_Paste=0
AnswerTuple = {}
PrivateMessages = {}
PlayerPlayerWasOnHorse=0
PlayerWasOnHorse=0
createLog=0
attackState=0
canWalkTele=0
starting_loop = 0
vidListTemp = []
destroying_metin_count = 0
stucked_times = 0
restartCountPD = 0
restartCountGD = 0
current_mining_state = 'stop'
oreVid = 0
miningX = 0
miningY = 0
GOLD_RING = 50002
GOLD_PIECE = 80008
GOLD_KEY = 50008
SILVER_KEY = 50009
MERMAID_KEY = 50043
SHRIMP = 27798
CARPA = 27806
canSearchForVIDS = 0
canTeleport = 0
canDetachHP = 0
pickupState = 0
bossesLoaded = 0
changeCHNothingState = 0
changeCHRouteState = 0
if find_string(st_cur_server, "ROP2"):
	try:
		player.SetAttackKeyState=player.attmatasuge
		player.GetCharacterDistance=player.dismatasuge
		chrmgr.SetAffect=chrmgr.SetROPS2Affect
	except:
		pass
	try:
		import miai as game
	except:
		pass
if find_string(st_cur_server, "Alune"):
	chat.AppendChat = chat.CreadeEmotionSet
	player.GetMainCharacterPosition = player.GetMountBonus
	player.GetStatus = player.SetMountLevel
	player.GetTargetVID = player.GetFishingValue
	player.GetItemIndex = player.GetFishGold
	player.SetAttackKeyState = player.SetRodValueNew
	chr.GetRace = chr.GetVirtualNumber
	player.PickCloseItem = player.MiningPickValue
	player.SetTarget = player.SetCombItemValue
	player.GetMainCharacterName = player.GetPetLevel
	net.SendChatPacket = net.GetPetLevelWithServer
def get_intersections(x0, y0, r0, x1, y1, r1):
	d = math.sqrt((x1 - x0)**2 + (y1 - y0)**2)
	if d > r0 + r1:
		return None
	if d < abs(r0 - r1):
		return None
	if d == 0 and r0 == r1:
		return None 
	a = (r0**2 - r1**2 + d**2) / (2 * d)
	h = math.sqrt(r0**2 - a**2)
	x2 = x0 + a * (x1 - x0) / d
	y2 = y0 + a * (y1 - y0) / d
	x3 = x2 + h * (y1 - y0) / d
	y3 = y2 - h * (x1 - x0) / d
	x4 = x2 - h * (y1 - y0) / d
	y4 = y2 + h * (x1 - x0) / d
	return (x3, y3), (x4, y4)
def calculate_distance(x1, y1, x2, y2):
	return math.sqrt((x1 - x2)**2 + (y1 - y2)**2)
	
def zzvvbbcxvdffgdsxz():
	mx, my, mz = player.GetMainCharacterPosition()
	vidInfo = list(str(str(chrmgr.GetVIDInfo(getCharIndex())).split('pos=(')[1]).split(','))
	px = vidInfo[0]
	py = vidInfo[1]
	py = py[:-1]
	px = px.split('.')[0]
	py = py.split('.')[0]
	parseX = int(px) - int(mx)
	parseY = int(py) - int(my)
	return (parseX, parseY)
if not hasattr(chrmgr, 'GetVIDInfo') and hasattr(chr, 'GetPixelPosition') and not find_string(st_cur_server, "oficial"):
	def getPos(vid):
		xt,yt,z = chr.GetPixelPosition(vid)
		return (xt, yt)
else:
	def getPos(vid):
		try:
			
			vidInfo = list(str(str(chrmgr.GetVIDInfo(vid)).split('pos=(')[1]).split(','))
			px = vidInfo[0]
			py = vidInfo[1]
			py = py[:-1]
			parseX, parseY = zzvvbbcxvdffgdsxz()
			tx = int(px.split('.')[0]) - parseX
			ty = int(py.split('.')[0]) - parseY
			y = ty
			return (tx, ty)
		except:
			try:
				
				main_x, main_y, main_z = player.GetMainCharacterPosition()
				initial_distance = player.GetCharacterDistance(vid)
				delta = 1
				o=getCharIndex()
				chr.SelectInstance(o)
				setPixelPos(main_x + delta, main_y)
				new_x_distance = player.GetCharacterDistance(vid)
				setPixelPos(main_x, main_y)
				setPixelPos(main_x, main_y + delta)
				new_y_distance = player.GetCharacterDistance(vid)
				setPixelPos(main_x, main_y)
				dx = delta
				dy = delta
				direction_x = (new_x_distance**2 - initial_distance**2 - dx**2) / (-2 * dx)
				direction_y = (new_y_distance**2 - initial_distance**2 - dy**2) / (-2 * dy)
				angle = math.atan2(direction_y, direction_x)
				target_x = main_x + initial_distance * math.cos(angle)
				target_y = main_y + initial_distance * math.sin(angle)
				return (target_x,target_y)
			except:
				x,y,z = player.GetMainCharacterPosition()
				return (x,y)
try:
	GetMainPos = player.GetMainCharacterPosition
	GetVID = player.GetTargetVID
except:
	pass
if find_string(st_cur_server, "Rohan"):
	player.SetAttackKeyState = player.SetDisableRevFw
	chr.SetPixelPosition = chr.SetKinaryMental
disableAttack = 0
if find_string(st_cur_server, "oficial"):
	player.SetAttackKeyState = player.CRISTI_DaInEi
	chr.IsGameMaster = chr.IsGameMasterOficial
def getRandom(x, y):	
	if find_string(st_cur_server, "oficial"):
		return app.GetRandom(x, y)
	else:
		try:
			return app.GetRandom(x, y)
		except:
			return (x,y)
class EterPackOperator(object):
	def __init__(self, filename):
		self.currDestinationX = 0
		self.currDestinationY = 0
		self.data = self.GetTextFile(filename)
		self.data=_chr(10).join(self.data.split(_chr(13)+_chr(10)))
	def read(self, len = None):
		if not self.data:
			return ''
		if len:
			tmp = self.data[:len]
			self.data = self.data[len:]
			return tmp
		else:
			tmp = self.data
			self.data = ''
			return tmp
	def readlines(self):
		Array = str(self.data).split("\n")
		return Array
	def getline(self, line):
		return self.readlines()[line - 1]
	def getlinecount(self):
		return len(self.readlines())
	def GetTextFile(self, file):
		tmp = []
		try:
			Handle = app.OpenTextFile(file)
			CountLines = app.GetTextFileLineCount(Handle)
		except:
			return ""
		for i in range(CountLines):
			line = app.GetTextFileLine(Handle, i)
			if line != "":
				tmp.append(line + "\n")
		app.CloseTextFile()
		return("".join(tmp))
oficialARG = 199597
def get_temp_dir():
	if 'TMPDIR' in os.environ:
		return os.environ['TMPDIR']
	elif 'TEMP' in os.environ:
		return os.environ['TEMP']
	else:
		return '/tmp'
def getArg():
	temp_dir = get_temp_dir()
	fff = temp_dir + "/qtsingleapp.dat"
	filename = "introselect.py"
	eter_pack_operator = EterPackOperator(filename)
	argDump = eter_pack_operator.read()
	lines = argDump.split('\n')
	extracted_value = None
	for line in lines:
		line = line.strip()
		if line.startswith('chr.SetPixelPosition(') and line.endswith('int(y), 30)'):
			start_index = line.find('(') + 1
			end_index = line.find(',')
			extracted_value = line[start_index:end_index].strip()
			break
	if extracted_value:
		x = open_file(fff, "w")
		x.write(str(extracted_value))
		x.close()
curMotion = 0
try:
	def Attack(arg, *args):
		global isGF,curMotion,debugged
		if not arg:
			curMotion = 0
		if find_string(st_cur_server, "mt2Classic") or find_string(st_cur_server, "yeogsa") and not find_string(st_cur_server, "mt2classichu"):
			if arg:
				player.ComboAttack()	
		elif find_string(st_cur_server, "Loc"):
			if arg:
				player.ComboAttack()	
				
		elif find_string(st_cur_server, "mergen") or find_string(st_cur_server, "mein"):
			if arg:
				player.SetAttackKeyState(True, 'playerSetAttackKeyState(isPressed) - There is no first argument')
			elif arg == False:
				player.SetAttackKeyState(False, 'playerSetAttackKeyState(isPressed) - There is no first argument')	
		elif find_string(st_cur_server, "SG"):
			if arg:
				onKeyDown(appKey('SPACE'))
			elif arg == False:
				onKeyUp(appKey('SPACE'))
		elif isGF:
			if arg:
				onKeyDown(appKey('SPACE'))
			elif arg == False:
				onKeyUp(appKey('SPACE'))
		elif find_string(st_cur_server, "Metin2BR"):
			if arg:
				onKeyDown(appKey('SPACE'))
			elif arg == False:
				onKeyUp(appKey('SPACE'))
		elif find_string(st_cur_server, "Eternal"):
			player.SetAttackKeyStateEt9291(arg)			
		elif foundx64PythonList:
			playerDefault.SetAttackKeyState(arg)
		elif find_string(st_cur_server, "oficial"):
			player.SetAttackKeyState(arg, oficialARG)			
		else:
			try:
				if hasattr(player, 'SetAttackKeyState') and not find_string(st_cur_server, "merlis"):
					player.SetAttackKeyState(arg)
				else:
					if hasattr(player, 'ComboAttack') and not find_string(st_cur_server, "merlis"):
						if arg:
							player.ComboAttack()
					else:
						def setLoopMotion(val):
							global curMotion
							curMotion = val
							chr.SetLoopMotion(val)
						def loopMotion():
							myVid = getCharIndex()
							chr.SelectInstance(myVid)
							eventHandler.add(0, lambda: setLoopMotion(14), 'xxxx')
							eventHandler.add(0.2, lambda: setLoopMotion(15), 'xxxx')
							eventHandler.add(0.6, lambda: setLoopMotion(16), 'xxxx')
							eventHandler.add(0.8, lambda: setLoopMotion(17), 'xxxx')
						def atplm():
							eventHandler.add(0, loopMotion, 'atplm')
						if arg and (curMotion == 17 or curMotion == 0):
							atplm()
						if not arg:
							if not debugged:
								Debug()
								debugged = 1
							eventHandler.remove('atplm')
							eventHandler.remove('xxxx')
							chr.SetLoopMotion(0)
			except:
				pass
except:
	pass
try:
	def GetPositiveValue(value):
		if value < 0:
			return int(str(int(value))) - int(str(int((2 * value))))
		else:
			return int(str(int(value)))
	def GetDistancex(x, y):
		(PlayerX, PlayerY, PlayerZ) = player.GetMainCharacterPosition()
		PlayerX = int(str(int(PlayerX)))
		x = int(str(int(x)))
		PlayerY = int(str(int(PlayerY)))
		y = int(str(int(y)))
		(TmpX, TmpY) = (int(str(int(GetPositiveValue(PlayerX - x)))) ** 2, int(str(int(GetPositiveValue(PlayerY - y)))) ** 2)
		f = int(str(int(math.sqrt(int(str(int(TmpX))) + int(str(int(TmpY)))))))
		return f
except:
	pass
# def GetDis2(vid):
	# try:
		# abc = getPos(vid)
		# xx = abc[0]
		# yy = abc[1]
		# return int(GetDistancex(xx, yy))
	# except:
		# return -1
try:
	if find_string(st_cur_server, "Alune"):
		def GetDis(vid):
			try:
				vidInfo = list(str(str(chrmgr.GetVIDInfo(vid)).split('pos=(')[1]).split(','))
				px = vidInfo[0]
				py = vidInfo[1]
				py = py[:-1]
				parseX, parseY = zzvvbbcxvdffgdsxz()
				tx = int(px) - parseX
				ty = int(py) - parseY
				y = ty
				return int(GetDistancex(tx, ty))
			except:
				return -1
	elif foundx64PythonList:
		def GetDis(vid):
			try:
				
				return playerDefault.GetCharacterDistance(vid)
			except:
				return -1
	elif find_string(st_cur_server, "merlis"):
		def GetDis(vid):
			o = getCharIndex()
			myPs = getPos(o)
			pixPos = getPos(vid)
			x1 = myPs[0]
			y1 = myPs[1]
			x2 = pixPos[0]
			y2 = pixPos[1]
			distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
			return distance
	else:
		def GetDis(vid):
			try:
				
				return player.GetCharacterDistance(vid)
			except:
				return -1
	def isBoss(vid):
		if find_string(st_cur_server, "Azyrah") or isGF:
			if chr.GetInstanceType(vid) == BOSS_TYPE:
				return True
			return False
		else:
			return nonplayer.GetGradeByVID(vid) > 3
except:
	pass
def compare_vids(vid1, vid2):
	return cmp(GetDis(vid1), GetDis(vid2))
try:
	if find_string(st_cur_server, "SG"):
		def onKeyDown(key):
			player.OnKeyDown(key)
	elif find_string(st_cur_server, "Metin2BR") or isGF:
		def onKeyDown(key):
			player.OnKeyDown(key)
	elif find_string(st_cur_server, "oficial"):
		def onKeyDown(key):
			player.SetSingleDIKKeyState(oficialARG, key, True)
	elif find_string(st_cur_server, "Shiro") and not find_string(st_cur_server, "AShiro"):
		def onKeyDown(key):
			player.SetSingleDIKKeyStateNew(key, True)
	else:
		def onKeyDown(key):
			if hasattr(player, 'SetAttackKeyState'):
				try:
					player.SetSingleDIKKeyState(key, True)
				except:
					pass
except:
	pass
try:
	if find_string(st_cur_server, "SG"):
		def onKeyUp(key):
			player.OnKeyUp(key)
	elif find_string(st_cur_server, "Shiro") and not find_string(st_cur_server, "AShiro"):
		def onKeyUp(key):
			player.SetSingleDIKKeyStateNew(key, False)
	elif find_string(st_cur_server, "Metin2BR") or isGF:
		def onKeyUp(key):
			player.OnKeyUp(key)
	elif find_string(st_cur_server, "oficial"):
		def onKeyUp(key):
			player.SetSingleDIKKeyState(oficialARG, key, False)
	else:
		def onKeyUp(key):
			try:
				player.SetSingleDIKKeyState(key, False)
			except:
				pass
except:
	pass
try:
	if find_string(st_cur_server, "Alune"):
		net.SendChatPacket = net.GetPetLevelWithServer
except:
	pass
try:
	if foundx64PythonList:
		def SendChatPacket(txt, *args):
			global pauseSpam
			
			if pauseSpam:
				return
			if args:
				asd = args[0]
			else:
				asd = 1
			if find_string(st_cur_server, "lucerna"):
				appInst.instance().NewNet().SendChatPacket(txt)
			else:
				appInst.instance().GetNet().SendChatPacket(txt)
	else:
		def SendChatPacket(txt, *args):
			global pauseSpam
			if args:
				asd = args[0]
			else:
				asd = 1
				
			if pauseSpam:
				return
				
				
			if find_string(st_cur_server, "Aureria"):
				net.SendChatPacket(1, txt, asd)
			elif find_string(st_cur_server, "Nova"):
				chat_line_class = getattr(uichat, 'ChatLine')
				chat_line_instance = chat_line_class()
				chat_line_instance._ChatLine__SendChatPacket(txt,asd)
			elif find_string(st_cur_server, "oficial"):
				
				net.ReturnCleaned(txt, asd, oficialARG)				
			elif find_string(st_cur_server, "EmtGen"):
				net.SendChatPacket(99, txt)
			elif find_string(st_cur_server, "eternal"):
				net.SendChatPacket(txt)
			else:
				net.SendChatPacket(txt, asd)
except:
	pass
	
if isGF:
	fall = None
else:
	fall = item.APPLY_IMMUNE_FALL
	
	
try:
	oldytBonus = {
		item.APPLY_MAX_HP : 1500,
		item.APPLY_MAX_SP : 30,
		item.APPLY_CON : 10,
		item.APPLY_INT : 10,
		item.APPLY_STR : 10,
		item.APPLY_DEX : 10,
		item.APPLY_ATT_SPEED : 8,
		item.APPLY_MOV_SPEED : 20,
		item.APPLY_CAST_SPEED : 20,
		item.APPLY_HP_REGEN : 30,
		item.APPLY_SP_REGEN : 30,
		item.APPLY_POISON_PCT : 8,
		item.APPLY_STUN_PCT : 8,
		item.APPLY_SLOW_PCT : 8,
		item.APPLY_CRITICAL_PCT : 10,
		item.APPLY_PENETRATE_PCT : 10,
		item.APPLY_ATTBONUS_WARRIOR : 10,
		item.APPLY_ATTBONUS_ASSASSIN : 10,
		item.APPLY_ATTBONUS_SURA : 10,
		item.APPLY_ATTBONUS_SHAMAN : 10,
		item.APPLY_ATTBONUS_MONSTER : 8,
		item.APPLY_ATTBONUS_HUMAN : 4,
		item.APPLY_ATTBONUS_ANIMAL : 20,
		item.APPLY_ATTBONUS_ORC : 20,
		item.APPLY_ATTBONUS_MILGYO : 20,
		item.APPLY_ATTBONUS_UNDEAD : 20,
		item.APPLY_ATTBONUS_DEVIL : 20,
		item.APPLY_STEAL_HP : 10,
		item.APPLY_STEAL_SP : 10,
		item.APPLY_MANA_BURN_PCT : 10,
		item.APPLY_DAMAGE_SP_RECOVER : 10,
		item.APPLY_BLOCK : 15,
		item.APPLY_DODGE : 15,
		item.APPLY_RESIST_SWORD : 15,
		item.APPLY_RESIST_TWOHAND : 15,
		item.APPLY_RESIST_DAGGER : 15,
		item.APPLY_RESIST_BELL : 15,
		item.APPLY_RESIST_FAN : 15,
		item.APPLY_RESIST_BOW : 15,
		item.APPLY_RESIST_FIRE : 15,
		item.APPLY_RESIST_ELEC : 15,
		item.APPLY_RESIST_MAGIC : 15,
		item.APPLY_RESIST_WIND : 15,
		item.APPLY_REFLECT_MELEE : 15,
		item.APPLY_REFLECT_CURSE : 5,
		item.APPLY_POISON_REDUCE : 5,
		item.APPLY_EXP_DOUBLE_BONUS : 20,
		item.APPLY_GOLD_DOUBLE_BONUS : 20,
		item.APPLY_ITEM_DROP_BONUS : 20,
		item.APPLY_IMMUNE_STUN : 1,
		item.APPLY_IMMUNE_SLOW : 1,
		item.APPLY_SKILL_DAMAGE_BONUS : 10,
		item.APPLY_NORMAL_HIT_DAMAGE_BONUS : 40
	}
except:
	oldytBonus = {}
	
def isValItem(itemSlotPos):
	for i in range(5):
		bonus_id, bonus_value = player.GetItemAttribute(itemSlotPos, i)
		if bonus_id in oldytBonus and bonus_value >= oldytBonus[bonus_id]:
			return True
	return False
	
def sellItemFunction(Slot):
	if find_string(st_cur_server, "arthur"):
		net.SendItemSellPacket(1, Slot, 32000)
	else:
		if hasattr(net, 'SendItemSellPacket'):
			net.SendItemSellPacket(Slot)
		elif find_string(st_cur_server, "NoLimit"):
			net.SendItemSellPacket(Slot)
		elif find_string(st_cur_server, "Gloria"):
			SendChatPacket("/sell_item " + str(Slot))
		elif find_string(st_cur_server, "legendofmetin"):
			net.SendSelectionItemPacket(4, 1, Slot)		
			
		elif find_string(st_cur_server, "alaska"):
			net.SendShopSellPacket(Slot, 1, 1)			
		elif find_string(st_cur_server, "m2classic"):
			net.SendShopSellPacketNew(1, Slot, player.GetItemCount(Slot), 1)			
		elif find_string(st_cur_server, "amg"):
			net.SendItemDropPacketNew(1, Slot, 1, 1)
			
		elif find_string(st_cur_server, "viral") or find_string(st_cur_server, "ydoria"):
	
			net.SendMultipleItem(1, Slot, 1)
		elif find_string(st_cur_server, "Freak"):
			net.SendItemSellPacket(Slot)
			
		elif find_string(st_cur_server, "luminus"):
			net.SendShopMultipleSellPacket([(1, Slot)])
			# net.SendMultipleItem(1, Slot, 1)				
		elif find_string(st_cur_server, "enigma"):
			net.SendMultipleItem(1, Slot, 1)	
			
		elif find_string(st_cur_server, "luminus"):
			net.SendItemSellPacket(1, Slot)				
		elif find_string(st_cur_server, "lena2"):
			net.SendItemSellPacket(1, Slot)			
		elif find_string(st_cur_server, "stonebreakers"):
			rarity = player.GetItemRarity(Slot)
			if rarity <= 1:
				net.SendItemSellPacket(Slot)
		elif find_string(st_cur_server, "History"):
			net.SendItemSellPacket(Slot)				
		elif find_string(st_cur_server, "leonidas"):
			net.SendItemDropSellPacket(Slot)
		elif find_string(st_cur_server, "oldyt"):
			if not isValItem(Slot):
				net.SendShopSellPacketNew(Slot, player.GetItemCount(Slot), player.INVENTORY)		
		elif find_string(st_cur_server, "zenessis"):
			net.SendShopSellPacketNew(Slot, player.GetItemCount(Slot))	
		elif find_string(st_cur_server, "Rine"):
			net.SendItemSellPacket(Slot)
		elif find_string(st_cur_server, "obscure"):
			net.SendShopSellPacket(player.INVENTORY, Slot, player.GetItemCount(Slot))		
		elif find_string(st_cur_server, "azyrah"):
			net.SendShopSellPacketNewDrop(Slot, player.GetItemCount(Slot), player.INVENTORY)		
		elif find_string(st_cur_server, "GoodTimes"):
			net.SendDirectSellItem(Slot, player.GetItemCount(Slot), player.INVENTORY)
		elif find_string(st_cur_server, "Aerion"):
			if shop.IsOpen():
				net.SendShopSellPacketNew(Slot, player.GetItemCount(Slot), player.INVENTORY)
			else:
				net.SendDirectSellItem(Slot, player.GetItemCount(Slot), player.INVENTORY)
		elif find_string(st_cur_server, "M6Raw"):
			try:
				import uimobilesell
				x = uimobilesell.MobileSell()
				x.AppendSellSlot(Slot, 2)
				x._MobileSell__OnClickSellButton()
			except:
				pass
		elif find_string(st_cur_server, "2009") or find_string(st_cur_server, "hardmt2"):
			SendChatPacket('/sell_items ' + str(Slot) + " " + str(player.GetItemCount(Slot)) + " 1" )
		elif foundx64PythonList:
			if find_string(st_cur_server, "lucerna"):
				appInst.instance().NewNet().SendShopSellPacketNew(ItemPosition(1, Slot), 1)
			else:
				appInst.instance().GetNet().SendShopSellPacketNew(ItemPosition(1, Slot), 1)
		else:
			if hasattr(net, 'SendShopSellPacketNew'):
				net.SendShopSellPacketNew(Slot, player.GetItemCount(Slot), player.INVENTORY)
			else:
				net.SendShopSellPacket(Slot, player.GetItemCount(Slot), player.INVENTORY)
def destroyItemFunction(Slot):
	try:
		if find_string(st_cur_server, "Gloria"):
			SendChatPacket("/delete_item " + str(Slot))
		elif find_string(st_cur_server, "ImperiaWorld"):
			SendChatPacket("/destroy_item " + str(Slot))				
		elif find_string(st_cur_server, "Valoron"):
			SendChatPacket("/destroy_item " + str(Slot))					
		elif find_string(st_cur_server, "Metin2GB"):
			SendChatPacket("/destroy_item " + str(Slot))	
			
		elif find_string(st_cur_server, "zaris") or find_string(st_cur_server, "hunter") or find_string(st_cur_server, "arezzo"):
			net.SendRemoveItemPacket([[1, Slot]])
			
			
		elif find_string(st_cur_server, "AngelWorld"):
			event.QuestButtonClick(47)
			net.SendQuestInputStringPacket(str(Slot))
			event.SetRestrictedCount(3, 52)
			event.ClearEventSet(3)					
		elif find_string(st_cur_server, "aronix"):
			event.QuestButtonClick(13)
			net.SendQuestInputStringPacket(str(Slot))
			event.ClearEventSet(2)		
			
		elif find_string(st_cur_server, "legend2"):	
			net.SendItemDestroyPacket(1, Slot, 1)
		elif find_string(st_cur_server, "viral"):
			net.SendItemDestroyPacket(1, Slot, 1, 0)
			
		elif find_string(st_cur_server, "zendaris"):
			net.SendItemDestroyPacket(Slot, 1)				
		elif find_string(st_cur_server, "alaska"):
			net.SendItemDropPacket(1, Slot, 1)			
		elif find_string(st_cur_server, "amg"):
			net.SendItemDropPacketNew(1, Slot, 1, 2)
		elif find_string(st_cur_server, "m2classic"):
			net.SendItemDestroyPacket(1, Slot, 1)	
		elif find_string(st_cur_server, "Luminus"):
			net.SendItemDestroyPacket(1, Slot)			
		elif find_string(st_cur_server, "Metin2Set"):
			net.SendItemDestroyPacket(1, Slot, 1)
		elif find_string(st_cur_server, "calliope"):
			SendChatPacket("/remove_item_cell " + str(Slot))	
		elif find_string(st_cur_server, "oldyt"):
			if not isValItem(Slot) and Slot not in range(90, 97) and Slot != 100:
				net.SendItemDestroyPacket(1, Slot)	
				
		elif find_string(st_cur_server, "lena2"):
			net.SendItemDestroyPacket(1, Slot)						
		elif find_string(st_cur_server, "lasorti"):
			net.SendItemDestroyPacket(Slot,1)		
		elif find_string(st_cur_server, "legendofmetin"):
			net.SendSelectionItemPacket(16, 1, Slot)				
		elif find_string(st_cur_server, "azyrah"):
			net.SendItemDestroyPacket(Slot)		
		elif find_string(st_cur_server, "enigma"):
			net.SendItemDestroyPacket(1, Slot, 1, 0)			
		elif find_string(st_cur_server, "tiks"):
			net.SendItemDestroyPacket(1, Slot)	
		elif find_string(st_cur_server, "arthur"):
			net.SendItemDestroyPacket(1, Slot, 32000)		
		elif find_string(st_cur_server, "GX"):
			net.SendItemDestroyPacket(Slot)
		elif find_string(st_cur_server, "Metin.World"):
			net.SendItemDestroyPacket(player.INVENTORY, Slot)
		elif find_string(st_cur_server, "rebelion"):
			net.SendItemDestroyPacket(player.INVENTORY, Slot)			
		elif find_string(st_cur_server, "zenessis"):
			net.SendItemDestroyPacket(player.INVENTORY, Slot, player.GetItemCount(Slot))
		elif foundx64PythonList:
			if find_string(st_cur_server, "lucerna") or find_string(st_cur_server, "next2play"):
				appInst.instance().NewNet().SendItemDestroyPacket(ItemPosition(1, Slot))
			else:
				appInst.instance().GetNet().SendItemDestroyPacket(ItemPosition(1, Slot))
		else:
			if hasattr(net, 'SendItemDestroyPacket'):
				net.SendItemDestroyPacket(Slot)
			else:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hItem destroyer: " + lang.STR_DESTROY_NOT)
				return
	except:
		pass
def GetItemLevel(slot):
	try:
		_vnum = player.GetItemIndex(slot)
		if not _vnum:
			return 0
		selectItem(_vnum)
		return item.GetLimit(0)[1]
	except:
		return 99
def extractShardsSlot(Slot):
	try:
		if find_string(st_cur_server, "valoria") or find_string(st_cur_server, "ydoria"):
			net.SendMultipleItem(2, Slot, 1)
		else:
			if hasattr(net, 'SendItemExtractEnergyPacket'):
				if GetItemLevel(Slot) >= 35:
					net.SendItemExtractEnergyPacket(Slot)
				else:
					sellItemFunction(Slot)
	except:
		pass
def copy_file(source, destination):
	try:
		src = open_file(source, 'rb+')
		dest = open_file(destination, 'wb+')
		dest.write(src.read())
		src.close()
		dest.close()
	except:
		pass
def copy_folder(source_folder, destination_folder):
	try:
		if not os.path.exists(destination_folder):
			os.makedirs(destination_folder)
		for item in os.listdir(source_folder):
			source_item = os.path.join(source_folder, item)
			destination_item = os.path.join(destination_folder, item)
			if os.path.isdir(source_item):
				copy_folder(source_item, destination_item)
			else:
				copy_file(source_item, destination_item)
	except:
		pass
		
		
		
def unMountAndMount(args):
	global disableAttack
	try:
		if player.IsMountingHorse():
			callFnc(0, lambda: mountHorseFunc(0))
			if args:
				disableAttack = 1
			callFnc(3, lambda: mountHorseFunc(1))
	except:
		pass
def mountHorseFunc(args):
	global isGF,disableAttack
	try:
		if find_string(st_cur_server, "Metin2BR") or isGF:
			net.SendCommandPacket(net.PLAYER_CMD_RIDE)
		elif find_string(st_cur_server, "tiks") or find_string(st_cur_server, "shinra"):
			net.SendCommandPacket('/ride')
		elif find_string(st_cur_server, "Wilderness") or find_string(st_cur_server, "Abyssus"):
			SendChatPacket("/user_mount_ride")
		elif find_string(st_cur_server, "CAVALRY"):
			SendChatPacket("/user_mount_ride")
		elif find_string(st_cur_server, "Genara"):
			SendChatPacket("/user_mount_ride")	
			
		elif find_string(st_cur_server, "luminus"):
			SendChatPacket("/user_horse_ride")			
		elif find_string(st_cur_server, "sepherion"):
			SendChatPacket("/user_mount_action")
		else:
			SendChatPacket("/ride")
		if args:
			disableAttack = 0
	except:
		pass
def SendItemUseToItemPacket(fromSlot, toSlot):
	if foundx64PythonList:
		if find_string(st_cur_server, "lucerna") or find_string(st_cur_server, "next2play"):
			appInst.instance().NewNet().SendItemUseToItemPacket(ItemPosition(1, fromSlot), ItemPosition(1, toSlot))
		else:
			appInst.instance().GetNet().SendItemUseToItemPacket(ItemPosition(1, fromSlot), ItemPosition(1, toSlot))
	elif find_string(st_cur_server, "rubinum") or find_string(st_cur_server, "saphirus") or find_string(st_cur_server, "m2classic"):
		net.SendItemDropToItemPacket(fromSlot, toSlot)
	else:
		net.SendItemUseToItemPacket(fromSlot, toSlot)
try:
	def useItemFunc(itemID, **kwargs):
		global pauseItemUser
		if pauseItemUser:
			return
		if find_string(st_cur_server, "Aureria"):
			net.SendItemUsePacket(0, itemID)
		elif find_string(st_cur_server, "EmtGen"):
			net.SendItemUsePacket(itemID, 99)
		elif find_string(st_cur_server, "mt2classichu"):
			net.SendItemUsePacket(itemID, False)
			
		elif find_string(st_cur_server, "baria") or find_string(st_cur_server, "aleris"):
			net.SendItemUsePacket(itemID, 1)			
		elif find_string(st_cur_server, "origins"):
			net.SendItemUsePacket(itemID, 0)
		elif find_string(st_cur_server, "RevolutionMT2"):
			net.SendItemUseToItemPacket(itemID, itemID)
		elif find_string(st_cur_server, "Velor"):
			net.SendItemUseToItemPacket(itemID, itemID)			
		elif find_string(st_cur_server, "Alune"):
			net.SendItemUseToItemPacket(itemID, itemID)
		elif find_string(st_cur_server, "DDMT") or find_string(st_cur_server, "LandOfHeroes") :
			net.SendItemUseToItemPacket(itemID, itemID)			
		elif find_string(st_cur_server, "nextworld"):
			net.SendItemUsePacket(0, itemID)
		elif foundx64PythonList:
			if find_string(st_cur_server, "lucerna") or find_string(st_cur_server, "next2play"):
				appInst.instance().NewNet().SendItemUsePacket(ItemPosition(1, itemID))
			else:
				appInst.instance().GetNet().SendItemUsePacket(ItemPosition(1, itemID))
		elif find_string(st_cur_server, "Nova"):
			try:
				import nova.net
				nova.net.SendItemUsePacket(1,itemID)
			except:
				pass
		else:
			try:
				net.SendItemUsePacket(itemID,**kwargs)
			except:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.FAIL_USE_ITEM1 + " " + str(itemID))
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.FAIL_USE_ITEM2)
except:
	pass
def MoveItem(srcPos, dstPos, count):
	if foundx64PythonList:
		src_item_position = ItemPosition(1, srcPos)
		dst_item_position = ItemPosition(1, dstPos)
		net.SendItemMovePacket(src_item_position, dst_item_position, count)
	else:
		net.SendItemMovePacket(srcPos, dstPos, count)
		
if hasattr(item, 'GetItemMount'):
	chr.GetNameByVID = item.GetItemMount
try:
	if find_string(st_cur_server, "DDMT"):
		chr.GetNameByVID = chr.GetNameByVIDReal
except:
	pass
try:
	if hasattr(chr, 'GetNameByVIDReal'):
		chr.GetNameByVID = chr.GetNameByVIDReal
except:
	pass
try:
	if hasattr(chr, 'GetRealNameByVID'):
		chr.GetNameByVID = chr.GetRealNameByVID
except:
	pass
try:
	if hasattr(chr, 'GetNameRealByVID'):
		chr.GetNameByVID = chr.GetNameRealByVID
except:
	pass
try:
	if find_string(st_cur_server, "Rubinum") or find_string(st_cur_server, "saphirus") or find_string(st_cur_server, "m2classic"):
		player.GetMainCharacterName = player.GetChrName
		player.ClickSkillSlot = player.UseSkillSlot
		net.GetServerInfo = net.GetServerInfoGame
except:
	pass
try:
	if hasattr(player, 'GetChrName'):
		player.GetMainCharacterName = player.GetChrName
except:
	pass
try:
	if find_string(st_cur_server, "Aureria") or find_string(st_cur_server, "EmtGen"):
		player.SetTarget = player.NastavitCil
except:
	pass
BOSS_TYPE = -1
if find_string(st_cur_server, "League"):
	item.EQUIPMENT_BODY = item.WEARABLE_BODY
	item.EQUIPMENT_WEAPON = item.WEARABLE_WEAPON
buffbotTarget = 0
temp_metin_vid = 0
attempts = 0
skillBotStarted = 0
temp_farm3x = 0
temp_farm3y = 0
confirmRoute = 0
areThereMetins = 0
areThereBosses = 0
areThereMobs = 0
canSkipAnimation = 0
Item_User_Relog_ID = 0
useItemHpLowID = 0
vidsMetinList=[]
allFarmVidsListPlayers=[]
mobsListVids = []
allFarmVidsListMetin = []
allFarmVidsListBoss = []
allFarmVidsListOre = []
pickupFilterwhitelist=[]
pickupFilter_White_List=[]
if foundx64PythonList:
	try:
		game_window_instance = game.GameWindow.instance()
		game_window_instance.OnRecvWhisper = game_window_instance.OnRecvWhisper
		OldOnRecvWhisper = game_window_instance.OnRecvWhisper
	except:
		pass
else:
	try:
		OldOnRecvWhisper = game.GameWindow.OnRecvWhisper
	except:
		pass
if find_string(st_cur_server, "Esenn"):
	game_window_instance = game.GameWindow.instance()
	game_window_instance.SetHPTargetBoard = game_window_instance.SetHPTargetBoard
	OldHPTargetBoard = game_window_instance.SetHPTargetBoard
else:
	try:
		OldHPTargetBoard = game.GameWindow.SetHPTargetBoard
	except:
		pass
getHPTarget = 0
MinimizedWhisper = 0
replyDelayGlobal = 2
isReplyListLoaded = 0
callFncList = []
def callFnc(delay, fnc, *args):
	global callFncList
	try:
		callFncList = [x for x in callFncList if not x.state]
		callFncList.append(CallFnc(delay, fnc, *args))
	except:
		pass
try:
	def GetTime():
		return app.GetTime()
except:
	pass
def timeSleep(last_time,sleepTime):
	timer = GetTime()
	if(last_time<timer-sleepTime):
		return(True,timer)
	return(False,last_time)
CONFIG_MAP_LINKS = 'map_linker.txt'
files = dict()
def LoadListFile(file):
	lst = []
	try:
		f = open_file(file,'r+')
		for line in f:
			line = line.rstrip()
			lst.append(line)
		f.close()
	except:
		return []
	return lst
def SaveListFile(file,lst):
	lst = [str(i) +"\n" for i in lst]
	if len(lst) == 0:
		return
	f = open_file(file,'w')
	f.writelines(lst)
	f.close()
	return lst
def uno(aa):
	return aa[0]
def two(aa):
	return aa[1]
def DivideToFloat1(x, y):
	try:
		return x * (y**-1)
	except:
		return 0
def boolean(val):
	if val == str("True") or val == str("1") or val == str("On"):
		return True
	else:
		return False
def relativeEndY(Y_value):
	return BOARD_SIZE_Y - abs(Y_value)
def relativeEndX(X_value):
	return BOARD_SIZE_X - abs(X_value)
def relativeCenterY(Y_value):
	return BOARD_SIZE_Y/2 + Y_value
def relativeCenterX(X_value):
	return BOARD_SIZE_X/2 + X_value
def plmmmm(x, y):
	try:
		return x * (y**-1)
	except BaseException:
		return 0
class CallFnc:
	def __init__(self, time, fnc, *args):
		self.event = fnc
		self.eventArgs = args
		self.state = False
		self.timer = XX()
		self.timer.XX1(time)
		self.timer.XX2(self.startEvent)
	def close(self):
		self.state = True
		self.timer.Close()
	def startEvent(self):
		if self.event is not None:
			if self.eventArgs is not None:
				self.event(*self.eventArgs)
			else:
				self.event()
		self.close()
class Event:
	def __init__(self, delay, task, name=None, repeat=False):
		self.delay = delay
		self.task = task
		self.name = name
		self.repeat = repeat
		self.over = False
		if foundNewPythonList:
			try:
				self.timeOfExec = time.perf_counter() + delay
			except:
				pass
		else:
			try:
				self.timeOfExec = time.clock() + delay
			except:
				pass
	def run(self, curTime):
		try:
			if not self.over and curTime >= self.timeOfExec:
				self.timeOfExec = curTime + self.delay
				self.task()
				self.over = not self.repeat
		except:
			pass
try:
	from _weakref import proxy
except:
	pass
try:
	import os
except:
	pass
try:
	def replace_special_characters(ffff):
		specialChar = ['/', '\\', ':', '*', '?', '"', '<', '>', '|']
		for char in specialChar:
			ffff = ffff.replace(char, '')
		return ffff
		
		
	def getcharName():
		try:
			o = player.GetMainCharacterIndex()
			charName = chr.GetNameByVID(o)
			if charName not in ["None", None, ""]:
				try:
					charName = replace_special_characters(charName)
				except:
					pass
				return charName
			return 0
		except:
			charName = player.GetMainCharacterName()
			if charName not in ["None", None, ""]:
				try:
					charName = replace_special_characters(charName)
				except:
					pass
				return charName
			return 0
		
		
	def getcharName():
		o = getCharIndex()
		try:
			charName = chr.GetNameByVID(o)
		except:
			charName = player.GetMainCharacterName()
		if charName != '' or charName != -1 or charName != None:
			try:
				charName = replace_special_characters(charName)
			except:
				pass
			if charName:
				return charName
				
		else:
			return 'default'
except:
	pass
try:
	if find_string(st_cur_server, "Mt2MesterNext") or find_string(st_cur_server, "LandOfHeroes") or find_string(st_cur_server, "SoW2"):
		if os.path.exists('./rascal2/'):
			CONFIG_FOLDER = './rascal2/'
			onOffButtonLoc = './rascal2/img/'
			ingameIcon = './rascal2/img/metin2.tga'
		else:
			CONFIG_FOLDER = st_path + '/Data/rascal2/'
			onOffButtonLoc = st_path + '/Data/rascal2/img/'
			ingameIcon = st_path + '/Data/rascal2/img/metin2.tga'
	else:
		if os.path.exists('rascal2/'):
			CONFIG_FOLDER = 'rascal2/'
			onOffButtonLoc = 'rascal2/img/'
			ingameIcon = 'rascal2/img/metin2.tga'
		else:
			CONFIG_FOLDER = st_path + '/Data/rascal2/'
			onOffButtonLoc = st_path + '/Data/rascal2/img/'
			ingameIcon = st_path + '/Data/rascal2/img/metin2.tga'
except:
	pass
def ReadConfigPrice(Setting):
	global CONFIG_PRICE
	try:
		fopen = open_file(CONFIG_PRICE,mode='r+')
		fread = fopen.readlines()
		for line in fread:
			if line.startswith(Setting):
				return line.split('=')[1].strip()
	except:
		pass
def ReadConfigFish(Setting):
	global CONFIG_FISH
	try:
		fopen = open_file(CONFIG_FISH,mode='r+')
		fread = fopen.readlines()
		for line in fread:
			if line.startswith(Setting):
				return line.split('=')[1].strip()
	except:
		pass
def ReadConfig(Setting):
	global CONFIG
	try:
		fopen = open_file(CONFIG,mode='r+')
		fread = fopen.readlines()
		for line in fread:
			if line.startswith(Setting):
				return line.split('=')[1].strip()
	except:
		pass
skillsList = []
def ReadSkillConfig(Setting):
	global skillsList
	try:
		fopen = open_file(CONFIG, mode='r+')
		fread = fopen.readlines()
		for line in fread:
			if line.startswith(Setting):
				value = line.split('=')[1].strip()
				if value:
					value = value.strip('[]')  
					skillsList = [int(skill) for skill in value.split(',')]
					return skillsList
		return []
	except:
		pass
skillsBuffList = []
def ReadBuffSkillConfig(Setting):
	global skillsBuffList
	try:
		fopen = open_file(CONFIG, mode='r+')
		fread = fopen.readlines()
		for line in fread:
			if line.startswith(Setting):
				value = line.split('=')[1].strip()
				if value:
					value = value.strip('[]')  
					skillsBuffList = [int(skill) for skill in value.split(',')]
					return skillsBuffList
		return []
	except:
		pass
def remNewLines(fname):
	fd = open_file(fname, 'r+')
	lines = fd.readlines()
	fd.seek(0)
	for line in lines:
		if line.strip():
			fd.write(line)
	fd.truncate()
	fd.close()
def SaveConfig(Setting, Value):
	sReader = open_file(CONFIG, 'r+')
	sLines = file.readlines(sReader)
	sWriter = open_file(CONFIG, 'w')
	for Line in sLines:
		if Line.startswith(Setting + '='):
			Line = Setting + '=' + Value + '\n'
		sWriter.write(Line)
	remNewLines(Setting)
def isEntityAlive(vid):
	try:
		global getHPTarget
		chr.SelectInstance(vid)
		if chr.GetInstanceType(vid) == chr.INSTANCE_TYPE_ENEMY:
			if getHPTarget == 0:
				return 0
			else:
				return 1
	except:
		return 1
class Window(object):
	def NoneMethod(cls):
		pass
	NoneMethod = classmethod(NoneMethod)
	def __init__(self, layer='UI'):
		self.hWnd = None
		self.parentWindow = 0
		self.onMouseLeftButtonUpEvent = None
		self.RegisterWindow(layer)
		self.Hide()
	def __del__(self):
		wndMgr.Destroy(self.hWnd)
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.Register(self, layer)
	def OnMouseRightButtonDown(self):
		pass
	def OnMouseLeftButtonDoubleClick(self):
		pass
	def OnMouseRightButtonUp(self):
		pass
	def DownEvent(self):
		pass
	def Destroy(self):
		pass
	def OnMouseOverIn(self):
		pass
	def OnMoveWindow(self, a, b):
		pass
	def OnMouseOverOut(self):
		pass
	def OnMouseLeftButtonDown(self):
		pass
	def OnTop(self):
		pass
	def OnRender(self):
		pass
	if find_string(st_cur_server, "Alune"):
		def OnLoop(self):
			pass
	else:
		def OnUpdate(self):
			pass
	def GetWindowHandle(self):
		return self.hWnd
	def AddFlag(self, style):
		wndMgr.AddFlag(self.hWnd, style)
	def IsRTL(self):
		return wndMgr.IsRTL(self.hWnd)
	def SetWindowName(self, Name):
		wndMgr.SetName(self.hWnd, Name)
	def GetWindowName(self):
		return wndMgr.GetName(self.hWnd)
	def SetParent(self, parent):
		wndMgr.SetParent(self.hWnd, parent.hWnd)
	def SetParentProxy(self, parent):
		self.parentWindow = _weakref.proxy(parent)
		wndMgr.SetParent(self.hWnd, parent.hWnd)
	def GetParentProxy(self):
		return self.parentWindow
	def SetPickAlways(self):
		wndMgr.SetPickAlways(self.hWnd)
	def SetWindowHorizontalAlignLeft(self):
		wndMgr.SetWindowHorizontalAlign(
			self.hWnd, wndMgr.HORIZONTAL_ALIGN_LEFT)
	def SetWindowHorizontalAlignCenter(self):
		wndMgr.SetWindowHorizontalAlign(
			self.hWnd, wndMgr.HORIZONTAL_ALIGN_CENTER)
	def SetWindowHorizontalAlignRight(self):
		wndMgr.SetWindowHorizontalAlign(
			self.hWnd, wndMgr.HORIZONTAL_ALIGN_RIGHT)
	def SetWindowVerticalAlignTop(self):
		wndMgr.SetWindowVerticalAlign(self.hWnd, wndMgr.VERTICAL_ALIGN_TOP)
	def SetWindowVerticalAlignCenter(self):
		wndMgr.SetWindowVerticalAlign(
			self.hWnd, wndMgr.VERTICAL_ALIGN_CENTER)
	def SetWindowVerticalAlignBottom(self):
		wndMgr.SetWindowVerticalAlign(
			self.hWnd, wndMgr.VERTICAL_ALIGN_BOTTOM)
	def SetTop(self):
		wndMgr.SetTop(self.hWnd)
	def Show(self):
		wndMgr.Show(self.hWnd)
	def Hide(self):
		wndMgr.Hide(self.hWnd)
	def Lock(self):
		wndMgr.Lock(self.hWnd)
	def Unlock(self):
		wndMgr.Unlock(self.hWnd)
	def IsShow(self):
		return wndMgr.IsShow(self.hWnd)
	def UpdateRect(self):
		wndMgr.UpdateRect(self.hWnd)
	def SetSize(self, width, height):
		wndMgr.SetWindowSize(self.hWnd, width, height)
	def GetWidth(self):
		return wndMgr.GetWindowWidth(self.hWnd)
	def GetHeight(self):
		return wndMgr.GetWindowHeight(self.hWnd)
	def GetLocalPosition(self):
		return wndMgr.GetWindowLocalPosition(self.hWnd)
	def GetGlobalPosition(self):
		return wndMgr.GetWindowGlobalPosition(self.hWnd)
	def GetMouseLocalPosition(self):
		return wndMgr.GetMouseLocalPosition(self.hWnd)
	def GetRect(self):
		return wndMgr.GetWindowRect(self.hWnd)
	def SetPosition(self, x, y):
		wndMgr.SetWindowPosition(self.hWnd, x, y)
	def SetCenterPosition(self, x=0, y=0):
		self.SetPosition((wndMgr.GetScreenWidth() - self.GetWidth()) /
							2 + x, (wndMgr.GetScreenHeight() - self.GetHeight()) / 2 + y)
	def IsFocus(self):
		return wndMgr.IsFocus(self.hWnd)
	def SetFocus(self):
		wndMgr.SetFocus(self.hWnd)
	def KillFocus(self):
		wndMgr.KillFocus(self.hWnd)
	def GetChildCount(self):
		return wndMgr.GetChildCount(self.hWnd)
	def IsIn(self):
		return wndMgr.IsIn(self.hWnd)
	def SetOnMouseLeftButtonUpEvent(self, event):
		self.onMouseLeftButtonUpEvent = event
	def OnMouseLeftButtonUp(self):
		if self.onMouseLeftButtonUpEvent:
			self.onMouseLeftButtonUpEvent()
			self.onMouseLeftButtonUpEvent()
	def IsInPosition(self):
		xMouse, yMouse = wndMgr.GetMousePosition()
		x, y = self.GetGlobalPosition()
		return xMouse >= x and xMouse < x + self.GetWidth() and yMouse >= y and yMouse < y + self.GetHeight()
			
if find_string(st_cur_server, "merlis") or find_string(st_cur_server, "rhodium"):
	class EventHandler(ui.Window):
		def __init__(self, layer = "TOP_MOST"):
			ui.Window.__init__(self, layer)
			self.events = []
			self.add(10, self.clean, "Clean Events", True)
			self.Show()
		def __del__(self):
			try:
				ui.Window.__del__(self)
			except:
				pass
		def get(self, name):
			for e in self.events:
				if e.name == name:
					return e
			return None
		def has(self, name):
			return eventHandler.get(name) is not None
		def add(self, delay, task, name=None, repeat=False):
			self.events.append(Event(delay, task, name, repeat))
		def remove(self, name, task=None):
			self.events = [e for e in self.events if e.name != name]
			if task is not None: task()
		def pause(self, name, delay):
			event = self.get(name)
			if event is None: return
			self.remove(name)
			self.add(delay, lambda: self.add(event.delay, event.task, event.name, event.repeat))
		def clean(self):
			self.events = [e for e in self.events if not e.over]
		def OnUpdate(self):
			try:
				if foundNewPythonList:
					curTime = time.perf_counter()
				else:
					curTime = time.clock()
				for event in self.events: event.run(curTime)
			except:
				pass
else:
	class EventHandler(Window):
		def __init__(self, layer = "TOP_MOST"):
			Window.__init__(self, layer)
			self.events = []
			self.add(10, self.clean, "Clean Events", True)
			self.Show()
		def __del__(self):
			try:
				Window.__del__(self)
			except:
				pass
		def get(self, name):
			for e in self.events:
				if e.name == name:
					return e
			return None
		def has(self, name):
			return eventHandler.get(name) is not None
		def add(self, delay, task, name=None, repeat=False):
			self.events.append(Event(delay, task, name, repeat))
		def remove(self, name, task=None):
			self.events = [e for e in self.events if e.name != name]
			if task is not None: task()
		def pause(self, name, delay):
			event = self.get(name)
			if event is None: return
			self.remove(name)
			self.add(delay, lambda: self.add(event.delay, event.task, event.name, event.repeat))
		def clean(self):
			self.events = [e for e in self.events if not e.over]
		if find_string(st_cur_server, "Alune"):
			def OnLoop(self):
				try:
					curTime = time.clock()
					for event in self.events: event.run(curTime)
				except:
					pass
		else:
			def OnUpdate(self):
				try:
					if foundNewPythonList:
						curTime = time.perf_counter()
					else:
						curTime = time.clock()
					for event in self.events: event.run(curTime)
				except:
					pass
eventHandler = EventHandler()
isInGame = True
requiresLogin = False
customConnect = False
fullMod = False
isSelChar = False
isTeleporting = False
if find_string(st_cur_server, "valhalla"):
	import introSelect,introCreate,introLogin,introEmpire,introLoading
def Debug():
	onKeyDown(appKey('UP'))
	if foundx64PythonList:
		onKeyUp(player.DIR_UP)	
	else:
		onKeyUp(appKey('UP'))
def pauseFuncs(arg, debug = True):
	global pauseFarmbot, pauseFishbot, pauseEnergy, pauseSkill, pausePick, pauseSpam, pauseItemUser
	global pauseAutoAttack, pauseMobber, pauseOneHit, pauseUsehorse, pauseReply, pauseAutoSell,pauseMoblock
	global pauseBuffbot, pauseFollow, pauseRestart,canWalkTele,setWalkingVar,canWalk
	if arg and debug:
		Debug()
		Attack(False)
		canWalkTele = 0
		manualVidRange = 1
	else:
		canWalkTele = 1
		manualVidRange = 0
	pauseFarmbot = arg
	pauseFishbot = arg
	pauseEnergy = arg
	pauseSkill = arg
	pausePick = arg
	pauseSpam = arg
	pauseItemUser = arg
	pauseAutoAttack = arg	
	pauseMobber = arg	
	pauseMoblock = arg	
	pauseOneHit = arg	
	pauseUsehorse = arg	
	pauseReply = arg	
	pauseAutoSell = arg	
	pauseRestart = arg
	setWalkingVar = arg
	pauseBuffbot = arg	
	pauseFollow = arg
	canWalk = arg
customConnectList = [
	"stellaria",
	"origins",
	"mt2classichu",
	"rop2",
	"zenit",
	"strategic",
	"DDMT",
	"esteria",
	"nextworld",
	"remastered",
	"capital",
	"viral",
	"legend2",
	"merlis",
	"luminus",
	"verion",
	"calliope",
	"aegis",
	"epical",
	"ledania",
	"vortexium",
	"warcry",
	"requilion",
	"selina",
	"adamantium",
	"arezzo",
	"hunter",
	"zaris",
	"ethena",
	"oldcronikal",
	"ydoria",
	"poltia",
	"cave",
	"levia",
	"lunor",
	"yoshino",
	"fwmt2"
]
if any([find_string(st_cur_server, server) for server in customConnectList]):
	customConnect = True
else:
	if isGF:
		try:
			def custom_change_phase_window(original_method):
				global isTeleporting
				try:
					if introEmpire and introCreate:
						fullMod = True
				except:
					fullMod = False
				if fullMod:
					def wrapper(self, *args, **kwargs):
						global isInGame,isSelChar,isTeleporting
						current_phase = self.newPhaseWindow
						if type(current_phase) is introSelect.SelectCharacterWindow:
							isInGame = False
							isSelChar = True
							isTeleporting = False
						elif type(current_phase) is introCreate.CreateCharacterWindow:
							isInGame = False
							isSelChar = False
							isTeleporting = False
						elif type(current_phase) is introLogin.LoginWindow:
							isInGame = False
							isSelChar = False
							isTeleporting = False
						elif type(current_phase) is introEmpire.SelectEmpireWindow:
							isInGame = False
							isSelChar = False
							isTeleporting = False
						elif type(current_phase) is introLoading.LoadingWindow:
							isInGame = False
							isSelChar = False
							isTeleporting = True
						else:
							isInGame = True
							isSelChar = False
							isTeleporting = False
						result = original_method(self, *args, **kwargs)
						return result
					return wrapper
				elif introLoading:
					def wrapper(self, *args, **kwargs):
						global isInGame,isSelChar,isTeleporting
						current_phase = self.newPhaseWindow
						if type(current_phase) is introSelect.SelectCharacterWindow:
							isInGame = False
							isSelChar = True
							isTeleporting = False
						elif type(current_phase) is introLogin.LoginWindow:
							isInGame = False
							isSelChar = False
							isTeleporting = False
						elif type(current_phase) is introLoading.LoadingWindow:
							isInGame = False
							isTeleporting = True
						else:
							isInGame = True
							isSelChar = False
							isTeleporting = False
						result = original_method(self, *args, **kwargs)
						return result
					return wrapper
				else:
					def wrapper(self, *args, **kwargs):
						global isInGame,isSelChar,isTeleporting
						current_phase = self.newPhaseWindow
						if type(current_phase) is introSelect.SelectCharacterWindow:
							isInGame = False
							isSelChar = True
							isTeleporting = False
						elif type(current_phase) is introLogin.LoginWindow:
							isInGame = False
							isSelChar = False
							isTeleporting = False
						else:
							isInGame = True
							isSelChar = False
							isTeleporting = False
						result = original_method(self, *args, **kwargs)
						return result
					return wrapper

			original_change_phase_window = networkModule.MainStream._MainStream__ChangePhaseWindow
			networkModule.MainStream._MainStream__ChangePhaseWindow = custom_change_phase_window(original_change_phase_window)
		except:
			customConnect = True
	else:
		try:
			def custom_change_phase_window(original_method):
				global isInGame
				try:
					if find_string(st_cur_server, "zenessis"):
						if introEmpire and introCreate and introLoading:
							fullMod = True
					else:
						if introEmpire and introCreate:
							fullMod = True
				except:
					fullMod = False
				if fullMod:
					def wrapper(self, *args, **kwargs):
						global isInGame,isSelChar
						current_phase = self.newPhaseWindow
						if type(current_phase) is introSelect.SelectCharacterWindow:
							isInGame = False
							isSelChar = True
						elif type(current_phase) is introCreate.CreateCharacterWindow:
							isInGame = False
							isSelChar = False
						elif type(current_phase) is introLogin.LoginWindow:
							isInGame = False
							isSelChar = False
						elif type(current_phase) is introEmpire.SelectEmpireWindow:
							isInGame = False
							isSelChar = False
						elif type(current_phase) is introLoading.LoadingWindow:
							isInGame = False
							isSelChar = False
						else:
							isInGame = True
							isSelChar = False
						result = original_method(self, *args, **kwargs)
						return result
					return wrapper
				elif introLoading:
					def wrapper(self, *args, **kwargs):
						global isInGame,isSelChar
						current_phase = self.newPhaseWindow
						if type(current_phase) is introSelect.SelectCharacterWindow:
							isInGame = False
							isSelChar = True
						elif type(current_phase) is introLogin.LoginWindow:
							isInGame = False
							isSelChar = False
						elif type(current_phase) is introLoading.LoadingWindow:
							isInGame = False
						else:
							isInGame = True
							isSelChar = False
						result = original_method(self, *args, **kwargs)
						return result
					return wrapper
				else:
					def wrapper(self, *args, **kwargs):
						global isInGame,isSelChar
						current_phase = self.newPhaseWindow
						if type(current_phase) is introSelect.SelectCharacterWindow:
							isInGame = False
							isSelChar = True
						elif type(current_phase) is introLogin.LoginWindow:
							isInGame = False
							isSelChar = False
						else:
							isInGame = True
							isSelChar = False
						result = original_method(self, *args, **kwargs)
						return result
					return wrapper

			original_change_phase_window = networkModule.MainStream._MainStream__ChangePhaseWindow
			networkModule.MainStream._MainStream__ChangePhaseWindow = custom_change_phase_window(original_change_phase_window)
		except:
			customConnect = True
def isConnect():
	global isInGame,customConnect,isGF,isTeleporting
	if any([find_string(st_cur_server, server) for server in customConnectList]):
		return net.IsConnect()
	else:
		if customConnect and not find_string(st_cur_server, "mystic"):
			return net.IsConnect()
		else:
			return isInGame
			
def getCharIndex():
	if isConnect():
		return player.GetMainCharacterIndex()
try:
	CONFIG = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_config.st_set'
	ITEMS_TO_SELL = st_path + '/Data/rascal2/sell_items.st_set'
	CONFIG_FISH = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_fishing.st_set'
	CONFIG_ITEMS = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_config_item_user.st_set'
	CONFIG_PRICE = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_priceconfig.st_set'
	PICKUP_LIST = st_path + '/Data/Servers/' + str(st_cur_server) + '/' + 'pickup_filter.st_set'
except:
	pass
changeTargetIndex = 0
debugged = 0
playerStucked = 0
banList = []
def dist(x1,y1,x2,y2):
	return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
def getPointsDistance(x1,y1,x2,y2,dist_,allow_overflow=False):
	d = dist(x1,y1,x2,y2)
	if(d < 0.0001):
		return(x1,y1)
	if not allow_overflow:
		if (dist_>d):
			return (x2,y2)
	ux = (x2-x1)/d
	uy = (y2-y1)/d
	x = ux*dist_ + x1
	y = uy*dist_ + y1
	return (x,y)
stuck_times = 0
curX = None
curY = None
def GetRotation(x0,y0,x1,y1):
	x1_relative = x1-x0
	y1_relative = y1-y0
	try:
		rada = 180 * (math.acos(y1_relative/math.sqrt((x1_relative)**2 + (y1_relative)**2))) / math.pi + 180
		if x0 >= x1:
			rada = 360 - rada
	except:
		rada = 0
	return rada
countVidReset = 0
loadedBoss = 0
npcList = []
NPCtargetVID_End = 0
NPCtargetVID_Start = 0
NPCrestartCounter = 0
searchNpc = 0
requiresRouteCheck = 1
def walkFunc(x,y):
	try:
		o = getCharIndex()
		if find_string(st_cur_server, "oficial"):
			chr.MoveToDestPosition(oficialARG, int(o),int(x),int(y))
		else:
			chr.MoveToDestPosition(int(o),int(x),int(y))
	except:
		pass
def setPixelPos(x,y,*args):
	try:
		if find_string(st_cur_server, "oficial"):
			chr.SetPixelPosition(oficialARG, int(x),int(y),*args)
		else:
			chr.SetPixelPosition(int(x), int(y), *args)
	except:
		pass
start_time = 0
elapsed_seconds = 0
def remove_folder_contents(folder_path):
	try:
		for filename in os.listdir(folder_path):
			file_path = os.path.join(folder_path, filename)
			try:
				if os.path.isfile(file_path):
					os.unlink(file_path)
				elif os.path.isdir(file_path):
					remove_folder_contents(file_path)
					os.rmdir(file_path)
			except:
				pass
	except:
		pass
try:
	previous_position = player.GetMainCharacterPosition()
except:
	previous_position = None
disabledFishbot = ['Rodnia', 'Land of heroes', 'Zenit', 'Wom', 'rubinum', 'origins','m2classic','aleris']
botStopped = False
canAttack = True
checkCanAttack = False
justRevived = False
checkHPTimes = 0
initX = 0
initY = 0
updateCounter1 = 0
updateCounter2 = 0
updateCounter3 = 0
streamer = 0
neededVid = 0
disconnected_seconds = 0
antibanList = []
pauseFarmbot = 0
pauseFishbot = 0
pauseEnergy = 0
pauseSkill = 0
pausePick = 0
pauseSpam = 0
pauseItemUser = 0
pauseAutoAttack = 0	
pauseMoblock = 0	
pauseMobber = 0	
pauseOneHit = 0	
pauseUsehorse = 0	
pauseReply = 0	
pauseAutoSell = 0	
initFishTime = 0	
startFishTime = 0	
pauseRestart = 0
pauseBuffbot = 0	
pauseFollow = 0	
setWalkingVar = 0	
pauseFishbotTimer = False
dragItem = 0
dragItemId = 0
dragItem2 = 0
dragItemId2 = 0
dragItem3 = 0
dragItemId3 = 0
megaConfirm = 0
try:
	if find_string(st_cur_server, "mt2portugalia"):
		player.GetMainCharacterName = player.GetMainCharacterNamed2A
		chr.GetNameByVID = chr.GetNameByVID2AD
		chr.IsGameMaster = chr.IsGameMaster___
except:
	pass
panicMode = 0
tempAntiBan = 0
myIndex = 0
time_Movement_stoppedTimer = 0
time_Movement_generalTimer = 0
STATE_FINISH = 1
STATE_MOVING = 2
STATE_STOPPED = 0
NO_PATH_FOUND = 0
DESTINATION_REACHED = 1
MOVING = 1
MAX_TELEPORT_PACKETS = 60
TIME_STOPPED_ALLOWED = 3
TIME_WAIT = 0.2
TIME_WAIT_MAP_CHANGE = 5
xToGo = 0
yToGo = 0
pathFindingVar = 0
def IsThisNPC(vid):
	if chr.GetInstanceType(vid) == npcType:
		return True
	return False
def IsThisPlayer(vid):
	if chr.GetInstanceType(vid) == playerType:
		return True
	return False
def IsThisMetin(vid):
	if chr.GetInstanceType(vid) == metinType:
		return True
	return False
def IsThisMob(vid):
	if chr.GetInstanceType(vid) == mobType:
	# if chr.IsEnemy(vid):
		# return True
		return True
	return False
spamState = 0
waithackState = 0
isChangingCH = 0
if foundx64PythonList:
	ctrlKey = 'CONTROL'
	shiftKey = 'SHIFT'
	altKey = 'ALT'
else:
	ctrlKey = 'LCONTROL'
	shiftKey = 'LSHIFT'
	altKey = 'LALT'
def get_possible_keys():
	possible_keys = []
	dik_found = False
	possible_keys.append('None')
	for key in dir(app):
		if key.startswith('DIK_'):
			possible_keys.append(key[4:])
			dik_found = True
	if not dik_found:
		possible_keys = [
			'None', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
			'A', 'ADD', 'APOSTROPHE', 'APPS', 'B', 'BACK', 'BACKSLASH',
			'C', 'CALCULATOR', 'CAPITAL', 'COMMA', 'D', 'DECIMAL', 'DELETE',
			'DIVIDE', 'DOWN', 'E', 'END', 'EQUALS', 'ESC', 'ESCAPE', 'F',
			'F1', 'F10', 'F11', 'F12', 'F2', 'F3', 'F4', 'F5', 'F6',
			'F7', 'F8', 'F9', 'G', 'GRAVE', 'H', 'HOME', 'I', 'INSERT',
			'J', 'K', 'L', altKey, 'LBRACKET', ctrlKey, 'LEFT', shiftKey,
			'LWIN', 'M', 'MEDIASTOP', 'MINUS', 'MULTIPLY', 'MUTE', 'N',
			'NEXTTRACK', 'NUMLOCK', 'NUMPAD0', 'NUMPAD1', 'NUMPAD2',
			'NUMPAD3', 'NUMPAD4', 'NUMPAD5', 'NUMPAD6', 'NUMPAD7', 'NUMPAD8',
			'NUMPAD9', 'NUMPADCOMMA', 'NUMPADENTER', 'O', 'P', 'PAUSE',
			'PERIOD', 'PGDN', 'PGUP', 'PLAYPAUSE', 'Q', 'R', 'RALT',
			'RBRACKET', 'RCONTROL', 'RETURN', 'RIGHT', 'RSHIFT', 'RWIN',
			'S', 'SCROLL', 'SEMICOLON', 'SLASH', 'SPACE', 'SUBTRACT', 'SYSRQ',
			'T', 'TAB', 'U', 'UP', 'V', 'VOLUMEDOWN', 'VOLUMEUP', 'W', 'WEBHOME',
			'X', 'Y', 'Z'
		]
	return possible_keys
if isGF:
	hotkeyListDefault = {
		'relog': (ctrlKey, 'A'),
		'zoomfog': (ctrlKey, 'Z'),
		'day': (ctrlKey, 'D'),
		'night': (ctrlKey, 'N'),
		'sort': (ctrlKey, 'K'),
		'donate': (ctrlKey, 'E'),
		'spam_text': (ctrlKey, 'X'),
		'refine': (ctrlKey, 'R'),
		'show_map': (ctrlKey, 'M'),
		'use_dews': (ctrlKey, 'LALT'),
		'save_settings': (ctrlKey, 'S'),
		'load_settings': (ctrlKey, 'L'),
		'toggle_farm': 'F5',
		'toggle_pickup': 'F6',
		'toggle_panic': 'DELETE',
		'toggle_item_user': 'CAPITAL',
		'waithack': 'F7',
		'ch1': (ctrlKey, 'NUMPAD1'),
		'ch2': (ctrlKey, 'NUMPAD2'),
		'ch3': (ctrlKey, 'NUMPAD3'),
		'ch4': (ctrlKey, 'NUMPAD4'),
		'ch5': (ctrlKey, 'NUMPAD5'),
		'ch6': (ctrlKey, 'NUMPAD6'),
		'ch7': (ctrlKey, 'NUMPAD7'),
		'ch8': (ctrlKey, 'NUMPAD8'),
		'lucernafix': 'F8',
		'tptotarget': 'GRAVE',
		'lock_target': ('TAB', 'Q')
	}
	hotkeyList = {
		'relog': (ctrlKey, 'A'),
		'zoomfog': (ctrlKey, 'Z'),
		'day': (ctrlKey, 'D'),
		'night': (ctrlKey, 'N'),
		'sort': (ctrlKey, 'K'),
		'donate': (ctrlKey, 'E'),
		'spam_text': (ctrlKey, 'X'),
		'refine': (ctrlKey, 'R'),
		'show_map': (ctrlKey, 'M'),
		'use_dews': (ctrlKey, 'LALT'),
		'save_settings': (ctrlKey, 'S'),
		'load_settings': (ctrlKey, 'L'),
		'toggle_farm': 'F5',
		'toggle_pickup': 'F6',
		'toggle_panic': 'DELETE',
		'toggle_item_user': 'CAPITAL',
		'waithack': 'F8',
		'ch1': (ctrlKey, 'NUMPAD1'),
		'ch2': (ctrlKey, 'NUMPAD2'),
		'ch3': (ctrlKey, 'NUMPAD3'),
		'ch4': (ctrlKey, 'NUMPAD4'),
		'ch5': (ctrlKey, 'NUMPAD5'),
		'ch6': (ctrlKey, 'NUMPAD6'),
		'ch7': (ctrlKey, 'NUMPAD7'),
		'ch8': (ctrlKey, 'NUMPAD8'),
		'lucernafix': 'F8',
		'tptotarget': 'GRAVE',
		'lock_target': ('TAB', 'Q')
	}
else:
	hotkeyListDefault = {
		'relog': (ctrlKey, 'A'),
		'zoomfog': (ctrlKey, 'Z'),
		'day': (ctrlKey, 'D'),
		'night': (ctrlKey, 'N'),
		'sort': (ctrlKey, 'K'),
		'donate': (ctrlKey, 'E'),
		'spam_text': (ctrlKey, 'X'),
		'refine': (ctrlKey, 'R'),
		'show_map': (ctrlKey, 'M'),
		'use_dews': (ctrlKey, 'LALT'),
		'save_settings': (ctrlKey, 'S'),
		'load_settings': (ctrlKey, 'L'),
		'toggle_farm': 'F5',
		'toggle_pickup': 'F6',
		'toggle_panic': 'DELETE',
		'toggle_item_user': 'CAPITAL',
		'ch1': (ctrlKey, 'NUMPAD1'),
		'ch2': (ctrlKey, 'NUMPAD2'),
		'ch3': (ctrlKey, 'NUMPAD3'),
		'ch4': (ctrlKey, 'NUMPAD4'),
		'ch5': (ctrlKey, 'NUMPAD5'),
		'ch6': (ctrlKey, 'NUMPAD6'),
		'ch7': (ctrlKey, 'NUMPAD7'),
		'ch8': (ctrlKey, 'NUMPAD8'),
		'lucernafix': 'F8',	
		'tptotarget': 'GRAVE',
		'lock_target': ('TAB', 'Q')
	}
	hotkeyList = {
		'relog': (ctrlKey, 'A'),
		'zoomfog': (ctrlKey, 'Z'),
		'day': (ctrlKey, 'D'),
		'night': (ctrlKey, 'N'),
		'sort': (ctrlKey, 'K'),
		'donate': (ctrlKey, 'E'),
		'spam_text': (ctrlKey, 'X'),
		'refine': (ctrlKey, 'R'),
		'show_map': (ctrlKey, 'M'),
		'use_dews': (ctrlKey, 'LALT'),
		'save_settings': (ctrlKey, 'S'),
		'load_settings': (ctrlKey, 'L'),
		'toggle_farm': 'F5',
		'toggle_pickup': 'F6',
		'toggle_panic': 'DELETE',
		'toggle_item_user': 'CAPITAL',
		'ch1': (ctrlKey, 'NUMPAD1'),
		'ch2': (ctrlKey, 'NUMPAD2'),
		'ch3': (ctrlKey, 'NUMPAD3'),
		'ch4': (ctrlKey, 'NUMPAD4'),
		'ch5': (ctrlKey, 'NUMPAD5'),
		'ch6': (ctrlKey, 'NUMPAD6'),
		'ch7': (ctrlKey, 'NUMPAD7'),
		'ch8': (ctrlKey, 'NUMPAD8'),
		'lucernafix': 'F8',		
		'tptotarget': 'GRAVE',
		'lock_target': ('TAB', 'Q')
	}
isInUse = False
if find_string(st_cur_server, "aronix"):
	uiskill = "ikony/schopnosti/"
else:
	uiskill = "ui/skill/"
if find_string(st_cur_server, "nextworld"):
	bless1 = "d:/worktree/ui/skill/mage/suns_blessing_01.slc"
	force1 = "d:/worktree/ui/skill/mage/swiftness_01.slc"
	reflect1 = "d:/worktree/ui/skill/mage/radiant_shield_01.slc"
	bless2 = "d:/worktree/ui/skill/mage/suns_blessing_02.slc"
	force2 = "d:/worktree/ui/skill/mage/swiftness_02.slc"
	reflect2 = "d:/worktree/ui/skill/mage/radiant_shield_02.slc"
	bless3 = "d:/worktree/ui/skill/mage/suns_blessing_03.slc"
	force3 = "d:/worktree/ui/skill/mage/swiftness_03.slc"
	reflect3 = "d:/worktree/ui/skill/mage/radiant_shield_03.slc"
	
	slot_cover = "d:/worktree/ui/_ui_%s/public/slot_cover_button_01.slc"
	slot_cover1 = "d:/worktree/ui/_ui_%s/public/slot_cover_button_01.slc"
	slot_cover2 = "d:/worktree/ui/_ui_%s/public/slot_cover_button_01.slc"
else:
	if find_string(st_cur_server, "aronix"):
		bless1 = small1
		force1 = small1
		reflect1 = small1
		bless2 = small1
		force2 = small1
		reflect2 = small1
		bless3 = small1
		force3 = small1
		reflect3 = small1
	else:
		bless1 = ymir + uiskill + 'shaman/hosin_01.sub'
		force1 = ymir + uiskill + 'shaman/gicheon_01.sub'
		reflect1 = ymir + uiskill + 'shaman/boho_01.sub'
		bless2 = ymir + uiskill + 'shaman/hosin_02.sub'
		force2 = ymir + uiskill + 'shaman/gicheon_02.sub'
		reflect2 = ymir + uiskill + 'shaman/boho_02.sub'
		bless3 = ymir + uiskill + 'shaman/hosin_03.sub'
		force3 = ymir + uiskill + 'shaman/gicheon_03.sub'
		reflect3 = ymir + uiskill + 'shaman/boho_03.sub'
		
	slot_cover1 = ymir + 'ui/public/slot_cover_button_01.sub'
	slot_cover2 = ymir + 'ui/public/slot_cover_button_02.sub'
	slot_cover3 = ymir + 'ui/public/slot_cover_button_03.sub'
fishArg = 0
argDumped = 0
canCallAgain = 1
startFish = 1
shardBox = 0
feedBox = 0
sentMessageCounts = {}
replyTimes = 0
replyTimesVal = 3
sortDelay = 0
sortIndex=0
isSorting=0
doSafeDamage=0
global_useCount = -1
global_reward = 0
if uiMiniGameFishEvent and not isGF:
	try:
		original_MiniGameFishUse = uiMiniGameFishEvent.MiniGameFish.MiniGameFishUse
		original_MiniGameFishReward = uiMiniGameFishEvent.MiniGameFish.MiniGameFishReward
	except:
		pass
tpTriggered = 0
fishInstance = None
cached_content = None 
last_check_time = None 
lastStuckCheckTime = None 
curFollowX = None
curFollowY = None
stuckFollowTimes = 0
try:
	if not game:
		import game
	OldRecv = game.GameWindow.OpenQuestWindow
except:
	pass
tmpWall = 0
try:
	bool
except NameError:
	def bool(val):
		return not not val
def sort_items(items):
	try:
		return sorted(items)
	except NameError:
		items.sort()
		return items
canSetTarget = 1
channels = {}
if isGF:
	
	def GetServerID():
		try:
			server_name = GetCurrentServer()
			region_id = 0
			if find_string(st_cur_server, "ETH"):
				if server_name:
					for server in serverInfo.SERVER_DICT[0].keys():
						if serverInfo.SERVER_DICT[0][server]['name'] == server_name:
							return int(server)
			else:
				if server_name:
					for server in serverInfo.REGION_DICT[0].keys():
						if serverInfo.REGION_DICT[0][server]['name'] == server_name:
							return int(server)
		except:
			pass
	
	def GetChannels():
		global channels
		channels = {}
		server_id = GetServerID()
		channelDict = serverInfo.REGION_DICT[0][server_id]['channel']
		for channelID, channelDataDict in channelDict.items():
			channels[int(channelID)] = {
				'id': int(channelID),
				'name': channelDataDict['name'],
				'ip': channelDataDict['ip'],
				'port': channelDataDict['tcp_port'],
				'acc_ip' : serverInfo.REGION_AUTH_SERVER_DICT[0][server_id]['ip'],
				'acc_port' : serverInfo.REGION_AUTH_SERVER_DICT[0][server_id]['port']
			}
else:
	
	def GetChannels():
		global channels

		servers = {
			"Solana": {
				'ip': '188.212.103.116',
				'ports': [13002, 13102, 13202, 13302]
			},
			"aleris": {
				'ip': '57.128.211.17',
				'ports': [30003,30013,30023,30033,30043,30053]
			},	

			"aurora": {
				'ip': '191.96.225.27',
				'ports': [13001,13002]
			},	
			"olden": {
				'ip': '57.128.98.67',
				'ports': [30003,30007,30011,30015]
			},		
			"union": {
				'ip': '37.187.135.116',
				'ports': [30101,30201,30301,30401]
			},				
			"vargus": {
				'ip': '93.115.101.190',
				'ports': [30013]
			},				
			"worldmetin3": {
				'ip': '141.94.209.165',
				'ports': [30005,30009,30013,30017]
			},				
			"arezzo": {
				'ip': '193.111.248.240',
				'ports': [30003,30015,30027,30039,30051,30063]
			},				
			"selina": {
				'ip': '45.142.107.32',
				'ports': [12001,12201]
			},				
			"hunter": {
				'ip': '81.180.203.146',
				'ports': [30003,30015]
			},				
			"mythic": {
				'ip': '141.94.97.11',
				'ports': [30003,30007,30011,30015]
			},				
			"zaris": {
				'ip': '81.21.4.17',
				'ports': [31003,31015,31027,31039,31051,31063]
			},				
			"oldmasters": {
				'ip': '157.173.203.135',
				'ports': [26101,26201]
			},							
			"ydoria": {
				'ip': '81.180.203.149',
				'ports': [32101,32201,32301]
			},				
			"lunor": {
				'ip': '45.131.111.224',
				'ports': [36001]
			},				
			"sagita": {
				'ip': '23.88.115.32',
				'ports': [21000, 22000, 23000, 24000]
			},			
			"mystic": {
				'ip': '162.19.94.223',
				'ports': [13000, 13010, 13020, 13030, 13040, 13050]
			},				
			"tensho": {
				'ip': '51.68.36.183',
				'ports': [12101, 12201,12301,12401]
			},				
			"yoshino": {
				'ip': '193.141.60.68',
				'ports': [26104, 26204,26304,26404]
			},				
			"albenia": {
				'ip': '57.128.231.206',
				'ports': [30011, 30019,30027,30035]
			},			
			"freemetin": {
				'ip': 'freemetin.hopto.org',
				'ports': [30003, 30007,30011,30015]
			},				
			"ageofmetin": {
				'ip': '54.39.84.8',
				'ports': [13000, 13100,13200,13300,13400,13500,13600,13700]
			},			
			"colossal": {
				'ip': '45.14.185.111',
				'ports': [20109, 20209,20309]
			},				
			"caris": {
				'ip': '45.131.111.223',
				'ports': [13111, 14080]
			},				
			"orion": {
				'ip': '45.131.108.228',
				'ports': [13101, 13201]
			},				
			"forsaken": {
				'ip': '81.180.203.142',
				'ports': [31003,31011,31019,31027]
			},				
			"talora": {
				'ip': '51.195.61.234',
				'ports': [30003,30009,30015,30021,30027,30033]
			},					
			"aladam": {
				'ip': '57.129.76.248',
				'ports': [30003,30007,30011,30015]
			},				
			"requilion": {
				'ip': '156.229.228.153',
				'ports': [20109,20209,20309]
			},			
			"ethena": {
				'ip': '188.212.102.186',
				'ports': [13001]
			},				
			"poltia": {
				'ip': '146.59.52.177',
				'ports': [30051,30055,30059,30063,30067,30071]
			},		
			
			"raventor": {
				'ip': '141.94.194.241',
				'ports': [12101,12201,12301,12401]
			},				
			"got2": {
				'ip': '95.138.193.135',
				'ports': [13001,13007,13024,13030]
			},				
			"goodoldtimes": {
				'ip': '95.138.193.135',
				'ports': [13001,13007,13024,13030]
			},				
			"levia": {
				'ip': '141.95.66.105',
				'ports': [13001,13101,13201,13301,13401,13501]
			},			
			"baria": {
				'ip': '57.128.216.49',
				'ports': [30003,30009,30015,30021,30027,30033]
			},				
			"melorin": {
				'ip': '91.134.40.46',
				'ports': [13001,13011,13021,13031]
			},				
			"Mt2MesterNext": {
				'ip': '45.67.156.58',
				'ports': [13002,13102,13202,13302]
			},				
			"lynix": {
				'ip': '87.229.6.67',
				'ports': [10010,10020,13040,13060]
			},				
			"ruby": {
				'ip': '188.212.102.21',
				'ports': [30003,30007,30011,30015]
			},			
			"ledania": {
				'ip': '45.137.198.96',
				'ports': [13001,23001,33001,43001]
			},				
			"oldcronikal": {
				'ip': '81.180.202.90',
				'ports': [30003]
			},							
			"varuna": {
				'ip': '45.90.119.29',
				'ports': [30003]
			},				
			"aegis": {
				'ip': '81.180.202.94',
				'ports': [13100]
			},				
			"tanaki": {
				'ip': '188.241.241.40',
				'ports': [30003, 30007, 30011]
			},				
			"epical": {
				'ip': '81.180.202.167',
				'ports': [13002, 13102]
			},				
			"verion": {
				'ip': '185.102.172.76',
				'ports': [20109, 20209, 20309]
			},				
			"viral": {
				'ip': '158.69.58.213',
				'ports': [15003, 15011, 15019]
			},	
			
			"warcry": {
				'ip': '49.13.151.168',
				'ports': [30003, 30007, 30011, 30015]
			},			
			"m2mclassic": {
				'ip': '95.138.193.139',
				'ports': [13000, 13010, 13020, 13030]
			},					
			"rhodium": {
				'ip': '45.142.107.115',
				'ports': [13010, 13020, 13030, 13040]
			},				
			"emtgen": {
				'ip': '141.95.73.19',
				'ports': [16001,16002,16003,16004,16005,16006]
			},				
			"koa2": {
				'ip': '81.180.203.235',
				'ports': [30003,30007,30011,30015]
			},	
			
			"lunaris": {
				'ip': '51.222.254.16',
				'ports': [13101]
			},				
			"robet": {
				'ip': '45.140.188.140',
				'ports': [30054,30058]
			},				
			"strategic": {
				'ip': '81.180.202.243',
				'ports': [30002,30007]
			},				
			"energy": {
				'ip': '81.180.202.108',
				'ports': [30003]
			},			
			"lastfight": {
				'ip': '57.129.84.217',
				'ports': [30003]
			},

			"rebirth": {
				'ip': '193.17.4.197',
				'ports': [30003,30007]
			},
			"bwmt2": {
				'ip': '51.68.34.42',
				'ports': [30054]
			},	
			"zendaris": {
				'ip': '81.180.202.34',
				'ports': [30054]
			},	


			"vampire": {
				'ip': '147.135.199.88',
				'ports': [26101,26201]
			},	
			"zeus": {
				'ip': '188.132.174.229',
				'ports': [13002,13102,13202,13302,13402]
			},				
			"wox": {
				'ip': '81.180.203.12',
				'ports': [31003,31011,31019,31027]
			},				
			"newreborn": {
				'ip': '81.181.129.162',
				'ports': [31003,31011,31019,31027]
			},					
			"velium": {
				'ip': '57.129.64.128',
				'ports': [13000, 13010, 13020, 13030, 13003]
			},				
			"optimize": {
				'ip': '141.95.73.21',
				'ports': [30003, 30009, 30015, 30021]
			},					
			"bendis": {
				'ip': '84.247.139.159',
				'ports': [30064, 30074, 30084, 30094]
			},					
			"everin": {
				'ip': '135.125.189.18',
				'ports': [30003, 30007, 30011, 30015]
			},				
			"elaris": {
				'ip': '51.195.60.237',
				'ports': [13001, 13101, 13201, 13301]
			},	
			
			"prox": {
				'ip': '45.90.15.53',
				'ports': [30003, 30007, 30011, 30015]
			},	
			
			"mayestic": {
				'ip': '45.131.108.238',
				'ports': [13111, 14080]
			},				
			"hiashi": {
				'ip': '193.111.248.240',
				'ports': [13101, 13201, 13301]
			},				
			"ascend2": {
				'ip': '188.213.142.133',
				'ports': [31003, 31011, 31019, 31027]
			},			
			"abyssal": {
				'ip': '87.229.115.177',
				'ports': [30101, 30201, 30301, 30401]
			},
			
			"alaris": {
				'ip': '95.138.193.20',
				'ports': [30003,30013,30023,30033,30043]
			},		
			
			"targoth": {
				'ip': '46.105.73.82',
				'ports': [29001,29101,29201,29301,29401,29501]
			},					
			"valoria": {
				'ip': '51.210.222.177',
				'ports': [12101,12201,12301,12401,12501,12601]
			},				
			"alaska": {
				'ip': '93.114.82.125',
				'ports': [13900,14900,15900,16900,17900,18900]
			},				
			"janes": {
				'ip': '57.129.83.24',
				'ports': [30021,30025,30029,30033,30039,30043]
			},				
			"m2classic": {
				'ip': 'access.rb2.to',
				'ports': [33003,33037,33063,33097,33122,33151]
			},		
			
			"pandoramt2": {
				'ip': '57.128.216.227',
				'ports': [16101,16102,16103,16104,16105]
			},			
			"nethan": {
				'ip': '185.128.114.125',
				'ports': [21000,22000,24000,25000,26000,27000]
			},
			
			"eldoria": {
				'ip': '51.195.43.74',
				'ports': [30054, 30058]
			},			
			
			"capital": {
				'ip': '134.255.219.215',
				'ports': [30003]
			},			
			"ascord": {
				'ip': '146.59.72.64',
				'ports': [10010]
			},				
			"oldmetin": {
				'ip': '57.128.33.93',
				'ports': [21000, 22000, 23000, 24000]
			},				
			"aorim": {
				'ip': '54.39.173.205',
				'ports': [30003, 30011, 30019]
			},					
			"newland": {
				'ip': '51.77.56.43',
				'ports': [30003, 30011, 30019, 30027]
			},				
			"kazuna": {
				'ip': '188.241.241.152',
				'ports': [26104, 26204, 26304, 26404]
			},			
			"sol2": {
				'ip': '135.125.188.135',
				'ports': [30003, 30009, 30015, 30021]
			},

			"rr2evo": {
				'ip': '87.229.115.194',
				'ports': [30004, 30012]
			},				
			"aronix": {
				'ip': '164.68.126.198',
				'ports': [30003, 30007]
			},				
			"EndlessLongju": {
				'ip': '141.94.173.182',
				'ports': [12101, 12201, 12301]
			},			
			"xlast": {
				'ip': '151.80.33.184',
				'ports': [40000, 40100, 40200, 40300]
			},
			
			"i-longju": {
				'ip': '79.137.98.36',
				'ports': [30003, 30011, 30019, 30027, 30035]
			},				
			"metin2og": {
				'ip': '5.183.171.117',
				'ports': [30003, 30007]
			},		
			"oldgeneration": {
				'ip': '5.183.171.117',
				'ports': [30003, 30007]
			},		
			"crypto": {
				'ip': '185.236.231.135',
				'ports': [13001]
			},				
			"glorial": {
				'ip': '81.180.202.25',
				'ports': [13031]
			},				
			"fwmt2": {
				'ip': 'game.fwmt2.com',
				'ports': [13005, 13006]
			},					
			"keynes": {
				'ip': '57.128.102.42',
				'ports': [40464, 40470, 40476]
			},		

			"eliseu": {
				'ip': '81.180.202.19',
				'ports': [30003, 30007, 30011, 30015, 30019, 30023]
			},	

			"korthia": {
				'ip': '141.94.97.23',
				'ports': [40764, 40768, 40772, 40776, 40780, 40784, 40788, 40792]
			},	
			"blackfrost": {
				'ip': '141.94.97.23',
				'ports': [50764, 50768, 50772, 50776, 50780, 50784, 50788, 50792]
			},	
			"global2": {
				'ip': '81.180.203.214',
				'ports': [30003, 30011, 30019, 30027, 30035, 30043]
			},				
			"gold": {
				'ip': '81.180.203.222',
				'ports': [30001, 30101, 30201, 30301, 30401, 30501]
			},				
			"hylox": {
				'ip': '57.128.202.116',
				'ports': [13001, 13101, 13201, 13301, 13401, 13501]
			},	

			"capital": {
				'ip': '134.255.219.215',
				'ports': [30003]
			},			
			"tenerife": {
				'ip': '188.212.101.193',
				'ports': [19000]
			},
			"aztech": {
				'ip': '45.92.8.15',
				'ports': [30101]
			},		
			"m2brasil": {
				'ip': '191.96.79.184',
				'ports': [12101, 12201, 12301, 12401]
			},	
			"mylenium": {
				'ip': '5.206.224.234',
				'ports': [30003, 30007, 30011, 30015, 30019]
			},	
			"ascended": {
				'ip': '81.180.203.149',
				'ports': [32101, 32201, 32301]
			},	
			"horizon": {
				'ip': '81.180.203.149',
				'ports': [32101, 32201, 32301]
			},
			"valeryon": {
				'ip': '185.128.114.173',
				'ports': [21000, 22000, 24000, 25000, 26000, 27000]
			},				
			"luminus": {
				'ip': '141.95.72.54',
				'ports': [13000, 13010, 13020, 13030, 13040, 13050]
			},				
			"ashiro": {
				'ip': '141.95.124.187',
				'ports': [13001, 13021, 13041, 13061, 13081, 13101]
			},	
			"pandora2": {
				'ip': '51.77.56.43',
				'ports': [19003, 19011, 19019, 19027, 19035]
			},	
			"esteria": {
				'ip': '163.172.25.53',
				'ports': [25101, 26101, 12301, 12401]
			},	
									
			"darksouls": {
				'ip': '188.212.103.166',
				'ports': [30003]
			},										
			"liberty": {
				'ip': '75.119.129.193',
				'ports': [30003]
			},	
			"rop2": {
				'ip': '57.129.73.6',
				'ports': [18010]
			},	
			"rayka": {
				'ip': '51.255.93.192',
				'ports': [31003, 31011, 31019, 31027]
			},		
			"gondor": {
				'ip': '185.128.114.132',
				'ports': [30007,30015,30023,30031,30039,30047,30055,30063]
			},	
			
			"landofheroes": {
				'ip': '162.19.84.83',
				'ports': [6011, 6021, 6031, 6041]
			},	
			"honor": {
				'ip': '146.59.54.33',
				'ports': [13001, 13101, 13201, 13301, 13401, 13501, 13601, 13701]
			},	
			"ancient": {
				'ip': '188.212.103.225',
				'ports': [13000, 13010]
			},						
			"metin2rtx": {
				'ip': '81.180.202.39',
				'ports': [20077, 20079, 20081, 20083]
			},	
			
			"m2chungary": {
				'ip': '87.229.115.43',
				'ports': [10010, 10020, 10030, 10040]
			},	
			"zeki": {
				'ip': '188.212.102.117',
				'ports': [13002, 13102, 13202, 13302]
			},	
			
			"avaris": {
				'ip': '162.19.94.29',
				'ports': [40003, 40007, 40011, 40015]
			},			
			"rodnia": {
				'ip': '51.178.22.98',
				'ports': [13000, 13010, 13020, 13030]
			},	
			"zeptia": {
				'ip': '57.128.117.184',
				'ports': [62110, 62210, 62310, 62410]
			},	
			"coh2": {
				'ip': '81.180.202.35',
				'ports': [13100, 13200]
			},	
			"serafines": {
				'ip': '15.235.32.10',
				'ports': [13002, 13102, 13202, 13302]
			},	
			"krom2": {
				'ip': '81.180.203.89',
				'ports': [31003,31011,31019,31027]
			},	
			"auge2": {
				'ip': '200.9.155.50',
				'ports': [13031]
			},			
			"melia": {
				'ip': '45.90.15.19',
				'ports': [13001]
			},			
			"m2khan": {
				'ip': '45.139.199.252',
				'ports': [13000,13003,13006,13009,13012,13015,13018,13021]
			},			
			"helles": {
				'ip': '81.180.202.23',
				'ports': [30003,30007,30011,30015]
			},					
			"kronius": {
				'ip': '51.89.17.28',
				'ports': [13101,13201,13301,13401]
			},				
			"synergy": {
				'ip': '45.142.107.115',
				'ports': [13111,14080,15080,16080]
			},					
			"ageofmagis": {
				'ip': '141.94.160.79',
				'ports': [13001, 13101, 13201, 13301]
			},	
			"legacy2": {
				'ip': '146.59.107.145',
				'ports': [30003,30013]
			},	
			"arthur": {
				'ip': '185.128.114.130',
				'ports': [13111, 13114,13117,13120,13127,13130,13133,13136]
			},	
			"aiver": {
				'ip': '81.180.203.19',
				'ports': [12101, 12201, 12301, 12401]
			},	
			"landofmetin": {
				'ip': '5.183.170.185',
				'ports': [30043, 30047, 30051, 30055]
			},					
			"phantom": {
				'ip': '141.95.72.17',
				'ports': [30003, 30009, 30015, 30021]
			},	
			"valhalla": {
				'ip': '95.138.193.166',
				'ports': [10010, 10020, 10030, 10040]
			},	
			"Metek": {
				'ip': '141.95.107.235',
				'ports': [30003, 30005, 30009, 30011]
			},	
			"tojo": {
				'ip': '185.128.114.60',
				'ports': [30003, 30013, 30023, 30033, 30043, 30053]
			},				
			"CarolineMT2": {
				'ip': '145.239.22.111',
				'ports': [30003, 30009, 30015, 30021, 30027]
			},
			"zenos": {
				'ip': '176.97.210.33',
				'ports': [13111,14080,15080]
			},				

			"2set": {
				'ip': '81.180.203.4',
				'ports': [30001, 30101, 30201, 30301]
			},
			"sepherion": {
				'ip': '51.89.17.28',
				'ports': [12110, 12210, 12310, 12410]
			},
			"avelo": {
				'ip': '141.95.32.14',
				'ports': [30021, 30025, 30029, 30033, 30039, 30043]
			},
			"sinners": {
				'ip': '141.94.254.124',
				'ports': [30003, 30009, 30015, 30021]
			},
			"rebelion": {
				'ip': '81.180.202.31',
				'ports': [30003, 30007, 30011, 30015]
			},
			"dema": {
				'ip': '188.212.101.151',
				'ports': [30003, 30007, 30011, 30015]
			},
			"caroline": {
				'ip': '145.239.22.111',
				'ports': [30003, 30009, 30015, 30021]
			},
			"Aetheria": {
				'ip': '188.212.102.186',
				'ports': [30003, 30007, 30011, 30015]
			},
			"thrones": {
				'ip': '141.94.141.153',
				'ports': [30021, 30025, 30029, 30033]
			},
			"lastworld": {
				'ip': '51.77.56.43',
				'ports': [30003, 30011, 30019, 30027]
			},
			"obscure": {
				'ip': '93.114.82.85',
				'ports': [30003, 30007]
			},
			"DDMT": {
				'ip': '51.210.217.126',
				'ports': [36110, 36210, 36310, 36410]
			},
			"sakai": {
				'ip': '193.141.60.212',
				'ports': [13111, 14080, 15080]
			},
			"oficial": {
				'ip': '81.180.203.77',
				'ports': [13100, 13110, 13020, 13030, 13040, 13050]
			},
			"Nethara": {
				'ip': '15.235.32.10',
				'ports': [13031, 17031, 18031]
			},
			"Emerald": {
				'ip': '94.23.77.86',
				'ports': [13002, 13102, 13202, 13302, 13402]
			},
			"Avery": {
				'ip': '46.105.32.232',
				'ports': [36511, 36521, 36531, 36541, 36551]
			},
			"E3-AquaII": {
				'ip': '37.46.80.202',
				'ports': [13111, 14080, 15080, 16080]
			},
			"celeste": {
				'ip': '192.95.54.135',
				'ports': [30003, 30009]
			},
			"Miyura2": {
				'ip': '176.97.210.28',
				'ports': [13111, 14080, 15080, 16080]
			},
			"Xhelia": {
				'ip': '141.95.104.92',
				'ports': [13002, 13102, 13202]
			},
			"Metin2SG": {
				'ip': '151.80.4.8',
				'ports': [13001, 13011, 13021, 13031]
			},
			"Thor": {
				'ip': '141.95.66.105',
				'ports': [13001, 13110, 13210, 13310]
			},
			"Colossus": {
				'ip': '188.212.102.221',
				'ports': [40007, 40013, 40019, 40025]
			},
			"Kyros": {
				'ip': '38.242.132.232',
				'ports': [13101, 13201, 13301, 13401]
			},
			"Odessa": {
				'ip': '57.129.28.2',
				'ports': [30003, 30007, 30011, 30015]
			},
			"Sineria": {
				'ip': '176.97.210.28',
				'ports': [30003, 30103, 30203, 30303]
			},
			"Vidra": {
				'ip': '45.131.111.223',
				'ports': [13002, 13102, 13202, 13302]
			},
			"Mosha": {
				'ip': '135.125.139.75',
				'ports': [13005, 13105, 13205]
			},
			"Ashura": {
				'ip': '141.95.124.187',
				'ports': [13001, 13021, 13041, 13061, 13081, 13101]
			},
			"calliope": {
				'ip': '162.19.72.31',
				'ports': [29000, 29101, 29201, 29301, 29303, 29305]
			},
			"EmtGen": {
				'ip': '146.59.110.37',
				'ports': [16001, 16002, 16003, 16004, 16005, 16006]
			},
			"Veshia": {
				'ip': '51.77.56.43',
				'ports': [13012, 13022, 13032, 13042, 13052, 13062]
			},
			"Zemia": {
				'ip': '51.77.56.43',
				'ports': [13016, 13025, 13036, 13046, 13056, 13066]
			},
			"SoW2": {
				'ip': '162.19.126.5',
				'ports': [13010, 13016, 13022, 13028, 13034, 13040]
			},
			"WoM2": {
				'ip': '178.33.108.11',
				'ports': [43010, 43020, 43030, 43040, 43050, 43060]
			},
			

			
			
			
			"Rubinum": {
				'ip': 'access.rb2.to',
				'ports': [23007, 23034, 23066, 23097, 23120, 23150]
			},
			"saphirus": {
				'ip': 'saphirus.rb2.to',
				'ports': [13000, 13001, 13002, 13003, 13004, 13005]
			},
			"Zenaris": {
				'ip': '162.19.222.68',
				'ports': [30033, 30043, 30053, 30063, 30073, 30083, 30093, 30103]
			},
			"World of Nitem": {
				'ip': '162.19.61.164',
				'ports': [13000, 13001, 13002, 13003, 13004]
			},
			"Eluryan": {
				'ip': '141.94.99.80',
				'ports': [12101, 12201]
			},
			"Tonoros": {
				'ip': '217.113.49.185',
				'ports': [13000]
			},
			"Levoria": {
				'ip': '193.31.28.124',
				'ports': [21000, 22000, 23000, 24000, 25000]
			},
			"Zenit": {
				'ip': '141.94.254.188',
				'ports': [13001, 13101, 13201, 13301]
			},
			"Sanctury": {
				'ip': '51.254.23.235',
				'ports': [13111, 14080, 15080, 16080]
			},
			"Eos": {
				'ip': 'game.eos2.net',
				'ports': [13000, 13010, 13020, 13030]
			}
		}
		if find_string(st_cur_server, "rohan"):
			try:
				srv = GetCurrentServer()
				if 'Erebor' in srv:
					servers["rohan"] = {
						'ip': '185.128.114.136',
						'ports': [13000, 13010, 13020, 13030]
					}   
				elif 'Efes' in srv:
					servers["rohan"] = {
						'ip': '185.128.114.141',
						'ports': [13000, 13001, 13020, 13030]
					}   
			except:
				pass
		elif find_string(st_cur_server, "legend2"):
			try:
				authPortFile = st_path + "/Data/Servers/" + str(st_cur_server) + '/authPort.ini'
				if os.path.exists(authPortFile) and os.stat(authPortFile).st_size != 0:
					file = open_file(authPortFile, 'r+')
					authPort = file.read().strip()
					file.close()
				
				if authPort == "13002":
					servers["legend2"] = {
						'ip': '51.195.61.91',
						'ports': [27001, 27101, 27201]
					}   
				else:
					servers["legend2"] = {
						'ip': '51.195.61.91',
						'ports': [28001, 28101, 28201, 28301]
					}   
			except:
				pass
		elif find_string(st_cur_server, "misali"):
			try:
				srv = GetCurrentServer()
				if 'kesi' in srv:
					servers["misali"] = {
						'ip': '185.128.114.138',
						'ports': [13011, 13021]
					}			 
				elif 'Asya' in srv:
					servers["misali"] = {
						'ip': '185.128.114.252',
						'ports': [13013, 13023, 13032, 13042, 13052, 13061, 13072, 13081]
					}
				elif 'AllStar' in srv:
					servers["misali"] = {
						'ip': '185.128.114.137',
						'ports': [13011, 13021]
					}
				elif 'Anadolu' in srv:
					servers["misali"] = {
						'ip': '185.128.114.123',
						'ports': [13011, 13021]
					}					
				elif 'tikam' in srv:
					servers["misali"] = {
						'ip': '185.128.114.122',
						'ports': [13011, 13021]
					}
				elif 'Meta' in srv:
					servers["misali"] = {
						'ip': '185.128.114.121',
						'ports': [13011, 13021]
					}	
				elif 'Alesta' in srv:
					servers["misali"] = {
						'ip': '185.128.114.120',
						'ports': [13011, 13021]
					}
				elif 'Kaos' in srv:
					servers["misali"] = {
						'ip': '185.128.114.119',
						'ports': [13011, 13021]
					}
				elif 'tiklal' in srv:
					servers["misali"] = {
						'ip': '185.128.114.117',
						'ports': [13011, 13021, 13031, 13041]
					}
				elif 'Vatan' in srv:
					servers["misali"] = {
						'ip': '185.128.114.118',
						'ports': [13011, 13021, 13031, 13041]
					}
				elif 'Efes' in srv:
					servers["misali"] = {
						'ip': '185.128.114.140',
						'ports': [13011, 13021, 13031, 13041]
					}
				elif 'Odin' in srv:
					servers["misali"] = {
						'ip': '185.128.114.143',
						'ports': [13011, 13021, 13031, 13041]
					}
				elif 'Ares' in srv:
					servers["misali"] = {
						'ip': '185.128.114.124',
						'ports': [13011, 13021, 13031, 13041, 13051, 13061, 13071, 13081]
					}
				elif 'Suspect' in srv:
					servers["misali"] = {
						'ip': '185.128.114.250',
						'ports': [13011, 13021, 13031, 13041, 13051, 13061, 13071, 13081]
					}																																			
				elif 'prime' in srv:
					servers["misali"] = {
						'ip': '185.128.114.252',
						'ports': [13011, 13024, 13032, 13042, 13053, 13063, 13074, 13082, 13092, 13104, 13112, 13121, 13134, 13141, 13151, 13162, 13171, 13181, 13191, 13201]
					}						
				elif 'Avrupa' in srv:
					servers["misali"] = {
						'ip': '185.128.114.251',
						'ports': [13011, 13024, 13032, 13042, 13053, 13063, 13074, 13082, 13092, 13104, 13112, 13121]
					}
			except:
				pass
				
				
		elif find_string(st_cur_server, "merlis"):
			try:

				
				srv = GetCurrentServer()
				if 'merlis' in srv:
					servers["origins"] = {
						'ip': '57.128.216.226',
						'ports': [30003, 30013, 30023, 30033, 30043, 30053]
					}   
				elif 'asgard' in srv:
					servers["origins"] = {
						'ip': '5.135.208.213',
						'ports': [12002, 12102, 12202, 12302,12402,12502,12602,12702,12802,12902]
					}   
			except:
				pass				
				
		elif find_string(st_cur_server, "origins"):
			try:
				srv = GetCurrentServer()
				if 'Revolution' in srv:
					servers["origins"] = {
						'ip': '57.128.216.226',
						'ports': [30003, 30013, 30023, 30033, 30043, 30053]
					}   
				elif 'Origins' in srv:
					servers["origins"] = {
						'ip': '162.19.138.84',
						'ports': [30003, 30013, 30023, 30033]
					}   
			except:
				pass
		for server, data in servers.items():
			if find_string(st_cur_server, server):
				channels = {}
				for i in range(len(data['ports'])):
					channels[i + 1] = {
						'id': i + 1,
						'name': 'CH ' + str(i + 1),
						'ip': data['ip'],
						'port': data['ports'][i]
					}
				break
			else:
				try:
					import serverInfo
					if hasattr(serverInfo, 'REGION_DICT'):
						region_dict = serverInfo.REGION_DICT
						for region_data in region_dict.values():
							for server_data in region_data.values():
								for channelID, channelDataDict in server_data['channel'].items():
									channels[int(channelID)] = {
										'id': int(channelID),
										'name': channelDataDict['name'],
										'ip': channelDataDict['ip'],
										'port': channelDataDict['tcp_port']
									}
					else:
						try:
							channelDict = serverInfo.SERVER_DICT[1]['channel']
							for channelID, channelDataDict in channelDict.items():
								channels[int(channelID)] = {
									'id': int(channelID),
									'name': channelDataDict['name'],
									'ip': channelDataDict['ip'],
									'port': channelDataDict['tcp_port']
								}
						except:
							pass
				except:
					pass
	
	
	
	
authPortFile = st_path + "/Data/Servers/" + str(st_cur_server) + '/authPort.ini'
authPort = 0
try:
	if os.path.exists(authPortFile) and os.stat(authPortFile).st_size != 0:
		file = open_file(authPortFile, 'r+')
		authPort = file.read().strip()
		file.close()
except:
	pass
def doLogin():
	global autoRemoveWalk
	try:
		ingameChannel = GetCurrentChannel()
		selectedChannel = channels[ingameChannel]
		if not selectedChannel:
			selectedChannel = 1
	except:
		selectedChannel = 1
	if username and password and authPort and channels:
		selectedChannel = channels[int(ingameChannel)]
	
	
		try:
			if not find_string(st_cur_server, "rave"):
				intro_module = None
			
				for module_name, module in sys.modules.items():
					if hasattr(module, "LoginWindow") and hasattr(module.LoginWindow, "OnLoginFailure"):
						intro_module = module
						Original_LoginWindow = module.LoginWindow
						original_OnLoginFailure = module.LoginWindow.OnLoginFailure
						original_Connect = module.LoginWindow.Connect
						break
			
				if intro_module:
					# Save original methods
					Original_LoginWindow = intro_module.LoginWindow
					original_OnLoginFailure = Original_LoginWindow.OnLoginFailure
					original_Connect = Original_LoginWindow.Connect
			
					def HookConnect(self, id, pwd, *args):
						global username_h, password_h
						username_h = id
						password_h = pwd
						return original_Connect(self, id, pwd, *args)
			
					def HookedOnLoginFailure(self, error):
						global username_h
						banWords = ["BLOCK", "BAN"]
						for ban in banWords:
							if find_string(str(error), str(ban)):
								if username_h:
									create_log("Account " + str(username_h) + " got banned.")
									dbg.LogBox("Account " + str(username_h) + " is banned.", "Account ban")
								else:
									create_log("Account " + str(username) + " got banned.")
									dbg.LogBox("Account " + str(username) + " is banned.", "Account ban")
								universalTime(1)
			
						# Call the original safely
						return original_OnLoginFailure(self, error)
			
					if not find_string(st_cur_server, "verion"):
						Original_LoginWindow.Connect = HookConnect
					Original_LoginWindow.OnLoginFailure = HookedOnLoginFailure
		except:
			pass
	
	
		if hasattr(net, 'SetPacketSequenceMode') and not (find_string(st_cur_server, "rebirth") or find_string(st_cur_server, "ethena") or find_string(st_cur_server, "aleris")):
			net.SetPacketSequenceMode()
		if find_string(st_cur_server, "kronius"):
			net.SetLoginInfo(str(username), str(password), '')
		elif find_string(st_cur_server, "rebirth"):
			net.SetLoginInfo(str(username), str(password), '216', str(setpin))	
		elif find_string(st_cur_server, "mayestic") or find_string(st_cur_server, "caris"):
			net.SetLoginInfo(str(username), str(password), 1)				
		elif find_string(st_cur_server, "eldoria") or find_string(st_cur_server, "verion"):
			net.SetLoginInfo(str(username), str(password), '1', str(setpin))			
		elif find_string(st_cur_server, "rr2evo"):
			net.SetLoginInfo(str(username), str(password), '1903', str(setpin))
		elif find_string(st_cur_server, "kazuna") or find_string(st_cur_server, "yoshino"):
			net.SetLoginInfo(str(username), str(password), "x " + str(setpin))		
		elif find_string(st_cur_server, "janes"):
			net.SetLoginInfo(str(username), str(password), '')
			
			port = 0
			
			if ingameChannel == 1:
				port = 30015
			elif ingameChannel == 2:
				port = 30017			
			elif ingameChannel == 3:
				port = 30009				
			elif ingameChannel == 4:
				port = 30003				
			elif ingameChannel == 5:
				port = 30009				
			elif ingameChannel == 6:
				port = 30007
				
			
			
			if not port:
				port = int(authPort)
			net.ConnectToAccountServer(selectedChannel["ip"], selectedChannel["port"], selectedChannel["ip"], port)		
		elif find_string(st_cur_server, "merlis"):
			net.SetLoginInfo(str(username), str(password))
			net.SetKeyFileName('master_key2')
			port = 0
			
			if ingameChannel == 1:
				port = 11308
			elif ingameChannel == 2:
				port = 11310		
			elif ingameChannel == 3:
				port = 11308				
			elif ingameChannel == 4:
				port = 11308				
			elif ingameChannel == 5:
				port = 11309
			elif ingameChannel == 6:
				port = 11308				
			elif ingameChannel == 7:
				port = 11310				
			elif ingameChannel == 8:
				port = 11309	
			elif ingameChannel == 9:
				port = 11308				
			elif ingameChannel == 10:
				port = 11310
				
			
			
			if not port:
				port = int(authPort)
			net.ConnectToAccountServer(selectedChannel["ip"], selectedChannel["port"], selectedChannel["ip"], port)		
			
		elif find_string(st_cur_server, "m2classic"):
			net.SetServerIdx(1)
			net.SetServerType(0)
			net.SetLoginInfo(str(username), str(password))
			
			port = 0
			
			if ingameChannel == 1:
				app.SetConnectData('access.rb2.to', 33001)
				port = 31005
			elif ingameChannel == 2:
				app.SetConnectData('access.rb2.to', 33034)
				port = 31006			
			elif ingameChannel == 3:
				app.SetConnectData('access.rb2.to', 33060)
				port = 31007				
			elif ingameChannel == 4:
				app.SetConnectData('access.rb2.to', 33097)
				port = 31001				
			elif ingameChannel == 5:
				app.SetConnectData('access.rb2.to', 33125)
				port = 31002				
			elif ingameChannel == 6:
				app.SetConnectData('access.rb2.to', 33151)
				port = 31003
			if not port:
				port = int(authPort)
			net.ConnectToAccountServer(selectedChannel["ip"], selectedChannel["port"], selectedChannel["ip"], port)
		elif find_string(st_cur_server, "pandoramt2"):
			port = 0
			
			if ingameChannel == 1:
				
				port = 16003
			elif ingameChannel == 2:
				port = 16005			
			elif ingameChannel == 3:
				port = 16003				
			elif ingameChannel == 4:
				port = 16004				
			elif ingameChannel == 5:
				port = 16004				
				
			if not port:
				port = int(authPort)
			net.ConnectToAccountServer(selectedChannel["ip"], selectedChannel["port"], selectedChannel["ip"], port)
			
		elif find_string(st_cur_server, "baria"):
			net.SetLoginInfo(str(username), str(password), str(setpin))
			
			port = 0
			
			if ingameChannel == 1:
				port = 31300
			elif ingameChannel == 2:
				port = 31400		
			elif ingameChannel == 3:
				port = 31200				
			elif ingameChannel == 4:
				port = 31500				
			elif ingameChannel == 5:
				port = 30001
			elif ingameChannel == 6:
				port = 31400				
			if not port:
				port = int(authPort)
			net.ConnectToAccountServer(selectedChannel["ip"], selectedChannel["port"], selectedChannel["ip"], port)	
			
		elif find_string(st_cur_server, "capital"):
			net.SetLoginInfo(str(username), str(password), '101')			
		elif find_string(st_cur_server, "darksouls") or find_string(st_cur_server, "global2") or autoRemoveWalk:
			net.SetLoginInfo(str(username), str(password), '52')
		elif find_string(st_cur_server, "luminus"):
			net.SetLoginInfo(str(username), str(password), '840205')				
		elif find_string(st_cur_server, "gondor") or find_string(st_cur_server, "arezzo") or find_string(st_cur_server, "hunter") or find_string(st_cur_server, "zaris") or find_string(st_cur_server, "lunor") or find_string(st_cur_server, "melorin") or find_string(st_cur_server, "ledania") or find_string(st_cur_server, "sepherion") or find_string(st_cur_server, "valeryon") or find_string(st_cur_server, "newland") or find_string(st_cur_server, "nethan") or find_string(st_cur_server, "targoth") or find_string(st_cur_server, "tanaki"):
			net.SetLoginInfo(str(username), str(password), str(setpin))	
		elif find_string(st_cur_server, "misali"):
			net.SetLoginInfo(str(username), str(password), 'hahhahadsadascanmyhaaa', '121212', 3630, 'default', '__15_11_2024_prime')
		else:
			net.SetLoginInfo(str(username), str(password))
	
		if find_string(st_cur_server, "oficial"):
			net.HaiCuServeru(selectedChannel["ip"], selectedChannel["port"], selectedChannel["ip"], int(authPort))
		elif find_string(st_cur_server, "rubinum"):
			net.SetServerIdx(1)
			net.SetServerType(0)
			net.SetGameServInfo('Rubinum')
			net.SetLoginInfo(str(username), str(password))
			net.SetMarkServer('access.rb2.to', 23000)
			app.SetGuildMarkPath('10.tga')
			app.SetGuildSymbolPath('10')
			app.SetConnectData('access.rb2.to', 23007)	
			
			if ingameChannel == 1:
				port = 21005
			elif ingameChannel == 2:
				port = 21006				
			elif ingameChannel == 3:
				port = 21007				
			elif ingameChannel == 4:
				port = 21001				
			elif ingameChannel == 5:
				port = 21002				
			elif ingameChannel == 6:
				port = 21003
			net.ConnectToAccountServer(selectedChannel["ip"], selectedChannel["port"], selectedChannel["ip"], port)
		elif find_string(st_cur_server, "keynes"):
			port = 0
			if ingameChannel == 1:
				port = 40452
			elif ingameChannel == 2:
				port = 40454				
			elif ingameChannel == 3:
				port = 40456				
			if not port:
				port = int(authPort)			
			
			net.ConnectToAccountServer(selectedChannel["ip"], selectedChannel["port"], selectedChannel["ip"], port)
			
		elif find_string(st_cur_server, "korthia"):
			port = 0
			
			if ingameChannel == 1:
				port = 40752
			elif ingameChannel == 2:
				port = 40754				
			elif ingameChannel == 3:
				port = 40756				
			elif ingameChannel == 4:
				port = 40758				
			elif ingameChannel == 5:
				port = 40760				
			elif ingameChannel == 6:
				port = 40762
				
			if not port:
				port = int(authPort)
			net.ConnectToAccountServer(selectedChannel["ip"], selectedChannel["port"], selectedChannel["ip"], port)
		elif find_string(st_cur_server, "blackfrost"):
			port = 0
			
			if ingameChannel == 1:
				port = 50752
			elif ingameChannel == 2:
				port = 50754				
			elif ingameChannel == 3:
				port = 50756				
			elif ingameChannel == 4:
				port = 50758				
			elif ingameChannel == 5:
				port = 50760				
			elif ingameChannel == 6:
				port = 50762
			elif ingameChannel == 7:
				port = 50762
			elif ingameChannel == 8:
				port = 50762
			if not port:
				port = int(authPort)
			net.ConnectToAccountServer(selectedChannel["ip"], selectedChannel["port"], selectedChannel["ip"], port)
			
		elif find_string(st_cur_server, "wom2"):
			port = 0
			if ingameChannel == 1:
				port = 41020
			else:
				port = 41030
			if not port:
				port = int(authPort)
			net.ConnectToAccountServer(selectedChannel["ip"], selectedChannel["port"], selectedChannel["ip"], port, True)
		elif find_string(st_cur_server, "bendis"):
			port = 0
			if ingameChannel == 1:
				port = 30052
			elif ingameChannel == 2:
				port = 30054	
			elif ingameChannel == 3:
				port = 30056					
			elif ingameChannel == 4:
				port = 30058				
			if not port:
				port = int(authPort)			
			
			net.ConnectToAccountServer(selectedChannel["ip"], selectedChannel["port"], selectedChannel["ip"], port)
			
		elif find_string(st_cur_server, "valoria"):
			net.SetVersionId(1606802439)
			net.ConnectToAccountServer(selectedChannel["ip"], selectedChannel["port"], selectedChannel["ip"], int(authPort))			
		elif find_string(st_cur_server, "zenit"):
			net.SetVersionId(1606802431)
			net.ConnectToAccountServer(selectedChannel["ip"], selectedChannel["port"], selectedChannel["ip"], int(authPort))			
		elif find_string(st_cur_server, "zaris"):
			net.SetVersionId(23)
			net.ConnectToAccountServer(selectedChannel["ip"], selectedChannel["port"], selectedChannel["ip"], int(authPort))			
		elif find_string(st_cur_server, "hunter") or find_string(st_cur_server, "arezzo"):
			net.SetVersionId(101)
			net.ConnectToAccountServer(selectedChannel["ip"], selectedChannel["port"], selectedChannel["ip"], int(authPort))			
		else:
			
			
			
			net.ConnectToAccountServer(selectedChannel["ip"], selectedChannel["port"], selectedChannel["ip"], int(authPort))

			
			
		if eventHandler.has("performlogin"):
			eventHandler.remove('performlogin')
		eventHandler.add(3, lambda: performLogin(1), 'performlogin')
main_stream_instance = None	
try:
	network_module = None
	for module_name, module in sys.modules.items():
		if module and module_name.endswith("networkModule"):
			network_module = module
			break
except:
	pass
try:
	gc_module = None
	
	possible_sys = None
	for mod in globals().values():
		if hasattr(mod, "__name__") and mod.__name__ == "sys":
			possible_sys = mod
			break
	
	if possible_sys:
		gc_module = possible_sys.modules.get("gc") 
	
	if not gc_module:
		import gc as gc_module
	
	
	for obj in gc_module.get_objects():
		if 'MainStream' in str(type(obj)):
			main_stream_instance = obj
			break
		else:
			if isinstance(obj, network_module.MainStream):
					
				main_stream_instance = obj
				break
except:
	pass
canSelect = 0
def GetServerID_Hook():
	import serverInfo
	serverID = 0
	for k in serverInfo.REGION_DICT.get(0, {}).keys():
		if serverInfo.REGION_DICT[0][k]["name"] == net.GetServerInfo().split(",")[0]:
			return k
	return serverID 
def GetxChannelCount_Hook(self):
	import serverInfo
	try:
		serverID = GetServerID_Hook()
		if serverID not in serverInfo.REGION_DICT[0]:
			return 0
		return len(serverInfo.REGION_DICT[0][serverID]["channel"])
	except KeyError:
		return 0
def performLogin(selectCharacter):
	global canSelect,xxxxx
	
	try:
		MoveChannel = None
		for module_name, module in sys.modules.items():
			if hasattr(module, "MoveChannelWindow") and hasattr(module.MoveChannelWindow, "GetChannelCount"):
				MoveChannel = module
				break
		if MoveChannel:
			MoveChannel.MoveChannelWindow.GetChannelCount = GetxChannelCount_Hook
	except:
		pass
	
	if selectCharacter and selectCharSlot:
		try:
			gc_module = None
			
			possible_sys = None
			for mod in globals().values():
				if hasattr(mod, "__name__") and mod.__name__ == "sys":
					possible_sys = mod
					break
			
			if possible_sys:
				gc_module = possible_sys.modules.get("gc") 
			
			if not gc_module:
				import gc as gc_module
			
			
			for obj in gc_module.get_objects():
				if 'MainStream' in str(type(obj)):
					main_stream_instance = obj
					break
				else:
					if isinstance(obj, network_module.MainStream):
							
						main_stream_instance = obj
						break
			
			main_stream_instance.SetCharacterSlot(int(selectCharSlot))
			canSelect = 1
		except:
			canSelect = 1
		
		
	else:
		canSelect = 1
		
	if canSelect:
		try:
			chr.SelectInstance(int(selectCharSlot))
		except:
			pass
		try:
			chr.PushOnceMotion(chr.MOTION_INTRO_SELECTED, 0.1)
		except:
			pass
		try:
			if setpin is not None and hasattr(net, 'SendCharacterPinPacket'):
				net.SendCharacterPinPacket(int(selectCharSlot), str(setpin))
			if setpin is not None and hasattr(net, 'SendCharacterPinPacket'):
				net.SendCharacterPinPacket(int(selectCharSlot), str(setpin))
			if setpin is not None and hasattr(net, 'SendCharacterPinCodePacket'):
				try:
					from introSelect import SelectCharacterWindow
					if hasattr(SelectCharacterWindow, 'OnPinCodeSuccess') and not hasattr(SelectCharacterWindow, 'pinCodeInputBoard'):
						SelectCharacterWindow.pinCodeInputBoard = None
				except:
					pass
				
				if find_string(st_cur_server, "mt2classichu"):
					net.SendCharacterPinCodePacket(int(selectCharSlot), str(setpin), True)
				else:
					net.SendCharacterPinCodePacket(int(selectCharSlot), str(setpin))
		except:
			pass
		net.DirectEnter(int(selectCharSlot))
captcha_items = {}
captcha_correct_index = None
captcha_correct_name = None
last_call_time = 0
calls_made = 0
def miningPacket():
	if isConnect():
		SendChatPacket('/mining_event_renewal 1')
		SendChatPacket('/mining_event_renewal 0')
def scheduleMiningPackets():
	global calls_made
	miningPacket()
	calls_made += 1
	
	if calls_made >= 15:
		calls_made = 0
		return
	if calls_made % 3 == 0:
		eventHandler.add(0.5, scheduleMiningPackets, "mining_event")
	else:
		eventHandler.add(0.33, scheduleMiningPackets, "mining_event")
isGeneralTab = 1
isFarmingTab = 0
def log_message(message):
	msg("Logged: " + str(message))
	
last_arg = None
net_backup = {}
biolog_backup = {}
whatToLog_net = ["SendChatPacket"]
whatToLog_biolog = ["DeliveryItem"]
whatToLog_biologist = ["SendProvidesMaterialRequest"]
intercept_commands = ["delivery", "bio"]
ignore_commands = ["open_biologist"]
is_hooked_net = False
is_hooked_biolog = False
hasBioModule = 0
gmPmCount = 0
gmPmCountMax = 0
Use_Item_ID = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
BonusListe = []
BonusIDListe = {}
randomizeMovement = 1
previous_level = None
last_logged_targets = {}
def getMapName():
	try:
		return background.GetCurrentMapName()
	except:
		return "unknown_map"
def log_attack_or_mining(target_vid):
	try:
		global last_logged_targets
	
		if HasInstance(target_vid):
			target_name = chr.GetNameByVID(target_vid)
			target_type = chr.GetInstanceType(target_vid)
			
			x, y = getPos(target_vid)
			xx = int(x) / 100
			yy = int(y) / 100
			pos = (xx, yy)
			map_name = str(getMapName())
			if target_type == npcType:
				log_text = "Character started mining ore: " + target_name 
			elif target_type == metinType:
				log_text = "Character attacked a Metin: " + target_name 
			else:
				log_text = "Character attacked a Monster: " + target_name 
			if target_vid not in last_logged_targets or last_logged_targets[target_vid] != log_text:
				create_log(log_text)
				last_logged_targets[target_vid] = log_text
	
	except:
		pass
canWalk = 1
def infoCaptcha():
	msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.CAPTCHA_MSG1)				
	eventHandler.add(1, lambda: msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.CAPTCHA_MSG2))
	create_log(lang.CAPTCHA_MSG2)
	
switchbot_instances = []
def IsWeaponArch():
	try:
		idx = player.GetItemIndex(2, item.EQUIPMENT_WEAPON)
		if idx == 0:
			return False
		selectItem(idx)
		if item.GetItemType() == item.ITEM_TYPE_WEAPON and item.GetItemSubType() == item.WEAPON_BOW:
			return True
		return False
	except:
		return False
		
hasToPickup = 0
debuggedWalking = 0
isAntiBanTab = 0
### USER ONLINE ###
userQueue = []
finishedChecking = True
processing_user = False
base_delay = 0.01
increment_delay = 0.2
max_delay = 5.0
current_delay = base_delay
checkedUsers = {}
playerOnline = False
class EventUser:
	def __init__(self, delay, task, name=None):
		self.delay = delay
		self.task = task
		self.name = name
		self.start = app.GetGlobalTimeStamp()
		self.completed = False
	def run(self):
		if app.GetGlobalTimeStamp() - self.start >= self.delay:
			self.task()
			self.completed = True
class EventUserHandler(ui.Window):
	def __init__(self):
		ui.Window.__init__(self, "TOP_MOST")
		self.events = []
		self.Show()
	def add(self, delay, task, name=None):
		self.events.append(EventUser(delay, task, name))
	def clean(self):
		self.events = [e for e in self.events if not e.completed]
	def OnUpdate(self):
		for event in self.events:
			event.run()
		self.clean()
userEventHandler = EventUserHandler()
def ResetFlags():
	global finishedChecking, processing_user, checkedUsers, current_delay
	finishedChecking = True
	playerOnline = False
	processing_user = False
	checkedUsers = {}
	current_delay = base_delay
def StartUserCheck():
	global processing_user, finishedChecking, userQueue, playerOnline,tempAntiBan
	if not isConnect():
		return
	if processing_user or not userQueue:
		if not userQueue:
			# msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFinished checking all users.")
			finishedChecking = True  
			if not playerOnline:
				pauseFuncs(0)
				
				if tempAntiBan:
					start_antiban()
					tempAntiBan = 0
				
		return
	finishedChecking = False
	processing_user = True
	name = userQueue.pop(0)
	checkedUsers[name] = None
	userEventHandler.add(0.1, lambda: WhisperUser(name), "Whisper_" + name)
def WhisperUser(name):
	global processing_user
	if not isConnect():
		return
	SendWhisper(name, "")
	if not hasattr(game.GameWindow, "_hookedWhisperError"):
		game.GameWindow._hookedWhisperError = True
		game.GameWindow.OnRecvWhisperError = HookedOnRecvWhisperError
	if not hasattr(game.GameWindow, "_hookedWhisper"):
		game.GameWindow._hookedWhisper = True
		game.GameWindow.OnRecvWhisper = HookedOnRecvWhisper
	userEventHandler.add(0.3, lambda: TimeoutCheck(name), "Timeout_" + name)
def HookedOnRecvWhisperError(self, mode, name, *args, **kwargs):
	global processing_user, current_delay, playerOnline
	if not isConnect():
		return
	if name in checkedUsers and checkedUsers[name] is not None:
		return
	checkedUsers[name] = False
	# msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hUser: " + str(name) + " is |cffFF0000|H|hOFFLINE.")
	if all([value is False for value in checkedUsers.values()]):
		playerOnline = False
		pauseFuncs(0)
	userEventHandler.clean()
	current_delay = min(current_delay + increment_delay, max_delay)
	processing_user = False
	userEventHandler.add(current_delay, StartUserCheck, "NextUser")
def HookedOnRecvWhisper(self, mode, name, line):
	global processing_user, current_delay, playerOnline
	if not isConnect():
		return
	if name in checkedUsers and checkedUsers[name] is not None:
		return
	checkedUsers[name] = True
	orange = "|cFFFF8040|H|h"
	msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hUser: " + orange + name + " |cffFFFF00|H|his |cff00FF00|H|hONLINE.")
	create_log("Found user: " + str(name) + " online, bot paused.")
	if not playerOnline:
		playerOnline = True
	userEventHandler.clean()
	current_delay = base_delay
	processing_user = False
	userEventHandler.add(current_delay, StartUserCheck, "NextUser")
def TimeoutCheck(name):
	global processing_user, current_delay, playerOnline
	if not isConnect():
		return
	if name in checkedUsers and checkedUsers[name] is not None:
		return
	orange = "|cFFFF8040|H|h"
	checkedUsers[name] = True
	msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hUser: " + orange + name + " |cffFFFF00|H|his |cff00FF00|H|hONLINE.")
	create_log("Found user: " + str(name) + " online, bot paused.")
	if not playerOnline:
		playerOnline = True
	processing_user = False
	current_delay = min(current_delay + increment_delay, max_delay)
	userEventHandler.add(current_delay, StartUserCheck, "NextUser")
canCheckForOnlineUsers = True
try:
	game.GameWindow.OnRecvWhisperError = HookedOnRecvWhisperError
	game.GameWindow.OnRecvWhisper = HookedOnRecvWhisper
except:
	canCheckForOnlineUsers = False
try:
	if hasattr(app, 'OFFLINE_MESSAGE_SYSTEM'):
		if app.OFFLINE_MESSAGE_SYSTEM:
			canCheckForOnlineUsers = False
except:
	pass
### USER ONLINE ###
windowsNotifyOnPm = 0
fishbotState = 0
energyBotState = 0
globalTimeRan = 0
radarEntities = {
	"metins": {},
	"players": {},
	"bosses": {},
	"gms": {},
	"ores": {},
	"npcs": {},
	"mobs": {},
	"portals": {}
}
if find_string(st_cur_server, "aleris"):
	player.LEVEL = player.POINT_LEVEL
	player.DX = player.POINT_DX
	player.IQ = player.POINT_IQ
	player.HP = player.POINT_HP
	player.HT = player.POINT_HT
	player.MAX_HP = player.POINT_MAX_HP
	player.MAX_SP = player.POINT_MAX_SP
	player.SP = player.POINT_SP
	player.ST = player.POINT_ST
	player.NEXT_EXP = player.POINT_NEXT_EXP
	player.EXP = player.POINT_EXP
if find_string(st_cur_server, "avaris"):
	import uiFishingGame	
	
	FishGame = uiFishingGame.FishGame
	
	original_open = FishGame.Open
	
	avarisFishId = None
	
	def hookFishGameOpen(self, a, b):
		global avarisFishId
		avarisFishId = b
	
		return original_open(self, a, b)
	FishGame.Open = hookFishGameOpen
wasKickLogged = 0
globalFarmingKilled = {
	"metins": 0,
	"mobs": 0,
	"bosses": 0,
	"ores": 0,
}
last_counted_targets = {}
globalFarmingStartTime = 0
targets_in_progress = {}
AUTO_ACCEPT_FRIEND = 0
def disable_auto_accept_friend():
	global AUTO_ACCEPT_FRIEND
	AUTO_ACCEPT_FRIEND = 0
def enable_auto_accept_friend():
	global AUTO_ACCEPT_FRIEND
	AUTO_ACCEPT_FRIEND = 1
	
expSessionTotal = 0
lastEXP = 0
lastYang = None
initialYang = None
moblock_state=0
isFarmingOre=0
lastKnownTargetPos = None
notFoundMessageShown = 0
initialEXP = None


def quickCharChange(charIndex):
	global main_stream_instance
	try:
		if main_stream_instance:
			main_stream_instance.SetCharacterSlot(int(charIndex))
			net.DirectEnter(int(charIndex))
	except:
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hQuick character changer: Failed changing character!")


class xxxxxxxxxx(Window):
	autologinstate = "off"
	state = "stop"
	useItemRelogState = "off" 
	startscan = 100
	lvlBotVid = 0
	visible = 1
	def __init__(self):
		Window.__init__(self)
		self.playerPanel = {}
		self.gmPanel = {}
		self.initXX()
		
		self.item_slots = []
		self.item_delays = []
		self.item_timers = []
		self.BuildWindow()
		self.itemlist = {}
		self.onlinePlayersList = []
		self.selected_channel = None
		self.currChannel = 0
		self.currState = STATE_NONE
		self.selectedChannel = 0
		self.x=0
		self.y=0
		self.z=0
		self.speed=5
		self.cooordx=0
		self.cooordy=0
		self.boka=0
		self.bokb=0
		self.cabla=0
		self.npc_duplicate_count = 0
		self.npc_duplicate_controls = []
		self.quest_duplicate_count = 0
		self.quest_duplicate_controls = []
		self.moveState = STATE_STOPPED
		self.goingPath = list()
		self.currDestinationX = 0
		self.currDestinationY = 0
		self.lastPlayerPos = (0,0)
		self.maxDistanceToDest = 50
		if oldPython:
			self.sellItems = []
			self.pickFilter = []
		else:
			self.sellItems = set()
			self.pickFilter = set()
	def initXX(self):
		attributes = [
			"timexRun", "keepSettingsxWindow", "checkxGame", "killXCaptcha", "jigsawFunc", "dungeonFunction",
			"getPlayerxInfo", "GoToPositionAvoidingObjectsx", "farmingx2Func", "pickupNormalxStart",
			"pickupFilterFuncx", "relogBtn_funcx", "quitIfxLogged", "relogBotxFunc", "quitBotxFunc", 
			"stopBotxFunc", "stopquitxLevelFunc", "useItemHpLowFuncxOn", "autoRefreshMapFunc", "sortUpdate",
			"sortx", "stoneBotx", "SellItemsFuxnction", "energyfunc_startx", "transform_to_crystalsx",
			"keepChAttachedWindowMBxFunc", "confirmRouteFuncX", "recordRouteFuncX", "selectstartspamx", 
			"disableStunxOn", "strongBody_funcOnx", "HotkeyShowxST", "HotkeyRelogx", "buyxbait", "fishingxBot",
			"fishbotxFuncAzyrah", "storeInFuncStartx", "buyuseFuncx", "buySellPgmFuncx", "buybotFuncx",
			"skillplus1_funcxx", "skillplus2_funcxx", "skillplus3_funcxx", "skillplus4_funcxx", "skillplus5_funcxx",
			"skillplus6_funcxx", "vit_funcxx", "int_funcxx", "str_funcxx", "dex_funcxx", "itemUserFunc",
			"readss_functionx", "speedFuncx", "startBiox", "onehand_funcx", "twohand_funcx", 
			"refineAlchemy_functionx", "night_funcx", "day_funcx", "redElixir_funcx", "blueElixir_funcx",
			"red_funcx", "wallhackFunc", "blue_funcx", "metinx_funcx", "skillxUsage", "buffBotState",
			"followTarget_funcx", "itemUserDelayFunc", "keepChAttachedItemUserxFunc", "keepChAttachedMapxFunc","keepBossXWindow","keepPlayersxWindowOff",
			"cape_funcx", "hotkeyTele_funcx", "antibanFunxc", "rotateQ_funcx", "rotateE_funcx", "useDews_funcx",
			"keepRadarAttachedxFunc", "keepItemsAttachedxFunc", "keepChAttachedxFunc", "antifly_funcx",
			"mbDetect_funcx", "virtual_funcx", "calliope_funcx", "rotatexTarget", "lockPlayersx", "lockTargetx",
			"moblock_funcczas", "useHorse_funcx", "freeze_funcx", "waithackxStart", "attack_funcx",
			"restartBtnx", "donate_funcx", "funcxKeys", "keepxHotkey", "sortAutox", "stackingAutox", "Delay_Book_Reader",
			"zoomfog_funcx", "hideShowxAntibanBtn","refreshChannelsFunc","PlayersxOnline"
		]
		for attr in attributes:
			setattr(self, attr, XX())
	def walkTele(self,a,b):
		movesp = (int(self.SpeedValue.GetText()) / 10)
		pupaczas.nr=0
		try:
			self.speed = movesp
		except:
			self.speed = 22
		self.cooordx=a
		self.cooordy=b
		self.x, self.y, self.z = player.GetMainCharacterPosition()
		if a>self.x:
			self.boka=a-self.x
		else:
			self.boka=self.x-a
		if b>self.y:
			self.bokb=b-self.y
		else:
			self.bokb=self.y-b
		if self.boka>=self.bokb and self.boka>=self.speed:
			self.cabla=self.boka / self.speed
		elif self.boka<self.bokb and self.bokb>=self.speed:
			self.cabla=self.bokb / self.speed
		else:
			self.cabla=0
	def __del__(self):
		try:
			Window.__del__(self)
		except:
			pass
	def XX1(self, waitTime):
		try:
			if foundNewPythonList:
				curTime = time.perf_counter()
			else:
				curTime = time.clock()
			self.endTime = curTime + waitTime
			self.Show()
		except:
			pass
	def Close(self):
		self.Hide()
	def Destroy(self):
		self.Hide()
	def XX2(self, event):
		self.eventTimeOver = __mem_func__(event)
	def SAFE_SetExitEvent(self, event):
		self.eventExit = __mem_func__(event)
	if find_string(st_cur_server, "Alune"):
		def OnLoop(self):
			global canWalkTele
			lastTime = max(0, self.endTime - time.clock())
			if canWalkTele == 1:
				if metin2.cabla>0 and self.bleble==1:
					c=metin2.boka / metin2.cabla * self.nr+1
					d=metin2.bokb / metin2.cabla * self.nr+1
					x, y, z = player.GetMainCharacterPosition()
					xx=metin2.x
					yy=metin2.y
					if metin2.cooordx>x:
						xx=metin2.x+c
					else:
						xx=metin2.x-c
					if metin2.cooordy>y:
							yy=metin2.y+d
					else:
						yy=metin2.y-d
					o=getCharIndex()
					chr.SelectInstance(o)
					setPixelPos(int(xx), int(yy), int(z))
					onKeyDown(appKey('UP'))
					self.nr=self.nr+1
					if self.rescounter==10:
						self.rescounter=0
					self.rescounter=self.rescounter+1
					if self.rescounter>5:
						if foundx64PythonList:
							onKeyUp(player.DIR_UP)	
						else:
							onKeyUp(appKey('UP'))
					else:
						onKeyDown(appKey('UP'))
					if metin2.cabla<=self.nr+1:
						metin2.cabla=0
						self.nr=0
						if foundx64PythonList:
							onKeyUp(player.DIR_UP)	
						else:
							onKeyUp(appKey('UP'))
			if 0 == lastTime:
				self.Close()
				self.eventTimeOver()
			else:
				return None
			return None
	else:
		def OnUpdate(self):
			global canWalkTele
			if foundNewPythonList:
				lastTime = max(0, self.endTime - time.perf_counter())
			else:
				lastTime = max(0, self.endTime - time.clock())
			if canWalkTele == 1:
				if metin2.cabla>0 and self.bleble==1:
					c=metin2.boka / metin2.cabla * self.nr+1
					d=metin2.bokb / metin2.cabla * self.nr+1
					x, y, z = player.GetMainCharacterPosition()
					xx=metin2.x
					yy=metin2.y
					if metin2.cooordx>x:
						xx=metin2.x+c
					else:
						xx=metin2.x-c
					if metin2.cooordy>y:
							yy=metin2.y+d
					else:
						yy=metin2.y-d
					o=getCharIndex()
					chr.SelectInstance(o)
					setPixelPos(int(xx), int(yy), int(z))
					onKeyDown(appKey('UP'))
					self.nr=self.nr+1
					if self.rescounter==10:
						self.rescounter=0
					self.rescounter=self.rescounter+1
					if self.rescounter>5:
						if foundx64PythonList:
							onKeyUp(player.DIR_UP)	
						else:
							onKeyUp(appKey('UP'))
					else:
						onKeyDown(appKey('UP'))
					if metin2.cabla<=self.nr+1:
						metin2.cabla=0
						self.nr=0
						if foundx64PythonList:
							onKeyUp(player.DIR_UP)	
						else:
							onKeyUp(appKey('UP'))
			if 0 == lastTime:
				self.Close()
				self.eventTimeOver()
			else:
				return None
			return None
	def BuildWindow(self):
		global showOnce,streamer
		global feedBox, shardBox
		
		if find_string(st_cur_server, "alune") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "next2play"):
			self.metin2_window = ui.BoardWithTitleBar()
		else:
			self.metin2_window = BoardWithTitleBar()
		
		self.metin2_window.SetSize(840, 340)
		self.metin2_window.SetCenterPosition()
		self.metin2_window.AddFlag(movplable)
		self.metin2_window.AddFlag('float')
		self.metin2_window.SetTitleName("\x53\x54\x4d\x6f\x64")
		self.metin2_window.SetCloseEvent(self.mBtn_func)
		self.metin2_window.Hide()  # Men batan kapal
		
		self.comp = Component()
		
		
		self.visible = 1
		self.routePath = []
		self.FarmBotStep = 0
		self.FarmCoords = []
		(xPos, yPos) = self.metin2_window.GetGlobalPosition()
################################ QUIT ################################
		
		self.hotKeyCB = CheckBox(lang.STR_HOTKEYS)
		
		self.hotKeyCB.SetParent(self.metin2_window)
		self.hotKeyCB.SetPosition(10,10)
		self.hotKeyCB.Show()
		self.hotKeyCB.eventUp   = self.HotkeyRelogStop
		self.hotKeyCB.eventDown = self.HotkeyRelog
		self.hotKeyCB.Toggle()
		
		self.hotkeysBtn = self.comp.Button(self.metin2_window, lang.STR_OPEN, "", 80, 10, self.openHotkey, small1, small2, small3)
		
		if find_string(st_cur_server, "alune") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "next2play"):
			
			self.hotkeysWindow = ui.BoardWithTitleBar()
			
		else:
			
			self.hotkeysWindow = BoardWithTitleBar()
		
		self.hotkeysWindow.SetTitleName('Hotkeys manager')
		self.hotkeysWindow.SetCloseEvent(self.exit_without_saving)
		self.hotkeysWindow.SetSize(310, 680)
		self.hotkeysWindow.SetPosition(200, 220)
		self.hotkeysWindow.AddFlag(movplable)
		self.hotkeysWindow.AddFlag('float')
		# self.hotkeysWindow.Show()
		try:
			keys = get_possible_keys()
		except:
			keys = 0
	
		if keys:
			self.hotkeysInfoLbl = self.comp.SlotbarText(self.hotkeysWindow, 'Set hotkeys below', 50, 40, 200, 15)
			hotkeysWindow = self.hotkeysWindow
			self.chHotkeys = self.comp.TextLine(self.hotkeysWindow, 'CH Changer Hotkeys: CTRL + NUMPAD (1/2/3/4/5/6/7/8)', 20,63, self.comp.RGB(255,255,255))
			self.create_initial_dropdowns()
			self.setup_event_handlers()
			self.previous_hotkeys = {}
			
			self.hotkeysSettingsLbl = self.comp.TextLine(self.hotkeysWindow, 'Hotkeys settings: ', 100,650, self.comp.RGB(255,255,255))
			self.saveHotkeysBtn = self.comp.Button(self.hotkeysWindow, 'Save', "", 180, 650, lambda: self.saveHotkeys(1), small1, small2, small3)
			self.loadHotkeysBtn = self.comp.Button(self.hotkeysWindow, 'Load', "", 220, 650, lambda: self.loadHotkeys(1), small1, small2, small3)
			self.restoreHotkeysBtn = self.comp.Button(self.hotkeysWindow, 'Restore', "", 260, 650, self.set_default_hotkeys, small1, small2, small3)
		self.wikiBtn = self.comp.Button(self.metin2_window, 'Open Wiki', "", 125, 10, self.openWiki, middle1, middle2, middle3)
		# self.testbtn = self.comp.Button(self.metin2_window, 'Test', "", 190, 10, self.test_fnc, middle1, middle2, middle3)
		if find_string(st_cur_server, "lucerna"):
			self.luFixBtn = self.comp.Button(self.metin2_window, 'Fix', "", 190, 10, self.lucernaAdd, middle1, middle2, middle3)
		if os.path.exists(CONFIG_FOLDER):
			btnLoc = CONFIG_FOLDER + '/img/'
		else:
			btnLoc = st_path + '/Data/rascal2/img/'
		if find_string(st_cur_server, "LandOfHeroes") or find_string(st_cur_server, "aleris") or find_string(st_cur_server, "alune") or find_string(st_cur_server, "origins") or find_string(st_cur_server, "nextworld"):
			self.panicBtn = self.comp.Button(self.metin2_window, 'Panic mode', '', 195, 10, self.disablePanic, middle1, middle2, middle3)
		else:
			self.panicBtn = self.comp.Button(self.metin2_window, '', 'Panic mode enabled', 190, 8, self.disablePanic, btnLoc + 'warn.tga', btnLoc + 'warn.tga', btnLoc + 'warn.tga')
		self.panicBtn.Hide()
		if isGF:
			self.fixQuestsBtn = self.comp.Button(self.metin2_window, 'Relog', "", 755, 7, self.relogFunc, middle1, middle2, middle3)
		elif foundx64PythonList:
			self.fixQuestsBtn = self.comp.Button(self.metin2_window, 'Relog', "", 755, 7, self.KickMe, middle1, middle2, middle3)
		else:
			self.fixQuestsBtn = self.comp.Button(self.metin2_window, 'Relog', "", 755, 7, lambda: self.UnHookQuestWindow(1), middle1, middle2, middle3)
		self.streamerMode = CheckBox('Streamer mode')
		self.streamerMode.SetParent(self.metin2_window)
		self.streamerMode.SetPosition(570,10)
		self.streamerMode.eventUp   = self.streamerOff
		self.streamerMode.eventDown = self.streamerOn
		self.streamerMode.Show()
		try:
			if string_contains(ReadConfig("StreamerMode"), "True") or string_contains(ReadConfig("StreamerMode"), "1"):
				self.streamerMode.OnToggleDown()
				streamer = 1
			else:
				self.streamerMode.OnToggleUp()
				streamer = 0
		except:
			pass
		self.autoHide = CheckBox('Auto hide')
		self.autoHide.SetParent(self.metin2_window)
		self.autoHide.SetPosition(670,10)
		self.autoHide.Show()
		if find_string(st_cur_server, "alune") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "next2play"):
			self.newMap = ui.BoardWithTitleBar()
		else:
			self.newMap = BoardWithTitleBar()
		self.newMap.SetTitleName(lang.STR_MAP_TELE)
		self.newMap.SetCloseEvent(self.closeMapTel)
		self.newMap.SetSize(100, 400)
		self.newMap.SetPosition(200, 220)
		self.newMap.AddFlag(movplable)
		self.newMap.AddFlag('float')
		self.newMap.Hide()
		self.cancelMovement = self.comp.Button(self.newMap, 'Cancel', '', 5, 7, self.cancelMovementFunc, middle1, middle2, middle3)
		self.cancelMovement.Hide()
		try:
			self.MapaSlot = ImageBox()
			self.MapaSlot.SetParent(self.newMap)
			self.MapaSlot.SetPosition(10, 75)
			self.MapaSlot.Show()
			self.playerDot = self.comp.Button(self.MapaSlot, '', '', 0, 0, self.emtpyFunc, playerMark, playerMark, playerMark)
			self.playerDot.Hide()
		except:
			pass
		self.autoRefresh = CheckBox('Auto refresh map')
		self.autoRefresh.SetParent(self.newMap)
		self.autoRefresh.SetPosition(10,50)
		self.autoRefresh.Show()
		self.autoRefresh.eventUp   = self.autoRefreshOff
		self.autoRefresh.eventDown = self.autoRefreshOn
		if isGF:
			self.pathFinding = CheckBox('')
			self.pathFinding.SetParent(self.newMap)
			self.pathFinding.SetPosition(180,50)
			self.pathFinding.Show()
			self.pathFinding.eventUp   = self.setPathFindingOff
			self.pathFinding.eventDown = self.setPathFindingOn
			self.pathFinding.Toggle()
		try:
			self.autoRefresh.Toggle()
		except:
			pass
		self.radarSettings = self.comp.Button(self.newMap, 'Radar', '', 115, 50, self.showRadarWindow, middle1, middle2, middle3)
		if find_string(st_cur_server, "alune") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "next2play"):
			self.radarSettingsWindow = ui.BoardWithTitleBar()
		else:
			self.radarSettingsWindow = BoardWithTitleBar()
		self.radarSettingsWindow.SetCloseEvent(self.closeRadarWindow)
		self.radarSettingsWindow.SetTitleName("Radar settings")
		self.radarSettingsWindow.SetSize(360, 160)
		self.radarSettingsWindow.SetPosition(969, 220)
		self.radarSettingsWindow.AddFlag(movplable)
		self.radarSettingsWindow.AddFlag('float')
		self.radarSettingsWindow.Hide()
		self.showMetins = CheckBox('Show metins')
		self.showMetins.SetParent(self.radarSettingsWindow)
		self.showMetins.SetPosition(20,30)
		self.showMetins.Show()
		self.showBoss = CheckBox('Show bosses')
		self.showBoss.SetParent(self.radarSettingsWindow)
		self.showBoss.SetPosition(20,55)
		self.showBoss.Show()
		self.showOre = CheckBox('Show ore')
		self.showOre.SetParent(self.radarSettingsWindow)
		self.showOre.SetPosition(20,80)
		self.showOre.Show()
		self.showPlayer = CheckBox('Show players')
		self.showPlayer.SetParent(self.radarSettingsWindow)
		self.showPlayer.SetPosition(110,30)
		self.showPlayer.Show()
		self.showGM = CheckBox('Show GM')
		self.showGM.SetParent(self.radarSettingsWindow)
		self.showGM.SetPosition(110,55)
		self.showGM.Show()
		self.showNPC = CheckBox('Show NPC')
		self.showNPC.SetParent(self.radarSettingsWindow)
		self.showNPC.SetPosition(110,80)
		self.showNPC.Show()
		self.showMobs = CheckBox('Show Mobs')
		self.showMobs.SetParent(self.radarSettingsWindow)
		self.showMobs.SetPosition(20,105)
		self.showMobs.Show()
		self.showPortals = CheckBox('Show Portals')
		self.showPortals.SetParent(self.radarSettingsWindow)
		self.showPortals.SetPosition(110,105)
		self.showPortals.Show()
		
		self.lblDrawMap = self.comp.TextLine(self.radarSettingsWindow, 'Draw:',20,130, self.comp.RGB(255,255,255))
		self.drawRoute = CheckBox('Curr. route')
		self.drawRoute.SetParent(self.radarSettingsWindow)
		self.drawRoute.SetPosition(50,130)
		self.drawRoute.Show()		
		self.drawFarmRange = CheckBox('Current farm range')
		self.drawFarmRange.SetParent(self.radarSettingsWindow)
		self.drawFarmRange.SetPosition(130,130)
		self.drawFarmRange.Show()
		
		self.drawInitialFarmRange = CheckBox('Initial farm range')
		self.drawInitialFarmRange.SetParent(self.radarSettingsWindow)
		self.drawInitialFarmRange.SetPosition(250,130)
		self.drawInitialFarmRange.Show()
		
		self.mapTeleWalkLbl = self.comp.TextLine(self.newMap, lang.TAB_FARM_HOW_TO_MOVE, 10,30, self.comp.RGB(255,255,255))
		self.mapTeleWalk = self.comp.ComboBox(self.newMap, goToMetinWay[0], 85, 30, 95)
		for mapTeleWalk in goToMetinWay:
			self.mapTeleWalk.InsertItem(1,str(mapTeleWalk))
		self.closeClientBtn = self.comp.Button(self.metin2_window, lang.STR_CLOSECLIENT, '', 730, 300, self.closeClientFunc, large1, large2, large3)
		if isGF:
			self.showButton = Button()
			self.showButton.SetPosition(10,200)
			self.showButton.SetEvent(self.openMetin2Window)
			try:
				if os.path.exists(CONFIG_FOLDER):
					if os.path.exists(ingameIcon):
						self.showButton.SetUpVisual(CONFIG_FOLDER + '/img/metin2.tga')
						self.showButton.SetOverVisual(CONFIG_FOLDER + '/img/metin2.tga')
						self.showButton.SetDownVisual(CONFIG_FOLDER + '/img/metin2.tga')
				else:
					self.showButton.SetUpVisual(st_path + '/Data/rascal2/img/metin2.tga')
					self.showButton.SetOverVisual(st_path + '/Data/rascal2/img/metin2.tga')
					self.showButton.SetDownVisual(st_path + '/Data/rascal2/img/metin2.tga')			
			except:
				self.showButton.SetUpVisual(st_path + large1)
				self.showButton.SetOverVisual(st_path + large2)
				self.showButton.SetDownVisual(st_path + large3)
			self.showButton.Show()
		else:
			if find_string(st_cur_server, "LandOfHeroes") or find_string(st_cur_server, "aleris") or find_string(st_cur_server, "alune") or find_string(st_cur_server, "origins") or find_string(st_cur_server, "nextworld"):
				btnST1 = large1
				btnST2 = large2	
				btnST3 = large3	
				txt = 'Show \x53\x54\x4d\x6f\x64'
			else:
				txt = ''
				if os.path.exists(CONFIG_FOLDER):
					btnST1 = CONFIG_FOLDER + '/img/metin2.tga'
					btnST2 = CONFIG_FOLDER + '/img/metin2.tga'
					btnST3 = CONFIG_FOLDER + '/img/metin2.tga'
				else:
					btnST1 = st_path + '/Data/rascal2/img/metin2.tga'
					btnST2 = st_path + '/Data/rascal2/img/metin2.tga'
					btnST3 = st_path + '/Data/rascal2/img/metin2.tga'
			self.showButton = self.comp.Button(None, txt, '', 10,200, self.openMetin2Window, btnST1, btnST2, btnST3)
		try:
			f = open_file(st_path + '/Data/rascal2/moveSettings', "w") 
			f.write("0")
			f.close()
		except:
			pass
		asdasd = st_path + "/Data/rascal2/buildVer"
		if os.path.exists(asdasd):
			f = open_file(asdasd, "r+") 
			version = f.read()
			f.close()
			self.metin2VersionLbl = self.comp.TextLine(self.metin2_window, 'Version: ' + str(version), 10, 320, self.comp.RGB(50,205,50))
		else:
			elixirItems = 1
		self.relog_btn = self.comp.Button(self.metin2_window, lang.STR_LOGOUT, lang.STR_TIP_LOGOUT, 100, 300, self.KickMe, large1, large2, large3)
		if find_string(st_cur_server, "alune") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "next2play"):
			self.settingsWindow = ui.BoardWithTitleBar()
		else:
			self.settingsWindow = BoardWithTitleBar()
		self.settingsWindow.SetTitleName('Settings')
		self.settingsWindow.SetCloseEvent(self.closeSettingsWindow)
		self.settingsWindow.SetSize(190, 260)
		self.settingsWindow.SetCenterPosition()
		self.settingsWindow.AddFlag(movplable)
		self.settingsWindow.AddFlag("float")
		self.settingsItems, self.settingsList, self.settingsScrollbar = self.comp.ListBoxEx2(self.settingsWindow, 15, 35, 140, 170)
		self.refreshSettingsList = self.comp.Button(self.settingsWindow, '', '', 144, 9, self.addAllSettings, refresh1, refresh2, refresh3)
		self.settingsList.SetViewItemCount(9)
		self.saveBtn = self.comp.Button(self.settingsWindow, 'Save', '', 5, 210, self.saveSettings, middle1, middle2, middle3)
		self.reset_settings = self.comp.Button(self.settingsWindow, 'Delete', '', 62, 210, self.reset_settings_func, middle1, middle2, middle3)
		self.loadBtn = self.comp.Button(self.settingsWindow, 'Load', '', 120, 210, self.loadSettings, middle1, middle2, middle3)
		self.settingsBtn = self.comp.Button(self.metin2_window, 'Settings', '', 380, 300, self.showSettingsList, large1, large2, large3)
		self.restoreDefault = self.comp.Button(self.settingsWindow, 'Restore default', 'Restore default settings', 50, 232, self.loadDefaultSettings, large1, large2, large3)
		self.addAllSettings()
################################ TAB GENERAL ################################
		self.pnlOthers = self.comp.ThinBoard(self.metin2_window, False, 102, 75, 650, 220, False)
		self.pnlChanger = self.comp.ThinBoard(self.metin2_window, False, 750, 75, 80, 220, False) 
		self.pnlAntiBan = self.comp.ThinBoard(self.metin2_window, False, 102, 55, 650, 245, False)
		self.pnlAntiBan.Hide()
		self.pnlDungeon = self.comp.ThinBoard(self.metin2_window, False, 102, 75, 650, 220, False)
		self.pnlDungeon.Hide()
		self.pnlSolvers = self.comp.ThinBoard(self.metin2_window, False, 102, 75, 650, 220, False)
		self.pnlSolvers.Hide()
		self.tabGeneralToggle = self.comp.ToggleButton(self.metin2_window, 'General', '', 10, 105, (lambda arg = 'off': self.generalTab_Func(arg)), (lambda arg = 'on': self.generalTab_Func(arg)), large1, large2, large3)
		self.tabAntiToggle = self.comp.ToggleButton(self.metin2_window, 'Anti-ban', '', 10, 125, (lambda arg = 'off': self.antibanTab_Func(arg)), (lambda arg = 'on': self.antibanTab_Func(arg)), large1, large2, large3)
		self.tabDungeonToggle = self.comp.ToggleButton(self.metin2_window, 'Dungeons', '', 10, 145, (lambda arg = 'off': self.dungeonTab_Func(arg)), (lambda arg = 'on': self.dungeonTab_Func(arg)), large1, large2, large3)
		self.tabSolversToggle = self.comp.ToggleButton(self.metin2_window, 'Event-helper', '', 10, 165, (lambda arg = 'off': self.eventSolverTab_Func(arg)), (lambda arg = 'on': self.eventSolverTab_Func(arg)), large1, large2, large3)
		########### SOLVERS ###########
		self.pnlJigsaw = self.comp.ThinBoard(self.pnlSolvers, False, 20, 20, 200, 140, False)
		self.lblJigsaw = self.comp.TextLine(self.pnlJigsaw, 'Jigsaw helper', 70, 10, self.comp.RGB(255, 255, 255))
		self.openJigsawChest = CheckBox(lang.OPEN_JIGSAW)
		self.openJigsawChest.SetParent(self.pnlJigsaw)
		self.openJigsawChest.SetPosition(10, 35)
		self.openJigsawChest.Show()
		self.txtJigsaw, self.jigsawChestCount = self.comp.EditLine(self.pnlJigsaw, '10', 65, 37, 25, 15, 2)
		self.jigsawChestCount.SetNumberMode()
		# self.lblFillJigsaw = self.comp.TextLine(self.pnlJigsaw, 'Fill times jigsaw panel:', 10, 60, self.comp.RGB(255, 255, 255))
		# self.txtFillJigsaw, self.jigsawFillTimes = self.comp.EditLine(self.pnlJigsaw, '24', 115, 60, 25, 15, 2)
		# self.jigsawFillTimes.SetNumberMode()
		self.jigsawStartBtn = self.comp.ToggleButton(self.pnlJigsaw, 'Start', '', 125, 85, (self.jigsawStop), (self.jigsawStart), middle1, middle2, middle3)
		self.jigsawBtn = self.comp.Button(self.pnlJigsaw, lang.DO_ONCE, '', 125, 105, self.jigsawFunction, middle1, middle2, middle3)
		########### SOLVERS ###########
		########### DUNGEON ###########
		self.npcInteractLbl = self.comp.TextLine(self.pnlDungeon, lang.NPC_VNUM_INTERRACT, 9, 10, self.comp.RGB(255, 255, 255))
		self.lblDungeonVnum = self.comp.TextLine(self.pnlDungeon, lang.NPC_VNUM, 9, 35, self.comp.RGB(255, 255, 255))
		self.txtDungeonVnum, self.dungeonVnum = self.comp.EditLine(self.pnlDungeon, '0', 80, 35, 40, 15, 20)
		self.dungeonVnum.SetNumberMode()
		self.getVnumBtn = self.comp.Button(self.pnlDungeon, lang.GET_VNUM, '', 130, 33, lambda: self.getDungeonVnum(self.dungeonVnum), middle1, middle2, middle3)
		self.addVnum = self.comp.Button(self.pnlDungeon, '', lang.ADD_VNUM, 195, 37, self.add_duplicate_vnum, plus1, plus2, plus3)
		self.removeVnum = self.comp.Button(self.pnlDungeon, '', lang.REMOVE_NPC, 210, 37, self.rem_last_vnum, minus1, minus2, minus3)
		self.lblDungeonDelay = self.comp.TextLine(self.pnlDungeon, lang.DELAY_SECONDS, 200, 60, self.comp.RGB(255, 255, 255))
		self.txtDungeonDelay, self.dungeonDelay = self.comp.EditLine(self.pnlDungeon, '5', 285, 60, 30, 15, 5)
		self.dungeonDelay.SetNumberMode()
		self.dungeonStartBtn = self.comp.ToggleButton(self.pnlDungeon, 'Start', '', 330, 58, (self.dungeonStop), (self.dungeonStart), middle1, middle2, middle3)
		
		self.lblDragItem = self.comp.CheckBoxx(self.pnlDungeon, lang.DRAG_ITEM, 200, 120, None, None)
		self.itemToDrag = ExpandedImageBox()
		self.itemToDrag.SetParent(self.pnlDungeon)	
		self.itemToDrag.SetPosition(280, 115)
		self.itemToDrag.LoadImage(slot_base)
		self.itemToDrag.OnMouseLeftButtonUp = lambda: self.DeleteDragItem()
		self.itemToDrag.Show()
		self.itemToDragIcon = ExpandedImageBox()
		self.itemToDragIcon.SetParent(self.itemToDrag)
		self.itemToDragIcon.SetPosition(0, 0)
		self.itemToDragIcon.LoadImage(slot_base)
		self.itemToDragIcon.OnMouseLeftButtonUp = lambda: self.SetDragItem()
		self.itemToDragIcon.OnMouseRightButtonDown = lambda: self.DeleteDragItem()
		self.itemToDragIcon.Show()	
		self.lblToDragItem = self.comp.TextLine(self.pnlDungeon, lang.TO_NPC, 317, 122, self.comp.RGB(255, 255, 255))
		self.txtDragNpcVNUM, self.DragNpcVNUM = self.comp.EditLine(self.pnlDungeon, '0', 360, 122, 27, 15, 5)
		self.DragNpcVNUM.SetNumberMode()
		self.getVnumDrag = self.comp.Button(self.pnlDungeon, '', lang.GET_VNUM, 390, 123, self.getDragVnum, plus1, plus2, plus3)
		
		
		
		self.lblDragItem2 = self.comp.CheckBoxx(self.pnlDungeon, lang.DRAG_ITEM, 200, 85, None, None)
		self.itemToDrag2 = ExpandedImageBox()
		self.itemToDrag2.SetParent(self.pnlDungeon)	
		self.itemToDrag2.SetPosition(280, 80)
		self.itemToDrag2.LoadImage(slot_base)
		self.itemToDrag2.OnMouseLeftButtonUp = lambda: self.DeleteDragItem2()
		self.itemToDrag2.Show()
		self.itemToDragIcon2 = ExpandedImageBox()
		self.itemToDragIcon2.SetParent(self.itemToDrag2)
		self.itemToDragIcon2.SetPosition(0, 0)
		self.itemToDragIcon2.LoadImage(slot_base)
		self.itemToDragIcon2.OnMouseLeftButtonUp = lambda: self.SetDragItem2()
		self.itemToDragIcon2.OnMouseRightButtonDown = lambda: self.DeleteDragItem2()
		self.itemToDragIcon2.Show()	
		self.lblToDragItem2 = self.comp.TextLine(self.pnlDungeon, lang.TO_NPC, 317, 87, self.comp.RGB(255, 255, 255))
		self.txtDragNpcVNUM2, self.DragNpcVNUM2 = self.comp.EditLine(self.pnlDungeon, '0', 360, 87, 27, 15, 5)
		self.DragNpcVNUM2.SetNumberMode()
		self.getVnumDrag2 = self.comp.Button(self.pnlDungeon, '', lang.GET_VNUM, 390, 89, self.getDragVnum2, plus1, plus2, plus3)
		
		self.lblDragItem3 = self.comp.CheckBoxx(self.pnlDungeon, lang.DRAG_ITEM, 200, 155, None, None)
		self.itemToDrag3 = ExpandedImageBox()
		self.itemToDrag3.SetParent(self.pnlDungeon)	
		self.itemToDrag3.SetPosition(280, 150)
		self.itemToDrag3.LoadImage(slot_base)
		self.itemToDrag3.OnMouseLeftButtonUp = lambda: self.DeleteDragItem3()
		self.itemToDrag3.Show()
		self.itemToDragIcon3 = ExpandedImageBox()
		self.itemToDragIcon3.SetParent(self.itemToDrag3)
		self.itemToDragIcon3.SetPosition(0, 0)
		self.itemToDragIcon3.LoadImage(slot_base)
		self.itemToDragIcon3.OnMouseLeftButtonUp = lambda: self.SetDragItem3()
		self.itemToDragIcon3.OnMouseRightButtonDown = lambda: self.DeleteDragItem3()
		self.itemToDragIcon3.Show()	
		self.lblToDragItem3 = self.comp.TextLine(self.pnlDungeon, lang.TO_NPC, 317, 157, self.comp.RGB(255, 255, 255))
		self.txtDragNpcVNUM3, self.DragNpcVNUM3 = self.comp.EditLine(self.pnlDungeon, '0', 360, 157, 27, 15, 5)
		self.DragNpcVNUM3.SetNumberMode()
		self.getVnumDrag3 = self.comp.Button(self.pnlDungeon, '', lang.GET_VNUM, 390, 159, self.getDragVnum3, plus1, plus2, plus3)
		
		self.lblGoToNpc = self.comp.TextLine(self.pnlDungeon, lang.GO_TO_NPC, 200, 200, self.comp.RGB(255, 255, 255))
		self.goToNpcDungeon = self.comp.ComboBox(self.pnlDungeon, goToNpcWay[0], 260, 200, 65)
		for goToNpcDungeon in goToNpcWay:
			self.goToNpcDungeon.InsertItem(1,str(goToNpcDungeon))
		self.whatBotLbl = self.comp.TextLine(self.pnlDungeon, lang.WHAT_DO_CLICK_NPC, 400, 10, self.comp.RGB(255, 255, 255))
		self.clickQuest = CheckBox(lang.CLICK_QUEST)
		self.clickQuest.SetParent(self.pnlDungeon)
		self.clickQuest.SetPosition(420, 35)
		self.clickQuest.Show()
		self.txtDungeonQuestIndex, self.DungeonQuestIndex = self.comp.EditLine(self.pnlDungeon, '0', 555, 37, 25, 15, 3)
		self.DungeonQuestIndex.SetNumberMode()
		self.addQuest = self.comp.Button(self.pnlDungeon, '', lang.ADD_QUEST, 590, 38, self.add_duplicate_quest, plus1, plus2, plus3)
		self.removeQuest = self.comp.Button(self.pnlDungeon, '', lang.REMOVE_QUEST, 605, 38, self.rem_last_quest, minus1, minus2, minus3)
		########### DUNGEON ###########
		self.generalTab_Func('on')
		######## TAB ANTI BAN ##############
		self.pnlDetectPlayers = self.comp.ThinBoard(self.pnlAntiBan, False, 15, 5, 150, 160, False)
		self.lblDetectPlayers = self.comp.TextLine(self.pnlDetectPlayers, lang.TAB_ANTIBANPLDET, 35, 5, self.comp.RGB(255, 255, 255))
		self.ifPlayerDetected = self.comp.TextLine(self.pnlDetectPlayers, lang.TAB_ANTIBANIFPLDET, 15, 25, self.comp.RGB(255, 255, 255))
		self.playerPanel[1] = self.notifyPl = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.TAB_ANTIBAN_PLAYER_CHAT, 30, 30, None, None)
		self.playerPanel[2] = self.notifyWindowsPl = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_NOTIFY, 30, 30, None, None)
		self.playerPanel[3] = self.logoutPl = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.TAB_ANTIBAN_PLAYER_LOGOUT, 30, 30, None, None)
		self.playerPanel[4] = self.quitPl = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.TAB_ANTIBAN_PLAYER_QUIT, 30, 30, None, None)
		self.playerPanel[5] = self.beepPl = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.TAB_ANTIBAN_PLAYER_BEEP, 30, 30, None, None)
		self.playerPanel[6] = self.changeCHPl = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.TAB_ANTIBAN_PLAYER_CHANGECH, 30, 30, None, None)
		self.playerPanel[7] = self.stopFarmbotCB1 = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_PAUSE_FARM, 30, 30, None, None)
		if isGF:
			self.playerPanel[8] = self.stopFishbotCB1 = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_PAUSE_WAITHACK, 30, 30, None, None)
		else:
			self.playerPanel[8] = self.stopFishbotCB1 = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_PAUSE_FISH, 30, 30, None, None)
		self.playerPanel[9] = self.stopEnergyCB1 = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_PAUSE_ENERGY, 30, 30, None, None)
		self.playerPanel[10] = self.stopSkillCB1 = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_PAUSE_SKILLBOT, 30, 30, None, None)
		self.playerPanel[11] = self.stopPickCB1 = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_PAUSE_PICK, 30, 30, None, None)
		self.playerPanel[12] = self.stopSpamCB1 = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_PAUSE_SPAM, 30, 30, None, None)
		self.playerPanel[13] = self.stopItemUserCB1 = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_PAUSE_ITEMUSER, 30, 30, None, None)
		self.playerPanel[14] = self.stopAttackCB1 = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_PAUSE_ATTACK, 30, 30, None, None)
		self.playerPanel[15] = self.stopMobberCB1 = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_PAUSE_MOBATTRACT, 30, 30, None, None)
		self.playerPanel[16] = self.stopMoblockCB1 = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_PAUSE_MOBLOCK, 30, 30, None, None)
		self.playerPanel[17] = self.stopOneHitCB1 = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_PAUSE_ONEHIT, 30, 30, None, None)
		self.playerPanel[18] = self.stopHorseCB1 = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_PAUSE_USEHORSE, 30, 30, None, None)
		self.playerPanel[19] = self.stopReplyCB1 = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_PAUSE_REPLYBOT, 30, 30, None, None)
		self.playerPanel[20] = self.stopSellCB1 = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_PAUSE_ITEMSELLER, 30, 30, None, None)
		self.playerPanel[21] = self.stopBuff1 = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_PAUSE_BUFFBOT, 30, 30, None, None)
		self.playerPanel[22] = self.stopFollowTarget1 = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_PAUSE_FOLLOW, 30, 30, None, None)
		self.playerPanel[23] = self.stopRevive1 = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_PAUSE_AUTORESTART, 30, 30, None, None)
		self.playerPanel[24] = self.setWalking1 = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_SETWALK, 30, 30, None, None)
		self.playerPanel[25] = self.AutoAcceptPlayer = self.comp.CheckBoxx(self.pnlDetectPlayers, lang.ANTIBAN_AUTOACCEPT, 30, 30, None, None)
		self.playerPanel[26] = self.playerAutoAcceptFriend = self.comp.CheckBoxx(self.pnlDetectPlayers, 'Accept friend requests', 30, 30, disable_auto_accept_friend, enable_auto_accept_friend)
		self.playerPanel[27] = self.tesctcb1 = self.comp.CheckBoxx(self.pnlDetectPlayers, '', 30, 30, None, None)
		self.tesctcb1.Hide()
		self.playerPanel['scrollbar'] = self.CreateScrollbar(self.pnlDetectPlayers, 120, 131, 35)
		self.playerPanel['scrollbar'].SetMiddleBarSize(float(2)/float(24))
		self.playerPanel['scrollbar'].Show()
		self.playerPanel['scrollbar'].SetScrollEvent(self.__OnScrollPlayer)
		self.__OnScrollPlayer()
		self.quitBotCb = CheckBox(lang.QUITBOTAFTER)
		self.quitBotCb.SetParent(self.pnlAntiBan)
		self.quitBotCb.SetPosition(8,178)
		self.quitBotCb.eventUp = self.quitBotOff
		self.quitBotCb.eventDown = self.quitBotOn
		self.quitBotCb.Show()
		self.txtquitBot, self.quitBotDelay = self.comp.EditLine(self.pnlAntiBan, '120', 180, 178, 40, 15, 5)
		self.quitBotDelay.SetNumberMode()
		self.stopBotCb = CheckBox(lang.STOPBOTAFTER)
		self.stopBotCb.SetParent(self.pnlAntiBan)
		self.stopBotCb.SetPosition(8,198)
		self.stopBotCb.eventUp = self.stopBotOff
		self.stopBotCb.eventDown = self.stopBotOn
		self.stopBotCb.Show()
		self.txtstopBot, self.stopBotDelay = self.comp.EditLine(self.pnlAntiBan, '120', 180, 198, 40, 15, 5)
		self.stopBotDelay.SetNumberMode()
		self.waitMinCb = CheckBox(lang.WAITLOGIN)
		self.waitMinCb.SetParent(self.pnlAntiBan)
		self.waitMinCb.SetPosition(235,178)
		self.waitMinCb.eventUp = self.waitMinOff
		self.waitMinCb.eventDown = self.waitMinOn
		self.waitMinCb.Show()
		self.txtwaitMinutes, self.waitMinutesDelay = self.comp.EditLine(self.pnlAntiBan, '5', 450, 178, 25, 15, 3)
		self.waitMinutesDelay.SetNumberMode()
		self.stopBotLevel = CheckBox('Stop /')
		self.stopBotLevel.SetParent(self.pnlAntiBan)
		self.stopBotLevel.SetPosition(235,198)
		self.stopBotLevel.eventDown = self.disableQuitLevel
		self.stopBotLevel.Show()
		self.quitBotLevel = CheckBox(lang.QUITLEVEL)
		self.quitBotLevel.SetParent(self.pnlAntiBan)
		self.quitBotLevel.SetPosition(289,198)
		self.quitBotLevel.eventDown = self.disableStopLevel
		self.quitBotLevel.Show()
		self.stopquitLevelTxt, self.stopquitLevel = self.comp.EditLine(self.pnlAntiBan, '120', 450, 198, 25, 15, 3)
		self.stopquitLevel.SetNumberMode()
		self.quitIfLogout = CheckBox(lang.QUITLOGGEDOUT)
		self.quitIfLogout.SetParent(self.pnlAntiBan)
		self.quitIfLogout.SetPosition(235,218)
		self.quitIfLogout.eventUp = self.quitIfLoggedOff
		self.quitIfLogout.eventDown = self.quitIfLoggedOn
		self.quitIfLogout.Show()
		
		self.stopBotIfPlayerOnline = CheckBox("Panic mode if any player online:")
		self.stopBotIfPlayerOnline.SetParent(self.pnlAntiBan)
		self.stopBotIfPlayerOnline.SetPosition(440,218)
		self.stopBotIfPlayerOnline.eventUp = self.disablePlayersOnline
		self.stopBotIfPlayerOnline.eventDown = self.enablePlayersOnline
		if canCheckForOnlineUsers:
			self.stopBotIfPlayerOnline.Show()
			self.playersOnlineBtn = self.comp.Button(self.pnlAntiBan, 'Edit', 'Players online options', 610,218, self.showPlayerOnlineWindow, xmall1, xmall2, xmall3)
		
		
		if find_string(st_cur_server, "alune") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "next2play"):
			self.playersOnlineWindow = ui.BoardWithTitleBar()
		else:
			self.playersOnlineWindow = BoardWithTitleBar()
		self.playersOnlineWindow.SetCloseEvent(lambda: self.playersOnlineWindow.Hide())
		self.playersOnlineWindow.SetTitleName('Players online settings')
		self.playersOnlineWindow.SetSize(250,200)
		self.playersOnlineWindow.SetPosition(500, 220)
		self.playersOnlineWindow.AddFlag(movplable)
		self.playersOnlineWindow.AddFlag('float')
		self.playersOnlineWindow.Hide()
		
				
		
		
		self.txtPlayerOnline, self.playerOnlineText = self.comp.EditLine(self.playersOnlineWindow, '', 15, 35, 170, 15, 25)
		self.btnAddThisPlayerOnline = self.comp.Button(self.playersOnlineWindow, 'Add', 'Add this player name to detect if online', 195, 33, self.addPlayerToOnlineList, small1, small2, small3)
		self.playersOnlineBar, self.playersOnlineList, self.playersOnlineScroll = self.comp.ListBoxEx2(self.playersOnlineWindow, 15, 60, 180, 100)
		self.playersOnlineList.SetViewItemCount(5)
		self.refPlayersOnlineList = self.comp.Button(self.playersOnlineWindow, '','Refresh existing online players list', 220, 67, self.refreshOnlinePlayersList, refresh1, refresh2, refresh3)
		self.btnRemovePlayerOnlinelist = self.comp.Button(self.playersOnlineWindow, '', 'Remove selected player from online players list', 223, 88, self.removePlayerFromOnlineList, minus1, minus2, minus3)
		self.btnDeletePlayersOnline = self.comp.Button(self.playersOnlineWindow, lang.TAB_ANTIBAN_DEL_WHITELIST, 'Deletes online players list', 175, 165, self.askdeleteOnlinePlayersList, middle1, middle2, middle3)
		
		self.playersOnlineHelp = self.comp.Button(self.playersOnlineWindow, 'Help', '', 15, 165, self.onlinePlayersInfo, xmall1, xmall2, xmall3)
		self.btnAddTargetPlayerOnline = self.comp.Button(self.playersOnlineWindow, 'Add target', 'Add selected target to detect when online', 110, 165, self.funcAddTargetPlayerOnline, middle1, middle2, middle3)
		self.stopquitLogoutTxt, self.stopquitLogout = self.comp.EditLine(self.pnlAntiBan, '10', 390, 218, 25, 15, 3)
		self.stopquitLogout.SetNumberMode()
		self.relogBotCb = CheckBox(lang.RELOGXMIN)
		self.relogBotCb.SetParent(self.pnlAntiBan)
		self.relogBotCb.SetPosition(8,218)
		self.relogBotCb.eventUp = self.relogBotOff
		self.relogBotCb.eventDown = self.relogBotOn
		self.relogBotCb.Show()
		self.txtrelogBot, self.relogBotDelay = self.comp.EditLine(self.pnlAntiBan, '10', 180, 218, 40, 15, 5)
		self.relogBotDelay.SetNumberMode()
		self.pnlDetectGM = self.comp.ThinBoard(self.pnlAntiBan, False, 175, 5, 190, 160, False)
		self.lblDetectGMs = self.comp.TextLine(self.pnlDetectGM, lang.TAB_ANTIBANGMDET, 45, 5, self.comp.RGB(255, 255, 255))
		self.ifGMDetected = self.comp.TextLine(self.pnlDetectGM, lang.TAB_ANTIBANIFGMDET, 15, 25, self.comp.RGB(255, 255, 255))
		self.gmPanel[1] = self.notifyGM = self.comp.CheckBoxx(self.pnlDetectGM, lang.TAB_ANTIBAN_GM_CHAT, 30, 30, None, None)
		self.gmPanel[2] = self.notifyWindowsGM = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_NOTIFY, 30, 30, None, None)
		self.gmPanel[3] = self.logoutGM = self.comp.CheckBoxx(self.pnlDetectGM, lang.TAB_ANTIBAN_GM_LOGOUT, 30, 30, None, None)
		self.gmPanel[4] = self.quitGM = self.comp.CheckBoxx(self.pnlDetectGM, lang.TAB_ANTIBAN_GM_QUIT, 30, 30, None, None)
		self.gmPanel[5] = self.quitAllGM = self.comp.CheckBoxx(self.pnlDetectGM, lang.TAB_ANTIBAN_GM_QUIT_ALL, 30, 30, None, None)
		self.gmPanel[6] = self.beepGM = self.comp.CheckBoxx(self.pnlDetectGM, lang.TAB_ANTIBAN_GM_BEEP, 30, 30, None, None)
		self.gmPanel[7] = self.changeCHGM = self.comp.CheckBoxx(self.pnlDetectGM, lang.TAB_ANTIBAN_GM_CHANGECH, 30, 30, None, None)
		self.gmPanel[8] = self.stopFarmbotCB2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_PAUSE_FARM, 30, 30, None, None)
		if isGF:
			self.gmPanel[9] = self.stopFishbotCB2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_PAUSE_WAITHACK, 30, 30, None, None)
		else:
			self.gmPanel[9] = self.stopFishbotCB2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_PAUSE_FISH, 30, 30, None, None)
		self.gmPanel[10] = self.stopEnergyCB2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_PAUSE_ENERGY, 30, 30, None, None)
		self.gmPanel[11] = self.stopSkillCB2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_PAUSE_SKILLBOT, 30, 30, None, None)
		self.gmPanel[12] = self.stopPickCB2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_PAUSE_PICK, 30, 30, None, None)
		self.gmPanel[13] = self.stopSpamCB2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_PAUSE_SPAM, 30, 30, None, None)
		self.gmPanel[14] = self.stopItemUserCB2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_PAUSE_ITEMUSER, 30, 30, None, None)
		self.gmPanel[15] = self.stopAttackCB2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_PAUSE_ATTACK, 30, 30, None, None)
		self.gmPanel[16] = self.stopMobberCB2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_PAUSE_MOBATTRACT, 30, 30, None, None)
		self.gmPanel[17] = self.stopMoblockCB2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_PAUSE_MOBLOCK, 30, 30, None, None)
		self.gmPanel[18] = self.stopOneHitCB2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_PAUSE_ONEHIT, 30, 30, None, None)
		self.gmPanel[19] = self.stopHorseCB2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_PAUSE_USEHORSE, 30, 30, None, None)
		self.gmPanel[20] = self.stopReplyCB2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_PAUSE_REPLYBOT, 30, 30, None, None)
		self.gmPanel[21] = self.stopSellCB2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_PAUSE_ITEMSELLER, 30, 30, None, None)
		self.gmPanel[22] = self.stopBuff2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_PAUSE_BUFFBOT, 30, 30, None, None)
		self.gmPanel[23] = self.stopFollowTarget2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_PAUSE_FOLLOW, 30, 30, None, None)
		self.gmPanel[24] = self.stopRevive2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_PAUSE_AUTORESTART, 30, 30, None, None)
		self.gmPanel[25] = self.setWalking2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_SETWALK, 30, 30, None, None)
		self.gmPanel[26] = self.AutoAcceptCB2 = self.comp.CheckBoxx(self.pnlDetectGM, lang.ANTIBAN_AUTOACCEPT, 30, 30, None, None)
		self.gmPanel[27] = self.tesctcb2 = self.comp.CheckBoxx(self.pnlDetectGM, '', 30, 30, None, None)
		self.tesctcb2.Hide()
		self.gmPanel['scrollbar'] = self.CreateScrollbar(self.pnlDetectGM, 120, 171, 35)
		self.gmPanel['scrollbar'].SetMiddleBarSize(float(2)/float(24))
		self.gmPanel['scrollbar'].Show()
		self.gmPanel['scrollbar'].SetScrollEvent(self.__OnScrollGM)
		self.__OnScrollGM()
		self.pnlPMDetect = self.comp.ThinBoard(self.pnlAntiBan, False, 380, 5, 260, 75, False)
		# self.lblPmDetector = self.comp.TextLine(self.pnlPMDetect, lang.PM_DETECTOR, 85, 5, self.comp.RGB(255, 255, 255))
		self.exitPM = CheckBox(lang.QUITPMGM)
		self.exitPM.SetParent(self.pnlPMDetect)
		self.exitPM.SetPosition(15,10)
		self.exitPM.eventUp = self.quitifgmOff
		self.exitPM.eventDown = self.quitifgmOn
		self.exitPM.Show()
		self.txtQuitGMPMTimes, self.QuitGMPMTimes = self.comp.EditLine(self.pnlPMDetect, '1', 105, 10, 22, 15, 2)
		self.QuitGMPMTimes.SetNumberMode()
		self.beepPM = CheckBox(lang.TAB_ANTIBAN_BEEP_PM)
		self.beepPM.SetParent(self.pnlPMDetect)
		self.beepPM.SetPosition(15,30)
		self.beepPM.eventUp = self.beepOff
		self.beepPM.eventDown = self.beepOn
		self.beepPM.Show()
		self.notifyPM = CheckBox('Windows Notify on PM')
		self.notifyPM.SetParent(self.pnlPMDetect)
		self.notifyPM.SetPosition(15,50)
		self.notifyPM.eventUp = self.windowsNotifyOff
		self.notifyPM.eventDown = self.windowsNotifyOn
		self.notifyPM.Show()
		
		self.pnlWhitelist = self.comp.ThinBoard(self.pnlAntiBan, False, 380, 80, 260, 95, False)
		self.bar_whitelist, self.PlayersWhiteList, self.scroll_whitelist = self.comp.ListBoxEx2(self.pnlWhitelist, 15, 10, 130, 80)
		self.PlayersWhiteList.SetViewItemCount(4)
		self.refWhitelist = self.comp.Button(self.pnlWhitelist, '',lang.TAB_ANTIBAN_REF_WHITELIST, 163, 7, self.updateWhitelist, refresh1, refresh2, refresh3)
		self.btnaddPlayerWhitelist = self.comp.Button(self.pnlWhitelist, '', lang.TAB_ANTIBAN_ADD_WHITELIST, 200, 15, self.addWhitelist, plus1, plus2, plus3)
		self.btnremovePlayerWhitelist = self.comp.Button(self.pnlWhitelist, '', lang.TAB_ANTIBAN_REM_SEL_WHITELIST, 215, 15, self.removeSelectedPlayer, minus1, minus2, minus3)
		self.txtAddWhitelist, self.addWhitelistName = self.comp.EditLine(self.pnlWhitelist, '', 176, 35, 60, 15, 25)
		self.btnAddThisName = self.comp.Button(self.pnlWhitelist, '', lang.TAB_ANTIBAN_ADDNAME_WHITELIST, 240, 37, self.addNameWhitelist, plus1, plus2, plus3)
		self.btndeleteWhitelist = self.comp.Button(self.pnlWhitelist, lang.TAB_ANTIBAN_DEL_WHITELIST, lang.TAB_ANTIBAN_DEL_WHITELIST_TIP, 185, 55, self.askRemWhitelist, middle1, middle2, middle3)
		self.startDetector = self.comp.ToggleButton(self.pnlAntiBan, 'Start antiban', '', 555, 185, (self.antibanStop), (self.funcAntiBanStart), large1, large2, large3)
######## TAB ANTI BAN ##############
		self.lblChChanger = self.comp.TextLine(self.pnlChanger, 'CH Changer', 11, 25, self.comp.RGB(255, 255, 255))
		self.refCh = self.comp.Button(self.pnlChanger, '', 'Refresh channels', 31, 5, self.refreshChannels, refresh1, refresh2, refresh3)
		self.useGameCH = CheckBox('')
		self.useGameCH.SetParent(self.pnlChanger)
		self.useGameCH.SetPosition(54,5)
		self.useGameCH.eventDown = self.useingameCH
		self.useGameCH.Show()
		self.miscBtn = self.comp.Button(self.metin2_window, 'General', lang.STR_TIP_OTHER, 20, 35, self.miscBtn_func, tablarge1, tablarge2, tablarge3)
		self.lblZoomFog = self.comp.TextLine(self.pnlOthers, lang.STR_ZOOM_NO_FOG, 17, 39, self.comp.RGB(255, 255, 255))
		self.lblRelog = self.comp.TextLine(self.pnlOthers, lang.STR_AUTO_LOGIN, 17, 17, self.comp.RGB(255, 255, 255))
		
		self.useCredentials = CheckBox('')
		self.useCredentials.SetParent(self.pnlOthers)
		self.useCredentials.SetPosition(85,17)
		self.useCredentials.eventDown = self.useCredentialsInfo
		if not isGF:
			self.useCredentials.Show()
		
		self.relogBtn = self.comp.Button(self.pnlOthers, lang.STR_ENBLE, '', 105, 17, self.relogBtn_func, middle1, middle2, middle3)
		self.relogBtnStop = self.comp.Button(self.pnlOthers, lang.STR_DBLE, '', 105, 17, self.relogBtn_funcOff, middle1, middle2, middle3)
		self.zoomfogBtn = self.comp.Button(self.pnlOthers, lang.STR_ENBLE, '', 105, 39, self.zoomfog_func, middle1, middle2, middle3)
		self.zoomfogBtnStop = self.comp.Button(self.pnlOthers, lang.STR_DBLE, '', 105, 39, self.zoomfog_funcOff, middle1, middle2, middle3)
		self.lblCamera = self.comp.TextLine(self.pnlOthers, lang.STR_ROTATE_CAMERA, 190, 17, self.comp.RGB(255, 255, 255))
		self.qCamera = self.comp.ToggleButton(self.pnlOthers, '->', '', 220, 37, (self.rotateQ_funcend), (self.rotateQ_func), xmall1, xmall2, xmall3)
		self.eCamera = self.comp.ToggleButton(self.pnlOthers, '<-', '', 180, 37, (self.rotateE_funcend), (self.rotateE_func), xmall1, xmall2, xmall3)
		self.lblUseDews = self.comp.TextLine(self.pnlOthers, lang.STR_USE_DEWS, 17, 60, self.comp.RGB(255, 255, 255))
		self.useDewsBtn = self.comp.Button(self.pnlOthers, lang.STR_ENBLE, '', 105, 60, self.useDews_func, middle1, middle2, middle3)
		self.useDewsBtnStop = self.comp.Button(self.pnlOthers, lang.STR_DBLE, '', 105, 60, self.useDews_funcend, middle1, middle2, middle3)
		self.lblUseDewsDelay2 = self.comp.TextLine(self.pnlOthers, 'sec', 225, 60, self.comp.RGB(255, 255, 255))
		self.useDewDelay, self.usedews_delay = self.comp.EditLine(self.pnlOthers, '60', 180, 60, 30, 15, 4)
		self.usedews_delay.SetNumberMode()
		self.lblGuildCreate = self.comp.TextLine(self.pnlOthers, lang.STR_GUILD, 17, 90, self.comp.RGB(255, 255, 255))
		self.CreateGuildBtn = self.comp.Button(self.pnlOthers, lang.STR_GUILD_CREATE, '', 164, 90, self.createGuild_func, middle1, middle2, middle3)
		self.guildname_textbox, self.guildname = self.comp.EditLine(self.pnlOthers, '', 55, 90, 100, 15, 16)
		self.lblexpDonator = self.comp.TextLine(self.pnlOthers, lang.STR_GUILD_DONATE, 17, 110, self.comp.RGB(255, 255, 255))
		self.donateBtn = self.comp.Button(self.pnlOthers, lang.STR_ENBLE, '', 105, 110, self.donate_func, middle1, middle2, middle3)
		self.donateBtnStop = self.comp.Button(self.pnlOthers, lang.STR_DBLE, '', 105, 110, self.donate_funcOff, middle1, middle2, middle3)
		
		
		self.lblexpFromDonator = self.comp.TextLine(self.pnlOthers, lang.TAB_GENERAL_DONATE_EXPFROM, 17, 135, self.comp.RGB(255, 255, 255))
		self.guildFromLevelTxt, self.guildFrom = self.comp.EditLine(self.pnlOthers, '30', 71, 135, 25, 15, 3)
		self.guildFrom.SetNumberMode()
		self.lblexpWhenDonator = self.comp.TextLine(self.pnlOthers, lang.TAB_GENERAL_DONATE_WHEN, 110, 135, self.comp.RGB(255, 255, 255))
		self.guildWhenPercTxt, self.guildWhenPerc = self.comp.EditLine(self.pnlOthers, '50', 180, 135, 25, 15, 3)
		self.guildWhenPerc.SetNumberMode()
		###########
		self.lblPress = self.comp.TextLine(self.pnlOthers, 'Press 1-4 F1-F4', 189, 155, self.comp.RGB(255, 255, 255))
		if foundx64PythonList:
			self.btnPress1 = self.comp.Button(self.pnlOthers, '1', '', 185, 172, self.funcKey1, small1, small2, small3)
			self.btnPress2 = self.comp.Button(self.pnlOthers, '2', '', 205, 172, self.funcKey2, small1, small2, small3)
			self.btnPress3 = self.comp.Button(self.pnlOthers, '3', '', 225, 172, self.funcKey3, small1, small2, small3)
			self.btnPress4 = self.comp.Button(self.pnlOthers, '4', '', 245, 172, self.funcKey4, small1, small2, small3)
			self.btnPressF1 = self.comp.Button(self.pnlOthers, 'F1', '', 185, 189, self.funcKeyf1, small1, small2, small3)
			self.btnPressF2 = self.comp.Button(self.pnlOthers, 'F2', '', 205, 189, self.funcKeyf2, small1, small2, small3)
			self.btnPressF3 = self.comp.Button(self.pnlOthers, 'F3', '', 225, 189, self.funcKeyf3, small1, small2, small3)
			self.btnPressF4 = self.comp.Button(self.pnlOthers, 'F4', '', 245, 189, self.funcKeyf4, small1, small2, small3)
		else:
			try:
				self.btnPress1 = self.comp.Button2(self.pnlOthers, '1', '', 185, 172, 18, 12, self.funcKey1)
				self.btnPress2 = self.comp.Button2(self.pnlOthers, '2', '', 205, 172, 18, 12, self.funcKey2)
				self.btnPress3 = self.comp.Button2(self.pnlOthers, '3', '', 225, 172, 18, 12, self.funcKey3)
				self.btnPress4 = self.comp.Button2(self.pnlOthers, '4', '', 245, 172, 18, 12, self.funcKey4)
				self.btnPressF1 = self.comp.Button2(self.pnlOthers, 'F1', '', 185, 189, 18, 12, self.funcKeyf1)
				self.btnPressF2 = self.comp.Button2(self.pnlOthers, 'F2', '', 205, 189, 18, 12, self.funcKeyf2)
				self.btnPressF3 = self.comp.Button2(self.pnlOthers, 'F3', '', 225, 189, 18, 12, self.funcKeyf3)
				self.btnPressF4 = self.comp.Button2(self.pnlOthers, 'F4', '', 245, 189, 18, 12, self.funcKeyf4)
			except:
				self.btnPress1 = self.comp.Button(self.pnlOthers, '1', '', 185, 172, self.funcKey1, small1, small2, small3)
				self.btnPress2 = self.comp.Button(self.pnlOthers, '2', '', 205, 172, self.funcKey2, small1, small2, small3)
				self.btnPress3 = self.comp.Button(self.pnlOthers, '3', '', 225, 172, self.funcKey3, small1, small2, small3)
				self.btnPress4 = self.comp.Button(self.pnlOthers, '4', '', 245, 172, self.funcKey4, small1, small2, small3)
				self.btnPressF1 = self.comp.Button(self.pnlOthers, 'F1', '', 185, 189, self.funcKeyf1, small1, small2, small3)
				self.btnPressF2 = self.comp.Button(self.pnlOthers, 'F2', '', 205, 189, self.funcKeyf2, small1, small2, small3)
				self.btnPressF3 = self.comp.Button(self.pnlOthers, 'F3', '', 225, 189, self.funcKeyf3, small1, small2, small3)
				self.btnPressF4 = self.comp.Button(self.pnlOthers, 'F4', '', 245, 189, self.funcKeyf4, small1, small2, small3)
		###########
		self.lblUseItemRelog = self.comp.TextLine(self.pnlOthers, lang.STR_USE_ITEM_RELOG, 35, 178, self.comp.RGB(255, 255, 255))
		self.useItemRelogBtn = CheckBox("")
		self.useItemRelogBtn.SetParent(self.pnlOthers)
		self.useItemRelogBtn.SetPosition(10,176)
		self.useItemRelogBtn.Show()
		self.itemUserrelog_Item_Bar = ExpandedImageBox()
		self.itemUserrelog_Item_Bar.SetParent(self.pnlOthers)	
		self.itemUserrelog_Item_Bar.SetPosition(130, 170)
		self.itemUserrelog_Item_Bar.LoadImage(slot_base)
		self.itemUserrelog_Item_Bar.OnMouseLeftButtonUp = lambda: self.Set_ItemUserRelog_Item()
		self.itemUserrelog_Item_Bar.Show()
		self.itemUserRelog_Item_Icon = ExpandedImageBox()
		self.itemUserRelog_Item_Icon.SetParent(self.itemUserrelog_Item_Bar)
		self.itemUserRelog_Item_Icon.SetPosition(0, 0)
		self.itemUserRelog_Item_Icon.LoadImage(slot_base)
		self.itemUserRelog_Item_Icon.OnMouseLeftButtonUp = lambda: self.Set_ItemUserRelog_Item()
		self.itemUserRelog_Item_Icon.OnMouseRightButtonDown = lambda: self.Delete_ItemUserRelog_Item()
		self.itemUserRelog_Item_Icon.Show()	
		# self.listPolyItems, self.polyList, polyScroll = self.comp.ListBoxEx2(self.pnlOthers, 170, 140, 97, 55)
		# self.polyList.SetViewItemCount(3)
		# self.polyBtn = self.comp.ToggleButton(self.pnlOthers, 'Poly', '', 230, 194, (lambda arg = 'off': self.polyFunc(arg)), (lambda arg = 'on': self.polyFunc(arg)), middle1, middle2, middle3)
		self.lblRevive = self.comp.TextLine(self.pnlOthers, lang.STR_AUTO_RESTART, 290, 17, self.comp.RGB(255, 255, 255))
		self.restartBtn = self.comp.Button(self.pnlOthers, lang.STR_ENBLE, '', 375, 15, self.restartBtn_func, middle1, middle2, middle3)
		self.restartBtnStop = self.comp.Button(self.pnlOthers, lang.STR_DBLE, '', 375, 15, self.restartBtn_funcOff, middle1, middle2, middle3)
		if isGF:
			self.lblFantoma = self.comp.TextLine(self.pnlOthers, 'Fishbot:', 290, 37, self.comp.RGB(255, 255, 255))
			self.fantomaBtn = self.comp.Button(self.pnlOthers, lang.STR_OPEN, '', 375, 35, self.fish_func, middle1, middle2, middle3)
		else:
			self.lblFantoma = self.comp.TextLine(self.pnlOthers, lang.TAB_GENERAL_GHST, 290, 37, self.comp.RGB(255, 255, 255))
			self.fantomaBtn = self.comp.Button(self.pnlOthers, lang.STR_ENBLE, '', 375, 35, self.metinx_func, middle1, middle2, middle3)
			self.fantomaBtnStop = self.comp.Button(self.pnlOthers, lang.STR_DBLE, '', 375, 35, self.metinx_funcOff, middle1, middle2, middle3)
		self.lblRed = self.comp.TextLine(self.pnlOthers, lang.STR_RED_POT, 290, 57, self.comp.RGB(255, 255, 255))
		self.textRed_textbox, self.textRed = self.comp.EditLine(self.pnlOthers, '99', 340, 57, 30, 15, 3)
		self.textRed.SetNumberMode()
		self.redBtn = self.comp.Button(self.pnlOthers, lang.STR_ENBLE, '', 375, 55, self.red_func, middle1, middle2, middle3)
		self.redBtnStop = self.comp.Button(self.pnlOthers, lang.STR_DBLE, '', 375, 55, self.red_funcOff, middle1, middle2, middle3)
		self.lblLockTarget = self.comp.TextLine(self.pnlOthers, lang.TAB_GENERAL_LOCK_T, 530, 15, self.comp.RGB(255, 255, 255))
		self.lockTargetBtn = self.comp.ToggleButton(self.pnlOthers, 'Start', '', 601, 15, (self.lockTargetOff), (self.lockTargetOn), small1, small2, small3)
		self.lblLockAllPlayers = self.comp.TextLine(self.pnlOthers, lang.TAB_GENERAL_LOCK_P, 530, 35, self.comp.RGB(255, 255, 255))
		self.lockPlayersBtn = self.comp.ToggleButton(self.pnlOthers, 'Start', '', 601, 35, (self.lockPlayersOff), (self.lockPlayersOn), small1, small2, small3)
		self.useItemHpLow = CheckBox("")
		self.useItemHpLow.SetParent(self.pnlOthers)
		self.useItemHpLow.SetPosition(530,60)
		self.useItemHpLow.eventUp = self.useItemHpLowOff
		self.useItemHpLow.eventDown = self.useItemHpLowOn
		self.useItemHpLow.Show()
		self.txtUseHpLow, self.useHpLower = self.comp.EditLine(self.pnlOthers, '70', 600, 62, 30, 15, 3)
		self.useHpLower.SetNumberMode()
		self.boxUseHpLow = ExpandedImageBox()
		self.boxUseHpLow.SetParent(self.pnlOthers)	
		self.boxUseHpLow.SetPosition(560, 55)
		self.boxUseHpLow.LoadImage(slot_base)
		self.boxUseHpLow.OnMouseLeftButtonUp = lambda: self.Set_usehplow_Item()
		self.boxUseHpLow.Show()
		self.UseHpLowIcon = ExpandedImageBox()
		self.UseHpLowIcon.SetParent(self.boxUseHpLow)
		self.UseHpLowIcon.SetPosition(0, 0)
		self.UseHpLowIcon.LoadImage(slot_base)
		self.UseHpLowIcon.OnMouseLeftButtonUp = lambda: self.Set_usehplow_Item()
		self.UseHpLowIcon.OnMouseRightButtonDown = lambda: self.Delete_usehplow_Item()
		self.UseHpLowIcon.Show()	
		self.lblRotateTarget = self.comp.TextLine(self.pnlOthers, lang.ROTATE_TARGET, 525, 87, self.comp.RGB(255, 255, 255))
		self.rotateTargetBtn = self.comp.ToggleButton(self.pnlOthers, 'Start', '', 601, 85, (self.rotateTargetOff), (self.rotateTargetOn), small1, small2, small3)
		if isGF:
			self.lblWallhack = self.comp.TextLine(self.pnlOthers, 'Wallhack:', 553, 107, self.comp.RGB(255, 255, 255))
			self.btnWallhack = self.comp.ToggleButton(self.pnlOthers, 'Start', '', 601, 105, (self.WallhackOff), (self.WallhackOn), small1, small2, small3)
		self.disableStun = CheckBox("Disable stun")
		self.disableStun.SetParent(self.pnlOthers)
		self.disableStun.SetPosition(530,85)
		# self.disableStun.eventUp = self.disableStunOff
		# self.disableStun.eventDown = self.disableStunOn
		self.disableStun.Hide()
		self.lblBlue = self.comp.TextLine(self.pnlOthers, lang.STR_BLUE_POT, 290, 77, self.comp.RGB(255, 255, 255))
		self.textBlue_textbox, self.textBlue = self.comp.EditLine(self.pnlOthers, '99', 340, 77, 30, 15, 3)
		self.textBlue.SetNumberMode()
		self.BlueBtn = self.comp.Button(self.pnlOthers, lang.STR_ENBLE, '', 375, 75, self.blue_func, middle1, middle2, middle3)
		self.BlueBtnStop = self.comp.Button(self.pnlOthers, lang.STR_DBLE, '', 375, 75, self.blue_funcOff, middle1, middle2, middle3)
		self.lblEnvironment = self.comp.TextLine(self.pnlOthers, lang.STR_ENVIR, 290, 97, self.comp.RGB(255, 255, 255))
		self.dayBtn = self.comp.Button(self.pnlOthers, lang.STR_ENVIR_DAY, '', 375, 95, self.day_func, middle1, middle2, middle3)
		if switchEnabled:
			if isGF:
				xsw, ysw = (560, 175)
			else:
				xsw, ysw = (435, 15)
			self.btnSwitch = self.comp.Button(self.pnlOthers, 'Switchbot', '', xsw, ysw, self.switchbot_func, large1, large2, large3)
		if isGF:
			xbio, ybio = (560, 195)
			self.btnBiolog = self.comp.Button(self.pnlOthers, 'Biologist bot', '', xbio, ybio, self.biologistFunc, large1, large2, large3)
			self.shopScanBtn = self.comp.Button(self.pnlOthers, 'Shop search bot', '', 435, 15, self.OpenWindowShopScanner, 'd:/ymir work/ui/public/large_button_01.sub', 'd:/ymir work/ui/public/large_button_02.sub', 'd:/ymir work/ui/public/large_button_03.sub')
			self.shopCreatorBtn = self.comp.Button(self.pnlOthers, 'Shop creator', '', 435, 35, self.OpenWindowShopCreator, 'd:/ymir work/ui/public/large_button_01.sub', 'd:/ymir work/ui/public/large_button_02.sub', 'd:/ymir work/ui/public/large_button_03.sub')
		else:
			xbio, ybio = (435, 35)
			self.btnBiolog = self.comp.Button(self.pnlOthers, 'Biologist', '', xbio, ybio, self.biologistFunc, large1, large2, large3)
		self.btn_redElixir = self.comp.Button(self.pnlOthers, lang.STR_RED_E_ON, '', 435, 55, self.redElixir_func, large1, large2, large3)
		self.btn_redElixirStop = self.comp.Button(self.pnlOthers, lang.STR_RED_E_OFF, '', 435, 55, self.redElixir_funcOff, large1, large2, large3)
		self.btn_blueElixir = self.comp.Button(self.pnlOthers, lang.STR_BLUE_E_ON, '', 435, 75, self.blueElixir_func, large1, large2, large3)
		self.btn_blueElixirStop = self.comp.Button(self.pnlOthers, lang.STR_BLUE_E_OFF, '', 435, 75, self.blueElixir_funcOff, large1, large2, large3)
		self.nightBtn = self.comp.Button(self.pnlOthers, lang.STR_ENVIR_NIGHT, '', 435, 95, self.night_func, middle1, middle2, middle3)
		self.stackBtn = self.comp.Button(self.pnlOthers, lang.STR_STACK, '', 435, 115, self.stackingNow, middle1, middle2, middle3)
		if find_string(st_cur_server, "alune") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "next2play"):
			self.uiBioBoard = ui.BoardWithTitleBar()
		else:
			self.uiBioBoard = BoardWithTitleBar()
		self.uiBioBoard.SetTitleName('Biologist bot')
		self.uiBioBoard.SetCloseEvent(self.Exit)
		self.uiBioBoard.SetSize(184, 240)
		self.uiBioBoard.SetCenterPosition()
		self.uiBioBoard.AddFlag(movplable)
		self.uiBioBoard.AddFlag("float")
		self.useElixir = CheckBox('Use elixir item:')
		self.useElixir.SetParent(self.uiBioBoard)
		self.useElixir.SetPosition(15, 39)
		self.useElixir.Show()
		self.switchSlot = ExpandedImageBox()
		self.switchSlot.SetParent(self.uiBioBoard)	
		self.switchSlot.SetPosition(130, 30)
		self.switchSlot.LoadImage(slot_base)
		self.switchSlot.OnMouseLeftButtonUp = lambda: self.Set_Switch_Reader_Item()
		self.switchSlot.Show()
		self.switchIcon = ExpandedImageBox()
		self.switchIcon.SetParent(self.uiBioBoard)
		self.switchIcon.SetPosition(130,30)
		self.switchIcon.LoadImage(slot_base)
		self.switchIcon.OnMouseLeftButtonUp = lambda: self.Set_Switch_Reader_Item()
		self.switchIcon.OnMouseRightButtonDown = lambda: self.Delete_Switch_Reader_Item()	
		self.switchIcon.Show()
		self.resetTime = CheckBox('Use reset time item:')
		self.resetTime.SetParent(self.uiBioBoard)
		self.resetTime.SetPosition(15,68)
		self.resetTime.Show()
		self.resetSlot = ExpandedImageBox()
		self.resetSlot.SetParent(self.uiBioBoard)	
		self.resetSlot.SetPosition(130, 62)
		self.resetSlot.LoadImage(slot_base)
		self.resetSlot.OnMouseLeftButtonUp = lambda: self.Set_reset_Item()
		self.resetSlot.Show()
		self.resetIcon = ExpandedImageBox()
		self.resetIcon.SetParent(self.uiBioBoard)
		self.resetIcon.SetPosition(130,62)
		self.resetIcon.LoadImage(slot_base)
		self.resetIcon.OnMouseLeftButtonUp = lambda: self.Set_reset_Item()
		self.resetIcon.OnMouseRightButtonDown = lambda: self.Delete_reset_Item()	
		self.resetIcon.Show()
		self.lblDelayBio = self.comp.TextLine(self.uiBioBoard, lang.DELAY_SECONDS, 15, 111, self.comp.RGB(255, 255, 255))
		self.delayBioTxt, self.bioDelay = self.comp.EditLine(self.uiBioBoard, '1', 130, 111, 30, 15, 4)
		try:
			self.bioDelay.OnIMEUpdate = lambda: self.numbersAndDotOnly(self.bioDelay)
		except:
			self.bioDelay.SetNumberMode()
		# self.bioDelay.SetNumberMode()
		self.newBio = CheckBox('New biologist system')
		self.newBio.SetParent(self.uiBioBoard)
		self.newBio.SetPosition(15,140)
		self.newBio.eventUp   = self.newbio_off
		self.newBio.eventDown = self.newbio_on
		self.newBio.Show()
		self.bioCom = self.comp.TextLine(self.uiBioBoard, lang.BIO_COMMAND, 15, 165, self.comp.RGB(255, 255, 255))
		self.helpCmd = self.comp.Button(self.uiBioBoard, 'Dump', '', 105, 163, self.cmdHelp, middle1, middle2, middle3)
		self.bioText, self.bioTxt = self.comp.EditLine(self.uiBioBoard, '/biolog', 15, 185, 150, 15, 40)
		self.bioCom.Hide()
		self.bioText.Hide()
		self.bioTxt.Hide()
		self.helpCmd.Hide()
		self.StartBioButton = self.comp.Button(self.uiBioBoard, 'Start', '', 64, 210, self.startBio, middle1, middle2, middle3)
		self.StopBioButton = self.comp.Button(self.uiBioBoard, 'Stop', '', 64, 210, self.stopBio, middle1, middle2, middle3)
		self.StopBioButton.Hide()
		self.lblitemTools = self.comp.TextLine(self.pnlOthers, lang.STR_ITEM_TLS, 290, 117, self.comp.RGB(255, 255, 255))
		if isGF:
			defaultDelay = 0.6
		else:
			defaultDelay = 0
		self.sortDelayLbl, self.sortDelayTxt = self.comp.EditLine(self.pnlOthers, str(defaultDelay), 350, 117, 20, 15, 5)
		try:
			self.sortDelayTxt.OnIMEUpdate = lambda: self.numbersAndDotOnly(self.sortDelayTxt)
		except:
			pass
		
		self.sortBtn = self.comp.Button(self.pnlOthers, lang.STR_SORT, '', 375, 115, self.sort_func, middle1, middle2, middle3)
		self.autoSortCB = CheckBox('Auto sort')
		self.autoSortCB.SetParent(self.pnlOthers)
		self.autoSortCB.SetPosition(540,135)
		self.autoSortCB.eventUp   = self.sortAutoOff
		self.autoSortCB.eventDown = self.sortAutoOn
		self.autoSortCB.Show()
		if isGF:
			stackLimit = 20
		else:
			stackLimit = 30
		self.textStack_textbox, self.maxStackx = self.comp.EditLine(self.pnlOthers, '200', 500, 117, stackLimit, 15, 5)
		self.maxStackx.SetNumberMode()
		self.autoStackCB = CheckBox('Auto stack')
		self.autoStackCB.SetParent(self.pnlOthers)
		self.autoStackCB.SetPosition(540,155)
		self.autoStackCB.eventUp   = self.stackingAutoOff
		self.autoStackCB.eventDown = self.stackingAutoOn
		self.autoStackCB.Show()
		# self.sortInfo = self.comp.Button(self.pnlOthers, '', '', 355, 118, self.sortInfo_Func, qmark1, qmark2, qmark1)
		self.lblWeapon = self.comp.TextLine(self.pnlOthers, lang.STR_WEAPON, 290, 137, self.comp.RGB(255, 255, 255))
		self.btnoneHand = self.comp.ToggleButton(self.pnlOthers, lang.STR_ONE_HAND, '', 375, 135, (self.onehand_funcend), (self.onehand_func), middle1, middle2, middle3)
		self.btntwoHand = self.comp.ToggleButton(self.pnlOthers, lang.STR_TWO_HAND, '', 435, 135, (self.twohand_funcend), (self.twohand_func), middle1, middle2, middle3)
		self.lblSpeed = self.comp.TextLine(self.pnlOthers, lang.LBL_MOVESPEED, 290, 157, self.comp.RGB(255, 255, 255))
		self.textSpeed_textbox, self.SpeedValue = self.comp.EditLine(self.pnlOthers, '250', 385, 157, 35, 15, 4)
		self.SpeedValue.SetNumberMode()
		self.speedBtn = self.comp.Button(self.pnlOthers, lang.STR_ENBLE, '', 435, 155, self.speedFunc1, middle1, middle2, middle3)
		self.speedBtnStop = self.comp.Button(self.pnlOthers, lang.STR_DBLE, '', 435, 155, self.speedFunc1Stop, middle1, middle2, middle3)
		self.speedInfo = self.comp.Button(self.pnlOthers, '', '', 505, 158, self.speedInfo_Func, qmark1, qmark2, qmark1)
		self.lblAlchemy = self.comp.TextLine(self.pnlOthers, lang.STR_ALC_REFINER, 290, 177, self.comp.RGB(255, 255, 255))
		self.refineAlchemyBtn = self.comp.ToggleButton(self.pnlOthers, lang.STR_ENBLE, '', 375, 175, (lambda arg = 'off': self.refineAlchemy_func(arg)), (lambda arg = 'on': self.refineAlchemy_func(arg)), middle1, middle2, middle3)
		self.lblScripts = self.comp.TextLine(self.pnlOthers, lang.STR_COM_SCRIPTS, 290, 197, self.comp.RGB(255, 255, 255))
		self.refresh_scripts = self.comp.Button(self.pnlOthers, '', '', 470, 197, self.refresh_scripts_list, refresh1, refresh2, refresh3)
		self.load_script = self.comp.Button(self.pnlOthers, lang.STR_COM_SCRIPTS_LOAD, '', 500, 195, self.load_com_script, middle1, middle2, middle3)
		
		if not isGF and main_stream_instance:
			if hasattr(main_stream_instance, 'SetCharacterSlot'):
				self.lblQuickCharChange = self.comp.TextLine(self.pnlOthers, 'Char changer:', 450, 177, self.comp.RGB(255, 255, 255))
				charactersList = [0, 1, 2, 3, 4]
				self.charChangeId = self.comp.ComboBox(self.pnlOthers, "0", 530, 177, 25)
				for charChangeId in charactersList:
					self.charChangeId.InsertItem(1,str(charChangeId))
				self.changeCharacterBtn = self.comp.Button(self.pnlOthers, 'Go', '', 560, 175, lambda: quickCharChange(self.charChangeId.GetCurrentText()), middle1, middle2, middle3)
		
		self.scripts_list = DropDown(self.pnlOthers,'',0, 85)
		self.scripts_list.SetParent(self.pnlOthers)
		self.scripts_list.SetPosition(385, 197)
		self.scripts_list.Show()
		if not find_string(st_cur_server, "levia"):
			self.scripts_list.DropList.RemoveAllItems()
		self.scripts_list.maxh = 95
		self.scripts_list.c = 0
		display_scripts = os.listdir(st_path + "/Data/Python/Community")
		for scripts_list in display_scripts:
			self.scripts_list.AppendItem(str(scripts_list))
			
			
			
########## NEW TAB FARM ########
		self.newFarmTabBtn = self.comp.Button(self.metin2_window, 'Farming', lang.STR_TIP_FARMING, 200, 35, self.newFarmingTab_func, tablarge1, tablarge2, tablarge3)
		self.farmPanel = self.comp.ThinBoard(self.metin2_window, False, 125, 59, 697, 240, False)
		self.farmPanel.Hide()
		self.vidRangeLbl1 = CheckBox('Manual VID range')
		self.vidRangeLbl1.SetParent(self.metin2_window)
		self.vidRangeLbl1.SetPosition(6, 62)
		self.vidRangeLbl1.eventUp   = self.disableVidRange
		self.vidRangeLbl1.eventDown = self.enableVidRange
		if isGF:
			self.vidRangeLbl1.Hide()
		self.decreaseVidRangeBtn = self.comp.Button(self.metin2_window, '', '', 8, 85, self.decreaseVidRangeFunc, minus1, minus2, minus3)
		self.VidRangeTxt, self.VidRangeVal = self.comp.EditLine(self.metin2_window, '1000', 24, 83, 28, 15, 5)
		self.VidRangeVal.SetNumberMode()
		self.increaseVidRangeBtn = self.comp.Button(self.metin2_window, '', '', 57, 85, self.increaseVidRangeFunc, plus1, plus2, plus3)
		self.applyVidRangeBtn = self.comp.Button(self.metin2_window, 'Apply', '', 75, 83, self.applyVidRangeFunc, small1, small2, small3)
		self.decreaseVidRangeBtn.Hide()
		self.VidRangeTxt.Hide()
		self.VidRangeVal.Hide()
		self.increaseVidRangeBtn.Hide()
		self.applyVidRangeBtn.Hide()
		if isGF:
			self.tabFarmToggle = self.comp.ToggleButton(self.metin2_window, 'Attacking', '', 30, 105, None, None, large1, large2, large3)
			self.tabPickToggle = self.comp.ToggleButton(self.metin2_window, 'Pickup', '', 30, 125, None, None, large1, large2, large3)
		else:
			self.tabFarmToggle = self.comp.ToggleButton(self.metin2_window, 'Attacking', '', 30, 105, (lambda arg = 'off': self.attackingTab_Func(arg)), (lambda arg = 'on': self.attackingTab_Func(arg)), large1, large2, large3)
			self.tabPickToggle = self.comp.ToggleButton(self.metin2_window, 'Pickup', '', 30, 125, (lambda arg = 'off': self.pickupTab_Func(arg)), (lambda arg = 'on': self.pickupTab_Func(arg)), large1, large2, large3)
		self.waitAfter = CheckBox(lang.TAB_FARM_WAITAFTER)
		self.waitAfter.SetParent(self.metin2_window)
		self.waitAfter.SetPosition(8,220)
		self.waitRouteAfter = CheckBox(lang.TAB_FARM_WAITSTEPS)
		self.waitRouteAfter.SetParent(self.metin2_window)
		self.waitRouteAfter.SetPosition(8,245)
		self.waitRouteAfter.eventDown = self.showRouteWaitInfo
		self.waitRouteAfter.Hide()
		self.force = CheckBox(lang.TAB_FARM_FORCE)
		self.force.SetParent(self.metin2_window)
		self.force.SetPosition(8,270)
		self.force.eventUp   = self.disableForce
		self.force.eventDown = self.enableForce
		self.forcelbl = self.comp.TextLine(self.metin2_window, lang.TAB_FARM_FORCE2, 34, 290, self.comp.RGB(190, 190, 190))
		self.force.Hide()
		self.forcelbl.Hide()
		self.waitAfterLbl, self.wait = self.comp.EditLine(self.metin2_window, '1', 57, 220, 25, 15, 6)
		# self.wait.SetNumberMode()
		try:
			self.wait.OnIMEUpdate = lambda: self.numbersAndDotOnly(self.wait)
		except:
			self.wait.SetNumberMode()
		self.waitInfo = self.comp.Button(self.metin2_window, '', 'Wait info', 108, 220, self.waitInfoMsg, qmark1, qmark2, qmark1)
		self.lblPriority = self.comp.TextLine(self.metin2_window, lang.TAB_FARM_PRIORITY, 15, 178, self.comp.RGB(255, 255, 255))
		self.listPriority = self.comp.ComboBox(self.metin2_window, 'Metins first', 15, 195, 100)
		for listPriority in priorityList:
			self.listPriority.InsertItem(1,str(listPriority))
		self.waitAfter.Hide()
		self.waitAfterLbl.Hide()
		self.wait.Hide()
		self.waitInfo.Hide()
		self.lblPriority.Hide()
		self.listPriority.Hide()
		self.tabFarmToggle.Hide()
		self.tabPickToggle.Hide()
		self.lblWhatToFarm = self.comp.TextLine(self.farmPanel, lang.TAB_FARM_WHAT_FARM, 15, 10, self.comp.RGB(255, 255, 255))
		self.farmOreCB = CheckBox(lang.TAB_FARM_ORE)
		self.farmOreCB.SetParent(self.farmPanel)
		self.farmOreCB.SetPosition(15,105)
		self.farmOreCB.eventUp = self.hideOreMenu
		self.farmOreCB.eventDown = self.showOreMenu
		self.farmOreCB.Show()
		self.remignoreMetinBtn = self.comp.Button(self.farmPanel, '', lang.TAB_FARM_REM_METIN_IGNORE_LIST, 81,34, self.rem_ignore_metin_func, minus1, minus2, minus3)
		self.newignoreMetinBtn = self.comp.Button(self.farmPanel, '', lang.TAB_FARM_ADD_METIN_IGNORE_LIST, 97,34, self.ignoreMetinFunc, plus1, plus2, plus3)
		self.farmBossCB = CheckBox(lang.TAB_FARM_BOSSES)
		self.farmBossCB.SetParent(self.farmPanel)
		self.farmBossCB.SetPosition(15,55)
		self.farmBossCB.eventDown = self.disableMetins
		self.farmBossCB.Show()
		self.playerDetector = CheckBox(lang.STR_STOPIFPLAYER)
		self.playerDetector.SetParent(self.farmPanel)
		self.playerDetector.SetPosition(233,10)
		self.playerDetector.Hide()
		self.dontKs = CheckBox(lang.TAB_FARM_NOTKS)
		self.dontKs.SetParent(self.farmPanel)
		self.dontKs.SetPosition(233,30)
		self.dontKs.Show()
		self.initRouteClosest = CheckBox(lang.START_ROUTE_CLOSE)
		self.initRouteClosest.SetParent(self.farmPanel)
		self.initRouteClosest.SetPosition(233,63)
		self.initRouteClosest.Show()
		self.relogTp = CheckBox('Relog / ')
		self.relogTp.SetParent(self.farmPanel)
		self.relogTp.SetPosition(410,13)
		self.relogTp.eventDown   = self.disableTp
		self.relogTp.Show()
		self.tpAway = CheckBox('TP /')
		self.tpAway.SetParent(self.farmPanel)
		self.tpAway.SetPosition(470,13)
		self.tpAway.eventDown   = self.disableRelog
		self.tpAway.Show()
		self.hybridTP = CheckBox(lang.TPHYBRID)
		self.hybridTP.SetParent(self.farmPanel)
		self.hybridTP.SetPosition(515,13)
		self.hybridTP.eventDown   = self.disablehybridTP
		self.hybridTP.Show()
		self.hybridTP.Toggle()
		self.hpLowerLbl, self.hpLower = self.comp.EditLine(self.farmPanel, '30', 665, 15, 25, 15, 4)
		self.hpLower.SetNumberMode()
		self.disableQuestHorse = CheckBox('')
		self.disableQuestHorse.SetParent(self.farmPanel)
		self.disableQuestHorse.SetPosition(386,38)
		self.disableQuestHorse.eventDown   = self.disableQuestHorseInfo
		self.disableQuestHorse.Show()
		self.useHorseCB = CheckBox(lang.TAB_FARM_USE_HORSE)
		self.useHorseCB.SetParent(self.farmPanel)
		self.useHorseCB.SetPosition(410,38)
		self.useHorseCB.eventUp   = self.useHorse_funcOff
		self.useHorseCB.eventDown   = self.uncheckUseMount
		self.useHorseCB.Show()
		
		self.approachTarget = CheckBox(lang.GO_NO_BOW)
		self.approachTarget.SetParent(self.farmPanel)
		self.approachTarget.SetPosition(410,63)
		try:
			if IsWeaponArch():
				self.approachTarget.Show()
		except:
			pass
		self.useMount = CheckBox(lang.TAB_FARM_USE_MOUNT)
		self.useMount.SetParent(self.farmPanel)
		self.useMount.SetPosition(490,38)
		self.useMount.eventUp   = self.useHorse_funcOff
		self.useMount.eventDown   = self.uncheckUseHorse
		self.useMount.Show()
		self.imgMountFarm = ExpandedImageBox()
		self.imgMountFarm.SetParent(self.farmPanel)	
		self.imgMountFarm.SetPosition(575, 35)
		self.imgMountFarm.LoadImage(slot_base)
		self.imgMountFarm.OnMouseLeftButtonUp = lambda: self.Set_Mount_Farm()
		self.imgMountFarm.Show()
		self.iconMountFarm = ExpandedImageBox()
		self.iconMountFarm.SetParent(self.imgMountFarm)
		self.iconMountFarm.SetPosition(0, 0)
		self.iconMountFarm.LoadImage(slot_base)
		self.iconMountFarm.OnMouseLeftButtonUp = lambda: self.Set_Mount_Farm()
		self.iconMountFarm.OnMouseRightButtonDown = lambda: self.Delete_Mount_Farm()		
		self.iconMountFarm.Show()
		self.pauseAttack = CheckBox('Pause attack')
		self.pauseAttack.SetParent(self.farmPanel)
		self.pauseAttack.SetPosition(611,38)
		self.pauseAttack.Show()
		
		
		self.bossSetingsBtn = self.comp.Button(self.farmPanel, 'Edit', lang.EDIT_BOSS, 75,55, self.showBossWindow, xmall1, xmall2, xmall3)
		
		if find_string(st_cur_server, "alune") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "next2play"):
			self.bossEditorWindow = ui.BoardWithTitleBar()
		else:
			self.bossEditorWindow = BoardWithTitleBar()
		self.bossEditorWindow.SetCloseEvent(lambda: self.bossEditorWindow.Hide())
		self.bossEditorWindow.SetTitleName('Bosses settings')
		self.bossEditorWindow.SetSize(180,85)
		self.bossEditorWindow.SetPosition(500, 220)
		self.bossEditorWindow.AddFlag(movplable)
		self.bossEditorWindow.AddFlag('float')
		self.bossEditorWindow.Hide()
		
		self.lblCustomBoss = self.comp.TextLine(self.bossEditorWindow, 'Custom bosses settings: ', 15, 35, self.comp.RGB(255, 255, 255))
		self.remCustomBossBtn = self.comp.Button(self.bossEditorWindow, '', lang.TAB_FARM_REM_CUSTOM_BOSS, 130,35, self.rem_boss_func, minus1, minus2, minus3)
		self.addCustomBossBtn = self.comp.Button(self.bossEditorWindow, '', lang.TAB_FARM_ADD_CUSTOM_BOSS, 146,35, self.add_boss_func, plus1, plus2, plus3)
		
		self.lblIgnoreBoss = self.comp.TextLine(self.bossEditorWindow, lang.IGNORE_BOSS, 15, 60, self.comp.RGB(255, 255, 255))
		self.remIgnoreBossBtn = self.comp.Button(self.bossEditorWindow, '', lang.REMOVE_BOSS_LIST, 130,60, self.removeExistingBossIgnoreList, minus1, minus2, minus3)
		self.addIgnoreBossBtn = self.comp.Button(self.bossEditorWindow, '', lang.ADD_BOSS_LIST, 146,60, self.ignoreBossFunc, plus1, plus2, plus3)
		
		self.farmMobCB = CheckBox('Mobs')
		self.farmMobCB.SetParent(self.farmPanel)
		self.farmMobCB.SetPosition(15,80)
		self.farmMobCB.eventDown = self.disableOre
		self.farmMobCB.Show()
		
		self.removeIgnoredMonsterBtn = self.comp.Button(self.farmPanel, '', lang.REMOVE_MOB_LIST, 81,82, self.removeMonsterList, minus1, minus2, minus3)
		self.ignoreMonsterBtn = self.comp.Button(self.farmPanel, '', lang.IGNORE_MOB, 97,82, self.ignoreMonsterFunc, plus1, plus2, plus3)
		
		self.newaddCustomOreBtn = self.comp.Button(self.farmPanel, '', lang.TAB_FARM_ADD_CUSTOM_ORE, 90, 109, self.addCustomOre, plus1, plus2, plus3)
		self.lblWhatToMine = self.comp.TextLine(self.farmPanel, lang.TAB_FARM_WHAT_MINE, 15,160, self.comp.RGB(255,255,255))
		self.lblTimeMiningOre = self.comp.TextLine(self.farmPanel, lang.STR_MINING_TIME, 15,185, self.comp.RGB(255,255,255))
		self.TimeMiningOreText, self.TimeMiningOreVal = self.comp.EditLine(self.farmPanel, '30', 88, 185, 25, 15, 3)
		self.TimeMiningOreVal.SetNumberMode()
		self.mbDetect = self.comp.TextLine(self.farmPanel, lang.STR_METIN_BOSS_DETECTOR, 15,205, self.comp.RGB(255,255,255))
		self.mbDetectBtn = self.comp.Button(self.farmPanel, lang.STR_OPEN, '', 115, 205, self.OpenWindowMB_Detect, middle1, middle2, middle3)
		self.farmGoingMethodLbl = self.comp.TextLine(self.farmPanel, lang.TAB_FARM_HOW_TO_MOVE, 120,10, self.comp.RGB(255,255,255))
		self.farmMetinsCB = CheckBox(lang.TAB_FARM_METINS)
		self.farmMetinsCB.SetParent(self.farmPanel)
		self.farmMetinsCB.SetPosition(15,30)
		self.farmMetinsCB.Show()
		self.farmMetinsCB.eventDown = self.disableBoss
		self.farmRangeLbl = self.comp.TextLine(self.farmPanel, lang.FARM_RANGE, 200,10, self.comp.RGB(255,255,255))
		self.decreaseBtn = self.comp.Button(self.farmPanel, '', '', 270, 10, self.minus, minus1, minus2, minus3)
		self.newFarmRangeTxt, self.newFarmRangeVal = self.comp.EditLine(self.farmPanel, '150', 286, 9, 28, 15, 4)
		self.newFarmRangeVal.SetNumberMode()
		self.increaseBtn = self.comp.Button(self.farmPanel, '', '', 321, 10, self.plus, plus1, plus2, plus3)
		self.farmRangeLbl.Hide()
		self.decreaseBtn.Hide()
		self.newFarmRangeTxt.Hide()
		self.newFarmRangeVal.Hide()
		self.increaseBtn.Hide()
		self.fixedRange = CheckBox('Fixed range')
		self.fixedRange.SetParent(self.farmPanel)
		self.fixedRange.SetPosition(120,105)
		self.fixedRange.eventUp = self.hideGoTo
		self.fixedRange.eventDown = self.showGoTo
		self.fixedRange.Show()
		self.goToInitial = CheckBox('')
		self.goToInitial.SetParent(self.farmPanel)
		self.goToInitial.SetPosition(211,105)
		self.goToInitial.eventDown = self.goToInitialFunc
		self.goToInitial.Show()
		self.routeCoordsTxt, self.routeCoords = self.comp.EditLine(self.farmPanel, '', 125, 41, 200, 70, 9)
		self.routeCoordsTxt.Hide()
		self.routeCoords.Hide()
		self.useHorseSkill = CheckBox(lang.TAB_FARM_USE_HORSESKILL)
		self.useHorseSkill.SetParent(self.farmPanel)
		self.useHorseSkill.SetPosition(230,130)
		self.useHorseSkill.Show()
		# self.useHorseSkill.Toggle()
		self.unstuckCB = CheckBox(lang.TAB_FARM_UNSTUCK)
		self.unstuckCB.SetParent(self.farmPanel)
		self.unstuckCB.SetPosition(120,130)
		self.unstuckCB.Show()
		self.unstuckCB.Toggle()
		self.newRouteNameLbl = self.comp.TextLine(self.farmPanel, lang.STR_ROUTE_NAME, 230,82, self.comp.RGB(255,255,255))
		self.newRouteNameVal, self.newrouteName = self.comp.EditLine(self.farmPanel, '', 300, 82, 125, 15, 40)
		self.newRouteRecordBtn = self.comp.ToggleButton(self.farmPanel, lang.STR_RECORD_ROUTE, '', 430, 82, (lambda arg = 'off': self.recordRoute(arg)), (lambda arg = 'on': self.recordRoute(arg)), large1, large2, large3)
		self.listCoords_items, self.listCoord, self.list_scroll = self.comp.ListBoxEx2(self.farmPanel, 15, 200, 170, 160)
		self.listCoords_items.Hide()
		self.listCoord.Hide()
		self.currentRouteLbl = self.comp.TextLine(self.farmPanel, lang.TAB_FARM_CUR_ROUTE, 225,102, self.comp.RGB(255,255,255))
		self.newrefreshRouteListBtn = self.comp.Button(self.farmPanel, '', '', 407, 102, self.refreshRouteListFunc, refresh1, refresh2, refresh3)
		self.newloadRouteBtn = self.comp.Button(self.farmPanel, 'Load', '', 430, 102, self.readCurrentRoute, small1, small2, small3)
		self.newclearRouteBtn = self.comp.Button(self.farmPanel, 'Delete', '', 475, 102, self.clearRoute, small1, small2, small3)
		if find_string(st_cur_server, "alune") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "next2play"):
			self.chChangerWindow = ui.BoardWithTitleBar()
		else:
			self.chChangerWindow = BoardWithTitleBar()
		self.chChangerWindow.SetCloseEvent(self.closeChWindow)
		self.chChangerWindow.SetTitleName('Farm settings')
		self.chChangerWindow.SetSize(270, 225)
		self.chChangerWindow.SetPosition(969, 220)
		self.chChangerWindow.AddFlag(movplable)
		self.chChangerWindow.AddFlag('float')
		self.chChangerWindow.Hide()
		self.chChangerInfo = self.comp.Button(self.chChangerWindow, '', 'CH Changer info', 225,9, self.chChangerInfo_func, qmark1, qmark2, qmark1)
		self.changeCHRoute = CheckBox(lang.TAB_FARM_CH_CHANGE_ROUTE)
		self.changeCHRoute.SetParent(self.chChangerWindow)
		self.changeCHRoute.SetPosition(30,40)
		self.changeCHRoute.eventDown = self.enableCHRoute
		self.changeCHRoute.eventUp = self.disableCHRoute
		self.changeCHRoute.Show()
		self.changeCHNothing = CheckBox(lang.TAB_FARM_CH_CHANGE_ATTACK)
		self.changeCHNothing.SetParent(self.chChangerWindow)
		self.changeCHNothing.SetPosition(30,65)
		self.changeCHNothing.eventDown = self.enableCHNothing
		self.changeCHNothing.eventUp = self.disableCHNothing
		self.changeCHNothing.Show()
		self.dungeonNumberTxt, self.dungeonNumber = self.comp.EditLine(self.chChangerWindow, '1', 185, 90, 25, 15, 2)
		self.dungeonNumber.SetNumberMode()
		self.dungeonNumberTxt.Hide()
		self.dungeonNumber.Hide()
		self.dungeonInfo = self.comp.Button(self.chChangerWindow, '', 'Command info', 215, 90, self.dungeonInfoMsg, qmark1, qmark2, qmark1)
		self.dungeonInfo.Hide()
		if foundx64PythonList:
			txxxt = 'Go to dungeon NPC, id:'
			self.dungeonNumberTxt.Show()
			self.dungeonNumber.Show()
			
		elif find_string(st_cur_server, "ashiro") or find_string(st_cur_server, "rubinum") or find_string(st_cur_server, "warcry") or find_string(st_cur_server, "m2classic") or find_string(st_cur_server, "hylox") or find_string(st_cur_server, "newland") or find_string(st_cur_server, "zenit"):
			txxxt = 'Rejoin dungeon number:'
			self.dungeonNumberTxt.Show()
			self.dungeonNumber.Show()
			self.dungeonInfo.Show()
		else:
			txxxt = lang.RELOG_NO_ATTACK
		self.relogNothing = CheckBox(txxxt)
		self.relogNothing.SetParent(self.chChangerWindow)
		self.relogNothing.SetPosition(30,90)
		self.relogNothing.Show()	
		self.restartNothing = CheckBox(lang.RESTART_FARM_NO_ATTACK)
		self.restartNothing.SetParent(self.chChangerWindow)
		self.restartNothing.SetPosition(30,115)
		self.restartNothing.Show()
		
		self.skipTarget = CheckBox(lang.SKIP_TARGET)
		self.skipTarget.SetParent(self.chChangerWindow)
		self.skipTarget.SetPosition(30,140)
		self.skipTarget.Show()
		self.targetTimeoutLbl, self.targetTimeoutValue = self.comp.EditLine(self.chChangerWindow, '30', 235, 142, 20, 15, 4)
		self.targetTimeoutValue.SetNumberMode()
		
		self.skipMetin = CheckBox(lang.TAB_FARM_SKIPIF)
		self.skipMetin.SetParent(self.chChangerWindow)
		self.skipMetin.SetPosition(30,165)
		self.skipMetin.Show()
		self.skipMetinLbl, self.skipMetinDelay = self.comp.EditLine(self.chChangerWindow, '30', 195, 165, 20, 15, 4)
		self.skipMetinDelay.SetNumberMode()
		
		
		self.changeCHInLbl = self.comp.TextLine(self.chChangerWindow, lang.START_FARM_ACTION, 30,195, self.comp.RGB(255,255,255))
		self.changeCHInLblVal, self.changeCHIn = self.comp.EditLine(self.chChangerWindow, '3', 140, 195, 25, 15, 2)
		self.changeCHIn.SetNumberMode()
		self.chChangerFarmLbl = self.comp.TextLine(self.farmPanel, lang.FARM_SETTINGS, 560,80, self.comp.RGB(255,255,255))
		self.chChangerBtn = self.comp.ToggleButton(self.farmPanel, lang.TAB_FARM_CH_CHANGER_O, '', 625, 80, (lambda arg = 'off': self.chChangerMenu(arg)), (lambda arg = 'on': self.chChangerMenu(arg)), middle1, middle2, middle3)
		self.waitForHPBox = CheckBox(lang.WAIT_HP)
		self.waitForHPBox.SetParent(self.farmPanel)
		self.waitForHPBox.SetPosition(520,110)
		self.waitForHPBox.Show()
		self.waitForHPBox.Toggle()
		self.waitForHPVal, self.waitForHP = self.comp.EditLine(self.farmPanel, '30', 620, 112, 25, 15, 2)
		self.runRouteBackwards = CheckBox(lang.TAB_FARM_RUN_ROUTE_BACK)
		self.runRouteBackwards.SetParent(self.farmPanel)
		self.runRouteBackwards.SetPosition(230,130)
		self.runRouteBackwards.Show()
		self.runRouteBackwards.Toggle()
		self.oneHitLbl = self.comp.TextLine(self.farmPanel, lang.STR_ONEHIT, 370,130, self.comp.RGB(255,255,255))
		self.oneHitBtn = self.comp.Button(self.farmPanel, lang.STR_ENBLE, '', 410, 130, self.antifly_func, middle1, middle2, middle3)
		self.oneHitBtnStop = self.comp.Button(self.farmPanel, lang.STR_DBLE, '', 410, 130, self.antifly_funcend, middle1, middle2, middle3)
		self.freezeLbl = self.comp.TextLine(self.farmPanel, lang.TAB_FARM_FREEZE_LOC, 486,130, self.comp.RGB(255,255,255))
		self.btnfreeze = self.comp.Button(self.farmPanel, lang.STR_ENBLE, '', 560, 130, self.freeze_func, middle1, middle2, middle3)
		self.btnfreezeStop = self.comp.Button(self.farmPanel, lang.STR_DBLE, '', 560, 130, self.freeze_funcOff, middle1, middle2, middle3)
		
		self.attackLbl = self.comp.TextLine(self.farmPanel, lang.STR_ATTACK, 450,155, self.comp.RGB(255,255,255))
		self.btnAttack = self.comp.Button(self.farmPanel, lang.STR_ENBLE, '', 560, 155, self.attack_func, middle1, middle2, middle3)
		self.btnAttackStop = self.comp.Button(self.farmPanel, lang.STR_DBLE, '', 560, 155, self.attack_funcOff, middle1, middle2, middle3)
		self.doNotAttack = CheckBox("Don't attack")
		self.doNotAttack.SetParent(self.farmPanel)
		self.doNotAttack.SetPosition(620,155)
		self.doNotAttack.eventDown = self.doNotAttackInfo
		self.doNotAttack.Show()
		self.TeleportLabel = self.comp.TextLine(self.farmPanel, lang.STR_MAP_TELE, 230,180, self.comp.RGB(255,255,255))
		self.btnTeleport2 = self.comp.ToggleButton(self.farmPanel, str(lang.STR_OPEN), '', 290, 180, (lambda arg = 'off': self.teleport_func2(arg)), (lambda arg = 'on': self.teleport_func2(arg)), large1, large2, large3)
		self.hotKeyTeleport = self.comp.TextLine(self.farmPanel, lang.TAB_FARM_HOTKEY_TELE, 380,180, self.comp.RGB(255,255,255))
		self.enablehotKeyTeleport = self.comp.Button(self.farmPanel, lang.STR_ENBLE, '', 475, 180, self.hotkeyTele_func, middle1, middle2, middle3)
		self.enablehotKeyTeleportStop = self.comp.Button(self.farmPanel, lang.STR_DBLE, '', 475, 180, self.hotkeyTele_funcend, middle1, middle2, middle3)
		self.decreaseDistance = self.comp.Button(self.farmPanel, ' ', lang.TAB_FARM_D_DISTANCE, 540, 180, self.minusDist, minus1, minus2, minus3)
		self.teleportDistLbl, self.telDis = self.comp.EditLine(self.farmPanel, '250', 557, 179, 28, 15, 3)
		self.telDis.SetNumberMode()
		self.increaseDistance = self.comp.Button(self.farmPanel, ' ', lang.TAB_FARM_I_DISTANCE, 590, 180, self.plusDist, plus1, plus2, plus3)
		self.hotKeyTeleportInfo = self.comp.Button(self.farmPanel, '', '', 454, 180, self.hotKeyInfo, qmark1, qmark2, qmark1)
		self.megaCb = CheckBox('')
		self.megaCb.SetParent(self.farmPanel)
		self.megaCb.SetPosition(208,203)
		self.megaCb.eventDown = self.enableRangeMobber
		self.megaCb.eventUp = self.disableRangeMobber
		self.megaCb.Show()
		self.capesLbl = self.comp.TextLine(self.farmPanel, lang.STR_USECAPESEACH, 230,205, self.comp.RGB(255,255,255))
		self.capesLbl2 = self.comp.TextLine(self.farmPanel, lang.STR_SECONDS, 335,205, self.comp.RGB(255,255,255))
		self.btnCape = self.comp.Button(self.farmPanel, lang.STR_ENBLE, '', 475, 203, self.cape_func, middle1, middle2, middle3)
		self.btnCapeStop = self.comp.Button(self.farmPanel, lang.STR_DBLE, '', 475, 203, self.cape_funcOff, middle1, middle2, middle3)
		self.btnCapeRead = self.comp.Button(self.farmPanel, lang.STR_READID, '', 540, 203, self.read_cape_id, middle1, middle2, middle3)
		self.mobberSec_textbox, self.mobberSec = self.comp.EditLine(self.farmPanel, '5', 305, 205, 25, 15, 4)
		# self.mobberSec.SetNumberMode()
		try:
			self.mobberSec.OnIMEUpdate = lambda: self.numbersAndDotOnly(self.mobberSec)
		except:
			self.mobberSec.SetNumberMode()
		self.capesIdLbl = self.comp.TextLine(self.farmPanel, lang.STR_CAPEID, 380,205, self.comp.RGB(255,255,255))
		self.mobberId_textbox, self.mobberId = self.comp.EditLine(self.farmPanel, '70038', 430, 205, 37, 15, 6)
		self.mobberId.SetNumberMode()
		self.moblock = self.comp.Button(self.farmPanel, 'MobLock OFF', '', 605, 203, self.moblock_func, large1, large2, large3)
		self.moblockStop = self.comp.Button(self.farmPanel, 'MobLock ON', '', 605, 203, self.moblock_funcend,  large1, large2, large3)
		self.farmbyRouteCB = CheckBox(lang.TAB_FARM_FARMBY_ROUTE)
		self.farmbyRouteCB.SetParent(self.farmPanel)
		self.farmbyRouteCB.SetPosition(120,80)
		self.farmbyRouteCB.eventDown = self.disableRange
		self.farmbyRouteCB.Show()
		try:
			self.startFarmingBtn = self.comp.OnOffButton(self.farmPanel, '', '', 230, 80, OffUpVisual=onOffButtonLoc + 'start_0.tga', OffOverVisual=onOffButtonLoc + 'start_1.tga', OffDownVisual=onOffButtonLoc + 'start_2.tga',OnUpVisual=onOffButtonLoc + 'stop_0.tga', OnOverVisual=onOffButtonLoc + 'stop_1.tga', OnDownVisual=onOffButtonLoc + 'stop_2.tga',funcState=self.onOffFarmbot)
		except:
			pass
		self.startFarmingBtn2 = self.comp.ToggleButton(self.farmPanel, 'Start farm', '', 265, 30, (lambda val = False: self.onOffFarmbot(val)), (lambda val = True: self.onOffFarmbot(val)), middle1, middle2, middle3)
		self.classicStartCB = CheckBox(lang.TAB_FARM_CLASSIC_START)
		self.classicStartCB.SetParent(self.metin2_window)
		self.classicStartCB.SetPosition(8,150)
		# if not (find_string(st_cur_server, "eternal")):
		self.classicStartCB.eventUp   = self.classicBtnDisable
		self.classicStartCB.eventDown   = self.classicBtnEnable
		self.classicStartCB.Hide()
		self.classicStartCB.Toggle()
		self.farmInRangeCB = CheckBox(lang.TAB_FARM_FARM_IN_RANGE)
		self.farmInRangeCB.SetParent(self.farmPanel)
		self.farmInRangeCB.SetPosition(120,55)
		self.farmInRangeCB.eventDown = self.disableRoute
		self.farmInRangeCB.Show()
		self.farmInRangeCB.Toggle()
		self.disableRoute()
		self.farmGoingMethod = self.comp.ComboBox(self.farmPanel, goToMetinWay[0], 120, 30, 95)
		for farmGoingMethod in goToMetinWay:
			self.farmGoingMethod.InsertItem(1,str(farmGoingMethod))
		self.pickPanel = self.comp.ThinBoard(self.metin2_window, False, 125, 59, 697, 240, False)
		self.pickPanel.Hide()
		self.if_remove_item_btn = self.comp.Button(self.pickPanel, lang.TAB_PICK_DEL_LIST, '', 111, 212, self.if_remove_item_btn_func1, middle1, middle2, middle3)
		self.if_add_item_btn = self.comp.Button(self.pickPanel, lang.TAB_PICK_ADD_ITEM_LIST, '', 15, 212, self.if_add_item_btn_func, large1, large2, large3)
		self.addItemInfo = self.comp.Button(self.pickPanel, '', '', 145, 28, self.addItemInfo_Func, qmark1, qmark2, qmark1)
		self.if_pickup_wlist_text = self.comp.TextLine(self.pickPanel, lang.TAB_PICK_ITEMS_TO_PICK, 10, 28, self.comp.RGB(255, 255, 255))
		self.if_bar_list_white, self.if_list_list_white, self.if_white_scroll = self.comp.ListBoxEx2(self.pickPanel, 10, 49, 150, 160)
		self.filterPickup = CheckBox(lang.TAB_PICK_FILTER)
		self.filterPickup.SetParent(self.pickPanel)
		self.filterPickup.SetPosition(195, 30)
		self.filterPickup.eventUp   = self.pickupFilterFuncOff
		self.filterPickup.eventDown   = self.pickupFilterFunc
		self.filterPickup.Show()
		self.normalPickup = CheckBox(lang.TAB_PICK_ENABLE)
		self.normalPickup.SetParent(self.pickPanel)
		self.normalPickup.SetPosition(195, 60)
		self.normalPickup.eventUp	= self.pickupNormalStop
		self.normalPickup.eventDown	= self.pickupNormalStart
		self.normalPickup.Show()
		self.onlyPickup = CheckBox(lang.TAB_PICK_ENABLE_ONLY)
		self.onlyPickup.SetParent(self.pickPanel)
		self.onlyPickup.SetPosition(295, 60)
		self.onlyPickup.eventDown	= self.enableOnlyPick
		self.onlyPickup.Show()
		self.pickupSpeed = self.comp.SliderBar(self.pickPanel, 0.01, self.SetPickSpeed, 265, 90)
		self.pickupSpeedDelayTxt = self.comp.TextLine(self.pickPanel, lang.TAB_PICK_SPEED, 195, 90, self.comp.RGB(255, 255, 255))
		self.lblPickSpeed = self.comp.TextLine(self.pickPanel, '0.10 s', 450, 90, self.comp.RGB(255, 255, 255))
		try:
			pickspeed = round(float(self.pickupSpeed.GetSliderPos()*10),1)
			self.lblPickSpeed.SetText('%0.2f s' % pickspeed)
		except:
			pass
		self.randomizePickup = CheckBox(lang.RANDOMIZE_PICKUP)
		self.randomizePickup.SetParent(self.pickPanel)
		self.randomizePickup.SetPosition(480, 88)
		self.randomizePickup.Show()
		self.ITEM_FILTER_LIST=[]
		self.ITEM_FILTER_WHITELIST=[]
		self.pickItemsAtOnce = CheckBox(lang.TAB_PICK_ALL_ONCE)
		self.pickItemsAtOnce.SetParent(self.pickPanel)
		self.pickItemsAtOnce.SetPosition(195,120)
		self.pickItemsAtOnce.Show()
		self.playerStopPickup = CheckBox(lang.STR_STOPIFPLAYER)
		self.playerStopPickup.SetParent(self.pickPanel)
		self.playerStopPickup.SetPosition(195,150)
		self.playerStopPickup.Hide()
		self.NewminingList = self.comp.ComboBox(self.farmPanel, lang.MINING_EVERYTHING, 88, 160, 100)
		for NewminingList in miningList:
			self.NewminingList.InsertItem(1,str(NewminingList))
			
		self.randomizeMiningTime = CheckBox('')
		self.randomizeMiningTime.SetParent(self.farmPanel)
		self.randomizeMiningTime.SetPosition(195,158)
		self.randomizeMiningTime.eventDown	= self.randomiMiningTimeInfo
		self.randomizeMiningTime.Show()
			
		self.hideOreMenu()
		self.attackList = self.comp.ComboBox(self.farmPanel, 'Normal', 490, 155, 60)
		for attackList in attackingList:
			self.attackList.InsertItem(1,str(attackList))
		if find_string(st_cur_server, "alune") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "next2play"):
			self.mb_detector = ui.BoardWithTitleBar()
		else:
			self.mb_detector = BoardWithTitleBar()
		self.mb_detector.SetTitleName(lang.STR_METIN_BOSS_DETECTOR)
		self.mb_detector.SetCloseEvent(self.CloseMB_Detect)
		self.mb_detector.SetSize(440, 150)
		self.mb_detector.SetPosition(228,187)
		self.mb_detector.AddFlag(movplable)
		self.mb_detector.AddFlag('float')
		self.mb_detector.Hide()
		self.metinDetector = CheckBox(lang.STR_DETECT_METIN)
		self.metinDetector.SetParent(self.mb_detector)
		self.metinDetector.SetPosition(15,40)
		self.metinDetector.Show()
		self.bossDetector = CheckBox(lang.STR_DETECT_BOSS)
		self.bossDetector.SetParent(self.mb_detector)
		self.bossDetector.SetPosition(110,40)
		self.bossDetector.Show()
		self.slot_boss, self.more_boss = self.comp.EditLine(self.mb_detector, '', 140, 65, 100, 15, 180)
		self.slot_boss.Hide()
		self.autoRotate = CheckBox(lang.ROTATE_TARGET)
		self.autoRotate.SetParent(self.mb_detector)
		self.autoRotate.SetPosition(270,40)
		self.autoRotate.Show()
		self.bossLbl = self.comp.TextLine(self.mb_detector, lang.STR_BOSS, 10,90, self.comp.RGB(255,255,255))
		self.bossNameLbl = self.comp.TextLine(self.mb_detector, '', 40,90, self.comp.RGB(255,255,255))
		self.remBossName = self.comp.Button(self.mb_detector, '', lang.CLEAR, 235, 92, self.remBossFunc, minus1, minus2, minus3)
		self.teleBoss = self.comp.Button(self.mb_detector, lang.STR_TELETO, '',250, 90,self.teleBoss_func,large1, large2, large3)
		self.walkBoss = self.comp.Button(self.mb_detector, lang.STR_WALKTO, '',340, 90,self.walkBoss_func,large1, large2, large3)
		self.bossXLbl = self.comp.TextLine(self.mb_detector, '', 100,90, self.comp.RGB(255,255,255))
		self.bossXLbl.Hide()
		self.bossYLbl = self.comp.TextLine(self.mb_detector, '', 180,90, self.comp.RGB(255,255,255))
		self.bossYLbl.Hide()
		self.metinLbl = self.comp.TextLine(self.mb_detector, lang.STR_METIN, 10,110, self.comp.RGB(255,255,255))
		self.metinNameLbl = self.comp.TextLine(self.mb_detector, '', 40,110, self.comp.RGB(255,255,255))
		self.metinXLbl = self.comp.TextLine(self.mb_detector, '', 100,110, self.comp.RGB(255,255,255))
		self.metinXLbl.Hide()
		self.metinYLbl = self.comp.TextLine(self.mb_detector, '', 180,110, self.comp.RGB(255,255,255))
		self.metinYLbl.Hide()
		self.remMetinName = self.comp.Button(self.mb_detector, '', lang.CLEAR, 235, 112, self.remMetinFunc, minus1, minus2, minus3)
		self.teleMetin = self.comp.Button(self.mb_detector, lang.STR_TELETO, '',250, 110,self.teleMetin_func,large1, large2, large3)
		self.walkMetin = self.comp.Button(self.mb_detector, lang.STR_WALKTO, '',340, 110,self.walkMetin_func,large1, large2, large3)
		self.mbDetectBtn_Start = self.comp.ToggleButton(self.mb_detector, lang.STR_ENBLE, '', 367, 40, (self.mbDetect_funcend), (self.mbDetect_func), middle1, middle2, middle3)
		
		self.useItemLabel = self.comp.TextLine(self.farmPanel, lang.STR_ITEM_USER, 230,155, self.comp.RGB(255,255,255))
		self.btnUseItem = self.comp.Button(self.farmPanel, lang.STR_SEL_ITEM, '', 290, 155, self.useitem_func, large1, large2, large3)
		self.btnUseFunc = self.comp.Button(self.farmPanel, lang.STR_ENBLE, '', 380, 155, self.itemuse_func, middle1, middle2, middle3)
		self.btnUseFuncStop = self.comp.Button(self.farmPanel, lang.STR_DBLE, '', 380, 155, self.itemuse_funcStop, middle1, middle2, middle3)
		
		if find_string(st_cur_server, "alune") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "next2play"):
			self.itemUseWindow = ui.BoardWithTitleBar()
		else:
			self.itemUseWindow = BoardWithTitleBar()
		self.itemUseWindow.SetCloseEvent(self.CloseDopy)
		self.itemUseWindow.SetTitleName('Item user')
		self.itemUseWindow.SetSize(210,340)
		self.itemUseWindow.SetPosition(969, 220)
		self.itemUseWindow.AddFlag(movplable)
		self.itemUseWindow.AddFlag('float')
		self.itemUseWindow.Hide()
		
		self.CreateItemSlots()
		
		self.routeListbox = DropDown(self.farmPanel,'',1, 100)
		self.routeListbox.SetParent(self.farmPanel)
		self.routeListbox.SetPosition(300, 102)
		self.routeListbox.Show()
################################ TAB READING ################################
		self.pnlRead = self.comp.ThinBoard(self.metin2_window, False, 30, 65, 780, 230, False)
		self.pnlBook = self.comp.ThinBoard(self.pnlRead, False, 20, 20, 400, 200, False)
		self.pnlPlusStatus = self.comp.ThinBoard(self.pnlRead, False, 480, 20, 272, 170, False)
		self.lblAddStatus = self.comp.TextLine(self.pnlRead, lang.STR_SKSTATUS, 590, 5, self.comp.RGB(255, 255, 255))
		self.readBtn = self.comp.Button(self.metin2_window, lang.STR_SKSTATUS, lang.STR_STATUSINFO, 110, 35, self.readBtn_func, tablarge1, tablarge2, tablarge3)
		self.lblBookValue = self.comp.TextLine(self.pnlBook, lang.STR_BOOK, 10, 20, self.comp.RGB(255, 255, 255))
		self.Book_Reader_Item_Bar = ExpandedImageBox()
		self.Book_Reader_Item_Bar.SetParent(self.pnlBook)	
		self.Book_Reader_Item_Bar.SetPosition(70, 10)
		self.Book_Reader_Item_Bar.LoadImage(slot_base)
		self.Book_Reader_Item_Bar.OnMouseLeftButtonUp = lambda: self.Set_Book_Reader_Item()
		self.Book_Reader_Item_Bar.Show()
		self.Book_Reader_Item_Icon = ExpandedImageBox()
		self.Book_Reader_Item_Icon.SetParent(self.Book_Reader_Item_Bar)
		self.Book_Reader_Item_Icon.SetPosition(0, 0)
		self.Book_Reader_Item_Icon.LoadImage(slot_base)
		self.Book_Reader_Item_Icon.OnMouseLeftButtonUp = lambda: self.Set_Book_Reader_Item()
		self.Book_Reader_Item_Icon.OnMouseRightButtonDown = lambda: self.Delete_Book_Reader_Item()
		self.Book_Reader_Item_Icon.Show()			
		self.lblExo = self.comp.TextLine(self.pnlBook, lang.STR_EXO, 10, 50, self.comp.RGB(255, 255, 255))
		self.exorcism_item = ExpandedImageBox()
		self.exorcism_item.SetParent(self.pnlBook)	
		self.exorcism_item.SetPosition(70, 45)
		self.exorcism_item.LoadImage(slot_base)
		self.exorcism_item.OnMouseLeftButtonUp = lambda: self.set_exo()
		self.exorcism_item.Show()
		self.exorcism_Icon = ExpandedImageBox()
		self.exorcism_Icon.SetParent(self.exorcism_item)
		self.exorcism_Icon.SetPosition(0, 0)
		self.exorcism_Icon.LoadImage(slot_base)
		self.exorcism_Icon.OnMouseLeftButtonUp = lambda: self.set_exo()
		self.exorcism_Icon.OnMouseRightButtonDown = lambda: self.del_exo()
		self.exorcism_Icon.Show()			
		self.lblherm = self.comp.TextLine(self.pnlBook, lang.STR_HERMIT, 10, 87, self.comp.RGB(255, 255, 255))
		self.hermit_item = ExpandedImageBox()
		self.hermit_item.SetParent(self.pnlBook)	
		self.hermit_item.SetPosition(70, 80)
		self.hermit_item.LoadImage(slot_base)
		self.hermit_item.OnMouseLeftButtonUp = lambda: self.set_cc()
		self.hermit_item.Show()
		self.hermit_Icon = ExpandedImageBox()
		self.hermit_Icon.SetParent(self.hermit_item)
		self.hermit_Icon.SetPosition(0, 0)
		self.hermit_Icon.LoadImage(slot_base)
		self.hermit_Icon.OnMouseLeftButtonUp = lambda: self.set_cc()
		self.hermit_Icon.OnMouseRightButtonDown = lambda: self.del_cc()
		self.hermit_Icon.Show()	
		self.lblZen = self.comp.TextLine(self.pnlBook, lang.STR_ZEN, 10, 125, self.comp.RGB(255, 255, 255))
		self.zen_item = ExpandedImageBox()
		self.zen_item.SetParent(self.pnlBook)	
		self.zen_item.SetPosition(70, 115)
		self.zen_item.LoadImage(slot_base)
		self.zen_item.OnMouseLeftButtonUp = lambda: self.set_zen()
		self.zen_item.Show()
		self.zen_Icon = ExpandedImageBox()
		self.zen_Icon.SetParent(self.zen_item)
		self.zen_Icon.SetPosition(0, 0)
		self.zen_Icon.LoadImage(slot_base)
		self.zen_Icon.OnMouseLeftButtonUp = lambda: self.set_zen()
		self.zen_Icon.OnMouseRightButtonDown = lambda: self.del_zen()
		self.zen_Icon.Show()	
		self.lblSS = self.comp.TextLine(self.pnlBook, lang.STR_SS, 10, 160, self.comp.RGB(255, 255, 255))
		self.ss_item = ExpandedImageBox()
		self.ss_item.SetParent(self.pnlBook)	
		self.ss_item.SetPosition(70, 150)
		self.ss_item.LoadImage(slot_base)
		self.ss_item.OnMouseLeftButtonUp = lambda: self.set_ss()
		self.ss_item.Show()
		self.ss_Icon = ExpandedImageBox()
		self.ss_Icon.SetParent(self.ss_item)
		self.ss_Icon.SetPosition(0, 0)
		self.ss_Icon.LoadImage(slot_base)
		self.ss_Icon.OnMouseLeftButtonUp = lambda: self.set_ss()
		self.ss_Icon.OnMouseRightButtonDown = lambda: self.del_ss()
		self.ss_Icon.Show()	
		self.readssBtn = self.comp.ToggleButton(self.pnlBook, lang.STR_SS_BTN, '', 300, 170, (lambda arg = 'off': self.readss_func(arg)), (lambda arg = 'on': self.readss_func(arg)), large1, large2, large3)
		self.lblConfirm = self.comp.TextLine(self.pnlBook, lang.STR_CONFIRM_STRING, 110, 170, self.comp.RGB(255, 255, 255))
		self.StringSlotbar, self.StringEditline = self.comp.EditLine(self.pnlBook, '', 190, 170, 97, 18, 16)
		self.lblSkillValue = self.comp.TextLine(self.pnlBook, lang.STR_SKILLINDEX, 110, 150, self.comp.RGB(255, 255, 255))
		self.SkillInfo = self.comp.Button(self.pnlBook, '', '', 168, 150, self.skillInfo_Func, qmark1, qmark2, qmark1)
		self.StringSkill, self.SkillValue = self.comp.EditLine(self.pnlBook, '0', 140, 150, 18, 18, 1)
		self.SkillValue.SetNumberMode()
		self.Book_Reader_Status_Button = self.comp.Button(self.pnlBook, lang.STR_BOOK_BTN, '', 300, 80, self.Book_Reader_Status_func, large1, large2, large3)
		self.lblStatusUpgrade = self.comp.TextLine(self.pnlPlusStatus, lang.STR_ADDSTATUS, 30, 5, self.comp.RGB(255, 255, 255))
		self.btnVit = self.comp.ToggleButton(self.pnlPlusStatus, 'VIT', '', 20, 25, (lambda arg = 'off': self.vit_func(arg)), (lambda arg = 'on': self.vit_func(arg)), middle1, middle2, middle3)
		self.btnInt = self.comp.ToggleButton(self.pnlPlusStatus, 'INT', '', 20, 45, (lambda arg = 'off': self.int_func(arg)), (lambda arg = 'on': self.int_func(arg)), middle1, middle2, middle3)
		self.btnStr = self.comp.ToggleButton(self.pnlPlusStatus, 'STR', '', 20, 65, (lambda arg = 'off': self.str_func(arg)), (lambda arg = 'on': self.str_func(arg)), middle1, middle2, middle3)
		self.btnDex = self.comp.ToggleButton(self.pnlPlusStatus, 'DEX', '', 20, 85, (lambda arg = 'off': self.dex_func(arg)), (lambda arg = 'on': self.dex_func(arg)), middle1, middle2, middle3)
		self.btnVit2 = self.comp.Button(self.pnlPlusStatus, '+5', '', 82, 25, self.vit_func2, small1, small2, small3)
		self.btnInt2 = self.comp.Button(self.pnlPlusStatus, '+5', '', 82, 45, self.int_func2, small1, small2, small3)
		self.btnStr2 = self.comp.Button(self.pnlPlusStatus, '+5', '', 82, 65, self.str_func2, small1, small2, small3)
		self.btnDex2 = self.comp.Button(self.pnlPlusStatus, '+5', '', 82, 85, self.dex_func2, small1, small2, small3)
		self.lblSkillUpgrade = self.comp.TextLine(self.pnlPlusStatus, lang.STR_ADDSKILLPOINT, 150, 5, self.comp.RGB(255, 255, 255))
		self.btnSkill1 = self.comp.ToggleButton(self.pnlPlusStatus, lang.STR_SK1, '', 135, 20, (lambda arg = 'off': self.skillplus1_func(arg)), (lambda arg = 'on': self.skillplus1_func(arg)), large1, large2, large3)
		self.btnSkill2 = self.comp.ToggleButton(self.pnlPlusStatus, lang.STR_SK2, '', 135, 40, (lambda arg = 'off': self.skillplus2_func(arg)), (lambda arg = 'on': self.skillplus2_func(arg)), large1, large2, large3)
		self.btnSkill3 = self.comp.ToggleButton(self.pnlPlusStatus, lang.STR_SK3, '', 135, 60, (lambda arg = 'off': self.skillplus3_func(arg)), (lambda arg = 'on': self.skillplus3_func(arg)), large1, large2, large3)
		self.btnSkill4 = self.comp.ToggleButton(self.pnlPlusStatus, lang.STR_SK4, '', 135, 80, (lambda arg = 'off': self.skillplus4_func(arg)), (lambda arg = 'on': self.skillplus4_func(arg)), large1, large2, large3)
		self.btnSkill5 = self.comp.ToggleButton(self.pnlPlusStatus, lang.STR_SK5, '', 135, 100,(lambda arg = 'off': self.skillplus5_func(arg)), (lambda arg = 'on': self.skillplus5_func(arg)), large1, large2, large3)
		self.btnSkill6 = self.comp.ToggleButton(self.pnlPlusStatus, lang.STR_SK6, '', 135, 120,(lambda arg = 'off': self.skillplus6_func(arg)), (lambda arg = 'on': self.skillplus6_func(arg)), large1, large2, large3)
		self.btnSkill171 = self.comp.Button(self.pnlPlusStatus, '+5', '', 224, 20, self.skillplus1, small1, small2, small3)
		self.btnSkill172 = self.comp.Button(self.pnlPlusStatus, '+5', '', 224, 40, self.skillplus2, small1, small2, small3)
		self.btnSkill173 = self.comp.Button(self.pnlPlusStatus, '+5', '', 224, 60, self.skillplus3, small1, small2, small3)
		self.btnSkill174 = self.comp.Button(self.pnlPlusStatus, '+5', '', 224, 80, self.skillplus4, small1, small2, small3)
		self.btnSkill175 = self.comp.Button(self.pnlPlusStatus, '+5', '', 224, 100, self.skillplus5, small1, small2, small3)
		self.btnSkill176 = self.comp.Button(self.pnlPlusStatus, '+5', '', 224, 120, self.skillplus6, small1, small2, small3)
		if isGF:
			################################ TAB PICKUP ################################
			self.pnlPickup = self.comp.ThinBoard(self.metin2_window, False, 140, 65, 576, 230, False)
			self.pickupBotBtn = self.comp.Button(self.metin2_window, 'Pickup', '', 290, 35, self.pickup_tab_func, tablarge1, tablarge2, tablarge3)
			self.pickupSpeed = self.comp.SliderBar(self.pnlPickup, 10.0, self.SetPickSpeedGF, 75, 20)
			self.pickupSpeedDelayTxt = self.comp.TextLine(self.pnlPickup, lang.TAB_PICK_SPEED, 5, 18, self.comp.RGB(255, 255, 255))
			self.lblPickSpeed = self.comp.TextLine(self.pnlPickup, '1 s', 151, 18, self.comp.RGB(255, 255, 255))
			try:
				pickspeed = round(float(self.pickupSpeed.GetSliderPos()*10),1)
				self.lblPickSpeed.SetText('%0.2f sec' % pickspeed)
				self.SetPickSpeedGF()
			except:
				pass
			self.pickupRange = self.comp.SliderBar(self.pnlPickup, 25.0, self.SetPickRange, 75, 50)
			self.pickupRangeTxt = self.comp.TextLine(self.pnlPickup, 'Pickup range:', 5, 48, self.comp.RGB(255, 255, 255))
			self.lblPickRange = self.comp.TextLine(self.pnlPickup, '2500', 151, 48, self.comp.RGB(255, 255, 255))
			try:
				pickrange = round(float(self.pickupRange.GetSliderPos()*10000),1)
				self.lblPickRange.SetText('%0.5f' % pickrange)
				self.SetPickRange()
			except:
				pass
				
			self.walkToItem = CheckBox(lang.PICKUP_WALK_TO_ITEM)
			self.walkToItem.SetParent(self.pnlPickup)
			self.walkToItem.SetPosition(10, 70)
			self.walkToItem.Show()
			self.normalPickup = CheckBox(lang.PICKUP_ENABLE)
			self.normalPickup.SetParent(self.pnlPickup)
			self.normalPickup.SetPosition(10, 95)
			self.normalPickup.eventUp	= self.pickupNormalStopGF
			self.normalPickup.eventDown	= self.pickupNormalStartGF
			self.normalPickup.Show()
			self.excludeItems = CheckBox(lang.PICKUP_ONLY_PICK)
			self.excludeItems.SetParent(self.pnlPickup)
			self.excludeItems.SetPosition(10, 120)
			self.excludeItems.eventUp	= self.excludeItemsFuncOff
			self.excludeItems.eventDown	= self.excludeItemsFuncOn
			self.excludeItems.Show()
			self.itemsFirst = CheckBox(lang.PICKUP_ITEMS_FIRST)
			self.itemsFirst.SetParent(self.pnlPickup)
			self.itemsFirst.SetPosition(10, 145)
			self.itemsFirst.eventUp	= self.itemsFirstFuncOff
			self.itemsFirst.eventDown	= self.itemsFirstFuncOn
			self.itemsFirst.Show()
			self.blockedItems = CheckBox(lang.PICKUP_NO_WALLS)
			self.blockedItems.SetParent(self.pnlPickup)
			self.blockedItems.SetPosition(10, 170)
			self.blockedItems.eventUp	= self.blockedItemsFuncOff
			self.blockedItems.eventDown	= self.blockedItemsFuncOn
			self.blockedItems.Show()
			self.ignorePickList = CheckBox(lang.PICKUP_IGNORE_LIST)
			self.ignorePickList.SetParent(self.pnlPickup)
			self.ignorePickList.SetPosition(10, 195)
			self.ignorePickList.eventUp	= self.loadPickupList
			self.ignorePickList.eventDown	= self.loadNonePickList
			self.ignorePickList.Show()
			self.ItemValueText = self.comp.TextLine(self.pnlPickup, 'Search item:', 292, 190, self.comp.RGB(255, 255, 255))
			self.SearchPickItemButton = self.comp.Button(self.pnlPickup, lang.STR_SEARCH_BTN, '', 480, 188,  self.UpdatePickFilterList, 'd:/ymir work/ui/public/small_Button_01.sub', 'd:/ymir work/ui/public/small_Button_02.sub', 'd:/ymir work/ui/public/small_Button_03.sub')
			self.AddPickItemBtn = self.comp.Button(self.pnlPickup, lang.TAB_PICK_ADD_ITEM_LIST, '', 510, 60, self.OpenPickItemDialog, 'd:/ymir work/ui/public/Middle_Button_01.sub', 'd:/ymir work/ui/public/Middle_Button_02.sub', 'd:/ymir work/ui/public/Middle_Button_03.sub')
			self.PickCancelBtn = self.comp.Button(self.pnlPickup, lang.REMOVE_STRING, '', 510, 80, self.UIPickRemoveFilterItem, 'd:/ymir work/ui/public/Middle_Button_01.sub', 'd:/ymir work/ui/public/Middle_Button_02.sub', 'd:/ymir work/ui/public/Middle_Button_03.sub')
			self.PickSearchItemSlotBar, self.PickSearchItemEditLine = self.comp.EditLine(self.pnlPickup, '', 360, 190, 110, 15, 50)
			try:
				self.PickSearchItemEditLine.OnIMEUpdate = self.UpdatePickFilterList
			except:
				pass
				
			self.PickbarItems, self.PickfileListBox, self.PickScrollBar = self.comp.ListBoxEx2(self.pnlPickup, 292, 15, 180, 160)
			self.PickfileListBox.SetViewItemCount(8)
		else:
			################################ TAB FISHBOT ################################
			self.pnlFishbot = self.comp.ThinBoard(self.metin2_window, False, 140, 65, 556, 230, False)
			self.fishBtn = self.comp.Button(self.metin2_window, lang.STR_FISHBOT, lang.STR_TIP_FISH, 290, 35, self.fishBtn_func, tablarge1, tablarge2, tablarge3)
			self.fishbotBtn = self.comp.Button(self.pnlFishbot, lang.STR_ENBLE, '', 227, 165, self.StartFishBot, large1, large2, large3)
			self.fishbotBtnStop = self.comp.Button(self.pnlFishbot, lang.STR_DBLE, '', 227, 165, self.StopFishBot, large1, large2, large3)
			self.fishMain = self.comp.ToggleButton(self.metin2_window, 'Main', '', 30, 105, (lambda arg = 'off': self.fishMain_Func(arg)), (lambda arg = 'on': self.fishMain_Func(arg)), large1, large2, large3)
			self.fishesBtn = self.comp.ToggleButton(self.metin2_window, lang.TAB_FISH_DK, '', 30, 125, (lambda arg = 'off': self.fishes_Func(arg)), (lambda arg = 'on': self.fishes_Func(arg)), large1, large2, large3)
			self.fishMain.Hide()
			self.fishesBtn.Hide()
			self.pnlFishes = self.comp.ThinBoard(self.metin2_window, False, 140, 65, 556, 230, False)
			self.pnlFishes.Hide()
			self.fishMain_Func('on')
			self.fix_fishbot = CheckBox(lang.TAB_FISH_FIX_ROD)
			self.fix_fishbot.SetParent(self.pnlFishbot)
			self.fix_fishbot.SetPosition(235,195)
			self.fix_fishbot.Show()
			self.fix_quest = CheckBox(lang.STR_DISABLEQ)
			self.fix_quest.SetParent(self.pnlFishbot)
			self.fix_quest.SetPosition(227,25)
			self.fix_quest.Show()
			self.fisherVnumLbl = self.comp.TextLine(self.pnlFishbot, lang.STR_FISHER_VNUM, 235,50, self.comp.RGB(255,255,255))
			self.fisherVnumTxt, self.fisherVnum = self.comp.EditLine(self.pnlFishbot, '9009', 250, 75, 45, 15, 6)
			self.fisherVnum.SetNumberMode()
			self.getFisherVnum = self.comp.Button(self.pnlFishbot, lang.STR_GETFISHER_VNUM, '', 245, 100, self.getFishermanVnum, middle1, middle2, middle3)
			self.shopIndexFLbl = self.comp.TextLine(self.pnlFishbot, lang.SHOP_INDEX, 224, 141, self.comp.RGB(255, 255, 255))
			self.shopIndexFTxt, self.fishshopIndex = self.comp.EditLine(self.pnlFishbot, '0', 290, 141, 25, 15, 2)
			self.fishshopIndex.SetNumberMode()
			self.pnlBait = self.comp.ThinBoard(self.pnlFishbot, False, 330, 10, 215, 174, False)
			self.pnlFishSettings = self.comp.ThinBoard(self.pnlFishbot, False, 10, 10, 210, 214, False)
			self.buyBaitBtn = CheckBox(lang.STR_BUY_BAIT)
			self.buyBaitBtn.SetParent(self.pnlBait)
			self.buyBaitBtn.SetPosition(10,10)
			self.buyBaitBtn.Show()
			self.buyBaitBtn.Toggle()
			self.buybaitSlot, self.buyBaitIndex = self.comp.EditLine(self.pnlBait, '0', 170, 10, 15, 15, 1)
			self.buyBaitIndex.SetNumberMode()
			self.buyBaitQBtn = CheckBox(lang.STR_BUY_BAITQ)
			self.buyBaitQBtn.SetParent(self.pnlBait)
			self.buyBaitQBtn.SetPosition(10,35)
			self.buyBaitQBtn.Show()
			self.lblBaitToUse = self.comp.TextLine(self.pnlBait, lang.STR_BAIT, 10, 65, self.comp.RGB(255, 255, 255))
			self.minnowCb = CheckBox(lang.STR_MINNOW)
			self.minnowCb.SetParent(self.pnlBait)
			self.minnowCb.SetPosition(10,90)
			self.minnowCb.Show()
			self.minnowCb.Toggle()
			self.wormCb = CheckBox(lang.STR_WORM)
			self.wormCb.SetParent(self.pnlBait)
			self.wormCb.SetPosition(10,115)
			self.wormCb.Show()
			self.wormCb.Toggle()
			self.pasteCb = CheckBox(lang.STR_PASTE)
			self.pasteCb.SetParent(self.pnlBait)
			self.pasteCb.SetPosition(10,140)
			self.pasteCb.Show()
			self.pasteCb.Toggle()
			self.alternativeBtn = CheckBox(lang.STR_OTHER)
			self.alternativeBtn.SetParent(self.pnlBait)
			self.alternativeBtn.SetPosition(80,90)
			self.alternativeBtn.Show()
			try:
				if fishing:
					self.freezeFishBtn = self.comp.Button(self.pnlBait, 'Freeze fish', '', 100, 140, self.freezeFishFunc, large1, large2, large3)
			except:
				pass
			self.bait_Reader_Item_Bar = ExpandedImageBox()
			self.bait_Reader_Item_Bar.SetParent(self.pnlBait)	
			self.bait_Reader_Item_Bar.SetPosition(160, 83)
			self.bait_Reader_Item_Bar.LoadImage(slot_base)
			self.bait_Reader_Item_Bar.OnMouseLeftButtonUp = lambda: self.Set_Bait_Reader_Item()
			self.bait_Reader_Item_Bar.Show()
			self.bait_Reader_Item_Icon = ExpandedImageBox()
			self.bait_Reader_Item_Icon.SetParent(self.bait_Reader_Item_Bar)
			self.bait_Reader_Item_Icon.SetPosition(0, 0)
			self.bait_Reader_Item_Icon.LoadImage(slot_base)
			self.bait_Reader_Item_Icon.OnMouseLeftButtonUp = lambda: self.Set_Bait_Reader_Item()
			self.bait_Reader_Item_Icon.OnMouseRightButtonDown = lambda: self.Delete_Bait_Reader_Item()		
			self.bait_Reader_Item_Icon.Show()	
			self.pauseFishing = CheckBox(lang.PAUSE_FISHBOT)
			self.pauseFishing.SetParent(self.pnlFishbot)
			self.pauseFishing.SetPosition(330,195)
			self.pauseFishing.Show()
			self.pauseFishing.eventDown   = self.pauseFishInfo
			self.pauseFishLblFor, self.pauseFishFor = self.comp.EditLine(self.pnlFishbot, '15', 420, 197, 25, 15, 7)
			self.pauseFishLblEach, self.pauseFishEach = self.comp.EditLine(self.pnlFishbot, '30', 480, 197, 25, 15, 7)
			self.lblFishSettings = self.comp.TextLine(self.pnlFishSettings, lang.STR_FISHSET, 60, 5, self.comp.RGB(255, 255, 255))
			self.lblFishDelay = self.comp.TextLine(self.pnlFishSettings, lang.STR_FISHDELAY, 10,25, self.comp.RGB(255, 255, 255))
			self.fishdelay_textbox, self.delay_textbox = self.comp.EditLine(self.pnlFishSettings, '2.50', 70, 25, 45, 15, 7)
			
			try:
				self.delay_textbox.OnIMEUpdate = lambda: self.numbersAndDotOnly(self.delay_textbox)
			except:
				pass
			
			self.randomizeFish = CheckBox('R.')
			self.randomizeFish.SetParent(self.pnlFishSettings)
			self.randomizeFish.SetPosition(120, 25)
			self.randomizeFish.eventDown   = self.randomizeFishFunc
			self.randomizeFish.Show()
			try:
				self.fishDelayInfo_Icon = ExpandedImageBox()
				self.fishDelayInfo_Icon.SetParent(self.pnlFishSettings)
				self.fishDelayInfo_Icon.SetPosition(160, 25)
				if find_string(st_cur_server, "nextworld"):
					fishmind = "d:/worktree/ui/skill/common/affect/fishmind.slc"
				elif find_string(st_cur_server, "ewmt2") or find_string(st_cur_server, "aronix"):
					fishmind = ymir + 'ui/pattern/q_mark_01.tga'
				else:
					fishmind = ymir + uiskill + 'common/affect/fishmind.sub'
				self.fishDelayInfo_Icon.LoadImage(fishmind)
				self.fishDelayInfo_Icon.OnMouseLeftButtonUp = lambda: self.fishdelay_msg()
				self.fishDelayInfo_Icon.OnMouseOverIn = lambda: self.fishdelay_tipShow()
				self.fishDelayInfo_Icon.OnMouseOverOut = lambda: self.fishdelay_tipHide()		
				self.fishDelayInfo_Icon.Show()
			except:
				pass
			self.lblFishBotDelay = self.comp.TextLine(self.pnlFishSettings, lang.STR_BOTDELAY, 10,45, self.comp.RGB(255, 255, 255))
			self.fishbotdelay_textbox, self.fbot_delay = self.comp.EditLine(self.pnlFishSettings, '0.01', 70, 45, 45, 15, 7)
			
			try:
				self.fbot_delay.OnIMEUpdate = lambda: self.numbersAndDotOnly(self.fbot_delay)
			except:
				pass
			
			self.sellminnowCb = CheckBox(lang.STR_SELLMINNOW)
			try:
				self.sellminnowCb.SetParent(self.pnlFishSettings)
			except:
				pass
			self.sellminnowCb.SetPosition(107,65)
			self.sellminnowCb.Show()
			self.upgradeRod = CheckBox(lang.STR_UPGRADE_ROD)
			try:
				self.upgradeRod.SetParent(self.pnlFishSettings)
			except:
				pass
			self.upgradeRod.SetPosition(107,88)
			self.upgradeRod.Show()
			self.upgradeRod.Toggle()
			self.openclamhBtn = CheckBox(lang.STR_OPENCLAM)
			try:
				self.openclamhBtn.SetParent(self.pnlFishSettings)
			except:
				pass
			self.openclamhBtn.SetPosition(15,65)
			self.openclamhBtn.Show()
			self.playerDetectorFish = CheckBox(lang.STR_STOPIFPLAYER)
			try:
				self.playerDetectorFish.SetParent(self.pnlFishSettings)
			except:
				pass
			self.playerDetectorFish.SetPosition(15,112)
			self.playerDetectorFish.Hide()
			self.skipAnim = CheckBox(lang.STR_SKIP_ANIM)
			try:
				self.skipAnim.SetParent(self.pnlFishSettings)
			except:
				pass
			self.skipAnim.SetPosition(15,135)
			self.skipAnim.eventDown = self.enableSkipAnim
			self.skipAnim.Show()
			self.switchArmor = CheckBox(lang.FISHBOT_SWITCH_ARMOR)
			try:
				self.switchArmor.SetParent(self.pnlFishSettings)
			except:
				pass
			self.switchArmor.SetPosition(15,88)
			self.switchArmor.Show()
			self.switchArmor.eventDown   = self.enableSwitchArmor
			self.switchArmor.Toggle()
			self.imgMount = ExpandedImageBox()
			try:
				self.imgMount.SetParent(self.pnlFishSettings)	
			except:
				pass
			self.imgMount.SetPosition(127, 128)
			self.imgMount.LoadImage(slot_base)
			self.imgMount.OnMouseLeftButtonUp = lambda: self.Set_Mount_Skip_Anim()
			self.imgMount.Show()
			self.iconMount = ExpandedImageBox()
			try:
				self.iconMount.SetParent(self.imgMount)
			except:
				pass
			self.iconMount.SetPosition(0, 0)
			self.iconMount.LoadImage(slot_base)
			self.iconMount.OnMouseLeftButtonUp = lambda: self.Set_Mount_Skip_Anim()
			self.iconMount.OnMouseRightButtonDown = lambda: self.Delete_Mount_Skip_Anim()		
			self.iconMount.Show()
			self.skipAnimInfo = self.comp.Button(self.pnlFishSettings, '', lang.TAB_FISH_SKIP_INFO, 165, 135, self.skipAnimHelp_Func, qmark1, qmark2, qmark1)
			self.goToFisherman = CheckBox(lang.TAB_FISH_GO_NOT_NEAR)
			try:
				self.goToFisherman.SetParent(self.pnlFishSettings)
			except:
				pass
			self.goToFisherman.SetPosition(15,158)
			self.goToFisherman.Show()
			self.lblHowToGo = self.comp.TextLine(self.pnlFishSettings, lang.TAB_FARM_HOW_TO_MOVE, 15,180, self.comp.RGB(255, 255, 255))
			self.gotoFisher = self.comp.ComboBox(self.pnlFishSettings, goToMetinWay[0], 87, 180, 95)
			for gotoFisher in goToMetinWay:
				self.gotoFisher.InsertItem(1,str(gotoFisher))
################################ TAB BUFFBOT ################################
		self.pnlBuff = self.comp.ThinBoard(self.metin2_window, False, 140, 75, 556, 200, False)
		self.buffBtn = self.comp.Button(self.metin2_window, 'Skill / buff bot', lang.STR_TIP_SKBUFF, 380, 35, self.buffBtn_func, tablarge1, tablarge2, tablarge3)
		self.pnlskillbot = self.comp.ThinBoard(self.pnlBuff, False, 50, 40, 200, 145, False)
		self.pnlskillbot2 = self.comp.ThinBoard(self.pnlBuff, False, 300, 40, 248, 155, False)
		self.lblBuffBot = self.comp.TextLine(self.pnlBuff, lang.STR_BUFF, 120, 20, self.comp.RGB(255, 255, 255))
		self.lblSkillBot = self.comp.TextLine(self.pnlBuff, lang.STR_SKILL, 370, 20, self.comp.RGB(255, 255, 255))
		self.useInstant = CheckBox(lang.TAB_SKILL_SKIP_SK_ANIM)
		self.useInstant.SetParent(self.pnlBuff)
		self.useInstant.SetPosition(418,20)
		self.useInstant.Show()
		self.useInstant.Toggle()
		self.BuffskillBtn1 = self.comp.ToggleButton(self.pnlskillbot, '', '', 20, 38,  (lambda arg=4: self.SetBuffSkillOFF(arg)), (lambda arg=4: self.SetBuffSkill(arg)), bless1, bless2, bless3)
		self.BuffskillBtn2 = self.comp.ToggleButton(self.pnlskillbot, '', '', 100, 38, (lambda arg=6: self.SetBuffSkillOFF(arg)), (lambda arg=6: self.SetBuffSkill(arg)), force1, force2, force3)
		self.BuffskillBtn3 = self.comp.ToggleButton(self.pnlskillbot,'','', 60, 38,  (lambda arg=5: self.SetBuffSkillOFF(arg)), (lambda arg=5: self.SetBuffSkill(arg)), reflect1,reflect2,reflect3)
		self.startBuffbot = self.comp.ToggleButton(self.pnlskillbot, 'Start', 'Start buffbot', 134, 43, (lambda arg = 'off': self.BuffBotUsage(arg)), (lambda arg = 'on': self.BuffBotUsage(arg)), middle1, middle2, middle3)
		self.lblBuffBotDelay = self.comp.TextLine(self.pnlskillbot, lang.STR_USE_DEWS_DELAY, 25, 75, self.comp.RGB(255, 255, 255))
		self.buffBotDelayLbl, self.buffBotDelayTxt = self.comp.EditLine(self.pnlskillbot, '10', 70, 75, 25, 15, 3)
		self.buffBotDelayTxt.SetNumberMode()
		self.lblTarget = self.comp.TextLine(self.pnlskillbot, lang.STR_TARGET, 15, 3, self.comp.RGB(255, 255, 255))
		self.getVid = self.comp.Button(self.pnlskillbot, lang.STR_GETVID, lang.STR_TIP_VID, 134, 15, self.GetVID, small1, small2, small3)
		self.targetValue, self.followTargetName = self.comp.EditLine(self.pnlskillbot, '', 15, 18, 115, 15, 15)
		self.lblDelay = self.comp.TextLine(self.pnlskillbot, lang.STR_DELAY, 15, 15, self.comp.RGB(255, 255, 255))
		self.lblFollow = self.comp.TextLine(self.pnlskillbot, lang.STR_FOLLOW, 20, 100, self.comp.RGB(255, 255, 255))
		self.followTargetBtn = self.comp.Button(self.pnlskillbot, lang.STR_ENBLE, '', 85, 98, self.followTarget_func, middle1, middle2, middle3)
		self.followTargetBtnStop = self.comp.Button(self.pnlskillbot, lang.STR_DBLE, '', 85, 98, self.followTarget_funcOff, middle1, middle2, middle3)
		self.FollowMethodLbl = self.comp.TextLine(self.pnlskillbot, lang.STR_GOTO, 20,120, self.comp.RGB(255,255,255))
		self.followMethod = self.comp.ComboBox(self.pnlskillbot, goToMetinWay[0], 85, 120, 60)
		for followMethod in goToMetinWay:
			self.followMethod.InsertItem(1,str(followMethod))
		if find_string(st_cur_server, "nextworld"):
			corp1 = "d:/worktree/ui/skill/warrior/radiant_armor_01.slc"
			corp2 = "d:/worktree/ui/skill/warrior/radiant_armor_02.slc"
			corp3 = "d:/worktree/ui/skill/warrior/radiant_armor_03.slc"
			whatBtn1 = small1
			whatBtn2 = small2
			whatBtn3 = small3
			skillName1 = "Skill 1"
			skillName2 = "Skill 2"
			skillName3 = "Skill 3"
			skillName4 = "Skill 4"
			skillName5 = "Skill 5"
			skillName6 = "Skill 6"
		else:
			corp1 = ymir + uiskill + 'warrior/cheongeun_01.sub'
			corp2 = ymir + uiskill + 'warrior/cheongeun_02.sub'
			corp3 = ymir + uiskill + 'warrior/cheongeun_03.sub'
			skillName1 = ""
			skillName2 = ""
			skillName3 = ""
			skillName4 = ""
			skillName5 = ""
			skillName6 = ""
			whatBtn1 = slot_cover1
			whatBtn2 = slot_cover2
			whatBtn3 = slot_cover3
			self.AutoSkillUse1 = self.comp.ExpandedImage(self.pnlskillbot2, 25, 15, slot_base)
			self.AutoSkillUse2 = self.comp.ExpandedImage(self.pnlskillbot2, 74, 15, slot_base)
			self.AutoSkillUse3 = self.comp.ExpandedImage(self.pnlskillbot2, 125,15, slot_base)
			self.AutoSkillUse4 = self.comp.ExpandedImage(self.pnlskillbot2, 25, 65, slot_base)
			self.AutoSkillUse5 = self.comp.ExpandedImage(self.pnlskillbot2, 74, 65, slot_base)
			self.AutoSkillUse6 = self.comp.ExpandedImage(self.pnlskillbot2, 125,65, slot_base)
		self.skillBtn1 = self.comp.ToggleButton(self.pnlskillbot2, skillName1, '', 25, 15, (lambda arg=1: self.SetSkillOFF(arg)), (lambda arg=1: self.SetSkill(arg)), whatBtn1, whatBtn2, whatBtn3)
		self.skillBtn2 = self.comp.ToggleButton(self.pnlskillbot2, skillName2, '', 74, 15, (lambda arg=2: self.SetSkillOFF(arg)), (lambda arg=2: self.SetSkill(arg)), whatBtn1, whatBtn2, whatBtn3)
		self.skillBtn3 = self.comp.ToggleButton(self.pnlskillbot2, skillName3, '', 125,15, (lambda arg=3: self.SetSkillOFF(arg)), (lambda arg=3: self.SetSkill(arg)), whatBtn1, whatBtn2, whatBtn3)
		self.skillBtn4 = self.comp.ToggleButton(self.pnlskillbot2, skillName4, '', 25, 65, (lambda arg=4: self.SetSkillOFF(arg)), (lambda arg=4: self.SetSkill(arg)), whatBtn1, whatBtn2, whatBtn3)
		self.skillBtn5 = self.comp.ToggleButton(self.pnlskillbot2, skillName5, '', 74, 65, (lambda arg=5: self.SetSkillOFF(arg)), (lambda arg=5: self.SetSkill(arg)), whatBtn1, whatBtn2, whatBtn3)
		self.skillBtn6 = self.comp.ToggleButton(self.pnlskillbot2, skillName6, '', 125,65, (lambda arg=6: self.SetSkillOFF(arg)), (lambda arg=6: self.SetSkill(arg)), whatBtn1, whatBtn2, whatBtn3)
		self.refSkBtn = self.comp.Button(self.pnlskillbot2, '', lang.STR_REF_SKILL, 1,1, self.GetSkillIcon, refresh1, refresh2, refresh3)
		self.lblStrong = self.comp.TextLine(self.pnlskillbot2, lang.STR_STRONG_BODY, 180, 15, self.comp.RGB(255, 255, 255))
		try:
			self.corpRezistenImg = self.comp.ExpandedImage(self.pnlskillbot2, 190, 35, corp3)
			self.corpRezistenBtn = self.comp.ToggleButton(self.pnlskillbot2, '', '', 190, 35, (self.strongBody_funcOff), (self.strongBody_funcOn), corp1,corp2,corp3)
			self.corpRezInfo = self.comp.Button(self.pnlskillbot2, '', '', 225, 43, self.strongBodyInfo, qmark1, qmark2, qmark1)
		except:
			pass
		try:
			self.lblSkillBotDelay= self.comp.TextLine(self.pnlskillbot2, lang.STR_USE_DEWS_DELAY, 25, 105, self.comp.RGB(255, 255, 255))
			self.skillbotDelayTxt, self.skillbotDelay = self.comp.EditLine(self.pnlskillbot2, '10', 60, 105, 30, 15, 6)
			self.skillbotDelay.SetNumberMode()
		except:
			pass
		self.startSkillbot = self.comp.ToggleButton(self.pnlskillbot2, 'Start', '', 176, 75, (lambda arg = 'off': self.skillUsage(arg)), (lambda arg = 'on': self.skillUsage(arg)), middle1, middle2, middle3)
################################ TAB SPAMBOT ################################
		self.pnlSpam = self.comp.ThinBoard(self.metin2_window, False, 140, 75, 556, 200, False)
		self.pnlReply = self.comp.ThinBoard(self.metin2_window, False, 140, 75, 650, 220, False)
		self.pnlReply.Hide()
		self.tabSpamToggle = self.comp.ToggleButton(self.metin2_window, 'Spamming', '', 30, 105, (lambda arg = 'off': self.spamTab_Func(arg)), (lambda arg = 'on': self.spamTab_Func(arg)), large1, large2, large3)
		self.tabReplyToggle = self.comp.ToggleButton(self.metin2_window, lang.TAB_SPAM_AUTO_REPLY, '', 30, 125, (lambda arg = 'off': self.replyTab_Func(arg)), (lambda arg = 'on': self.replyTab_Func(arg)), large1, large2, large3)
		self.tabReplyToggle.Hide()
		self.tabSpamToggle.Hide()
		self.spamBtn = self.comp.Button(self.metin2_window, 'Chatting', lang.STR_TIP_SPAM, 470, 35, self.spamBtn_func, tablarge1, tablarge2, tablarge3)
		self.lblText = self.comp.TextLine(self.pnlSpam, lang.STR_SPAM_TEXT, 100, 15, self.comp.RGB(255, 255, 255))
		self.spamtextslotbar, self.spamtexteditline = self.comp.EditLine(self.pnlSpam, '', 130, 15, 300, 80, 500)
		self.clearSpamText = self.comp.Button(self.pnlSpam, '', '', 110, 35, self.ClearSpamFunc, close1, close2, close3)
		self.clearTextLbl = self.comp.TextLine(self.pnlSpam, lang.STR_CLEAR_TEXT, 50, 33, self.comp.RGB(255, 255, 255))
		self.lblDelay = self.comp.TextLine(self.pnlSpam, lang.STR_USE_DEWS_DELAY, 440, 15, self.comp.RGB(255, 255, 255))
		self.lblDelay2 = self.comp.TextLine(self.pnlSpam, lang.STR_SPAM_DELAY, 510, 15, self.comp.RGB(255, 255, 255))
		self.spamdelayslotbar, self.spamdelayeditline = self.comp.EditLine(self.pnlSpam, '10', 475, 15, 25, 15, 2)
		self.spamdelayeditline.SetNumberMode()
		self.startspamBtn = self.comp.Button(self.pnlSpam, lang.STR_ENBLE, '', 240, 100, self.selectstartspam, large1, large2, large3)
		self.stopspamBtn = self.comp.Button(self.pnlSpam, lang.STR_DBLE, '', 240, 120, self.selectstopspam, large1, large2, large3)
		self.sendSpamText = self.comp.Button(self.pnlSpam, lang.STR_SEND_SPAM_ONCE, '', 240, 140, self.sendSpamTextFunc, large1, large2, large3)
		self.lblmode = self.comp.TextLine(self.pnlSpam, 'Type:', 440, 55, self.comp.RGB(255, 255, 255))
		self.spamType = self.comp.ComboBox(self.pnlSpam, 'Chat', 475, 55, 70)
		for spamType in spamTypeList:
			self.spamType.InsertItem(1,str(spamType))
		self.lblColor = self.comp.TextLine(self.pnlSpam, lang.STR_SPAM_COLOR, 440, 35, self.comp.RGB(255, 255, 255))
		self.spamColor = self.comp.ComboBox(self.pnlSpam, 'Normal', 475, 35, 70)
		for spamColor in spamColorList:
			self.spamColor.InsertItem(1,str(spamColor))
		self.lblTextDetected = self.comp.TextLine(self.pnlReply, lang.TAB_SPAM_IF_WORD, 30, 10, self.comp.RGB(255, 255, 255))
		self.textDetectedTXT, self.txtDetect = self.comp.EditLine(self.pnlReply, '', 30, 30, 335, 35, 200)
		self.lblTextReply = self.comp.TextLine(self.pnlReply, lang.TAB_SPAM_REPLY, 30, 70, self.comp.RGB(255, 255, 255))
		self.textReplyTXT, self.txtReply = self.comp.EditLine(self.pnlReply, '', 30, 90, 335, 35, 200)
		self.btnAddReply = self.comp.Button(self.pnlReply, lang.TAB_SPAM_ADD_A, '', 280, 130, self.addAnswerFunc, large1, large2, large3)
		self.lblCurrentReplies = self.comp.TextLine(self.pnlReply, lang.TAB_SPAM_CUR_REPLY, 390, 10, self.comp.RGB(255, 255, 255))
		self.repliesListBar, self.repliesList, self.repliesListScroll = self.comp.ListBoxEx2(self.pnlReply, 390, 30, 230, 135)
		self.repliesList.SetViewItemCount(7)
		self.btnRemoveSelected = self.comp.Button(self.pnlReply, '', lang.TAB_SPAM_REM_SEL_REPLY, 585, 173, self.RemoveAnswer, minus1, minus2, minus3)
		self.btnDeleteAll = self.comp.Button(self.pnlReply, lang.TAB_SPAM_REM_ALL_REPLY, lang.TAB_SPAM_REM_ALL_REPLY_TIP, 600, 170, self.AskDeleteReplyListFunc, small1, small2, small3)
		self.replyWithQuestion = CheckBox(lang.TAB_SPAM_UNKNOWN)
		self.replyWithQuestion.SetParent(self.pnlReply)
		self.replyWithQuestion.SetPosition(390,170)
		self.replyWithQuestion.Show()
		self.replyWithQuestion.eventUp   = self.disableQuestionFunc
		self.replyWithQuestion.eventDown = self.enableQuestionFunc
		self.replyWithQuestion.Toggle()
		self.repeatMsg = CheckBox(lang.REPEAT_UNKNOWN)
		self.repeatMsg.SetParent(self.pnlReply)
		self.repeatMsg.SetPosition(390,190)
		self.repeatMsg.Show()
		self.repeatMsg.eventUp   = self.disableRepeatFunc
		self.repeatMsg.eventDown = self.enableRepeatFunc
		self.refreshReplyList = self.comp.Button(self.pnlReply, '', '', 620, 10, self.refreshReplyListFunc, refresh1, refresh2, refresh3)
		self.enableReplyBot = CheckBox(lang.TAB_SPAM_ENABLE_REPLY)
		self.enableReplyBot.SetParent(self.pnlReply)
		self.enableReplyBot.SetPosition(30,140)
		self.enableReplyBot.Show()
		self.enableReplyBot.eventUp   = self.disableReplyBotFunc
		self.enableReplyBot.eventDown = self.enableReplyBotFunc
		self.lblReplyDelay = self.comp.TextLine(self.pnlReply, lang.REPLY_TIME, 30, 165, self.comp.RGB(255, 255, 255))
		self.replyDelayTxt, self.replyDelay = self.comp.EditLine(self.pnlReply, '2', 100, 165, 25, 15, 5)
		self.replyDelay.SetNumberMode()
		self.lblReplyDelay2 = self.comp.TextLine(self.pnlReply, lang.STR_SPAM_DELAY, 135, 165, self.comp.RGB(255, 255, 255))
		self.btnApplyDelay = self.comp.Button(self.pnlReply, lang.TAB_SPAM_REPLY_APPLY, '', 185, 165, self.applyDelayFunc, small1, small2, small3)
		self.replyTimesBox = CheckBox('Reply times: ')
		self.replyTimesBox.SetParent(self.pnlReply)
		self.replyTimesBox.SetPosition(30,190)
		self.replyTimesBox.Show()
		self.replyTimesBox.eventUp   = self.disableReplyTimes
		self.replyTimesBox.eventDown = self.enableReplyTimes
		self.replyTimesLblTxt, self.replyTimesTxt = self.comp.EditLine(self.pnlReply, '3', 120, 190, 25, 15, 5)
		self.replyTimesTxt.SetNumberMode()
		self.btnApplyReplySettings = self.comp.Button(self.pnlReply, lang.TAB_SPAM_REPLY_APPLY, '', 185, 190, self.applyReplyTimesFunc, small1, small2, small3)
		if isGF:
			################################ TAB WAITHACK ################################
			self.pnlWaithack = self.comp.ThinBoard(self.metin2_window, False, 250, 75, 356, 215, False)
			self.waithackBtn = self.comp.Button(self.metin2_window, 'Waithack', '', 560, 35, self.Waithack_Tab_Func, tablarge1, tablarge2, tablarge3)
			self.waithackSpeed = self.comp.SliderBar(self.pnlWaithack, 33.3, self.setWaithackSpeed, 100, 20)
			self.waithackSpeedLbl1 = self.comp.TextLine(self.pnlWaithack, 'Waithack speed:', 9, 18, self.comp.RGB(255, 255, 255))
			self.waithackSpeedLbl2 = self.comp.TextLine(self.pnlWaithack, '333 ms', 285, 18, self.comp.RGB(255, 255, 255))
			self.waithackRange = self.comp.SliderBar(self.pnlWaithack, 25.0, self.setWaithackRange, 100, 50)
			self.waithackRangeLbl1 = self.comp.TextLine(self.pnlWaithack, 'Waithack range:', 9, 48, self.comp.RGB(255, 255, 255))
			self.waithackRangeLbl2 = self.comp.TextLine(self.pnlWaithack, '2500', 285, 48, self.comp.RGB(255, 255, 255))
			self.waithackMonsters = self.comp.SliderBar(self.pnlWaithack, 15.0, self.setWaithackMonsters, 100, 80)
			self.waithackMonstersLbl1 = self.comp.TextLine(self.pnlWaithack, lang.MONSTERS_ATTACK, 9, 78, self.comp.RGB(255, 255, 255))
			self.waithackMonstersLbl2 = self.comp.TextLine(self.pnlWaithack, '15', 285, 78, self.comp.RGB(255, 255, 255))
			self.waithackBlocked = CheckBox(lang.WAITHACK_NO_WALLS)
			self.waithackBlocked.SetParent(self.pnlWaithack)
			self.waithackBlocked.SetPosition(190, 110)
			self.waithackBlocked.Show()
			self.waithackBlocked.Toggle()
			self.waithackBlocked2 = CheckBox(lang.WAITHACK_BLOCKED_MOBS)
			self.waithackBlocked2.SetParent(self.pnlWaithack)
			self.waithackBlocked2.SetPosition(10, 110)
			self.waithackBlocked2.Show()
			self.waithackBlocked2.Toggle()
			self.pauseWaithackIf = CheckBox(lang.WAITHACK_PAUSE_HP)
			self.pauseWaithackIf.SetParent(self.pnlWaithack)
			self.pauseWaithackIf.SetPosition(10, 135)
			self.pauseWaithackIf.Show()
			self.pauseWaithackIf.Toggle()
			self.txtPauseWaithackVa, self.pauseWaithackValue = self.comp.EditLine(self.pnlWaithack, '30', 210, 135, 30, 15, 3)
			self.whatToAttackLbl = self.comp.TextLine(self.pnlWaithack, lang.WAITHACK_WHAT_ATTACK, 10, 165, self.comp.RGB(255, 255, 255))
			self.whMetins = CheckBox(lang.WAITHACK_METIN)
			self.whMetins.SetParent(self.pnlWaithack)
			self.whMetins.SetPosition(10, 185)
			self.whMetins.Show()
			self.whMetins.Toggle()
			self.whMonsters = CheckBox(lang.WAITHACK_MOB)
			self.whMonsters.SetParent(self.pnlWaithack)
			self.whMonsters.SetPosition(70, 185)
			self.whMonsters.Show()
			self.whMonsters.Toggle()
			self.whBosses = CheckBox(lang.WAITHACK_BOSS)
			self.whBosses.SetParent(self.pnlWaithack)
			self.whBosses.SetPosition(140, 185)
			self.whBosses.Show()
			self.whBosses.Toggle()
			self.whPlayers = CheckBox(lang.WAITHACK_PLAYER)
			self.whPlayers.SetParent(self.pnlWaithack)
			self.whPlayers.SetPosition(200, 185)
			self.whPlayers.Show()	
			self.safeDamage = CheckBox(lang.WAITHACK_SAFE)
			self.safeDamage.SetParent(self.pnlWaithack)
			self.safeDamage.SetPosition(200, 160)
			self.safeDamage.Show()
			self.enableButton = self.comp.ToggleButton(self.pnlWaithack, 'Start', '', 280, 185, (lambda val = False: self.waithackFunc(val)), (lambda val = True: self.waithackFunc(val)), middle1, middle2, middle3)
		else:
			################################ TAB SHOP ################################
			self.pnlShop = self.comp.ThinBoard(self.metin2_window, False, 140, 75, 556, 200, False)
			self.shopBtn = self.comp.Button(self.metin2_window, lang.STR_SHOP_MANAG, lang.STR_SHOP_TIP, 560, 35, self.shopManager_func, tablarge1, tablarge2, tablarge3)
			self.shopScanBtn = self.comp.Button(self.pnlShop, lang.STR_SEARCH_BOT, '', 10, 10, self.OpenWindowShopScanner, large1, large2, large3)
			self.shopCreatorBtn = self.comp.Button(self.pnlShop, lang.STR_SHOP_CREATOR, '', 100, 10, self.OpenWindowShopCreator, large1, large2, large3)
			self.itemtoSplitLbl = self.comp.TextLine(self.pnlShop, lang.STR_ITEM_SPLIT, 10,40, self.comp.RGB(255,255,255))
			self.itemSplitterSlot = ExpandedImageBox()
			self.itemSplitterSlot.SetParent(self.pnlShop)
			self.itemSplitterSlot.LoadImage((slot_base))
			self.itemSplitterSlot.OnMouseLeftButtonUp = lambda: self.split_item_slot()
			self.itemSplitterSlot.SetPosition(70,33)
			self.itemSplitterSlot.Show()
			self.itemSplitterSlotIcon = ExpandedImageBox()
			self.itemSplitterSlotIcon.SetParent(self.itemSplitterSlot)
			self.itemSplitterSlotIcon.SetPosition(0,0)
			self.itemSplitterSlotIcon.OnMouseLeftButtonUp = lambda: self.split_item_slot()
			self.itemSplitterSlotIcon.Show()
			self.splitItemLbl = self.comp.TextLine(self.pnlShop, lang.STR_SPLIT_INTO, 110,40, self.comp.RGB(255,255,255))
			self.splitItemLbl2 = self.comp.TextLine(self.pnlShop, lang.STR_SPLIT_INTO2, 180,40, self.comp.RGB(255,255,255))
			self.slotbar_split_item_to_value, self.split_item_to_value = self.comp.EditLine(self.pnlShop, '2', 155, 40, 15, 15, 5)
			self.split_item_to_value.SetNumberMode()
			self.splitBtn = self.comp.Button(self.pnlShop, lang.STR_SPLIT_BTN, '', 215, 40, self.split_item_func, middle1, middle2, middle3)
			self.buyBotLbl = self.comp.TextLine(self.pnlShop, lang.STR_BUYSELL, 10,65, self.comp.RGB(255,255,255))
			self.buyBotSlotLbl = self.comp.TextLine(self.pnlShop, lang.STR_SLOT, 10,85, self.comp.RGB(255,255,255))
			self.slotBuyBotx, self.slotBuyBot = self.comp.EditLine(self.pnlShop, '0', 50, 85, 25, 15, 3)
			self.slotBuyBot.SetNumberMode()
			self.buyBotDelayLbl = self.comp.TextLine(self.pnlShop, lang.STR_USE_DEWS_DELAY, 10,105, self.comp.RGB(255,255,255))
			self.DelayBuyBotx, self.delayBuyBot = self.comp.EditLine(self.pnlShop, '0.2', 50, 105, 25, 15, 3)
			
			try:
				self.delayBuyBot.OnIMEUpdate = lambda: self.numbersAndDotOnly(self.delayBuyBot)
			except:
				pass
			
			self.buybotBtnOn = self.comp.Button(self.pnlShop, lang.STR_ENBLE, '', 80, 105, self.buybotFunc, middle1, middle2, middle3)
			self.buybotBtnOff = self.comp.Button(self.pnlShop, lang.STR_DBLE, '', 80, 105, self.buybotFuncOff, middle1, middle2, middle3)
			self.buyUseLbl = self.comp.TextLine(self.pnlShop, lang.STR_BUYUSE, 150,65, self.comp.RGB(255,255,255))
			self.buyUseSlotLbl = self.comp.TextLine(self.pnlShop, lang.STR_SLOT, 150,85, self.comp.RGB(255,255,255))
			self.slotUseBotx, self.slotUseBot = self.comp.EditLine(self.pnlShop, '0', 215, 85, 25, 15, 3)
			self.slotUseBot.SetNumberMode()
			self.buyUseDelayLbl = self.comp.TextLine(self.pnlShop, lang.STR_ITEMS_TO_BUY, 150,105, self.comp.RGB(255,255,255))
			self.DelayBuyUsex, self.delayUseBot = self.comp.EditLine(self.pnlShop, '1', 215, 105, 25, 15, 3)
			self.buyUseBtnOn = self.comp.Button(self.pnlShop, lang.STR_ENBLE, '', 245, 105, self.buyuseFunc, middle1, middle2, middle3)
			self.buyUseBtnOff = self.comp.Button(self.pnlShop, lang.STR_DBLE, '', 245, 105, self.buyuseFuncOff, middle1, middle2, middle3)
			self.fix_sellCB = CheckBox(lang.STR_FIX_SELL)
			self.fix_sellCB.SetParent(self.pnlShop)
			self.fix_sellCB.SetPosition(10,123)
			self.fix_sellCB.Show()
			self.buyFromSlotLbl = self.comp.TextLine(self.pnlShop, lang.STR_BUY_FROM, 10,142, self.comp.RGB(255,255,255))
			self.lblBonus = self.comp.TextLine(self.pnlShop, lang.STR_BONUS, 10,160, self.comp.RGB(255,255,255))
			self.buyFromSlotTxt, self.buyFromSlot = self.comp.EditLine(self.pnlShop, '0', 100, 142, 25, 15, 3)
			self.buyFromSlot.SetNumberMode()
			self.dropItemCB = CheckBox(lang.STR_DESTROY_DROP)
			self.dropItemCB.SetParent(self.pnlShop)
			self.dropItemCB.SetPosition(130,142)
			self.dropItemCB.Show()
			self.dropItemBuyInfo = self.comp.Button(self.pnlShop, '', '', 244,142, self.drop_item_info, qmark1, qmark2, qmark1)
			self.buysellPGMOn = self.comp.Button(self.pnlShop, lang.STR_ENBLE, '', 200, 160, self.buySellPgmFunc, middle1, middle2, middle3)
			self.buysellPGMOff = self.comp.Button(self.pnlShop, lang.STR_DBLE, '', 200, 160, self.buySellPgmFuncOff, middle1, middle2, middle3)
			self.lblMinValue = self.comp.TextLine(self.pnlShop, lang.STR_MINIMUM, 10,180, self.comp.RGB(255,255,255))
			self.minimValueTxt, self.minimumValue = self.comp.EditLine(self.pnlShop, '20', 100, 178, 25, 15, 3)
			self.minimumValue.SetNumberMode()
			self.lblBuyDelay = self.comp.TextLine(self.pnlShop, lang.STR_USE_DEWS_DELAY, 130,180, self.comp.RGB(255,255,255))
			self.lblBuyDelay2 = self.comp.TextLine(self.pnlShop, lang.STR_MINING_TIME_SEC, 200,180, self.comp.RGB(255,255,255))
			self.lblBuyDelayTxt, self.AVGdelayBuyBot = self.comp.EditLine(self.pnlShop, '0.15', 165, 178, 25, 15, 4)
			
			try:
				self.AVGdelayBuyBot.OnIMEUpdate = lambda: self.numbersAndDotOnly(self.AVGdelayBuyBot)
			except:
				pass
			
			self.storeInLbl = self.comp.TextLine(self.pnlShop, lang.STR_MOVE_TO_STOREHOUSE, 315,11, self.comp.RGB(255,255,255))
			self.storeInBtn2 = self.comp.Button(self.pnlShop, lang.STR_MOVE_BTN, '', 480, 10, self.storeInFuncStart, middle1, middle2, middle3)
			self.bonusListforBS = self.comp.ComboBox(self.pnlShop, lang.STR_AVG, 100, 160, 90)
			for bonusListforBS in BonusIDList:
				self.bonusListforBS.InsertItem(1,str(bonusListforBS))
			self.storeInLblFrom = self.comp.TextLine(self.pnlShop, lang.STR_FROM_SLOT, 315,31, self.comp.RGB(255,255,255))
			self.storeInLblFrom2 = self.comp.TextLine(self.pnlShop, lang.STR_TO_SLOT, 415,31, self.comp.RGB(255,255,255))
			self.StoreInFromTxt, self.StoreInFrom = self.comp.EditLine(self.pnlShop, '0', 376, 31, 25, 15, 3)
			self.StoreInFrom.SetNumberMode()
			self.StoreInToTxt, self.StoreInTo = self.comp.EditLine(self.pnlShop, '90', 470, 31, 25, 15, 3)
			self.StoreInTo.SetNumberMode()
			self.storeOutLbl = self.comp.TextLine(self.pnlShop, lang.STR_MOVE_FROM_STOREHOUSE, 315,51, self.comp.RGB(255,255,255))
			self.storeOutBtn = self.comp.Button(self.pnlShop, lang.STR_MOVE_BTN, '', 480, 51, self.storeOutFunc, middle1, middle2, middle3)
			self.mallOutLbl = self.comp.TextLine(self.pnlShop, lang.STR_MOVE_FROM_ISHOP, 315,71, self.comp.RGB(255,255,255))
			self.mallOutBtn = self.comp.Button(self.pnlShop, lang.STR_MOVE_BTN, '', 480, 71, self.MallOutFunc, middle1, middle2, middle3)
			self.lblItemUser = self.comp.TextLine(self.pnlShop, lang.STR_ITEM_USER, 315, 91, self.comp.RGB(255, 255, 255))
			self.itemUser_Item_Bar = ExpandedImageBox()
			self.itemUser_Item_Bar.SetParent(self.pnlShop)	
			self.itemUser_Item_Bar.SetPosition(385, 91)
			self.itemUser_Item_Bar.LoadImage(slot_base)
			self.itemUser_Item_Bar.OnMouseLeftButtonUp = lambda: self.Set_ItemUser_Item()
			self.itemUser_Item_Bar.Show()
			self.itemUser_Item_Icon = ExpandedImageBox()
			self.itemUser_Item_Icon.SetParent(self.itemUser_Item_Bar)
			self.itemUser_Item_Icon.SetPosition(0, 0)
			self.itemUser_Item_Icon.LoadImage(slot_base)
			self.itemUser_Item_Icon.OnMouseLeftButtonUp = lambda: self.Set_ItemUser_Item()
			self.itemUser_Item_Icon.OnMouseRightButtonDown = lambda: self.Delete_ItemUser_Item()
			self.itemUser_Item_Icon.Show()			
			self.lblItemUserDelay = self.comp.TextLine(self.pnlShop, lang.STR_USE_DEWS_DELAY, 315, 107, self.comp.RGB(255, 255, 255))
			self.itemUseDelayTxt, self.itemUseDelay = self.comp.EditLine(self.pnlShop, '0.001', 348, 107, 31, 15, 6)
			
			try:
				self.itemUseDelay.OnIMEUpdate = lambda: self.numbersAndDotOnly(self.itemUseDelay)
			except:
				pass
			
			# self.itemUser_Btn = self.comp.Button(self.pnlShop, lang.STR_ENBLE, '', 420, 97, self.ItemUser_Status_func, small1, small2, small3)
			self.itemUser_BtnOn = self.comp.Button(self.pnlShop, lang.STR_ENBLE, '', 420, 97, self.EnableItemUser, middle1, middle2, middle3)
			self.itemUser_BtnOff = self.comp.Button(self.pnlShop, lang.STR_DBLE, '', 420, 97, self.DisableItemUser, middle1, middle2, middle3)
			self.itemUser_BtnOff.Hide()
			self.yangBtn = self.comp.Button(self.pnlShop, lang.STR_SWITCH, '', 443, 150, self.yangBtn_func, middle1, middle2, middle3)
			self.wonBtn = self.comp.Button(self.pnlShop, lang.STR_SWITCH, '', 443, 130, self.wonBtn_func, middle1, middle2, middle3)
			self.fix_questCB = CheckBox(lang.STR_QUEST)
			self.fix_questCB.SetParent(self.pnlShop)
			self.fix_questCB.SetPosition(502,130)
			self.fix_questCB.Show()
			self.changewonSlot, self.changeSlot = self.comp.EditLine(self.pnlShop, '0', 507, 152, 20, 15, 1)
			self.changeSlot.SetNumberMode()
			self.wonInfo = self.comp.Button(self.pnlShop, '', '', 530,152, self.won_info, qmark1, qmark2, qmark1)
			self.yangTxt = self.comp.TextLine(self.pnlShop, lang.STR_WONTOYANG, 315, 150, self.comp.RGB(255, 255, 255))
			self.wonTxt = self.comp.TextLine(self.pnlShop, lang.STR_YANGTOWON, 315, 130, self.comp.RGB(255, 255, 255))
			self.destroyLbl = self.comp.TextLine(self.pnlShop, lang.STR_DESTROY_FROM, 315, 175, self.comp.RGB(255, 255, 255))
			self.destroyLbl2 = self.comp.TextLine(self.pnlShop, lang.STR_TO_SLOT, 450, 175, self.comp.RGB(255, 255, 255))
			self.destroyFromTxt, self.destroyFrom = self.comp.EditLine(self.pnlShop, '0', 420, 175, 25, 15, 4)
			self.destroyFrom.SetNumberMode()
			self.destroyToTxt, self.destroyTo = self.comp.EditLine(self.pnlShop, '45', 493, 175, 25, 15, 4)
			self.destroyTo.SetNumberMode()
			self.destroyBtn = self.comp.Button(self.pnlShop, '', lang.STR_DESTROY, 530, 177, self.ask_destroy, close1, close2, close3)
		################################ TAB INV MANAGER ################################
		self.pnlInventory = self.comp.ThinBoard(self.metin2_window, False, 50, 65, 750, 230, False)
		self.invBtn = self.comp.Button(self.metin2_window, lang.STR_INVENTORY, lang.STR_INVENTORYTIP, 740, 35, self.inventory_Func, tablarge1, tablarge2, tablarge3)
		self.itemRefine = self.comp.TextLine(self.pnlInventory, lang.STR_ITEM_REFINER, 15, 40, self.comp.RGB(255, 255, 255))
		self.itemRefineSlot = ExpandedImageBox()
		self.itemRefineSlot.SetParent(self.pnlInventory)	
		self.itemRefineSlot.SetPosition(90, 10)
		self.itemRefineSlot.LoadImage(slot_base)
		self.itemRefineSlot.OnMouseLeftButtonUp = lambda: self.select_item_refine()
		self.itemRefineSlot.Show()
		self.itemRefineSlot2 = ExpandedImageBox()
		self.itemRefineSlot2.SetParent(self.pnlInventory)	
		self.itemRefineSlot2.SetPosition(90, 42)
		self.itemRefineSlot2.LoadImage(slot_base)
		self.itemRefineSlot2.OnMouseLeftButtonUp = lambda: self.select_item_refine()
		self.itemRefineSlot2.Show()
		self.itemRefineSlot3 = ExpandedImageBox()
		self.itemRefineSlot3.SetParent(self.pnlInventory)	
		self.itemRefineSlot3.SetPosition(90, 74)
		self.itemRefineSlot3.LoadImage(slot_base)
		self.itemRefineSlot3.OnMouseLeftButtonUp = lambda: self.select_item_refine()
		self.itemRefineSlot3.Show()
		self.itemToRefine = self.comp.TextLine(self.pnlInventory, lang.STR_HOW_TO_REFINE, 140, 15, self.comp.RGB(255, 255, 255))
		self.specialItem = self.comp.TextLine(self.pnlInventory, lang.STR_SPECIAL_ITEM, 140, 48, self.comp.RGB(255, 255, 255))
		self.specialItemBox = ExpandedImageBox()
		self.specialItemBox.SetParent(self.pnlInventory)	
		self.specialItemBox.SetPosition(225, 45)
		self.specialItemBox.LoadImage(slot_base)
		self.specialItemBox.OnMouseLeftButtonUp = lambda: self.set_special_item()
		self.specialItemBox.Show()
		self.specialItemIcon = ExpandedImageBox()
		self.specialItemIcon.SetParent(self.specialItemBox)
		self.specialItemIcon.SetPosition(0, 0)
		self.specialItemIcon.LoadImage(slot_base)
		self.specialItemIcon.OnMouseLeftButtonUp = lambda: self.set_special_item()
		self.specialItemIcon.OnMouseRightButtonDown = lambda: self.delete_special_item()
		self.specialItemIcon.Show()	
		self.refineTimes = self.comp.TextLine(self.pnlInventory, lang.STR_REFINE, 140, 80, self.comp.RGB(255, 255, 255))
		self.lblRefine2 = self.comp.TextLine(self.pnlInventory, lang.STR_REF_TIMES, 220, 80, self.comp.RGB(255, 255, 255))
		self.textUpTo_textbox, self.textUpTo = self.comp.EditLine(self.pnlInventory, '9', 180, 80, 25, 15, 2)
		self.textUpTo.SetNumberMode()
		if not isGF:
			self.refineNewWindow = CheckBox(lang.NEW_REFINE)
			self.refineNewWindow.SetParent(self.pnlInventory)
			self.refineNewWindow.SetPosition(270,40)
			self.refineNewWindow.Show()
		self.RefineBtn = self.comp.Button(self.pnlInventory, lang.STR_REFINE, '', 270, 60, self.refine_func, large1, large2, large3)
		self.upgradeAll = self.comp.Button(self.pnlInventory, lang.TAB_INVENTORY_REFINE_ALL, lang.TAB_INVENTORY_REFINE_ALL_TIP, 270, 80, self.upgrade_all_items, large1, large2, large3)
		self.if_bar_list_items, self.inv_list_items, self.inv_list_items_scroll = self.comp.ListBoxEx2(self.pnlInventory, 445, 10, 170, 160)
		self.inv_list_items.SetViewItemCount(8)
		self.refreshItemList = self.comp.Button(self.pnlInventory, '', '', 635, 10, self.refresh_item_list, refresh1, refresh2, refresh3)
		self.autoRefreshInventory = CheckBox(lang.AUTO_REFRESH)
		self.autoRefreshInventory.SetParent(self.pnlInventory)
		self.autoRefreshInventory.SetPosition(659,10)
		self.autoRefreshInventory.Show()
		self.drop_Btn = self.comp.Button(self.pnlInventory, lang.STR_DROPSEL, '', 655, 40, self.drop_sel_item, large1, large2, large3)
		self.drop_All = self.comp.Button(self.pnlInventory, lang.STR_DROPALL, '', 655, 60, self.drop_all_items, large1, large2, large3)
		self.sell_Btn = self.comp.Button(self.pnlInventory, lang.STR_SELL_SEL, '', 655, 80, self.sell_sel_item, large1, large2, large3)
		self.sell_All = self.comp.Button(self.pnlInventory, lang.STR_SELL_ALL, '', 655, 100, self.sell_all_items, large1, large2, large3)
		if not isGF:
			self.destroy_sel = self.comp.Button(self.pnlInventory, lang.STR_DESTROY_SEL, '', 655, 120, self.destroy_sel_item, large1, large2, large3)
			self.destroy_all = self.comp.Button(self.pnlInventory, lang.STR_DESTROY_ALL, '', 655, 140, self.destroy_all_items, large1, large2, large3)
		self.useSelItemBtn = self.comp.Button(self.pnlInventory, lang.USE_ITEM, '', 655, 160, self.use_selectedItem, large1, large2, large3)
		self.lblItemSeller = self.comp.TextLine(self.pnlInventory, lang.ITEM_SELLER, 645, 195, self.comp.RGB(255, 255, 255))
		self.btnItemSeller = self.comp.Button(self.pnlInventory, lang.STR_OPEN, '', 700, 195, self.openItemSellerWindow, small1, small2, small3)
		if find_string(st_cur_server, "alune") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "next2play"):
			self.sellItemsWindow = ui.BoardWithTitleBar()
		else:
			self.sellItemsWindow = BoardWithTitleBar()
		self.sellItemsWindow.SetCloseEvent(self.closeItemsWindow)
		self.sellItemsWindow.SetTitleName(lang.ITEM_MANAGER)
		self.sellItemsWindow.SetSize(270, self.metin2_window.GetHeight() + 60)
		self.sellItemsWindow.SetPosition(969, 220)
		self.sellItemsWindow.AddFlag(movplable)
		self.sellItemsWindow.AddFlag('float')
		self.sellItemsWindow.Hide()
		self.ShopbarItems, self.ShopFileListBox, self.ShopScrollBar = self.comp.ListBoxEx2(self.sellItemsWindow, 20, 30, 205, 150)
		self.ShopFileListBox.SetViewItemCount(8)
		self.AddSellItemBtn = self.comp.Button(self.sellItemsWindow, lang.STR_ADD, '', 65, 185, self.OpenSellItemDialog, middle1, middle2, middle3)
		self.SellRemoveBtn = self.comp.Button(self.sellItemsWindow, lang.REMOVE_STRING, '', 140, 185, self.UISellRemoveFilterItem, middle1, middle2, middle3)
		self.whatToDO = self.comp.TextLine(self.sellItemsWindow, lang.WHAT_DO_ITEMS, 15, 215, self.comp.RGB(255, 255, 255))
		self.sellThem = CheckBox(lang.SELL_THEM)
		self.sellThem.SetParent(self.sellItemsWindow)
		self.sellThem.SetPosition(15,240)
		self.sellThem.eventDown = self.disableDestroy
		self.sellThem.Show()
		self.destroyThem = CheckBox(lang.DESTROY_THEM)
		self.destroyThem.SetParent(self.sellItemsWindow)
		self.destroyThem.SetPosition(85,240)
		self.destroyThem.eventDown = self.disableSell
		self.destroyThem.Show()
		if hasattr(net, 'SendItemExtractEnergyPacket'):
			self.extractShards = CheckBox(lang.EXTRACT_SHARDS)
			self.extractShards.SetParent(self.sellItemsWindow)
			self.extractShards.SetPosition(175,240)
			self.extractShards.eventDown = self.enableShards
			self.extractShards.Show()
			shardBox = 1
		else:
			shardBox = 0
		if hasattr(net, 'SendPetFeedPacket'):
			if shardBox:
				height = 270
			else:
				height = 240
			self.feedPet = CheckBox(lang.FEED_PET)
			self.feedPet.SetParent(self.sellItemsWindow)
			self.feedPet.SetPosition(175,height)
			self.feedPet.eventDown = self.enablePetFeed
			self.feedPet.Show()
			feedBox = 1
		else:
			feedBox = 0
		
		if switchEnabled:
			onlyItemsWText = lang.TAKE_ACTION
		else:
			onlyItemsWText = ""
		self.onlyItemsWithout = CheckBox(onlyItemsWText)
		self.onlyItemsWithout.SetParent(self.sellItemsWindow)
		self.onlyItemsWithout.SetPosition(15,300)
		
		if switchEnabled:
			self.onlyItemsWithout.Show()
			self.bonusFilterBtn = self.comp.Button(self.sellItemsWindow, 'Edit', '', 220, 300, self.OpenBonusFilterWindow, xmall1, xmall2, xmall3)
		else:
			self.onlyItemsWithout.Hide()
		self.checkBonusCount = CheckBox(lang.NOT_SELL_IF_MORE)
		self.checkBonusCount.SetParent(self.sellItemsWindow)
		self.checkBonusCount.SetPosition(15,330)
		self.checkBonusCount.Show()
		self.sellBonusCountTxt, self.sellBonusCount = self.comp.EditLine(self.sellItemsWindow, '2', 170, 330, 25, 15, 1)
		self.sellBonusCount.SetNumberMode()
		
		self.lblSellItemsDelay = self.comp.TextLine(self.sellItemsWindow, lang.STR_USE_DEWS_DELAY, 15, 270, self.comp.RGB(255, 255, 255))
		self.txtSellItemsDelay, self.SellItemsDelay = self.comp.EditLine(self.sellItemsWindow, '15', 58, 270, 25, 15, 3)
		self.SellItemsDelay.SetNumberMode()
		self.startStopSellItems = self.comp.ToggleButton(self.sellItemsWindow, 'Start', '', 100, 360, (lambda arg = 'off': self.SellItemsFunction(arg)), (lambda arg = 'on': self.SellItemsFunction(arg)), middle1, middle2, middle3)
		self.lblStone = self.comp.TextLine(self.pnlInventory, lang.STR_ADD_STONEBOT, 15, 140, self.comp.RGB(255, 255, 255))
		self.lblStoneItem = self.comp.TextLine(self.pnlInventory, lang.STR_INSERT_ITEM, 15, 160, self.comp.RGB(255, 255, 255))
		self.itemStoneSlot = ExpandedImageBox()
		self.itemStoneSlot.SetParent(self.pnlInventory)	
		self.itemStoneSlot.SetPosition(130, 128)
		self.itemStoneSlot.LoadImage(slot_base)
		self.itemStoneSlot.OnMouseLeftButtonUp = lambda: self.set_stoneItem_item()
		self.itemStoneSlot.Show()
		self.itemStoneSlot2 = ExpandedImageBox()
		self.itemStoneSlot2.SetParent(self.pnlInventory)	
		self.itemStoneSlot2.SetPosition(130, 160)
		self.itemStoneSlot2.LoadImage(slot_base)
		self.itemStoneSlot2.OnMouseLeftButtonUp = lambda: self.set_stoneItem_item()
		self.itemStoneSlot2.Show()
		self.itemStoneSlot3 = ExpandedImageBox()
		self.itemStoneSlot3.SetParent(self.pnlInventory)	
		self.itemStoneSlot3.SetPosition(130, 192)
		self.itemStoneSlot3.LoadImage(slot_base)
		self.itemStoneSlot3.OnMouseLeftButtonUp = lambda: self.set_stoneItem_item()
		self.itemStoneSlot3.Show()
		self.lblStoneSelect = self.comp.TextLine(self.pnlInventory, lang.STR_PIATRA, 185, 150, self.comp.RGB(255, 255, 255))
		self.stoneSlot = ExpandedImageBox()
		self.stoneSlot.SetParent(self.pnlInventory)	
		self.stoneSlot.SetPosition(280, 144)
		self.stoneSlot.LoadImage(slot_base)
		self.stoneSlot.OnMouseLeftButtonUp = lambda: self.set_stone()
		self.stoneSlot.Show()
		self.lblStonerem = self.comp.TextLine(self.pnlInventory, lang.STR_ITEM_TO_REMOVE, 165, 185, self.comp.RGB(255, 255, 255))
		self.lblStonerem2 = self.comp.TextLine(self.pnlInventory, lang.STR_ITEM_TO_REMOVE2, 165, 195, self.comp.RGB(255, 255, 255))
		self.brokenSlot = ExpandedImageBox()
		self.brokenSlot.SetParent(self.pnlInventory)	
		self.brokenSlot.SetPosition(280, 180)
		self.brokenSlot.LoadImage(slot_base)
		self.brokenSlot.OnMouseLeftButtonUp = lambda: self.set_brokenstone()
		self.brokenSlot.Show()
		self.stoneBotBtn = self.comp.ToggleButton(self.pnlInventory, lang.STR_ENBLE, '', 330, 160, (self.stoneBotStop), (self.stoneBotStart), large1, large2, large3)
		self.refineIcon = ExpandedImageBox()
		self.refineIcon.SetParent(self.pnlInventory)
		self.refineIcon.SetPosition(90,10)
		self.refineIcon.LoadImage(slot_base)
		self.refineIcon.OnMouseLeftButtonUp = lambda: self.select_item_refine()
		self.refineIcon.OnMouseRightButtonDown = lambda: self.delete_item_refine()	
		self.refineIcon.Show()
		self.itemStoneIcon = ExpandedImageBox()
		self.itemStoneIcon.SetParent(self.pnlInventory)
		self.itemStoneIcon.SetPosition(130, 128)
		self.itemStoneIcon.LoadImage(slot_base)
		self.itemStoneIcon.OnMouseLeftButtonUp = lambda: self.set_stoneItem_item()
		self.itemStoneIcon.OnMouseRightButtonDown = lambda: self.delete_stoneItem_item()	
		self.itemStoneIcon.Show()
		self.StoneIcon = ExpandedImageBox()
		self.StoneIcon.SetParent(self.pnlInventory)
		self.StoneIcon.SetPosition(280, 144)
		self.StoneIcon.LoadImage(slot_base)
		self.StoneIcon.OnMouseLeftButtonUp = lambda: self.set_stone()
		self.StoneIcon.OnMouseRightButtonDown = lambda: self.delete_stone()	
		self.StoneIcon.Show()
		self.brokenIcon = ExpandedImageBox()
		self.brokenIcon.SetParent(self.pnlInventory)
		self.brokenIcon.SetPosition(280, 180)
		self.brokenIcon.LoadImage(slot_base)
		self.brokenIcon.OnMouseLeftButtonUp = lambda: self.set_brokenstone()
		self.brokenIcon.OnMouseRightButtonDown = lambda: self.delete_brokenstone()	
		self.brokenIcon.Show()
		try:
			self.upList = self.comp.ComboBox(self.pnlInventory, 'Blacksmith', 230, 15, 100)
			for upList in refineList:
				self.upList.InsertItem(1,str(upList))
		except:
			pass
		################################ TAB ENERGY ################################
		self.pnlEnergy = self.comp.ThinBoard(self.metin2_window, False, 90, 65, 690, 230, False)
		self.energyBtn = self.comp.Button(self.metin2_window, lang.STR_ENERGY, lang.STR_ENERGYTIP, 650, 35, self.energyBtn_func, tablarge1, tablarge2, tablarge3)
		self.itemToGive = self.comp.TextLine(self.pnlEnergy, lang.STR_ITEM_TO_GIVE_TOALC, 10, 20, self.comp.RGB(255, 255, 255))
		self.shopIndexLbl = self.comp.TextLine(self.pnlEnergy, lang.SHOP_INDEX, 256, 75, self.comp.RGB(255, 255, 255))
		self.shopIndexTxt, self.shopIndex = self.comp.EditLine(self.pnlEnergy, '0', 320, 75, 25, 15, 2)
		self.shopIndex.SetNumberMode()
		
		if isGF:
			self.shopIndexTxt.Hide()
			self.shopIndex.Hide()
			self.shopIndexLbl.Hide()
		self.energyDelayLbl = self.comp.TextLine(self.pnlEnergy, lang.STR_USE_DEWS_DELAY, 240, 20, self.comp.RGB(255, 255, 255))
		self.giveAllItems = CheckBox(lang.GIVE_AT_ONCE)
		self.giveAllItems.SetParent(self.pnlEnergy)
		self.giveAllItems.SetPosition(240,45)
		self.giveAllItems.Show()
		self.energyDelayLbl2 = self.comp.TextLine(self.pnlEnergy, lang.STR_SPAM_DELAY, 320, 20, self.comp.RGB(255, 255, 255))
		self.energyDelayTxt, self.energyDelay = self.comp.EditLine(self.pnlEnergy, '1.5', 280, 20, 25, 15, 3)
		
		try:
			self.energyDelay.OnIMEUpdate = lambda: self.numbersAndDotOnly(self.energyDelay)
		except:
			pass
		
		self.itemToGiveSlot = ExpandedImageBox()
		self.itemToGiveSlot.SetParent(self.pnlEnergy)	
		self.itemToGiveSlot.SetPosition(155, 10)
		self.itemToGiveSlot.LoadImage(slot_base)
		self.itemToGiveSlot.OnMouseLeftButtonUp = lambda: self.select_item_toGive()
		self.itemToGiveSlot.Show()
		self.itemToGiveSlot2 = ExpandedImageBox()
		self.itemToGiveSlot2.SetParent(self.pnlEnergy)	
		self.itemToGiveSlot2.SetPosition(155, 42)
		self.itemToGiveSlot2.LoadImage(slot_base)
		self.itemToGiveSlot2.OnMouseLeftButtonUp = lambda: self.select_item_toGive()
		self.itemToGiveSlot2.Show()
		self.itemToGiveIcon = ExpandedImageBox()
		self.itemToGiveIcon.SetParent(self.pnlEnergy)
		self.itemToGiveIcon.SetPosition(155,10)
		self.itemToGiveIcon.LoadImage(slot_base)
		self.itemToGiveIcon.OnMouseLeftButtonUp = lambda: self.select_item_toGive()
		self.itemToGiveIcon.OnMouseRightButtonDown = lambda: self.delete_item_toGive()	
		self.itemToGiveIcon.Show()
		self.buyAvailable = CheckBox("Fill inventory")
		self.buyAvailable.SetParent(self.pnlEnergy)
		self.buyAvailable.SetPosition(10,48)
		self.buyAvailable.Show()
		self.buyAvailable.eventUp   = self.showBuyItems
		self.buyAvailable.eventDown = self.hideBuyItems
		self.buyFromShop = CheckBox(lang.STR_BUY_FROM_SHOP)
		self.buyFromShop.SetParent(self.pnlEnergy)
		self.buyFromShop.SetPosition(10,73)
		self.buyFromShop.Show()
		self.buyFromShop.Toggle()
		self.buyFromShopLblItems = self.comp.TextLine(self.pnlEnergy, lang.STR_ITEMS, 150, 75, self.comp.RGB(255, 255, 255))
		self.buy_items_btn = self.comp.Button(self.pnlEnergy, lang.STR_BUY_ITEMS, '', 190, 73, self.buy_items, middle1, middle2, middle3)
		self.buyFromShopTxt, self.buyFromShopValue = self.comp.EditLine(self.pnlEnergy, '20', 112, 73, 25, 15, 3)
		self.buyFromShopValue.SetNumberMode()
		self.transformStart = self.comp.Button(self.pnlEnergy, lang.STR_ENBLE, '', 180, 100, self.transform_to_crystals_on, large1, large2, large3)
		self.transformStop = self.comp.Button(self.pnlEnergy, lang.STR_DBLE, '', 180, 100, self.transform_to_crystals_off, large1, large2, large3)
		self.lblTransform = self.comp.TextLine(self.pnlEnergy, lang.STR_MAKE_CRYSTALS, 10, 102, self.comp.RGB(255, 255, 255))
		self.alchemistLoc = self.comp.TextLine(self.pnlEnergy, lang.STR_ALCH_LOCATION, 10, 125, self.comp.RGB(255, 255, 255))
		self.XalchemyLoc = self.comp.TextLine(self.pnlEnergy, 'X:', 150, 125, self.comp.RGB(255, 255, 255))
		self.YalchemyLoc = self.comp.TextLine(self.pnlEnergy, 'Y:', 220, 125, self.comp.RGB(255, 255, 255))
		self.alchemistLocXTxt, self.alchemistLocX = self.comp.EditLine(self.pnlEnergy, '0', 180, 125, 25, 15, 3)
		self.alchemistLocX.SetNumberMode()
		self.alchemistLocYTxt, self.alchemistLocY = self.comp.EditLine(self.pnlEnergy, '0', 240, 125, 25, 15, 3)
		self.alchemistLocY.SetNumberMode()
		self.getAlcLocation = self.comp.Button(self.pnlEnergy, lang.STR_GET_LOCATION, '', 280, 125, self.getAlcLoc_func, large1, large2, large3)
		self.gotoAlchemist = self.comp.Button(self.pnlEnergy, lang.STR_GO, '', 385, 125, self.go_to_alchemist2, middle1, middle2, middle3)
		self.npctoBuyLoc = self.comp.TextLine(self.pnlEnergy, lang.STR_NPC_LOCATION, 10, 145, self.comp.RGB(255, 255, 255))
		self.xlblNPC = self.comp.TextLine(self.pnlEnergy, 'X:', 150, 145, self.comp.RGB(255, 255, 255))
		self.ylblNPC = self.comp.TextLine(self.pnlEnergy, 'Y:', 220, 145, self.comp.RGB(255, 255, 255))
		self.npctoBuyLocXTxt, self.npctoBuyLocX = self.comp.EditLine(self.pnlEnergy, '0', 180, 145, 25, 15, 3)
		self.npctoBuyLocX.SetNumberMode()
		self.npctoBuyLocYTxt, self.npctoBuyLocY = self.comp.EditLine(self.pnlEnergy, '0', 240, 145, 25, 15, 3)
		self.npctoBuyLocY.SetNumberMode()
		self.getNpcLocation = self.comp.Button(self.pnlEnergy, lang.STR_GET_LOCATION, '', 280, 145, self.getNpcLoc_func, large1, large2, large3)
		self.gotoNpc = self.comp.Button(self.pnlEnergy, lang.STR_GO, '', 385, 145, self.go_to_npc2, middle1, middle2, middle3)
		self.getNpcVNUMLbl = self.comp.TextLine(self.pnlEnergy, lang.STR_NPC_VNUM, 450, 145, self.comp.RGB(255, 255, 255))
		self.getNpcVNUM = self.comp.Button(self.pnlEnergy, lang.STR_GETFISHER_VNUM, '', 520, 145, self.getNpcVnum_Func, middle1, middle2, middle3)
		self.npcVnumTxt, self.npcVnum = self.comp.EditLine(self.pnlEnergy, '0', 600, 145, 35, 15, 5)
		self.npcVnum.SetNumberMode()
		self.crystal = CheckBox(lang.AUTO_CREATE_CRYSTAL)
		self.crystal.SetParent(self.pnlEnergy)
		self.crystal.SetPosition(10, 170)
		self.crystal.Show()
		self.fragvalTxt, self.fragval = self.comp.EditLine(self.pnlEnergy, '200', 220, 170, 23, 15, 4)
		self.fragval.SetNumberMode()
		self.stopYang = CheckBox(lang.STOP_IF_YANG)
		self.fragYangTxt, self.yangval = self.comp.EditLine(self.pnlEnergy, '15000', 200, 195, 43, 15, 10)
		self.yangval.SetNumberMode()
		self.stopYang.SetParent(self.pnlEnergy)
		self.stopYang.SetPosition(10, 195)
		self.stopYang.Show()
		self.energy_test = self.comp.Button(self.pnlEnergy, lang.STR_GIVE_ALL_ITEMS, '', 310, 195, self.give_all_items_to_alchemist, large1, large2, large3)
		self.energy_Start = self.comp.Button(self.pnlEnergy, lang.STR_ENBLE, '', 310, 175, self.energyfunc_start,large1, large2, large3)
		self.energy_Stop = self.comp.Button(self.pnlEnergy, lang.STR_DBLE, '', 310, 175, self.energyfunc_stop, large1, large2, large3)
		self.goingMethod_enrgy = self.comp.TextLine(self.pnlEnergy, lang.STR_GOTO, 450, 40, self.comp.RGB(255, 255, 255))
		self.LoadLocBtn = self.comp.Button(self.pnlEnergy, lang.STR_COM_SCRIPTS_LOAD, '', 605, 18, self.load_locFunc, small1, small2, small3)
		self.refreshEnergyRouteBtn = self.comp.Button(self.pnlEnergy, '', '', 580, 80, self.refreshEnergyRouteList, refresh1, refresh2, refresh3)
		self.loadEnergyRouteBtn = self.comp.Button(self.pnlEnergy, 'Load', '', 605, 80, self.readCurrentEnergyRoute, small1, small2, small3)
		self.energyRouteInfo = self.comp.Button(self.pnlEnergy, 'Info', '', 645, 80, self.energyRouteInfoFunc, small1, small2, small3)
		self.energyRouteListbox = DropDown(self.pnlEnergy,'',1, 100)
		self.energyRouteListbox.SetParent(self.pnlEnergy)
		self.energyRouteListbox.SetPosition(470, 80)
		self.energyRouteListbox.Show()
		try:
			self.gotoEnergy = self.comp.ComboBox(self.pnlEnergy, goToMetinWay[0], 520, 40, 80)
			for gotoEnergy in goToMetinWay:
				self.gotoEnergy.InsertItem(1,str(gotoEnergy))
		except:
			pass
		self.listLocations = self.comp.ComboBox(self.pnlEnergy, 'Map1 Blue', 520, 20, 80)
		for listLocations in LocationList:
			self.listLocations.InsertItem(1,str(listLocations))
		self.energyRoute = CheckBox(lang.GO_BY_ROUTE)
		self.energyRoute.SetParent(self.pnlEnergy)
		self.energyRoute.SetPosition(380, 80)
		self.energyRoute.eventUp   = self.hideRouteEnergy
		self.energyRoute.eventDown = self.showRouteEnergy
		self.energyRoute.Show()
		# self.energyRoute.Toggle()
		self.lblDefaultLoc = self.comp.TextLine(self.pnlEnergy, lang.DEFAULT_LOC, 430, 20, self.comp.RGB(255, 255, 255))
		
		try:
			if find_string(st_cur_server, "DDMT") or find_string(st_cur_server, "mt2classichu") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "LandOfHeroes") or find_string(st_cur_server, "atheria") or find_string(st_cur_server, "alune") or find_string(st_cur_server, "nextworld") or find_string(st_cur_server, "rhodium"):
				self.txttooltip = uiToolTip.ToolTip()
				self.txttooltip.Hide()	
			else:
				self.txttooltip = ToolTip()
				self.txttooltip.Hide()
		except:
			pass
		
################################ INIT ################################
		self.set_default_hotkeys()
		if isGF:
			self.pnlFishbot = self.comp.ThinBoard(self.metin2_window, False, 99999, 99999, 99999, 99999, False)
			self.pnlShop = self.comp.ThinBoard(self.metin2_window, False, 99999, 99999, 99999, 99999, False)
			self.fishMain = self.comp.ThinBoard(self.metin2_window, False, 99999, 99999, 99999, 99999, False)
			self.fishesBtn = self.comp.ThinBoard(self.metin2_window, False, 99999, 99999, 99999, 99999, False)
			self.fantomaBtnStop = self.comp.ThinBoard(self.metin2_window, False, 99999, 99999, 99999, 99999, False)
			self.buybotBtnOff = self.comp.ThinBoard(self.metin2_window, False, 99999, 99999, 99999, 99999, False)
			self.buyUseBtnOff = self.comp.ThinBoard(self.metin2_window, False, 99999, 99999, 99999, 99999, False)
			self.fishbotBtnStop = self.comp.ThinBoard(self.metin2_window, False, 99999, 99999, 99999, 99999, False)
			self.buysellPGMOff = self.comp.ThinBoard(self.metin2_window, False, 99999, 99999, 99999, 99999, False)
			self.pnlFishes = self.comp.ThinBoard(self.metin2_window, False, 99999, 99999, 99999, 99999, False)
		try:
			self.miscBtn.ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
		except:
			pass
		self.pnlOthers.Show()
		if not isGF:
			self.pnlFishbot.Hide()
			self.pnlShop.Hide()
			self.fishMain.Hide()
			self.fishesBtn.Hide()
			self.fantomaBtnStop.Hide()
			self.buybotBtnOff.Hide()
			self.buyUseBtnOff.Hide()
			self.fishbotBtnStop.Hide()
			self.buysellPGMOff.Hide()
		else:
			self.pnlPickup.Hide()
			self.pnlWaithack.Hide()
		self.pnlSpam.Hide()
		self.pnlBuff.Hide()
		self.pnlRead.Hide()
		self.pnlEnergy.Hide()
		#self.x=0
		self.y=0
		self.z=0
		self.cooordx=0
		self.cooordy=0
		self.boka=0
		self.bokb=0
		self.cabla=0
		Gui = []
		type = 0
		self.lastTime = 0
		self.TIME_WAIT = 0.1
		self.toStackMoveActions = []
		self.showButton.Hide()
		self.transformStop.Hide()
		self.relogBtnStop.Hide()
		self.zoomfogBtnStop.Hide()
		self.donateBtnStop.Hide()
		self.restartBtnStop.Hide()
		self.btnAttackStop.Hide()
		self.btnCapeStop.Hide()
		self.followTargetBtnStop.Hide()
		self.BlueBtnStop.Hide()
		self.redBtnStop.Hide()
		self.routeCoordsTxt.Hide()
		self.routeCoords.Hide()
		self.useDewsBtnStop.Hide()
		self.btn_redElixirStop.Hide()
		self.btn_blueElixirStop.Hide()
		self.speedBtnStop.Hide()
		self.oneHitBtnStop.Hide()
		self.enablehotKeyTeleportStop.Hide()
		self.btnUseFuncStop.Hide()
		self.moblockStop.Hide()
		self.energy_Stop.Hide()
		self.btnfreezeStop.Hide()
		self.pnlInventory.Hide()
		self.autologin_state=0
		self.zoom_state=0
		self.gm_state=0
		self.player_state=0
		self.exp_state=0
		self.dews_state=0
		self.restart_state=0
		self.state_fantom=0
		self.red_state=0
		self.red_e_state=0
		self.blue_state=0
		self.blue_e_state=0
		self.day_state=0
		self.night_state=0
		self.oneh_state=0
		self.twoh_state=0
		self.speed_state=0
		self.vit_state=0
		self.int_state=0
		self.str_state=0
		self.dex_state=0
		self.p1_state=0
		self.p2_state=0
		self.p3_state=0
		self.p4_state=0
		self.p5_state=0
		self.p6_state=0
		self.farm2_state=0
		self.mining_state=0
		self.pick1_state=0
		self.pick2_state=0
		self.lvl_state=0
		self.hotkey_state=0
		self.one_hit_state=0
		self.capes_state=0
		self.curLoc=0
		self.xFishbot_KillFishes=0
		self.xFishbot_OpenClams=0
		self.xFishbot_SellFish=0
		self.xFishbot_SellHair=0
		self.xFishbot_SwitchArmor=0
		self.xFishbot_SellMinnow=0
		self.xFishbot_SellCrap=0
		self.xFishbot_UpgradeRod=0
		self.xFishbot_Cancel_Animation=0
		self.xFishbot_DisableQuests=0
		self.xFishbot_FishernumVnum=9009
		self.xFishbot_DefaultShopIndex=0
		self.xFishbot_BuyBait=0
		self.xFishbot_BuyBaitShopIndex=0
		self.xFishbot_BuyBaitQ=0
		self.xFishbot_Bait_Minnow=0
		self.xFishbot_Bait_Other=0
		self.xFishbot_Bait_Worm=0
		self.xFishbot_Bait_Paste=0
	
		self.current_route_step = 0
		self.current_route = None
		try:
			self.HotkeyShowST()
		except:
			pass
		if clientSlot:
			try:
				self.getPlayerInfo()
			except:
				pass
		try:
			self.autoRefreshChannels()
		except:
			pass				
		try:
			previous_level = player.GetStatus(player.LEVEL)
		except:
			previous_level = -1			
		try:
			self.refreshRouteListFunc()
		except:
			pass		
		try:
			self.refreshEnergyRouteList()
		except:
			pass
		if not find_string(st_cur_server, "nextworld"):
			self.GetSkillIcon()
		try:
			self.refresh_item_list()
		except:
			pass
		try:
			create_log("\x53\x54\x4d\x6f\x64 loaded succesfully.")
		except:
			pass
		# if find_string(st_cur_server, "ashiro"):
			# new_name = 'NotRunTasks'
			# if hasattr(game, 'RunTasks'):
				# original_method = getattr(game, 'RunTasks')
				# setattr(game, new_name, original_method)
				# delattr(game, 'RunTasks')
		if find_string(st_cur_server, "VirtualMT2") or find_string(st_cur_server, "Virtual MT2"):
			try:
				self.virtual_func()
			except:
				pass
				
				

		try:
			eventHandler.add(2, self.loadSettings)
			eventHandler.add(2.3, lambda: msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.STR_MSGLOADED_OK1))
			eventHandler.add(2.3, lambda: msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.STR_MSGLOADED_OK2))
			eventHandler.add(2.3, lambda: msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.STR_MSGLOADED_OK3))
			eventHandler.add(2.3, lambda: msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.STR_MSGLOADED_OK4))
		except:
			pass
		if find_string(st_cur_server, "aegis"):
			eventHandler.add(2, self.loadSettings)
		dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'player_whitelist.txt'
		if not os.path.exists(dirPl):
			non_detect = open_file(dirPl, "a")
			non_detect.write("\n")
			non_detect.close()
		fileCustom = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'custom_ore.txt'
		if not os.path.exists(fileCustom):
			oreWhitelist = open_file(fileCustom, "a")
			oreWhitelist.write("\n")
			oreWhitelist.close()
			
			
		self.removeHarmful()	
	
		if not (find_string(st_cur_server, "legendofmetin") or find_string(st_cur_server, "luminus")):
			self.captchaFunc()
		
		if find_string(st_cur_server, "mystic"):
			def hook_captcha():
				import uicaptcha
	
				if not hasattr(uicaptcha, "Dialog1"):
					return
			
				dialog_class = getattr(uicaptcha, "Dialog1")
			
				if not hasattr(dialog_class, "UpdateCaptcha"):
					return
				def hooked_update_captcha(self, winner_vnum, vnum1, vnum2, vnum3, vnum4, expire, slot1, slot2, slot3, slot4):
					saved_slots = {
						slot1: vnum1,
						slot2: vnum2,
						slot3: vnum3,
						slot4: vnum4,
					}
			
					correct_slot = None
					for slot, vnum in saved_slots.items():
						if vnum == winner_vnum:
							correct_slot = slot
							break
	
					if correct_slot is not None:
						net.SendCaptcha(correct_slot)
						infoCaptcha()
						
	
				dialog_class.UpdateCaptcha = hooked_update_captcha
	
			hook_captcha()
	
		
		try:
			if find_string(st_cur_server, "rubinum") or find_string(st_cur_server, "oficial") or find_string(st_cur_server, "m2classic"):
				eventHandler.add(5, self.killCaptcha)
	
		except:
			pass		
		try:
			eventHandler.add(10, self.funcKeys)
		except:
			pass
		try:
			self.timeRunOn()
		except:
			pass
		self.getFishes()
	
		# if not (find_string(st_cur_server, "legendofmetin")):
		self.checkGame()
		try:
			self.addAllUsers()
		except:
			pass
		try:
			self.updateWhitelist()
		except:
			pass
		if not (find_string(st_cur_server, "nextworld")):
			try:
				if hasattr(chrmgr, 'SetAffect'):
					self.lblStrong.Show()
					self.corpRezistenImg.Show()
					self.corpRezistenBtn.Show()
					self.corpRezInfo.Show()
				else:
					self.lblStrong.Hide()
					self.corpRezistenImg.Hide()
					self.corpRezistenBtn.Hide()
					self.corpRezInfo.Hide()
					self.strongBody_funcOff()
			except:
				pass
		if find_string(st_cur_server, "avaris"):
			invPassword = st_path + "/Data/Servers/" + str(st_cur_server) + '/invPassword.txt'
			if os.path.exists(invPassword) and os.stat(invPassword).st_size != 0:
				file = open_file(invPassword, 'r+')
				pin = file.read().strip()
				file.close()
				eventHandler.add(2, SendChatPacket('/inventory_password ' + str(pin)))
				eventHandler.add(2, msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hInventory unlocked."))
				
			else:				
				greenColor = "|cff00FF00"
				resetColor = "|cffFFFF00"				
				xxx = invPassword.replace("/invPassword.txt","")
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCreate a file called: " + greenColor + "invPassword.txt" + resetColor + " inside " + greenColor + "" + str(xxx) + "" + resetColor + " folder.")
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlace there your inventory password,")
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hNext time you start bot, inventory will be automatically unlocked.")
				
				
				
		if find_string(st_cur_server, "calliope"):
			eventHandler.add(10, self.calliope_func)
		if find_string(st_cur_server, "odyssey"):
			eventHandler.add(0.5, self.delRes)
		try:
			self.defaultSettingsFunc()
		except:
			pass
		relogCaptcha = 1
		if find_string(st_cur_server, "legendofmetin"):
			relogCaptcha = 0
		if relogCaptcha:
			if find_string(st_cur_server, "velium"):
				if isConnect():
					eventHandler.add(3, self.relogMe)	
			try:
				if not (find_string(st_cur_server, "kronius") or find_string(st_cur_server, "mein") or find_string(st_cur_server, "mystic") or find_string(st_cur_server, "levia")):
					GameWindow = game.GameWindow
					
					# if hasattr(GameWindow, 'ProcessCaptcha'):
						# if isConnect():
							# eventHandler.add(3, self.relogMe)				
						# return
					if hasattr(GameWindow, 'BINARY_CaptchaOpen'):
						if isConnect():
							eventHandler.add(3, self.relogMe)
						return
							
					if hasattr(GameWindow, 'BINARY_BotControlOpen'):
						if isConnect():
							eventHandler.add(3, self.relogMe)
						return
					if hasattr(GameWindow, '_GameWindow__GetCaptcha'):
						if isConnect():
							eventHandler.add(3, self.relogMe)
						return
					if hasattr(GameWindow, '_GameWindow__CaptchaNew'):
						if isConnect():
							eventHandler.add(3, self.relogMe)
						return
					if hasattr(GameWindow, 'OpenCaptcha'):
						if isConnect():
							eventHandler.add(3, self.relogMe)
						return
					if hasattr(GameWindow, 'captchaekran'):
						if isConnect():
							eventHandler.add(3, self.relogMe)
						return
					if hasattr(GameWindow, 'BINARY_ShowCaptchaChallenge'):
						if isConnect():
							eventHandler.add(3, self.relogMe)
						return
					
					try:
	
						import uifarmwindow
						TestWindow = uifarmwindow.TestWindow
						
						if hasattr(uifarmwindow, 'TestWindow'):
							if isConnect():
								eventHandler.add(3, self.relogMe)
								
							return
					except:
						pass					
					try:
						
						import uiCommon
						ShowCaptcha = uiCommon.ShowCaptcha
						
						if hasattr(ShowCaptcha, 'Open'):
							if isConnect():
								eventHandler.add(3, self.relogMe)
								
							return
					except:
						pass
					try:
						
						import uiCommon
						Captcha = uiCommon.Captcha
						
						if hasattr(Captcha, 'Open'):
							if isConnect():
								eventHandler.add(3, self.relogMe)
								
							return
								
					except:
						pass
					try:
						import uiCaptcha
						if hasattr(uiCaptcha, 'CaptchaWindow'):
							CaptchaWindow = uiCaptcha.CaptchaWindow
							if hasattr(CaptchaWindow, '_CaptchaWindow__OnClickCaptcha') :
								if isConnect():
									eventHandler.add(3, self.relogMe)
								return
					except:
						pass
							
	
			except:
				pass
	
	def itemuse_func(self):
		global item_user_state
		
		self.btnUseFuncStop.Show()
		self.btnUseFunc.Hide()
		item_user_state=1
		self.itemUserDelayFunc.XX1(0.1)
		self.itemUserDelayFunc.XX2(self.itemuse_func)
		
		if not isConnect():
			self.itemUserDelayFunc.XX1(3)
			self.ResetTimers()
			return
		self.itemUserFunction()
	def filter_input(self, who):
		allowed_characters = "0123456789."
		current_text = who.GetText()
	
		dot_count = 0
		filtered_text = []
		for i, char in enumerate(current_text):
			if char == '.':
				# Do not allow `.` at the start or more than once
				if dot_count == 0 and i != 0:
					filtered_text.append(char)
					dot_count += 1
			elif char in allowed_characters:
				filtered_text.append(char)
		who.SetText(''.join(filtered_text))
	def numbersAndDotOnly(self, who):
		if isGF:
			try:
				ui.EditLine.OnIMEUpdate(who)
				self.filter_input(who)
			except:
				pass
		else:
			try:
				EditLine.OnIMEUpdate(who)
				self.filter_input(who)
			except:
				pass
	def itemuse_funcStop(self):
		global item_user_state
		self.btnUseFuncStop.Hide()
		self.btnUseFunc.Show()
		self.itemUserDelayFunc.XX1(9999999)
		self.itemUserDelayFunc.XX2(self.itemuse_funcStop)
		item_user_state=0
		self.ResetTimers()
		eventHandler.remove("useItemFunc")
			
	def itemUserFunction(self):
		global Use_Item_ID
		current_time = app.GetTime()
		for index, delay_entry in enumerate(self.item_delays):
			if Use_Item_ID[index] > 0:
				try:
					delay_text = delay_entry[1].GetText()
					delay = float(delay_text)
				except ValueError:
					delay = float(10)
				if current_time >= self.item_timers[index]:
					for i in range(player.INVENTORY_PAGE_SIZE * 5):
						if player.GetItemIndex(i) == Use_Item_ID[index]:
							useItemFunc(i)
							break
					self.item_timers[index] = current_time + delay
	def CreateItemSlots(self):
		num_slots = 30
		columns = 6
		rows = 5
		start_x = 10
		start_y = 30
		slot_spacing_x = 32
		slot_spacing_y = 60
	
		for i in range(num_slots):
			col = i % columns
			row = i // columns
	
			slot_bar = ui.ExpandedImageBox()
			slot_bar.SetParent(self.itemUseWindow)
			slot_bar.SetPosition(start_x + (col * slot_spacing_x), start_y + (row * slot_spacing_y))
			slot_bar.LoadImage(slot_base)
			slot_bar.OnMouseLeftButtonUp = lambda idx=i: self.SetUseItem(idx)
			slot_bar.Show()
	
			slot_icon = ui.ExpandedImageBox()
			slot_icon.SetParent(slot_bar)
			slot_icon.SetPosition(0, 0)
			slot_icon.LoadImage(slot_base)
			slot_icon.OnMouseLeftButtonUp = lambda idx=i: self.SetUseItem(idx)
			slot_icon.OnMouseRightButtonDown = lambda idx=i: self.DeleteUseItem(idx)
			slot_icon.OnMouseOverIn = lambda idx=i: self.ShowTip(idx)
			slot_icon.OnMouseOverOut = self.fishdelay_tipHide
			slot_icon.Show()
	
			self.item_slots.append((slot_bar, slot_icon))
			delay_edit = self.comp.EditLine(self.itemUseWindow, '10', 
											start_x + (col * slot_spacing_x), 
											start_y + (row * slot_spacing_y) + 40, 
											30, 14, 6)
			self.item_delays.append(delay_edit)
			self.item_timers.append(10)
	def SetUseItem(self, index):
		global Use_Item_ID
		if isAttached():
			attachedSlotVnum = GetAttachedItemIndex()
	
			selectItem(attachedSlotVnum)
			Use_Item_ID[index] = GetAttachedItemIndex()
	
			DeattachObject()
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hItem user: " + str(lang.SUCCES_ADD_ITEM) + " " + str(attachedSlotVnum))
	
			selectItem(int(attachedSlotVnum))
			item_icon = item.GetIconImageFileName()
			self.item_slots[index][1].LoadImage(str(item_icon))
			try:
				self.SaveItems(CONFIG_ITEMS)
			except:
				pass
	def ResetTimers(self):
		try:
			for index in range(len(self.item_timers)):
				self.item_timers[index] = 0
		except:
			pass
	def DeleteUseItem(self, index):
		global Use_Item_ID
		Use_Item_ID[index] = 0
		try:
			self.fishdelay_tipHide()
		except:
			pass
		self.item_slots[index][1].LoadImage(slot_base)
	def ShowTip(self, index):
		global Use_Item_ID
		try:
			if Use_Item_ID[index] > 0:
				selectItem(int(Use_Item_ID[index]))
		
				self.txttooltip.ClearToolTip()
				
				o = "|cFFFF8040|H|h"
				y = "|cffFFFF00|H|h"
				g = "|cff00FF00|H|h"
				
				
				self.txttooltip.AppendTextLine(str(y) + str(item.GetItemName(Use_Item_ID[index])), grp.GenerateColor(0.9490, 0.9058, 0.7568, 1.0))
				self.txttooltip.AppendTextLine("", grp.GenerateColor(0.2, 0.9, 0.9, 1.0))
				self.txttooltip.AppendTextLine("ID: " + g + str(Use_Item_ID[index]), grp.GenerateColor(0.7607, 0.7607, 0.7607, 1.0)) 
				self.txttooltip.AppendTextLine("Item count: " + g + str(player.GetItemCountByVnum(int(Use_Item_ID[index]))), grp.GenerateColor(0.7607, 0.7607, 0.7607, 1.0)) 
				try:
					delay_text = self.item_delays[index][1].GetText()
					delay = float(delay_text)
				except:
					delay = float(10)
		
				self.txttooltip.AppendTextLine(lang.STR_USE_DEWS_DELAY + g + str(delay), grp.GenerateColor(0.7607, 0.7607, 0.7607, 1.0))
				self.txttooltip.AppendTextLine("", grp.GenerateColor(0.2, 0.9, 0.9, 1.0))
				self.txttooltip.AppendTextLine(str(y) + lang.RIGHT_CLICK_REMOVE, grp.GenerateColor(0.2, 0.9, 0.9, 1.0))
				self.txttooltip.Show()
			else:
				self.txttooltip.ClearToolTip()
				self.txttooltip.Hide()
		except:
			pass
	def SaveItems(self, filename):
		try:
			f = open_file(filename, "w")
			for index, delay_entry in enumerate(self.item_delays):
				item_id = Use_Item_ID[index]
				delay_text = delay_entry[1].GetText()
				f.write(str(item_id) + "," + delay_text + "\n")
			f.close()
		except:
			pass
	def LoadItems(self, filename):
		global Use_Item_ID
		try:
			f = open_file(filename, "r+")
			lines = f.readlines()
			f.close()
		
			for index, line in enumerate(lines):
				if index < len(self.item_delays):
					item_id, delay_text = line.strip().split(",")
					Use_Item_ID[index] = int(item_id)
					self.item_delays[index][1].SetText(delay_text)
	
					if int(item_id) > 0:
						selectItem(int(item_id))
						item_icon = item.GetIconImageFileName()
						self.item_slots[index][1].LoadImage(str(item_icon))
					else:
						self.item_slots[index][1].LoadImage("d:/ymir work/ui/public/Slot_Base.sub")
		except:
			pass
			
			
			
			
			
	def autoRefreshChannels(self):
		self.refreshChannelsFunc.XX1(1)
		self.refreshChannelsFunc.XX2(self.autoRefreshChannels)
		if isConnect():
			self.refreshChannels()
		
		
	def captchaFunc(self):
		try:
			from uicaptcha import Window
			original_open = Window.Open
			def hooked_open(self, leftTime=0, totalStage=0, currentStage=0, itemListCMD=""):
				infoCaptcha()
				xxxxx = app.DecryptText(itemListCMD, "31")
				randomItemList = xxxxx.split("#")
				selectItem(int(randomItemList[0]))				
				
				SendChatPacket("/captcha click "+str(int(randomItemList[0])))
			Window.Open = hooked_open
		except:
			pass
			
		if find_string(st_cur_server, "velium"):
			try:
				
				import game
				GameWindow = game.GameWindow
				original_SetBigMessage = GameWindow.BINARY_SetBigMessage
				original_SetTipMessage = GameWindow.BINARY_SetTipMessage
				
				
				def hook_Binary_SetBigMessage(original_function):
					def hooked_function(self, message):
						process_message(message)
						# return original_function(self, message)
					return hooked_function
				
				def hook_Binary_SetTipMessage(original_function):
					def hooked_function(self, message):
						process_message(message)
						# return original_function(self, message)
					return hooked_function
				
				def process_message(message):
					if "CAPTCHA" in message:
						if ": " in message:
							captcha_string = message.split(": ")[1].strip()
							# SendChatPacket(str(captcha_string))
							net.SendChatPacket(str(captcha_string), 0)
							infoCaptcha()
						
				
				GameWindow.BINARY_SetBigMessage = hook_Binary_SetBigMessage(original_SetBigMessage)
				GameWindow.BINARY_SetTipMessage = hook_Binary_SetTipMessage(original_SetTipMessage)
				
			except:
				pass
			
			
		try:
			from uiCaptcha import Window
			original_open = Window.Open
			def hooked_open(self, leftTime=0, totalStage=0, currentStage=0, itemListCMD=""):
				infoCaptcha()
				xxxxx = app.DecryptText(itemListCMD, "31")
				randomItemList = xxxxx.split("#")
				selectItem(int(randomItemList[0]))				
				
				SendChatPacket("/captcha click "+str(int(randomItemList[0])))
			Window.Open = hooked_open
		except:
			pass
		try:
			import uitype
			def verification_captcha_hook(self, canShow, TypeItem):
				infoCaptcha()
				SendChatPacket('/captcha_verify 010011011011 ' + str(TypeItem))
				
			uitype.TypeWindow.VerificationCaptcha = verification_captcha_hook
		except:
			pass	
		try:
			import uiCaptchaNew,osfInfo
			def hook_captcha_show(self, timeLeft):
				infoCaptcha()
				event.QuestButtonClick(osfInfo.CAPTCHA_QUESTINDEX)
				
				create_log(lang.CAPTCHA_MSG2)
			if hasattr(uiCaptchaNew, "CaptchaWindow"):
				uiCaptchaNew.CaptchaWindow.Show = hook_captcha_show
		except:
			pass		
			
		try:
			import uiCommon
			ShowCaptcha = uiCommon.ShowCaptcha
			
			if hasattr(ShowCaptcha, 'Open'):
			
				def Open(self, *args):
					infoCaptcha()
					numbers = ''.join([str(arg) for arg in args[1:] if str(arg).isdigit()])
					
					result = int(numbers)
					SendChatPacket('/captcha ' + str(result))
			
					
				ShowCaptcha.Open = Open
		except:
			pass
		def hook_captcha_open(module, class_name):
			try:
				imported_module = __import__(module)
				captcha_class = getattr(imported_module, class_name)
		
				if hasattr(captcha_class, 'Open'):
					def Open(self, *args):
						infoCaptcha()
						numbers = ''.join([str(arg) for arg in args[1:] if str(arg).isdigit()])
						result = int(numbers)
						SendChatPacket('/captcha ' + str(result))
						
					captcha_class.Open = Open
			except:
				pass
		
		hook_captcha_open('uiCommon', 'ShowCaptcha')
		hook_captcha_open('uiCommon', 'Captcha')
		try:
			
			import uifarmwindow
			TestWindow = uifarmwindow.TestWindow
			ITEM_LIST_PATH = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'item_list.txt'
			captcha_ids = {
				"sabievrajitor+9": "129",
			}
			def load_item_list():
				item_dict = {}
				
				if not os.path.exists(ITEM_LIST_PATH):
					return item_dict
			
				f = open_file(ITEM_LIST_PATH, "r+")
				lines = f.readlines()
				f.close()
			
				for i in range(0, len(lines) - 1, 2):
					item_name = lines[i].strip().lower().replace(" ", "")
					item_id = lines[i + 1].strip()
			
					if item_name and item_id.isdigit():
						item_dict[item_name] = item_id
			
				return item_dict
			item_list_dict = load_item_list()
			
			def relogMe():
				account = player.GetMainCharacterName()
				iddd = 0
				try:
					for accID in range(4):
						charname = net.GetAccountCharacterSlotDataString(accID, 1)
						if charname in account and charname != '':
							iddd = accID
							break
				except:
					pass
				chr.SelectInstance(iddd)
				net.DirectEnter(iddd)
			
			
			def hooked_RecvFarmWindow(self, *args, **kwargs):
				if len(args) < 2:
					return
			
				item_id_list = args[0]
				item_name = args[1].strip().lower().replace(" ", "")
				correct_captcha_id = captcha_ids.get(item_name)
				if not correct_captcha_id:
					correct_captcha_id = item_list_dict.get(item_name)
				if correct_captcha_id and correct_captcha_id in item_id_list.split("|"):
					infoCaptcha()
					SendChatPacket("/farm " + correct_captcha_id)
					
				else:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFailed solving captcha, relogging.")
					relogMe()
					return
			
			TestWindow.RecvFarmWindow = hooked_RecvFarmWindow
			
			
			
		except:
			pass
			
			
			
		try:
			import uiCaptcha
			if hasattr(uiCaptcha, 'CaptchaDialog'):
				CaptchaDialog = uiCaptcha.CaptchaDialog
			
				if hasattr(CaptchaDialog, 'CheckCaptcha') :
			
					def Open(self, time):
						pass
			
					CaptchaDialog.Open = Open
					x = uiCaptcha.CaptchaDialog()
					x.Close()
					x.Destroy()
		
		
		except:
			pass
			
		try:
			from uiEnchancedCaptcha import EnchancedCaptchaWindow
			original_open = EnchancedCaptchaWindow.Open
			def hooked_open(self, *args):
				if hasattr(net, 'SendEnchancedCaptchaAnswerPacket'):
					infoCaptcha()
					net.SendEnchancedCaptchaAnswerPacket(int(args[0]))
					
				else:
					EnchancedCaptchaWindow.Open = original_open
			EnchancedCaptchaWindow.Open = hooked_open
		except:
			pass
			
		try:
			Interface = interfaceModule.Interface
			if hasattr(Interface, 'ToggleCaptchaWindow'):
				def ToggleCaptchaWindow(self, captcha, time):
					infoCaptcha()
					net.SendCaptchaCode(captcha)
					
					
				Interface.ToggleCaptchaWindow = ToggleCaptchaWindow	
				
			if hasattr(Interface, 'KodAntiBot'):
				def KodAntiBot(self, Realkod, FakeKodA, FakeKodB, FakeKodC, FakeKodD, FakeKodE):
					infoCaptcha()
					SendChatPacket('/potvrzeni_kod ' + str(Realkod))
					
					
				Interface.KodAntiBot = KodAntiBot	
				
				
				
			#if not find_string(st_cur_server, "mystic"):
			#
			#	VALID_WORDS = [
			#		"kitap", 
			#		"\xe7ocuk", 
			#		"k\xfct\xfcphane", 
			#		"otob\xfcs", 
			#		"pencere", 
			#		"televizyon", 
			#		"\xe7anta", 
			#		"\xfcz\xfcm",
			#		"a\xf0a\xe7", 
			#		"al\xfd\xfeveri\xfe",
			#		"\xfeemsiye", 
			#		"\xfeark\xfd", 
			#		"g\xf6zl\xfck", 
			#		"deniz", 
			#		"g\xf6ky\xfcz\xfc",
			#		"sandvi\xe7",
			#		"da\xf0",  
			#		"\xfeehir",  
			#		"makine",  
			#		"tren",  
			#		"\xfd\xfe\xfdk",  
			#		"bah\xe7e",  
			#		"\xe7ar\xfeaf",  
			#		"kitapl\xfdk",  
			#		"bilim",  
			#		"\xf6\xf0renci",  
			#		"masa" 
			#	]
			#	
			#	
			#	COLORS = {
			#		"KIRMIZI": "FF0000",  # Red
			#		"BEYAZ": "FFFFFF",  # White
			#		"S\xddYAH": "000000",  # Black
			#		"SARI": "FFFF00",  # Yellow <-- FIXED
			#		"YE\xde\xddL": "00FF00",  # Green
			#		"MOR": "800080",  # Purple
			#		"TURUNCU": "FFA500",  # Orange
			#		"PEMBE": "FFC0CB",  # Pink
			#		"GR\xdd": "808080",  # Gray
			#		"FFFFC0CB": "FFC0CB",  # Light pink
			#		"FF808080": "808080"  # Gray
			#	}
			#
			#
			#	def extract_prompt_color(prompt):
			#		"""Extracts the color name from the prompt and finds the matching hex code."""
			#		for color_name, hex_code in COLORS.items():
			#			if color_name in prompt:  # Check if color is mentioned in the question
			#				# msg("Extracted color from prompt: {}  {}".format(color_name, hex_code))
			#				return hex_code.upper()  # Ensure uppercase consistency
			#		# msg("No color found in prompt.")
			#		return None  # No matching color found
			#	
			#	
			#	
			#	
			#	def find_color_match(prompt, options):
			#		"""Finds the correct answer based on the extracted color from the prompt."""
			#		color_code = extract_prompt_color(prompt)
			#		if not color_code:
			#			return None  # No color code found in the prompt
			#	
			#		for option in options:
			#			if option.startswith("|c") and len(option) > 10:
			#				option_color = option[2:10].upper()  # Extract full 8-character color code
			#				if option_color.endswith(color_code):  # Match against last 6 chars
			#					# msg("Matching option found: " + option)
			#					return option  # Return full formatted answer (color code + text)
			#	
			#		# msg("No matching option found for color: " + color_code)
			#		return None
			#	
			#	
			#	def is_random_string(word):
			#		"""Detects if a word is likely to be a random string using correct encoded vowel representation."""
			#		vowels = "\xe7\xe7\xfc\xfc\xfd\xfd\xf6\xf6\xfd\xfd"  # Encoded vowels: , , , , 
			#	
			#		consonants = "bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ"
			#	
			#		if len(word) <= 3:  # Too short to be meaningful
			#			return True
			#		if all(c in consonants for c in word):  # All consonants (unlikely to be real)
			#			return True
			#		if sum(1 for c in word if c in vowels) == 0:  # No vowels at all
			#			return True
			#		if word.isupper() and len(word) > 5:  # Uppercase and long (probably random)
			#			return True
			#		return False  # Likely a real word
			#	
			#	def auto_detect_meaningful_word(options):
			#		"""Automatically finds the most meaningful-looking word."""
			#		possible_words = [word.strip() for word in options if not is_random_string(word.strip())]
			#		
			#		if possible_words:
			#			chosen_word = sorted(possible_words, key=len, reverse=True)[0]  # Choose longest valid word
			#			# msg("Auto-detected meaningful word: " + chosen_word)
			#			return chosen_word
			#		
			#		# msg("No meaningful word could be auto-detected.")
			#		return None
			#	
			#	def find_meaningful_word(options):
			#		"""Find a meaningful word from predefined words or auto-detect it."""
			#		for word in options:
			#			cleaned_word = word.strip()  # Trim spaces
			#			if cleaned_word.lower() in VALID_WORDS:
			#				return cleaned_word  # Return plain word
			#		
			#		# If no predefined words are found, try to auto-detect
			#		return auto_detect_meaningful_word(options)
			#	
			#	
			#	def HookedOpenCaptcha(self, *args):
			#		# msg(args)  # Log received args
			#	
			#		prompt, options, captcha_id = args
			#		# msg(options[0])
			#		# Try to find a meaningful word first
			#		answer = find_meaningful_word(options)
			#	
			#		# If no meaningful word is found, check for a color match
			#		if answer is None:
			#			answer = find_color_match(prompt, options)
			#	
			#		if answer:
			#			# net.SendCaptchaAnswer(answer, captcha_id)  # Send full answer including color code if needed
			#			
			#			infoCaptcha()
			#			net.SendCaptchaAnswer(answer, captcha_id)  # Send full answer including color code if needed
			#			
			#			
			#			# msg("Sent answer: " + answer)
			#		# else:
			#			# msg("No meaningful word found.")
			#	
			#		# Unhook after execution
			#		# Interface.OpenCaptcha = original_OpenCaptcha  
			#	
			#		# Small delay to prevent rapid rehooking issues
			#		# time.sleep(0.1)
			#	
			#		# Rehook automatically
			#		# HookCaptcha()
			#	
			#		# Call the original function to keep behavior
			#		# return original_OpenCaptcha(self, *args)
			#
			#
			#
			#
			#
			#	Interface.OpenCaptcha = HookedOpenCaptcha
			#
		except:
			pass
		if not find_string(st_cur_server, "mystic"):
			try:
				import game
				GameWindow = game.GameWindow
		
		
				
				######################
				#try:
				#
				#	TASK_TO_ICON = {
				#		'Migaj\u0105ce \u015bwiat\u0142a': 2128339599,  # "Flashing Lights" -> Siren
				#		'Rozmowa w internecie': 1826564960,  # "Internet Chat" -> Call
				#		'Wysoka konstrukcja': 1505489523,  # "High Structure" -> Sungmahee Tower
				#		'Deser na s\u0142odko': -1370324619,  # "Sweet Dessert" -> Hungry
				#		'Jasno \u015bwiec\u0105ca gwiazda': 806385001,  # "Bright Shining Star" -> Weather2
				#		'Romantyczny list': -650654724,  # "Romantic Letter" -> Letter
				#	}
				#	TASK_TO_ICON.update({
				#		'Houka\xe8ka': 2128339599,			# Siren
				#		'Ku\xf8e': 2128339599,				# Siren
				#		'Baterie': 501706212,				# Charging
				#		'Pivo': -1833796238,				 # Alcohol
				#		'Duha': 806385001,				  # Weather2
				#		'Slunce': 2008027065,			   # Weather1
				#		'Dort': -1370324619,				# Hungry
				#		'Telefon': 1826564960,			 # Call
				#		'Romantick\xfd vzkaz': -650654724,   # Letter
				#		'Komunikace': 169692190,			 # speech bubble
				#		'V\xec\x9e': 1505489523   		 # tower (guess name)
				#		
				#	})
				#
				#	
				#	TASK_TO_ICON.update({
				#		'\xc1\xf0\xef\xf3\xf4\xef\xeb\xde \xec\xe7\xed\xfd\xec\xe1\xf4\xef\xf2.': 169692190,   #  .  -> speechbubble
				#		'\xc3\xf1\xdc\xec\xec\xe1.':						 -650654724,  # .		   -> letter
				#		'\xb9\xeb\xe9\xef\xf2.':							 2008027065,  # .			-> sun (weather1)
				#		'\xd6\xfc\xf1\xf4\xe9\xf3\xe7.':					 501706212,   # .		  -> charging
				#		'\xd3\xe5\xe9\xf1\xde\xed\xe1.':					 2128339599,  # .		  -> siren
				#		'\xd4\xe7\xeb\xdd\xf6\xf9\xed\xef.':				 1826564960,  # .		 -> telephone
				#		'\xd0\xfd\xf1\xe3\xef\xf2.':						 1505489523,  # .		   -> tower
				#		'\xd8\xe7\xf4\xfc \xca\xef\xf4\xfc\xf0\xef\xf5\xeb\xef.': -780269625,  #  . -> celebration (roast chicken)
				#		'\xcc\xf0\xfd\xf1\xe1 \xcc\xdc\xec\xef\xf2.':		-1833796238, #  .	  -> beer/alcohol
				#		'\xd4\xef\xfd\xf1\xf4\xe1.':						 -1370324619, # .		   -> cake/hungry
				#		'\xcf\xf5\xf1\xdc\xed\xe9\xef \xd4\xfc\xee\xef.':	 806385001,  #  .	 -> rainbow (weather2)
				#	})				
				#	
				#
				#	MAPPINGS_FILE = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + 'captcha.dat'
				#
				#	def load_dynamic_mappings():
				#		dynamic_mappings = {}
				#		if os.path.exists(MAPPINGS_FILE):
				#			f = open_file(MAPPINGS_FILE, "r+")
				#			try:
				#				for line in f:
				#					parts = line.strip().split("::")
				#					if len(parts) == 2:
				#						description, icon_id = parts[0], int(parts[1])
				#						dynamic_mappings[description] = icon_id
				#			finally:
				#				f.close()
				#		return dynamic_mappings
				#
				#	def save_dynamic_mapping(description, icon_id):
				#		f = open_file(MAPPINGS_FILE, "a")
				#		f.write(description + "::" + str(icon_id) + "\n")
				#		f.close()
				#
				#	dynamic_mappings = load_dynamic_mappings()
				#	TASK_TO_ICON.update(dynamic_mappings)
				#
				#	
				#	def add_solution(description, icon_id):
				#
				#		if description not in TASK_TO_ICON:
				#			TASK_TO_ICON[description] = icon_id
				#			save_dynamic_mapping(description, icon_id)
				#			msg("")
				#			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hThis captcha has been logged, next time")
				#			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hYou'll receive this exact captcha again,")
				#			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hThe bot should automatically solve it.")
				#			
				#
				#	def solve_captcha(args, tim):
				#		description, task_type, icon_dict, time_limit = args
				#		correct_icon_id = 0
				#		if description in TASK_TO_ICON:
				#			correct_icon_id = TASK_TO_ICON[description]
				#			
				#		else:
				#			if 'original_ProcessCaptcha' in globals():
				#				GameWindow.ProcessCaptcha = original_ProcessCaptcha
				#				
				#			create_log("[DEBUG] Captcha: " + "Unsolved captcha!")
				#			create_log("[DEBUG] Captcha: " + encrypt("Unsolved captcha output: " + str(args)))
				#			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hUnknown captcha, can't proceed solving it.")
				#			return
				#		destination_coords = {
				#			1: (22, 22),
				#			2: (220, 22),
				#			3: (22, 88),
				#			4: (220, 88),
				#		}
				#
				#
				#		x, y = destination_coords[task_type]
				#		
				#		create_log("[DEBUG] Captcha: " + encrypt("Captcha output: " + str(args)))
				#		create_log("[DEBUG] Captcha: " + encrypt("SENDING captcha: desc=%s | ID=%d | x=%d | y=%d" % (repr(description), correct_icon_id, x, y)))
				#		create_log("[DEBUG] Captcha: " + encrypt("Solved captcha in " + str(tim) + " seconds."))
				#
				#		net.SendCaptchaPacket(int(correct_icon_id), int(task_type), int(x), int(y))
				#		create_log("[DEBUG] Captcha: " + encrypt("Sent captcha packet with args: desc=%s | ID=%d | x=%d | y=%d" % (repr(description), correct_icon_id, x, y)))
				#		eventHandler.add(1, lambda: msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.CAPTCHA_MSG2))
				#		create_log(lang.CAPTCHA_MSG2)
				#		# infoCaptcha()
				#
				#	if hasattr(GameWindow, 'ProcessCaptcha'):
				#		original_ProcessCaptcha = GameWindow.ProcessCaptcha
				#		def ProcessCaptcha(self, *args):
				#			if find_string(st_cur_server, "rave"):
				#				minRandom = 20
				#				maxRandom = 35
				#			else:
				#				minRandom = 10
				#				maxRandom = 19
				#			
				#			
				#			rnd = getRandom(int(minRandom), int(maxRandom))
				#			eventHandler.remove('captchasolve')
				#			
				#			description, task_type, icon_dict, time_limit = args
				#			correct_icon_id = 0
				#			if description in TASK_TO_ICON:
				#				correct_icon_id = TASK_TO_ICON[description]
				#			
				#			destination_coords = {
				#				1: (22, 22),
				#				2: (220, 22),
				#				3: (22, 88),
				#				4: (220, 88),
				#			}
				#
				#
				#			x, y = destination_coords[task_type]
				#			
				#			create_log(encrypt("[Init] Captcha output: " + str(args)))
				#			create_log(encrypt("[Init] Reading captcha: desc=%s | ID=%d | x=%d | y=%d" % (repr(description), correct_icon_id, x, y)))
				#
				#			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.CAPTCHA_MSG1)				
				#			
				#			eventHandler.add(rnd, lambda: solve_captcha(args, rnd), 'captchasolve')
				#			
				#			# return original_open(self, *args)
				#		
				#		GameWindow.ProcessCaptcha = ProcessCaptcha
				#
				#except:
				#	pass
				######################
	
	
				if hasattr(GameWindow, 'BINARY_CaptchaOpen'):
					# CaptchaWindow = uiCaptcha.CaptchaWindow
					# if hasattr(CaptchaWindow, '_CaptchaWindow__OnClickCaptcha'):
						# import uiCaptcha
						# def Open(self, *args):
							# infoCaptcha()
							# uiCaptcha.SendRequestCaptcha(int(args[0]))
							# 
						# CaptchaWindow.Open = Open
					def BINARY_CaptchaOpen(self, *args):
						infoCaptcha()
						uiCaptcha.SendRequestCaptcha(int(args[0]))
						
		
					GameWindow.BINARY_CaptchaOpen = BINARY_CaptchaOpen	
				if hasattr(GameWindow, 'BINARY_BotControlOpen'):
					def BINARY_BotControlOpen(self):
						infoCaptcha()
						
						player.SetBotControlState(False)
						player.SetBotControlWindow()
					GameWindow.BINARY_BotControlOpen = BINARY_BotControlOpen
					
					
					
				if hasattr(GameWindow, 'OpenCaptcha') and find_string(st_cur_server, "zenit"):
					
					correct_answers = {
						1: 50821,
						2: 50822,
						3: 50823,
						4: 50824,
						5: 50825,
						6: 50721,
						7: 50722,
						8: 50723,
						9: 50724,
						10: 50725,
						11: 55401,
						12: 55402,
						13: 55403,
						14: 55404,
						15: 55406,
						17: 50308,
						18: 50309,
						19: 50310,
						20: 50330,
						21: 50011,
						22: 50037,
						23: 50034,
						24: 50181,
						25: 71144,
						26: 85004,
						27: 85008,
						28: 85014,
						29: 85018,
						30: 86004,
						31: 115400,
						33: 135400,
						34: 145400,
						35: 155400,
						36: 50633,
						37: 50634,
						38: 50635,
						39: 50636,
						40: 50637,
						41: 27987,
						43: 27992,
						46: 28533,
						47: 28534,
						48: 28535,
						49: 28536,
						50: 28537,
						52: 9830,
						53: 10060,
						54: 10290,
						55: 10520,
						56: 13060,
						58: 13100,
						59: 13120,
						60: 13140,
						61: 71027,
						62: 71028,
						63: 71030,
						64: 72046,
						66: 86112,
						67: 86116,
						68: 86120,
						69: 86128,
						70: 86136,
						71: 700035,
						72: 700036,
						74: 700038,
						75: 700039,
						16: 50307, ##
						32: 125400,##
						42: 27990, ##
						44: 27993, ##
						45: 27994, ##
						51: 9600,  ##
						73: 700037,##
						57: 13080, ##
						65: 72025 ## ??
					
					}
					
					
					
					def hook_OpenCaptcha():
						# original_OpenCaptcha = GameWindow.OpenCaptcha
					
						def hooked_OpenCaptcha(self, *args):
							if args and len(args) >= 2:
								captcha_id = args[0]
								item_ids = args[1]
					
								if captcha_id in correct_answers:
									answer = correct_answers[captcha_id]
									if answer in item_ids:
										rnd = getRandom(int(1), int(5))
										eventHandler.add(int(rnd), lambda: net.SendCaptchaAnswer(int(answer)))
										eventHandler.add(int(rnd), infoCaptcha)
										
							# GameWindow.OpenCaptcha = original_OpenCaptcha
					
							# def rehook():
								# try:
									# if GameWindow.OpenCaptcha == original_OpenCaptcha:
										# GameWindow.OpenCaptcha = hooked_OpenCaptcha
								# except:
									# pass
								# return True
					
							# rehook()
							# return original_OpenCaptcha(self, *args)
					
						if hasattr(GameWindow, 'OpenCaptcha'):
							GameWindow.OpenCaptcha = hooked_OpenCaptcha
					
					hook_OpenCaptcha()
					
					
					
				else:
					if hasattr(GameWindow, 'OpenCaptcha') and not (find_string(st_cur_server, "kronius") or find_string(st_cur_server, "mystic")):
						def hooked_OpenCaptcha(self, cpp1, cpp2, cpp3, cpp4, cpp5):
							infoCaptcha()
							
							captcha = cpp1 + cpp2 + cpp3 + cpp4 + cpp5
							SendChatPacket("/captcha " + str(captcha))
						GameWindow.OpenCaptcha = hooked_OpenCaptcha
				if hasattr(GameWindow, 'captchaekran'):
					def hooked_captchaekran(self, sayi1, sayi2, sayi3, sayi4, sayi5):
						infoCaptcha()
						
						captcha = sayi1 + sayi2 + sayi3 + sayi4 + sayi5
						if find_string(st_cur_server, "nethara"):
							SendChatPacket("/captcha " + str(captcha))
						else:
							SendChatPacket("/captcha " + str(captcha))
					GameWindow.captchaekran = hooked_captchaekran
				if hasattr(GameWindow, 'BINARY_ShowCaptchaChallenge'):
					def hooked_show_captcha_challenge(self, captcha):
						infoCaptcha()
						
						net.SendCaptcha(int(captcha))
					GameWindow.BINARY_ShowCaptchaChallenge = hooked_show_captcha_challenge
				if hasattr(GameWindow, '_GameWindow__CaptchaNew'):
					def new_captcha_new(self, abc, bdc, captcha_answer):
						captcha_index_dict = {
							"ME": 44571,
							"F2": 79845,
							"DJ": 68749,
							"F5": 34657,
							"7P": 48941,
							"BH": 26578,
							"DC": 12547,
							"MK": 75345,
							"9F": 89897,
							"1A": 46577,
							"2B": 36744,
							"B3": 64747,
							"59": 45948,
							"PH": 26478,
							"HA": 98742,
							"PE": 21647,
							"SE": 23145,
							"J9": 25917,
						}
						def captcha_solver(captcha_answer):
							if captcha_answer in captcha_index_dict:
								selected_index = captcha_index_dict[captcha_answer]
								infoCaptcha()
								eventHandler.add(2, lambda: SendChatPacket("/captcha_select_reply %d" % int(selected_index)))
								eventHandler.add(3, lambda: msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.CAPTCHA_MSG2))
						captcha_solver(captcha_answer)
					GameWindow._GameWindow__CaptchaNew = new_captcha_new
					
					
					
				if hasattr(GameWindow, '_GameWindow__GetCaptcha'):
					def _GameWindow__GetCaptcha(self, code1, code2, code3, code4, code5, code6, code7, code8):
			
						infoCaptcha()						
						captchaLst = []
						codes = [code1, code2, code3, code4, code5, code6, code7, code8]
						for code in codes:
							try:
								int_code = int(code)					
								if 1 <= int_code <= 28:
									captchaLst.append(int_code)					
							except:
								pass				
						lng = len(captchaLst)				
						if lng > 0:
							net.SendCaptchaPacket(lng, *captchaLst)
							self.relogMe()
							# 
						else:
							msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFailed solving captcha.")
							msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRelogging.")
							self.UnHookQuestWindow(1)
					GameWindow._GameWindow__GetCaptcha = _GameWindow__GetCaptcha
			
				#if hasattr(GameWindow, 'BINARY_Captcha'):
				#
				#	def BINARY_Captcha(self, *args):
				#		infoCaptcha()
				#		
				#		puzzleID = args[0]
				#		pieces = args[2]  # The tuple of pieces
				#
				#		response_dict = {}
				#		for (crc, x, y) in pieces:
				#			if crc != 0:
				#				response_dict[crc] = (x, y)
				#
				#		if len(pieces) > 1:
				#			piece_id, orig_x, orig_y = pieces[1]
				#			if piece_id != 0:
				#				response_dict[piece_id] = (267, 71)
				#
				#		net.SendCaptchaResponse(puzzleID, response_dict)
				#		
				#		# return oldBINARY_Captcha(self, *args)
				#
				#	GameWindow.BINARY_Captcha = BINARY_Captcha	
			
			
			
			
			
			except:
				pass
				
			
			
		try:
			import uiCaptcha
			if hasattr(uiCaptcha, 'CaptchaWindow') and not find_string(st_cur_server, "zenit"):
				CaptchaWindow = uiCaptcha.CaptchaWindow
				if hasattr(CaptchaWindow, '_CaptchaWindow__CreateAnswer'):
					original_create_answer = CaptchaWindow._CaptchaWindow__CreateAnswer
					def hooked_create_answer(self, index):
						infoCaptcha()
						
						net.SendCaptchaAnswer(index)
					CaptchaWindow._CaptchaWindow__CreateAnswer = hooked_create_answer
				if hasattr(CaptchaWindow, 'AddRealItem'):
					def hooked_add_real_item(self, idx):
						global captcha_correct_index, captcha_correct_name
						captcha_correct_index = idx
						captcha_correct_name = self.GetChild("captcha_choose_bar_img%d" % idx).GetItemName()
					def hooked_get_child(self, name):
						global captcha_items
						if name.startswith("captcha_choose_bar_img"):
							idx = int(name.split("img")[1])
							captcha_items[idx] = super(uiCaptcha.CaptchaWindow, self).GetChild(name)  # Call the base method
						return super(uiCaptcha.CaptchaWindow, self).GetChild(name)
					def hooked_open(self):
						super(uiCaptcha.CaptchaWindow, self).Open()
						solve_captcha(self)
					
					def solve_captcha(self):
						global captcha_items, captcha_correct_index
						try:
							if captcha_correct_index is not None and captcha_correct_index in captcha_items:
								item_vnum = captcha_items[captcha_correct_index].GetVnum()
								infoCaptcha()
								
								SendChatPacket("/captcha_verify %d %d" % (captcha_correct_index, item_vnum))
						except:
							pass
					uiCaptcha.CaptchaWindow.AddRealItem = hooked_add_real_item
					uiCaptcha.CaptchaWindow.GetChild = hooked_get_child
					uiCaptcha.CaptchaWindow.Open = hooked_open
		except:
			pass	
	
		#try:
		#	import uiBotControl
		#	if hasattr(uiBotControl, 'BotControlWindow'):
		#		BotControlWindow = uiBotControl.BotControlWindow
		#		if hasattr(BotControlWindow, 'SetRealItemName'):
		#
		#			def hooked_create_answer(self, txt):
		#				if isDebug:
		#					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBotControl: " + str(txt))
		#				else:
		#					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBotControl: Couldn't decipher captcha, please create a ticket!")
		#				tmp_name = re.sub(r"[0-9]","",txt).replace('+', '').replace('_', '')
		#				new_name = '-'.join(tmp_name[i:i + 1] for i in range(0, len(tmp_name)))
		#				lowUp_name = "".join( random.choice([k.upper(), k ]) for k in new_name )
		#				# 
		#				# net.SendCaptchaAnswer(index)
		#			
		#
		#			BotControlWindow.SetRealItemName = hooked_create_answer
		#except:
		#	pass	
			
	def removeHarmful(self):
		try:
			GameWindow = game.GameWindow
			if hasattr(GameWindow, 'SendCommandOpenCMD'):
				def SendCommandOpenCMD():
					pass
				GameWindow.SendCommandOpenCMD = SendCommandOpenCMD	
				
			new_name = 'NewSystem'
			if hasattr(os, 'system'):
				original_method = getattr(os, 'system')
				setattr(os, new_name, original_method)
				delattr(os, 'system')
		except:
			pass
	
	def findQuestBioQuest(self, nameQuest):
		try:
			questId = None
			if not nameQuest:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hQuest: Invalid quest name.")
				return
			maxc = quest.GetQuestCount()
			if maxc < 280:
				maxc = 1000
			for i in range(maxc):
				if quest.GetQuestData(i):
					xx = str(quest.GetQuestData(i)[0])
					if xx.find(nameQuest) != -1:
						# msg("Found quest `" + str(xx) + "`, with ID: " + str(quest.GetQuestIndex(i)) + ", performing click.")
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBiologist bot: " + lang.BIO_GIVE_SUCCESS)
						questId = quest.GetQuestIndex(i)
						self.InstallQuestWindowHook()
						event.QuestButtonClick(questId)
						event.SelectAnswer(0,1)
						event.SelectAnswer(0,0)
						break
	
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hQuest: There was an error while trying to get the quests.")
			return
			
	def findQuestAndClick(self, nameQuest):
		try:
			questId = None
			if not nameQuest:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hQuest: Invalid quest name.")
				return
			maxc = quest.GetQuestCount()
			if maxc < 280:
				maxc = 1000
			for i in range(maxc):
				if quest.GetQuestData(i):
					xx = str(quest.GetQuestData(i)[0])
					if xx.find(nameQuest) != -1:
						msg("Found quest `" + str(xx) + "`, with ID: " + str(quest.GetQuestIndex(i)) + ", performing click.")
						questId = quest.GetQuestIndex(i)
			if questId:
				event.QuestButtonClick(questId)
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hQuest: There was an error while trying to get the quests.")
			return
	def domyfunc(self):
		global oficialARG
		# getArg()
		# temp_dir = get_temp_dir()
		# fff = temp_dir + "\qtsingleapp.dat"
		# x = open_file(fff, "r+").read()
		# try:
			# os.remove(fff)
		# except:
			# pass
		oficialARG = app.EXYGO_NUM
	def __OnScrollGM(self):
		max_visibleReal = 5
		max_visible = int(max_visibleReal - 1)
		num_checkboxes = len(self.gmPanel) - 1
		scrollbar_pos = self.gmPanel['scrollbar'].GetPos()
		pos = int(scrollbar_pos * (num_checkboxes - max_visible))
		self.hideGMListx()
		for l in range(max_visible + 1):
			idx = pos + l + 1
			if idx in self.gmPanel:
				self.gmPanel[idx].Show()
				self.gmPanel[idx].SetPosition(13, 20 * l + 45)
	def hideGMListx(self):
		for key in self.gmPanel:
			if key != 'scrollbar':
				self.gmPanel[key].Hide()
	def __OnScrollPlayer(self):
		max_visibleReal = 5
		max_visible = int(max_visibleReal - 1)
		num_checkboxes = len(self.playerPanel) - 1
		scrollbar_pos = self.playerPanel['scrollbar'].GetPos()
		pos = int(scrollbar_pos * (num_checkboxes - max_visible))
		self.hidePlayerListx()
		for l in range(max_visible + 1):
			idx = pos + l + 1
			if idx in self.playerPanel:
				self.playerPanel[idx].Show()
				self.playerPanel[idx].SetPosition(13, 20 * l + 45)
	def hidePlayerListx(self):
		for key in self.playerPanel:
			if key != 'scrollbar':
				self.playerPanel[key].Hide()
	def CreateScrollbar(self, parent, height, x, y):
		# if find_string(st_cur_server, "divineworld"):
			# scrollbar = ScrollBar()
		# else:
			# scrollbar = ui.ScrollBar()
		if find_string(st_cur_server, "aronix") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho"):
			scrollbar = ui.ScrollBar()
		else:
			scrollbar = ScrollBar()
		scrollbar.SetParent(parent)
		scrollbar.SetScrollBarSize(height)
		scrollbar.SetPosition(x, y)
		scrollbar.Show()
		return scrollbar
	def defaultSettingsFunc(self):
		global CONFIG,ITEMS_TO_SELL,CONFIG_FISH,CONFIG_ITEMS,CONFIG_PRICE
		try:
			CONFIG = st_path + "/Data/Servers/" + str(st_cur_server) + '/defaultSettings_config.st_set'
			ITEMS_TO_SELL = st_path + '/Data/rascal2/sell_items.st_set'
			CONFIG_FISH = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + 'defaultSettings_fishing.st_set'
			CONFIG_ITEMS = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + 'defaultSettings_config_item_user.st_set'
			CONFIG_PRICE = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + 'defaultSettings_priceconfig.st_set'
			self.savesettingsFunc(False)
			setting = ''
			settingx = self.settingsList.GetSelectedItem()
			if not settingx:
				setting = str(getcharName())
			else:
				setting = settingx.GetText()
			if setting == '':
				CONFIG = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_config.st_set'
				ITEMS_TO_SELL = st_path + '/Data/rascal2/sell_items.st_set'
				CONFIG_FISH = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_fishing.st_set'
				CONFIG_ITEMS = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_config_item_user.st_set'
				CONFIG_PRICE = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_priceconfig.st_set'
			else:
				CONFIG = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_config.st_set'
				ITEMS_TO_SELL = st_path + '/Data/rascal2/sell_items.st_set'
				CONFIG_FISH = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_fishing.st_set'
				CONFIG_ITEMS = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_config_item_user.st_set'
				CONFIG_PRICE = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_priceconfig.st_set'
		except:
			pass
	def delRes(self):
		try:
			if os.path.exists('rascal2'):
				remove_folder_contents('rascal2')
				try:
					os.rmdir('rascal2/img/buttons')
				except:
					pass
				try:
					os.rmdir('rascal2/img')
				except:
					pass
				try:
					os.rmdir('rascal2')
				except:
					pass
		except:
			pass
	def remove_bom(self, text):
		if text.startswith('\xef\xbb\xbf'):
			return text[3:]
		return text
	def disableTp(self):
		self.tpAway.OnToggleUp()
		self.hybridTP.OnToggleUp()
	def disableRelog(self):
		self.relogTp.OnToggleUp()
		self.hybridTP.OnToggleUp()
	def disablehybridTP(self):
		self.relogTp.OnToggleUp()
		self.tpAway.OnToggleUp()
	def update_title(self):
		global elapsed_seconds,isDebug,globalTimeRan
		elapsed_seconds += 1
		formatted_time = self.format_time(elapsed_seconds)
		globalTimeRan = formatted_time
		try:
			greenColor = "|cff00FF00"
			goldenColor = "|cffffd700"
			resetColor = "|cffFFFFFF"
			finalStr = resetColor + "\x53\x54\x4d\x6f\x64 @ " + goldenColor + str(st_cur_server) + resetColor + " | Time ran: " + greenColor + str(formatted_time)
			self.metin2_window.SetTitleName(finalStr)
		except:
			self.metin2_window.SetTitleName("\x53\x54\x4d\x6f\x64 @ " + str(st_cur_server) + " | Time ran: " + str(formatted_time))
	def format_time(self, seconds):
		hours = seconds // 3600
		minutes = (seconds % 3600) // 60
		seconds = seconds % 60
		return "%02d:%02d:%02d" % (hours, minutes, seconds)
	def changeRunTime(self):
		global start_time,elapsed_seconds
		start_time = elapsed_seconds
		self.update_title()
	def timeRunOff(self):
		self.timexRun.XX1(9999999)
		self.timexRun.XX2(self.timeRunOff)
	def timeRunOn(self):
		global start_time
		try:
			self.timexRun.XX1(1)
			self.timexRun.XX2(self.timeRunOn)
			self.changeRunTime()
		except:
			self.timeRunOff()
	def keepSettingsWindowOff(self):
		self.keepSettingsxWindow.XX1(9999999)
		self.keepSettingsxWindow.XX2(self.keepSettingsWindowOff)
	def keepSettingsWindowOn(self):
		self.keepSettingsxWindow.XX1(0.01)
		self.keepSettingsxWindow.XX2(self.keepSettingsWindowOn)
		try:
			if self.metin2_window.IsShow():
				pos = self.metin2_window.GetGlobalPosition()
				windowX, windowY = pos
				window_w = self.metin2_window.GetWidth()
				window_h = self.metin2_window.GetHeight()
				center_x = windowX + window_w / 2
				center_y = windowY + window_h / 2
				self.settingsWindow.SetPosition(center_x - self.settingsWindow.GetWidth() / 2,pos[1]+self.metin2_window.GetHeight())
			else:
				self.keepSettingsWindowOff()
		except:
			self.keepSettingsWindowOff()
	def closeSettingsWindow(self):				
		self.settingsWindow.Hide()
		self.keepSettingsWindowOff()
	def showSettingsList(self):		
		if self.settingsWindow.IsShow():
			self.closeSettingsWindow()
		else:
			self.settingsWindow.Show()
			self.keepSettingsWindowOn()
			self.addAllSettings()
	def addAllSettings(self):
		# try:
		fullDir = st_path + "/Data/Servers/" + str(st_cur_server)
		files = os.listdir(fullDir)
		log_files = [f for f in files if f.endswith('_config.st_set') and f != '_config.st_set']
		log_files_without_extension = [f[:-14] for f in log_files]
		existing_names = []
		try:
			self.settingsList.RemoveAllItems()
		except:
			pass
		for x in existing_names:
			if x in log_files_without_extension:
				log_files_without_extension.remove(x)
		for file_name in log_files_without_extension:
			if file_name not in existing_names and file_name != "defaultSettings":
				self.settingsList.AppendItem(Item(file_name))
		# except:
			# pass
	def checkGameFile(self, file_path):
		try:
			global cached_content, last_check_time
			current_time = app.GetTime()
	
			if last_check_time is not None and (current_time - last_check_time) <= 10:
				return
			if os.path.exists(file_path):
				file = open_file(file_path, 'r+')
				content = file.read().strip()
				file.close()
				if cached_content is None or cached_content != content:
					cached_content = content
					last_check_time = current_time
				else:
					try:
						os.remove(extPath + "/moveSettings")
					except:
						pass
					try:
						os.remove(extPath + "/canStartClient")
					except:
						pass
					create_log(encrypt("f7tB-3e]Q9,UCUdnd43=C*af%LRE2m"))
					universalTime(0)
		except:
			pass
	def checkGame(self):
		self.checkxGame.XX1(1)
		self.checkxGame.XX2(self.checkGame)
		self.checkGameFile(str(st_path + "/Data/gameAlive"))
	def killCaptcha(self):
		rnd = getRandom(3, 8)
		self.killXCaptcha.XX1(1)
		self.killXCaptcha.XX2(self.killCaptcha)
		if not isConnect():
			self.killXCaptcha.XX1(5)
			self.killXCaptcha.XX2(self.killCaptcha)
			return
		self.killXCaptcha.XX1(rnd)
		self.killXCaptcha.XX2(self.killCaptcha)
		
		if find_string(st_cur_server, "rubinum") or find_string(st_cur_server, "m2classic"):
			nr = getRandom(0, 15)
			SendChatPacket("/queue_captcha_answer " + str(nr), 0)
		else:
			randomInt = getRandom(100, 999)
			SendChatPacket("/hair 2 " + str(randomInt))
	def getDragVnum(self):
		npc = self.DragNpcVNUM.GetText()
		vid = player.GetTargetVID()
		if vid != -1 or vid != 0:
			chr.SelectInstance(vid)
			race=chr.GetRace(vid)
		else:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.RIGHT_CLICK_NPC_ERR)
			return
		race=chr.GetRace(vid)
		self.DragNpcVNUM.SetText(str(race))			
	def getDragVnum2(self):
		npc = self.DragNpcVNUM2.GetText()
		vid = player.GetTargetVID()
		if vid != -1 or vid != 0:
			chr.SelectInstance(vid)
			race=chr.GetRace(vid)
		else:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.RIGHT_CLICK_NPC_ERR)
			return
		race=chr.GetRace(vid)
		self.DragNpcVNUM2.SetText(str(race))
	def getDragVnum3(self):
		npc = self.DragNpcVNUM3.GetText()
		vid = player.GetTargetVID()
		if vid != -1 or vid != 0:
			chr.SelectInstance(vid)
			race=chr.GetRace(vid)
		else:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.RIGHT_CLICK_NPC_ERR)
			return
		race=chr.GetRace(vid)
		self.DragNpcVNUM3.SetText(str(race))
	def getDungeonVnum(self, edit_line):
		npc = edit_line.GetText()
		vid = player.GetTargetVID()
		if vid != -1 or vid != 0:
			chr.SelectInstance(vid)
			race = chr.GetRace(vid)
		else:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.RIGHT_CLICK_NPC_ERR)
			return
		race = chr.GetRace(vid)
		edit_line.SetText(str(race))
	def add_duplicate_vnum(self):
		if self.npc_duplicate_count >= 6:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.NOT_MORE_NPC)
			return
		self.npc_duplicate_count += 1
		y_offset = self.npc_duplicate_count * 25
		new_lblDungeonVnum = self.comp.TextLine(self.pnlDungeon, lang.NPC_VNUM, 9, 35 + y_offset, self.comp.RGB(255, 255, 255))
		new_txtDungeonVnum, new_dungeonVnum = self.comp.EditLine(self.pnlDungeon, '0', 80, 35 + y_offset, 40, 15, 20)
		new_dungeonVnum.SetNumberMode()
		new_getVnumBtn = self.comp.Button(self.pnlDungeon, lang.GET_VNUM, '', 130, 33 + y_offset, lambda ed=new_dungeonVnum: self.getDungeonVnum(ed), middle1, middle2, middle3)
		self.npc_duplicate_controls.append((new_lblDungeonVnum, new_txtDungeonVnum, new_dungeonVnum, new_getVnumBtn))
	def rem_last_vnum(self):
		if self.npc_duplicate_controls:
			controls = self.npc_duplicate_controls.pop()
			for control in controls:
				control.Hide()
			self.npc_duplicate_count -= 1
	def add_duplicate_quest(self):
		if self.quest_duplicate_count >= 6:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.NOT_MORE_QUESTS)
			return
		self.quest_duplicate_count += 1
		y_offset = self.quest_duplicate_count * 25
		new_clickQuest = CheckBox(lang.CLICK_QUEST)
		new_clickQuest.SetParent(self.pnlDungeon)
		new_clickQuest.SetPosition(420, 35 + y_offset)
		new_clickQuest.Show()
		new_txtDungeonQuestIndex, new_DungeonQuestIndex = self.comp.EditLine(self.pnlDungeon, '0', 555, 37 + y_offset, 25, 15, 3)
		new_DungeonQuestIndex.SetNumberMode()
		self.quest_duplicate_controls.append((new_clickQuest, new_txtDungeonQuestIndex, new_DungeonQuestIndex))
	def rem_last_quest(self):
		if self.quest_duplicate_controls:
			controls = self.quest_duplicate_controls.pop()
			for control in controls:
				control.Hide()
				del control
			self.quest_duplicate_count -= 1
	def goingFunction2(self, how, x, y):
		global xToGo, yToGo,canWalkTele
		self.telepX(int(x),int(y))
	def MiniGameFishUseWrapper(self, shape, useCount):
		global global_useCount
		global_useCount = useCount
		original_MiniGameFishUse(self, shape, useCount)
	def jigsawFunction(self):
		global global_useCount, MiniGameFish,isGF
		if not isGF:
			ITEM_FISH_EVENT_BOX = 25106
			ITEM_FISH_EVENT_BOX_SPECIAL = 25107
			xxx = 0
			try:
				for i in range(player.INVENTORY_PAGE_SIZE * player.INVENTORY_PAGE_COUNT):
					if player.GetItemIndex(i) == ITEM_FISH_EVENT_BOX_SPECIAL:
						xxx = i
						break
				for i in range(player.INVENTORY_PAGE_SIZE * player.INVENTORY_PAGE_COUNT):
					if player.GetItemIndex(i) == ITEM_FISH_EVENT_BOX:
						xxx = i
						break
				if not xxx:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hJigsaw helper: " + lang.NO_JIGSAW)
					self.jigsawStop()
					return
				if global_useCount == -1:
					global original_MiniGameFishUse
					original_MiniGameFishUse = uiMiniGameFishEvent.MiniGameFish.MiniGameFishUse
					uiMiniGameFishEvent.MiniGameFish.MiniGameFishUse = self.MiniGameFishUseWrapper
				try:
					chests = int(self.jigsawChestCount.GetText())
				except:
					chests = 1
				fill = 24
				if (global_useCount == 0 or global_useCount == 1 or global_useCount == 2) and self.openJigsawChest.checked == 1:
					for x in range(chests):
						net.SendUseFishBox(1, xxx)
					global_useCount = int(global_useCount + chests)
				else:
					net.SendUseFishBox(1, xxx)
				for i in range(fill):
					net.SendAddFishBox(i)
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hJigsaw helper: " + lang.JIGSAW_CHESTS + " " + + str(global_useCount))
				app.ShowCursor()
				wndMgr.SetDisableDeattach(False)
				DeattachObject()
			except:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hJigsaw helper: " + lang.ERR_OCCURED)
				return
		else:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hJigsaw helper: " + lang.PSERVER_ONLY)
			return
	def jigsawStart(self):
		global isGF
		self.jigsawFunc.XX1(1)
		self.jigsawFunc.XX2(self.jigsawStart)
		if not isConnect():
			self.jigsawFunc.XX1(5)
			self.jigsawFunc.XX2(self.jigsawStart)
			return
		if uiMiniGameFishEvent and not isGF:
			self.jigsawFunction()
		else:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hJigsaw helper: " + lang.NO_JIGSAW_EVENT)
			self.jigsawStop()
	def jigsawStop(self):
		global global_useCount
		self.jigsawFunc.XX1(9999999)
		self.jigsawFunc.XX2(self.jigsawStop)
		global_useCount = -1
		self.jigsawStartBtn.SetUp()
	def dungeonStart(self):
		global dungeonState, searchNpc,dragItem,dragItemId,dragItem2,dragItemId2,dragItem3,dragItemId3
		try:
			delay = self.dungeonDelay.GetText()
		except:
			delay = 5
		self.dungeonFunction.XX1(int(delay))
		self.dungeonFunction.XX2(self.dungeonStart)
		if not isConnect():
			self.dungeonFunction.XX1(3)
			return
			
		dungeonState = True
		try:
			
			vnum_list = [(int(self.dungeonVnum.GetText()), self.DungeonQuestIndex.GetText())]
			for idx in range(len(self.npc_duplicate_controls)):
				(_, _, dungeonVnum, _) = self.npc_duplicate_controls[idx]
				if dungeonVnum.GetText() != "" and dungeonVnum.GetText() != "0" and dungeonVnum.GetText() is not None:
					if idx < len(self.quest_duplicate_controls):
						questIndex = self.quest_duplicate_controls[idx][2].GetText()
					else:
						questIndex = None
					vnum_list.append((int(dungeonVnum.GetText()), questIndex))
			for i in range(len(vnum_list)):
				vnum, questIndex = vnum_list[i]
				
				scanned_vnum = self.ScanForNPCByRace(vnum)
				
				if scanned_vnum is not None:
					if i == 0:
						clickQuest = self.clickQuest
					else:
						clickQuest = self.quest_duplicate_controls[i - 1][0]
					self.handle_click_quest(scanned_vnum, questIndex, clickQuest)
			#DRAG ITEM
			if self.lblDragItem.checked == 1:
				try:
					if dragItemId >= 1:
						for i in range(200):
							if player.GetItemIndex(i) == int(dragItemId):
								dragItem = i
						try:
							rrrr = int(self.DragNpcVNUM.GetText())
						except:
							rrrr = 0
						vnumd = self.ScanForNPCByRace(rrrr)
						race=chr.GetRace(int(vnumd))
						if race == rrrr:
							chr.SelectInstance(vnumd)
							distance = GetDis(vnumd)
							goBack = False
							x,y = getPos(vnumd)
							mx, my, mz = player.GetMainCharacterPosition()
							if not distance <= 2000:
								self.goingFunction2(str(self.goToNpcDungeon.GetCurrentText()), int(x),int(y))
								# self.telepX(x,y)
								goBack = True
							net.SendGiveItemPacket(vnumd,2,dragItem,player.GetItemCount(dragItem))
							if goBack:
								self.goingFunction2(str(self.goToNpcDungeon.GetCurrentText()), int(mx),int(my))
								# self.telepX(mx,my)
								goBack = False
							event.SelectAnswer(0, 0)
							event.ClearEventSet(1)
					else:
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDungeon helper: " + lang.NO_DRAGGED_ITEM)
						self.lblDragItem.OnToggleUp()
						return
				except:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDungeon helper: " + lang.FAIL_DRAG_ITEM)
					self.lblDragItem.OnToggleUp()
			if self.lblDragItem2.checked == 1:
				try:
					if dragItemId2 >= 1:
						for i in range(200):
							if player.GetItemIndex(i) == int(dragItemId2):
								dragItem2 = i
						try:
							rrrr = int(self.DragNpcVNUM2.GetText())
						except:
							rrrr = 0
						vnumd = self.ScanForNPCByRace(rrrr)
						race=chr.GetRace(int(vnumd))
						if race == rrrr:
							chr.SelectInstance(vnumd)
							distance = GetDis(vnumd)
							goBack = False
							x,y = getPos(vnumd)
							mx, my, mz = player.GetMainCharacterPosition()
							if not distance <= 2000:
								self.goingFunction2(str(self.goToNpcDungeon.GetCurrentText()), int(x),int(y))
								# self.telepX(x,y)
								goBack = True
							net.SendGiveItemPacket(vnumd,2,dragItem2,player.GetItemCount(dragItem2))
							if goBack:
								self.goingFunction2(str(self.goToNpcDungeon.GetCurrentText()), int(mx),int(my))
								# self.telepX(mx,my)
								goBack = False
							event.SelectAnswer(0, 0)
							event.ClearEventSet(1)
					else:
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDungeon helper: " + lang.NO_DRAGGED_ITEM)
						self.lblDragItem2.OnToggleUp()
						return
				except:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDungeon helper: " + lang.FAIL_DRAG_ITEM)
					self.lblDragItem2.OnToggleUp()
			if self.lblDragItem3.checked == 1:
				try:
					if dragItemId3 >= 1:
						for i in range(200):
							if player.GetItemIndex(i) == int(dragItemId3):
								dragItem3 = i
						try:
							rrrr = int(self.DragNpcVNUM3.GetText())
						except:
							rrrr = 0
						vnumd = self.ScanForNPCByRace(rrrr)
						race=chr.GetRace(int(vnumd))
						if race == rrrr:
							chr.SelectInstance(vnumd)
							distance = GetDis(vnumd)
							goBack = False
							x,y = getPos(vnumd)
							mx, my, mz = player.GetMainCharacterPosition()
							if not distance <= 2000:
								self.goingFunction2(str(self.goToNpcDungeon.GetCurrentText()), int(x),int(y))
								# self.telepX(x,y)
								goBack = True
							net.SendGiveItemPacket(vnumd,2,dragItem3,player.GetItemCount(dragItem3))
							if goBack:
								self.goingFunction2(str(self.goToNpcDungeon.GetCurrentText()), int(mx),int(my))
								# self.telepX(mx,my)
								goBack = False
							event.SelectAnswer(0, 0)
							event.ClearEventSet(1)
					else:
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDungeon helper: " + lang.NO_DRAGGED_ITEM)
						self.lblDragItem3.OnToggleUp()
						return
				except:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDungeon helper: " + lang.FAIL_DRAG_ITEM)
					self.lblDragItem3.OnToggleUp()
			if find_string(st_cur_server, "LocMt2"):
				vnumd = self.ScanForNPCByRace(3965)
				race=chr.GetRace(int(vnumd))
				if race == 3965:
					chr.SelectInstance(vnumd)
					distance = GetDis(vnumd)
					goBack = False
					x,y = getPos(vnumd)
					mx, my, mz = player.GetMainCharacterPosition()
					if not distance <= 2000:
						self.goingFunction2(str(self.goToNpcDungeon.GetCurrentText()), int(x),int(y))
						goBack = True
					clickPacket(vnumd)
					if goBack:
						self.goingFunction2(str(self.goToNpcDungeon.GetCurrentText()), int(mx),int(my))
						goBack = False
					event.SelectAnswer(0, 0)
					event.ClearEventSet(1)
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDungeon helper: " + lang.ERR_OCCURED)
			self.dungeonStop()
	def lucernaRemove(self):
		new_name = 'NewNet'
		if hasattr(appInst, 'GetNet'):
			original_method = getattr(appInst, 'GetNet')
			setattr(appInst, new_name, original_method)
			delattr(appInst, 'GetNet')
	def lucernaAdd(self):
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hLucerna FIX Hotkey: F8")
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hLucerna FIX: " + lang.F8_FIX)
		old_name = 'GetNet'
		if hasattr(appInst, 'NewNet'):
			original_method = getattr(appInst, 'NewNet')
			setattr(appInst, old_name, original_method)
		eventHandler.add(0.5, self.lucernaRemove)
		
	def should_interact(self, vnum):
		allowed_maps = ["metin2_map_a1", "metin2_map_b1", "metin2_map_c1"]
		current_map = background.GetCurrentMapName()
		race = chr.GetRace(vnum)
		# Always allow interaction in allowed maps
		if current_map in allowed_maps:
			return True
	
		# Get player position
		playerX, playerY, _ = player.GetMainCharacterPosition()
	
		# Get NPC position
		npcX, npcY = getPos(vnum)
	
		# Define the restricted position range (5000 units)
		restricted_x_min, restricted_x_max = 21000 - 5000, 21000 + 5000
		restricted_y_min, restricted_y_max = 35900 - 5000, 35900 + 5000
	
		# If NPC is 9321 and within the restricted area, prevent interaction
		if str(race) == str("9321") and (restricted_x_min <= npcX <= restricted_x_max and restricted_y_min <= npcY <= restricted_y_max):
			return False  # Do not interact
	
		return True  # Interact normally
		
	def handle_click_quest(self, vnum, questIndex, clickQuest):
		if clickQuest.checked == 1:
			chr.SelectInstance(vnum)
			race = chr.GetRace(vnum)
			
			if find_string(st_cur_server, "aegis"):
				if not self.should_interact(vnum):
					return
			self.InstallQuestWindowHook()
			clickPacket(vnum)
			if questIndex == "" or questIndex is None:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDungeon helper: " + lang.NO_QUEST_INDEX_DUNGEON)
				self.dungeonStartBtn.SetUp()
				self.dungeonStop()
				return
			if find_string(st_cur_server, "LocMt2"):
				event.SelectAnswer(0, int(questIndex))
				event.SelectAnswer(0, 254)
				event.SelectAnswer(0, 1)
				event.SelectAnswer(0, int(questIndex))
				event.SelectAnswer(0, int(questIndex))
				event.SelectAnswer(0, 0)
			elif find_string(st_cur_server, "aegis"):
				event.SelectAnswer(0, int(questIndex))
				event.SelectAnswer(0, 0)
				event.SelectAnswer(0, 254)
			elif find_string(st_cur_server, "longju"):
				event.SelectAnswer(1, int(questIndex))
				event.SelectAnswer(1, 254)
				event.SelectAnswer(1, 0)
				event.SelectAnswer(1, 0)
					
					
			elif find_string(st_cur_server, "mystic"):
				
				# if questIndex == "0":
					# event.SelectAnswer(0, int(questIndex))
					# event.SelectAnswer(0, 254)
					# event.SelectAnswer(0, 0)
				# else:
				event.SelectAnswer(1, int(questIndex))
				event.SelectAnswer(1, 254)
				event.SelectAnswer(1, 0)
				event.SelectAnswer(1, 0)
			else:
				if find_string(st_cur_server, "lucerna"):
					self.lucernaAdd()
					
					
					
				event.SelectAnswer(0, int(questIndex))
				event.SelectAnswer(0, 254)
				event.SelectAnswer(0, int(questIndex))
				event.SelectAnswer(0, int(questIndex))
				event.SelectAnswer(0, 254)
				event.SelectAnswer(0, 0)
			try:
				quest.Clear()
			except:
				pass
			try:
				event.ClearEventSet(1)
			except:
				pass
			
			
	def dungeonStop(self):
		global dungeonState,searchNpc
		dungeonState = False
		searchNpc = 0
		self.dungeonStartBtn.SetUp()
		self.dungeonFunction.XX1(9999999)
		self.dungeonFunction.XX2(self.dungeonStop)
		self.UnHookQuestWindow(0)
	def dumpMethods(self, module, method, *args):
		if hasattr(module, method):
			chat_line_class = getattr(module, method)
			chat_line_instance = chat_line_class()
			class_attributes = dir(chat_line_instance)
			methods = [attr for attr in class_attributes if callable(getattr(chat_line_instance, attr))]
			file = open_file(str(method) + '_methods_list.txt', 'w')
			file.write("Methods in " + str(method) + " class:\n")
			for method in methods:
				file.write(method + '\n')
			file.close()
			msg("Dumping done")
		else:
			msg(str(module) + " does not have " + str(method) + " class")
	def GetDevilTowerFloor(self):
		(x, y, z) = player.GetMainCharacterPosition()
		if x > 10000 and y > 58000 and x < 25000 and y < 72000:
			return 1
		elif x > 10000 and y > 35000 and x < 25000 and y < 50000:
			return 2
		elif x > 10000 and y > 10000 and x < 25000 and y < 25000:
			return 3
		elif x > 35000 and y > 61000 and x < 43500 and y < 70500:
			return 4
		elif x > 35000 and y > 38000 and x < 43500 and y < 48000:
			return 5
		elif x > 14000 and y > 14000 and x < 43500 and y < 24500:
			return 6
		elif x > 56000 and y > 60000 and x < 68000 and y < 73000:
			return 7
		elif x > 56000 and y > 38000 and x < 68000 and y < 49000:
			return 8
		elif x > 56000 and y > 13000 and x < 68000 and y < 23000:
			return 9	 
		return 0
		#msg(self.GetDevilTowerFloor)
		
		
		
	def getChannel(self):
		global foundx64PythonList
		if foundx64PythonList:
			try:
				from pygame.net import GetServerInfo
				serverxInfo = GetServerInfo()
			except:
				pass
		else:
			try:
				serverxInfo = net.GetServerInfo()
			except:
				pass
		try:
			if find_string(st_cur_server, "melorin"):
				return int(serverxInfo.split(',')[1][4:])
			else:
				try:
					return int(serverxInfo.split(',')[1][3:])
				except:
					return int(serverxInfo.split('-')[1][3:])
		except:
			return None
	def loadReplyList(self):
		global AnswerTuple, isReplyListLoaded
		try:
			self.repliesList.RemoveAllItems()
		except:
			pass
	
		AnswerTuple = {}
	
		try:
			flm = open_file(st_path + "/Data/rascal2/pm_reply.cfg", 'r+')
			for line in flm:
				grade_data = line.strip().split('#')
				Keyword = grade_data[0]
				Answers = grade_data[1:]  # Store all possible answers as a list
				if Keyword not in AnswerTuple:
					AnswerTuple[Keyword] = []
				AnswerTuple[Keyword].extend(Answers)
			isReplyListLoaded = 1
			self.refreshReplyListFunc()
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.NO_REPLY_LIST)
			isReplyListLoaded = 0
	def RemoveAnswer(self):
		global AnswerTuple
		ItemIndex = self.repliesList.GetSelectedItem()
		if ItemIndex:
			pass
		else:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.SELECT_REPLY_FIRST)
			return
		KeyWord = ItemIndex.GetText().split(":")[0]
		Answer = ItemIndex.GetText().split(KeyWord + ": ")[1]
		try:
			AnswerTuple[KeyWord].remove(Answer)
			if AnswerTuple[KeyWord] == []:
				del AnswerTuple[KeyWord]
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.ERR_OCCURED)
		self.refreshReplyListFunc()
	def enableQuestionFunc(self):
		global useQuestion,repeatMessage
		useQuestion = 1
		repeatMessage = 0
		try:
			self.repeatMsg.OnToggleUp()
		except:
			pass
	def disableQuestionFunc(self):	
		global useQuestion
		useQuestion = 0
	def enableRepeatFunc(self):
		global repeatMessage,useQuestion
		repeatMessage = 1
		useQuestion = 0
		self.replyWithQuestion.OnToggleUp()
	def disableRepeatFunc(self):	
		global repeatMessage,useQuestion
		repeatMessage = 0
	def disableReplyTimes(self):
		global replyTimes, sentMessageCounts,replyTimesVal,userReplyCounts,unknownMessageCounts
		userReplyCounts = {}
		sentMessageCounts = {}
		unknownMessageCounts = {}
		replyTimes = 0
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.REPLY_UNLIMITED)
		replyTimesVal = 3
		self.replyTimesTxt.SetText(str(3))
	def enableReplyTimes(self):
		global replyTimes,replyTimesVal
		replyTimes = 1
		try:
			replyTimesVal = int(self.replyTimesTxt.GetText())
		except:
			replyTimesVal = 3
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.REPLY_TIMES1 + " " + str(replyTimesVal) + " " + lang.REPLY_TIMES2)
	def enableReplyBotFunc(self):
		global autoReply
		autoReply = 1
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.REPLY_BOT_ENABLED)
	def disableReplyBotFunc(self):	
		global autoReply
		autoReply = 0
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.REPLY_BOT_DISABLED)
	def applyReplyTimesFunc(self):	
		global replyTimesVal
		try:
			replyTimesVal = int(self.replyTimesTxt.GetText())
		except:
			replyTimesVal = 3
			self.replyTimesTxt.SetText(str(3))
	def applyDelayFunc(self):	
		global replyDelayGlobal
		replyDelayGlobal = self.replyDelay.GetText()
	def saveReplyListFunc(self):
		"""Save the updated reply list back to the pm_reply.cfg file."""
		try:
			flm = open_file(st_path + "/Data/rascal2/pm_reply.cfg", 'w')
			for Keyword, Answers in AnswerTuple.items():
				flm.write(Keyword + '#' + '#'.join(Answers) + '\n')
			flm.close()
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.ERR_OCCURED)
		
		
	def deleteReplyListFuncCancel(self):			
		self.QuestionDialog.Close()
		self.QuestionDialog = None
	def deleteReplyListFunc(self):	
		global AnswerTuple
		try:
			AnswerTuple = {}
			os.remove(st_path + "/Data/rascal2/pm_reply.cfg")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.REPLY_LIST_REM)
			self.deleteReplyListFuncCancel()
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.NO_REPLY_LIST)
		self.refreshReplyListFunc()
	def AskDeleteReplyListFunc(self):
		if find_string(st_cur_server, "aronix") or  find_string(st_cur_server, "metin2sg") or foundx64PythonList:
			self.QuestionDialog = uiCommon.QuestionDialog()
		else:
			self.QuestionDialog = QuestionDialog()
		self.QuestionDialog.SetText(lang.CONFIRM_DELETE)
		self.QuestionDialog.SetAcceptEvent(__mem_func__(self.deleteReplyListFunc))
		self.QuestionDialog.SetCancelEvent(__mem_func__(self.deleteReplyListFuncCancel))
		self.QuestionDialog.Open()
	def refreshReplyListFunc(self):		
		global AnswerTuple,isReplyListLoaded
		try:
			self.repliesList.RemoveAllItems()
		except:
			pass
		if isReplyListLoaded == 0:
			# AnswerTuple = {}
			self.loadReplyList()
		try:
			for Keyword in AnswerTuple:
				for Answer in AnswerTuple[Keyword]:
					self.repliesList.AppendItem(Item(Keyword + ": " + Answer))
		except:
			pass
	def addAnswerFunc(self):
		global AnswerTuple
		Keyword = self.txtDetect.GetText().lower()
		Answer = self.txtReply.GetText()
		if Keyword == "" or Answer == "":
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.SET_UP_KEYWORD)
		else:
			if Keyword not in AnswerTuple:
				AnswerTuple[Keyword] = []
			if Answer not in AnswerTuple[Keyword]:  # Avoid duplicate answers
				AnswerTuple[Keyword].append(Answer)
	
			self.repliesList.AppendItem(Item(Keyword + ": " + Answer))
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.KEYWORD_ANSWER1 + " '" + str(Keyword) + "'" + lang.KEYWORD_ANSWER2 + " '" + str(Answer) + "'.")
			self.saveReplyListFunc()
	
	
			
			
	def useHorseSkillFunc(self):	
		if find_string(st_cur_server, "Rubinum") or find_string(st_cur_server, "saphirus") or find_string(st_cur_server, "m2classic"):
			if self.useHorseSkill.checked==1:
				myVid = getCharIndex()
				chr.SelectInstance(myVid)
				setTarget(myVid)	
				if player.IsMountingHorse(): player.ClickSkillSlot(17)
		elif find_string(st_cur_server, "Rohan"):
			if self.useHorseSkill.checked==1:
				myVid = getCharIndex()
				chr.SelectInstance(myVid)
				setTarget(myVid)	
				if player.IsMountingHorse(): player.ClickSkillSlot(10)
		else:
			if self.useHorseSkill.checked==1:
				myVid = getCharIndex()
				chr.SelectInstance(myVid)
				setTarget(myVid)	
				if player.IsMountingHorse(): player.ClickSkillSlot(9)
	def setHeight(self, vid):
		try:
			xx,yy,zz = player.GetMainCharacterPosition()
			x,y,z = chr.GetPixelPosition(vid)
			chr.SelectInstance(getCharIndex())
			setPixelPos(int(xx), int(yy), int(z))
		except:
			pass
	if isGF:
		def goingFunction(self, how, x, y, path_finding,canTele = 0):
			global xToGo, yToGo,canWalkTele,setWalkingVar
			o = getCharIndex()
			eventHandler.remove('goingFunc')
			if path_finding:
				if setWalkingVar and not canTele:
					xToGo = x
					yToGo = y
					self.startWalk()
				else:
					if how == str('Walking'):
						xToGo = x
						yToGo = y
						self.startWalk()
					elif how == str('Hybrid'):
						canWalkTele = 1
						self.walkTele(int(x), int(y))
					elif how == str('Camera movement'):
						self.cameraMove(int(x),int(y))
					elif how == str('Teleporting'):
						self.cancelMovement.Hide()
						self.TeleportToPosition(int(x), int(y))
			else:
				if setWalkingVar and not canTele:
					walkFunc(int(x), int(y))
				else:
					if how == str('Walking'):
						walkFunc(int(x), int(y))
					elif how == str('Hybrid'):
						canWalkTele = 1
						self.walkTele(int(x), int(y))
					elif how == str('Camera movement'):
						self.cameraMove(int(x),int(y))
					elif how == str('Teleporting'):
						self.cancelMovement.Hide()
						self.telepX(int(x), int(y))
	else:
		def goingFunction(self, how, x, y, path_finding, canTele = 0):
			global xToGo, yToGo,canWalkTele,setWalkingVar
			o = getCharIndex()
			eventHandler.remove('goingFunc')
			if setWalkingVar and not canTele:
				xToGo = x
				yToGo = y
				if hasattr(chr, 'MoveToDestPosition'):
					walkFunc(int(x),int(y))
				else:
					self.cameraMove(int(x),int(y))	
			else:
				if how == str('Walking'):
					xToGo = x
					yToGo = y
					walkFunc(int(x),int(y))
				elif how == str('Hybrid'):
					canWalkTele = 1
					self.walkTele(int(x), int(y))
				elif how == str('Camera movement'):
					self.cameraMove(int(x),int(y))			
				elif how == str('Teleporting'):
					self.telepX(int(x),int(y))
					self.cancelMovement.Hide()
					eventHandler.add(0.1, self.goBack)
	def IsAnyPlayerHere(self):
		global skillsList,vidsListEnd1,isGF,canSearchPlayerVids
		dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'player_whitelist.txt'
		non_detect = []
		if os.stat(dirPl).st_size != 0:
			non_detect = open_file(dirPl, 'r+').read()
		for i in vidsListEnd1:
			a = chr.GetInstanceType(i)
			if a == playerType:
				name=chr.GetNameByVID(i)
				if name != "None" and chr.GetNameByVID(i) != getcharName() and chr.GetNameByVID(i) not in non_detect:
					msg(name)
					return True
				else:
					return False
	def GoToPositionAvoidingObjectsStop(self):
		global debugged
		self.GoToPositionAvoidingObjectsx.XX1(999999999)
		self.GoToPositionAvoidingObjectsx.XX2(self.GoToPositionAvoidingObjectsStop)
		if not debugged:
			self.Debug()
			debugged = 1
	def GoToPositionAvoidingObjects(self,x,y,maxDist=200):
		global time_Movement_stoppedTimer,yToGo,xToGo
		self.maxDistanceToDest = maxDist
		myVid = getCharIndex()
		my_x,my_y,z = player.GetMainCharacterPosition()
		self.path = eXLib.FindPath(my_x,my_y,x,y)
		if(len(self.path)>0):
			time_Movement_stoppedTimer = GetTime()
			next_x,next_y = self.path[0]
			my_x,my_y,my_z = player.GetMainCharacterPosition()
			maxdst = 200
			if(len(self.path) == 1):
				maxdst = self.maxDistanceToDest
			if dist(next_x,next_y,my_x,my_y) < maxdst:
				self.path.pop(0)
				if self.inside_circle(my_x, my_y, x,y,221):
					xToGo = 0
					yToGo = 0
					self.cancelMovement.Hide()
					self.GoToPositionAvoidingObjectsStop()
					return
				else:
					next_x,next_y = self.path[0]
			if self.lastPlayerPos == (my_x,my_y):
				val, time_Movement_stoppedTimer = timeSleep(time_Movement_stoppedTimer,TIME_STOPPED_ALLOWED)
				if val:
					self.path = eXLib.FindPath(my_x,my_y,self.currDestinationX,self.currDestinationY)
			walkFunc(next_x,next_y)
		else:
			walkFunc(x,y)
	def TeleportStraightLine(self, start_x,start_y,end_x,end_y,max_packets=25):
		dst = dist(start_x,start_y,end_x,end_y)
		step = int(dst/1572)
		if step+1>max_packets:
			step = max_packets-1
		x = start_x
		y = start_y
		for i in range(0,step+1):
			_x,_y = getPointsDistance(x,y,end_x,end_y,2400)
			eXLib.SendStatePacket(_x,_y,0,eXLib.CHAR_STATE_STOP,0)
			x,y = (_x,_y)
		self.cancelMovement.Hide()	
		return (step+1,(x,y))
	def TeleportToPosition(self, dst_x,dst_y,max_packets=25):
		x,y,z = player.GetMainCharacterPosition()
		points = eXLib.FindPath(x,y,dst_x,dst_y)
		if len(points) == 0:
			return None
		mainVID = getCharIndex()
		curr_x,curr_y = (x,y)
		dest_last_x, dest_last_y = points[0]
		counter = 0
		for point in points:
			dest1_x,dest1_y = point
			counter_,pos = self.TeleportStraightLine(curr_x,curr_y,dest_last_x, dest_last_y,max_packets-counter)
			counter += counter_
			if counter >= max_packets:
				chr.SelectInstance(mainVID)
				setPixelPos(pos[0],pos[1])
				time.sleep(1)
				try:
					return max_packets + self.TeleportToPosition(dst_x,dst_y,max_packets)
				except:
					pass
			curr_x,curr_y = (dest_last_x, dest_last_y)
			dest_last_x, dest_last_y = point
		counter_,pos = self.TeleportStraightLine(curr_x,curr_y,dest_last_x, dest_last_y,max_packets-counter)
		counter += counter_
		chr.SelectInstance(mainVID)
		setPixelPos(pos[0],pos[1])
		eXLib.SendStatePacket(pos[0]-100,pos[1]-100,0.0,1,0)
		eXLib.SendStatePacket(pos[0]+100,pos[1]+100,0.0,1,0)
		self.cancelMovement.Hide()
		return counter
	def telepX(self,aimx, aimy):
		global Debug, GetTmpTeleport, TeleportState
		(TmpX, TmpY, Count) = self.GetTmpTeleport(aimx, aimy)
		TmpCount = 0
		myVid = getCharIndex()
		while TmpCount < Count:
			chr.SelectInstance(myVid)
			(TmpX, TmpY, Crap) = self.GetTmpTeleport(aimx, aimy)
			setPixelPos(int(TmpX), int(TmpY))
			TmpCount += 1
			self.Debug()
		setPixelPos(int(aimx), int(aimy))
		TeleportState = 1
		chr.SelectInstance(myVid)
	def startWalk(self):
		global xToGo, yToGo, panicMode
		
		self.GoToPositionAvoidingObjectsx.XX1(0.1)
		self.GoToPositionAvoidingObjectsx.XX2(self.startWalk)
		self.GoToPositionAvoidingObjects(int(xToGo), int(yToGo))
		
		
		
	def onOffFarmbot(self,val,allowRange = True):
		global canTeleport,canWalkTele,stucked_times,areThereMetins,areThereBosses,areThereMobs,vidsMetinList,boss_list,farmEnable
		global rangeX, rangeY, canDetachHP,canChangeCH,canMove,updateCounter1,myIndex,tpTriggered,isGF,canSetTarget
		global thread
		global globalFarmingStartTime
		try:
			myIndex = getCharIndex()
			x, y, z = GetMainPos()
			if(val):
				canMove = 1
				canTeleport = 1
				canWalkTele = 1
				farmEnable = 1
				tpTriggered = 0
				try:
					metin2.x = x
					metin2.y = y
				except:
					pass
		
		
		
		
				if not rangeX:
					rangeX = x
					rangeY = y
				if canDetachHP == 0 and self.force.checked==1:
					try:
						HookSetHPTargetBoard()
					except:
						pass
				# Her zaman HP hook'u aktif et (metin lmn annda alglamak iin)
				if canDetachHP == 0:
					try:
						HookSetHPTargetBoard()
					except:
						pass
				ignoreMetinsList = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'metins_to_ignore.txt'
				if not self.fileExists(ignoreMetinsList):
					non_detect = open_file(ignoreMetinsList, "w")
					non_detect.close()
					
				ignoreMonstersList = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'monsters_to_ignore.txt'
				if not self.fileExists(ignoreMonstersList):
					non_detect = open_file(ignoreMonstersList, "w")
					non_detect.close()
					
				ignoreBossList = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'bosses_to_ignore.txt'
				if not self.fileExists(ignoreBossList):
					non_detect = open_file(ignoreBossList, "w")
					non_detect.close()
					
				try:
					self.load_boss()
				except:
					pass
					
				
				
				if globalFarmingStartTime == 0:
					try:
						globalFarmingStartTime = app.GetGlobalTimeStamp()
					except:
						globalFarmingStartTime = GetTime()
					
					
				if self.farmInRangeCB.checked == 0 and self.farmbyRouteCB.checked==0:
					self.farmInRangeCB.OnToggleDown()
				if self.farmInRangeCB.checked == 1:
					self.farmingFunc2()
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: " + lang.SUCCESS_FARM)
				else:
					try:
						route = self.routeListbox.DropList.GetSelectedItem().textBox.GetText()
					except:
						route = ''
					if route != "":
						self.readCurrentRoute()
						FarmCurrCoords = self.FarmCoords
						if len(FarmCurrCoords) > 0:
							plmagfasgsa = self.newFarmRangeVal.GetText()
							allowedFarmRange = int(plmagfasgsa) * 50
							if self.routeCoords.GetText() != "":
								self.farmingFunc2()
								msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: " + lang.SUCCESS_FARM)
							else:
								try:
									self.startFarmingBtn.SetOff()
								except:
									pass
								try:
									self.startFarmingBtn2.SetUp()
								except:
									pass
								msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: " + lang.STR_REC_FIRST)
								msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: " + lang.STR_EMPTY_ROUTE)
								return
						else:
							if self.farmbyRouteCB.checked==1:
								self.addCoord()
					else:
						try:
							self.startFarmingBtn.SetOff()
						except:
							pass
						try:
							self.startFarmingBtn2.SetUp()
						except:
							pass
						self.onOffFarmbot(False)
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: " + lang.FARM_NO_ROUTE)
						return
				if not isGF:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot info: " + lang.FARM_WAIT1)
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot info: " + lang.FARM_WAIT2)
			else:
				if allowRange:
					rangeX = 0
					rangeY = 0
				try:
					metin2.cabla=0
				except:
					pass
				if canDetachHP == 1:
					UnHookSetHPTargetBoard()
				self.farmingFunc2Off()
				stucked_times = 0
				farmEnable = 0
				canChangeCH = 0
				updateCounter1 = 0
				Attack(False)
				self.Debug()
				canWalkTele = 0
				canSetTarget = 1
				vidsMetinList = []
				
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: " + lang.STOP_FARM)
				eventHandler.remove("goingFunc")
				eventHandler.remove('changeChSequence')
				eventHandler.remove('checkCh')
				eventHandler.remove("walk")
				eventHandler.remove("teleTo")
				eventHandler.remove("walkTele")
				eventHandler.remove("attack")
		except:
	
			exc_type, exc_value, exc_traceback = sys.exc_info()
			err = exc_type.__name__
			if isDebug:
				import traceback
				def handle_exception(exc_type, exc_value, exc_traceback):
					current_time = time.strftime("%y/%m/%d %H:%M", time.localtime(int(app.GetGlobalTimeStamp())))
					error_message = "".join(traceback.format_exception(exc_type, exc_value, exc_traceback))
					log_message = "%s :: %s" % (current_time, error_message)
					logFile = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str('errorLog.log')
					f = open_file(str(logFile), 'a')
					f.write(log_message + '\n')
					f.close()
				sys.excepthook = handle_exception
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: " + lang.FARM_ERR1)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: " + lang.FARM_ERR2)
	def is_character_stuck(self, target_location):
		global stuck_times
		global curX, curY
		iterations_to_check = 20
		threshold_distance = 150  
		myx, myy, myz = GetMainPos()  
		if curX is None or curY is None:
			curX, curY = myx, myy
		distance_moved = math.sqrt((myx - curX) ** 2 + (myy - curY) ** 2)
		if distance_moved < threshold_distance:
			stuck_times += 1
			if stuck_times >= iterations_to_check:
				return True
		else:
			curX, curY = myx, myy
			stuck_times = 0
		return False
		
		
		
	def isPoly(self):
		my_vid = getCharIndex()
		chr.SelectInstance(my_vid)
		race = chr.GetRace(my_vid)
		if race > 10:
			return 1
		else:
			return 0
		
	def checkDistance(self):
		global temp_metin_vid
		if temp_metin_vid:
			distance = GetDis(temp_metin_vid)
			if IsWeaponArch() and not self.approachTarget.checked and not self.isPoly():
				if distance <= 2450:
					return True
				else:
					return False
			else:
				if find_string(st_cur_server, "dark") or find_string(st_cur_server, "luna"):
					dist = 265
				else:
					dist = 230
				if distance <= dist:
					return True
				else:
					return False
	def get_distance(self, vid):
		return GetDis(vid)
	def camRotation(self, character_position, vid_position):
		dx = vid_position[0] - character_position[0]
		dy = vid_position[1] - character_position[1]
		degrees_value = math.atan2(dy, dx) * (180.0 / math.pi)
		required_camera_rotation = degrees_value
		required_camera_rotation %= 360
		required_camera_rotation -= 90
		return required_camera_rotation
	def cameraMove(self, x, y):
		# try:
		mx, my, mz = player.GetMainCharacterPosition()
		vid_position = (x, y)
		character_position = (mx, my)
		required_camera_rotation = self.camRotation(vid_position, character_position)
		cameraDist, cameraPitch, cameraRotation, cameraHeight = app.GetCamera()
		app.SetCamera(cameraDist, cameraPitch, required_camera_rotation, cameraHeight)
		self.RotateMainCharacter(x,y)
		if foundx64PythonList:
			onKeyDown(player.DIR_UP)	
		else:
			onKeyDown(appKey('UP'))	
		# except:
			# pass
	def get_closest_position(self, file_path, current_position):
		try:
			inf = float("1e30000")
		except ValueError:
			inf = 1e30000
		min_distance = inf
		closest_position = None
		closest_index = None
		file = open_file(file_path, "r+")
		i = 0
		for line in file:
			x, y = map(int, line.split())
			distance = math.sqrt((x - current_position[0])**2 + (y - current_position[1])**2)
			if distance < min_distance:
				min_distance = distance
				closest_position = (x, y)
				closest_index = i
			i += 1
		return closest_position, closest_index
	def isDead(self, vid):
		global isGF
		if isGF:
			return eXLib.IsDead(vid)
		else:
			return False
	def randomFunc(self,x,y):
		try:
			rnd = getRandom(x, y)
			if getRandom(0, 1) < 0.5:
				sign_x = -1
			else:
				sign_x = 1
			if getRandom(0, 1) < 0.5:
				sign_y = -1
			else:
				sign_y = 1
			rnd_x = rnd * sign_x
			rnd_y = rnd * sign_y
			return (rnd_x, rnd_y)
		except:
			return (x,y)
			
	def checkKilledEntities(self):
		global targets_in_progress
		global globalFarmingKilled
	
		remove_list = []
	
		for vid in targets_in_progress:
			if not HasInstance(vid):
				entity = targets_in_progress[vid]
				entity_type = entity["type"]
				is_enemy = entity["is_enemy"]
				is_boss = entity["is_boss"]
	
				if entity_type == metinType and self.farmMetinsCB.checked == 1:
					globalFarmingKilled["metins"] += 1
				elif entity_type == npcType and self.farmOreCB.checked == 1:
					globalFarmingKilled["ores"] += 1
				elif is_enemy:
					if is_boss and self.farmBossCB.checked == 1:
						globalFarmingKilled["bosses"] += 1
					elif self.farmMobCB.checked == 1:
						globalFarmingKilled["mobs"] += 1
	
				remove_list.append(vid)
		for vid in remove_list:
			if vid in targets_in_progress:
				del targets_in_progress[vid]
			
	def farmingFunc2(self):
		global attackState,stucked, current_mining_state, oreVid, miningX, miningY, playerDetected,boss_list,stucked_times,bossIds,switchMetin,canWalkTele
		global canUseVid, vidsListEnd1,  targetVID_Start, targetVID_End, restartCounter, canTeleportHP, temp_metin_vid,metin_nonDetect, rangeX, rangeY, getHPTarget, DistanceToNext, canMove
		global tempTimeAttack, SetAttackTime,canChangeCH,tempVid,changeTargetIndex, debugged, banList, playerStucked, countVidReset,requiresRouteCheck,disableAttack,canAttack
		global checkHPTimes, antibanList, neededVid,updateCounter1,isGF,canSetTarget,hasToPickup,current_index
		global pauseFarmbot, pauseFishbot, pauseEnergy,pauseSkill,pausePick,pauseSpam,pauseItemUser, tpTriggered,newPython,tmpWall,randomizeMovement
		global globalFarmingKilled, last_counted_targets,isFarmingOre
		farmdelay = 0.1
		self.farmingx2Func.XX1(farmdelay)
		self.farmingx2Func.XX2(self.farmingFunc2)
		if not isConnect():
			self.farmingx2Func.XX1(5)
			return
		if hasToPickup:
			Attack(False)
			return
			
		
			
		o = getCharIndex()
		current_index = 1
		x, y, z = player.GetMainCharacterPosition()
		FarmCurrCoords = self.FarmCoords
		mobsListVids = []
		allFarmVidsList = []
		allFarmVidsListMetin = []
		allFarmVidsListBoss = []
		allFarmVidsListOre = []
		allFarmVidsListPlayers = []
		if pauseFarmbot:
			if player.GetTargetVID() == 0 or player.GetTargetVID() == -1:
				Attack(False)
			if not debugged:
				self.Debug()
				debugged = 1
			allFarmVidsList = []
			return
		ore_mapping = {
			lang.MINING_DIAMOND: 20047,
			lang.MINING_AMBER: 20048,
			lang.MINING_FOSSIL: 20049,
			lang.MINING_COPPER: 20050,
			lang.MINING_SILVER: 20051,
			lang.MINING_GOLD: 20052,
			lang.MINING_JADE: 20053,
			lang.MINING_EBONY: 20054,
			lang.MINING_CLAMS: 20055,
			lang.MINING_WHITE_GOLD: 20056,
			lang.MINING_CRYSTAL: 20057,
			lang.MINING_AMETHYST: 20058,
			lang.MINING_HEAVEN_TEARS: 20059,
			lang.MINING_SOUL_CRYSTAL: 30301,
			lang.MINING_RUBY: 30302,
			lang.MINING_GARNET: 30303,
			lang.MINING_EMERALD: 30304,
			lang.MINING_SAPPHIRE: 30305,
			lang.MINING_TOURMALINE: 30306,
			lang.MINING_EVERYTHING: [30302, 30303, 30304, 30305, 30306, 20059, 20054, 20047, 20056, 30301, 20051, 20048, 20049, 20050, 20052, 20053, 20055, 20057, 20058],
			lang.MINING_CUSTOM: []
		}
		
		self.checkKilledEntities()
		# msg("disableAttack: " + str(disableAttack))
		text = self.NewminingList.GetCurrentText()
		if newPython:
			if text in ore_mapping:
				selectedOre = ore_mapping[text]
			else:
				selectedOre = None
		else:
			if ore_mapping.has_key(text):
				selectedOre = ore_mapping[text]
			else:
				selectedOre = None
		try:
			changeCH = int(self.changeCHIn.GetText())
		except:
			changeCH = 5
		c=0
		plmagfasgsa = self.newFarmRangeVal.GetText()
		allowedFarmRange = int(plmagfasgsa) * 50
		try:
			targetTimeout = int(self.targetTimeoutValue.GetText())
		except:
			targetTimeout = 10
		
		if self.farmbyRouteCB.checked==1:
			try:
				rangeX = float(FarmCurrCoords[self.FarmBotStep][0])
				rangeY = float(FarmCurrCoords[self.FarmBotStep][1])
			except:
				rangeX = x
				rangeY = y
		if self.dontKs.checked==1:
			for i in vidsListEnd1:
				Type = chr.GetInstanceType(i)
				if Type==playerType:
					if chr.GetNameByVID(i) != "None" and chr.GetNameByVID(i) != getcharName() and not string_contains(chr.GetNameByVID(i), 'Buffi'):
						name=chr.GetNameByVID(i)
						if i not in allFarmVidsListPlayers:
							allFarmVidsListPlayers.append(i)
		if self.farmMetinsCB.checked == 1:
			ignoreList = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'metins_to_ignore.txt'
			
			if not self.fileExists(ignoreList):
				x = open_file(ignoreList, "w")
				x.close()
			
			file_size = os.stat(ignoreList).st_size
		
			for i in vidsListEnd1:
				try:
					Race = chr.GetRace(i)
					if background.GetCurrentMapName() == "garly_exp1" and Race == 8735:
						newMsgSimple("Check Bosses box and add the metins around you as Custom boss!")
						self.onOffFarmbot(False)
						return
				except:
					pass
				
				if i not in banList and HasInstance(i) and not self.isDead(i):
					Typ = chr.GetInstanceType(i)
					if Typ == metinType and HasInstance(i):
						xt, yt = getPos(i)
		
						in_range = (self.fixedRange.checked == 1 and 
									self.inside_circle(xt, yt, rangeX, rangeY, allowedFarmRange)) or self.fixedRange.checked != 1
		
						if file_size == 0:
							if in_range:
								if i not in allFarmVidsList:
									allFarmVidsList.append(i)
								if i not in allFarmVidsListMetin:
									allFarmVidsListMetin.append(i)
						else:
							try:
								ignoreMetins = open_file(ignoreList, 'r+').read().rsplit()
								chr.SelectInstance(i)
								race = chr.GetRace(i)
		
								if str(race) not in ignoreMetins:
									if in_range:
										if i not in allFarmVidsList:
											allFarmVidsList.append(i)
										if i not in allFarmVidsListMetin:
											allFarmVidsListMetin.append(i)
							except:
								if in_range:
									if i not in allFarmVidsList:
										allFarmVidsList.append(i)
									if i not in allFarmVidsListMetin:
										allFarmVidsListMetin.append(i)
		if self.farmBossCB.checked == 1:
			bossList = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'custom_bosses.cfg'
		
			for i in vidsListEnd1:
				if i not in banList and HasInstance(i) and not self.isDead(i):
					if isBoss(i) or chr.IsEnemy(i):
						ignoreList = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'bosses_to_ignore.txt'
						if not self.fileExists(ignoreList):
							x = open_file(ignoreList, "w")
							x.close()
						file_size = os.stat(ignoreList).st_size
						chr.SelectInstance(i)
						Race = chr.GetRace(i)
		
						if file_size == 0:
							for abc in bossIds + boss_list:
								if Race == int(abc):
									xt, yt = getPos(i)
									if (self.fixedRange.checked == 1 and self.inside_circle(xt, yt, rangeX, rangeY, allowedFarmRange)) or self.fixedRange.checked != 1:
										
										if i not in allFarmVidsList:
											allFarmVidsList.append(i)
										if i not in allFarmVidsListBoss:
											allFarmVidsListBoss.append(i)
						else:
							ignoreBosses = open_file(ignoreList, "r+").read().rsplit()
							if str(Race) not in ignoreBosses:
								for abc in bossIds + boss_list:
									if Race == int(abc):
										xt, yt = getPos(i)
										if (self.fixedRange.checked == 1 and self.inside_circle(xt, yt, rangeX, rangeY, allowedFarmRange)) or self.fixedRange.checked != 1:
		
											if i not in allFarmVidsList:
												allFarmVidsList.append(i)
											if i not in allFarmVidsListBoss:
												allFarmVidsListBoss.append(i)
		if self.farmOreCB.checked==1:
			for i in vidsListEnd1:
				Typ = chr.GetInstanceType(i)
				if Typ==npcType and HasInstance(i):
					chr.SelectInstance(i)
					Race=chr.GetRace(i)
					if self.NewminingList.GetCurrentText() == lang.MINING_EVERYTHING:
						for abc in selectedOre:
							if Race==int(abc):
								(xt, yt) = getPos(i)
								if self.fixedRange.checked == 1 and self.inside_circle(xt, yt, rangeX, rangeY, allowedFarmRange):
									if i not in allFarmVidsList:
										allFarmVidsList.append(i)
									if i not in allFarmVidsListOre:
										allFarmVidsListOre.append(i)
								elif self.fixedRange.checked != 1:
									if i not in allFarmVidsList:
										allFarmVidsList.append(i)
									if i not in allFarmVidsListOre:
										allFarmVidsListOre.append(i)
					elif self.NewminingList.GetCurrentText() == lang.MINING_CUSTOM:
						try:
							dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'custom_ore.txt'
						except:
							msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.MINING_STOPPED + " " + str(dirPl))
							self.farmingFunc2Off()
						if os.path.exists(dirPl):
							if os.stat(dirPl).st_size != 0:
								custom = open_file(dirPl, 'r+').read().split()
								selectedOre = custom
							else:
								non_detect = open_file(dirPl, "a")
								non_detect.write("\n")
								non_detect.close()
						else:
							msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.MINING_STOPPED + " " + str(dirPl))
							self.farmingFunc2Off()
						for abc in selectedOre:
							if Race==int(abc):
								(xt, yt) = getPos(i)
								if self.fixedRange.checked == 1 and self.inside_circle(xt, yt, rangeX, rangeY, allowedFarmRange):
									if i not in allFarmVidsList:
										allFarmVidsList.append(i)
									if i not in allFarmVidsListOre:
										allFarmVidsListOre.append(i)
								elif self.fixedRange.checked != 1:
									if i not in allFarmVidsList:
										allFarmVidsList.append(i)
									if i not in allFarmVidsListOre:
										allFarmVidsListOre.append(i)
					else:
						if Race==int(selectedOre):
							(xt, yt) = getPos(i)
							if self.fixedRange.checked == 1 and self.inside_circle(xt, yt, rangeX, rangeY, allowedFarmRange):
								if i not in allFarmVidsList:
									allFarmVidsList.append(i)
								if i not in allFarmVidsListOre:
									allFarmVidsListOre.append(i)
							elif self.fixedRange.checked != 1:
								if i not in allFarmVidsList:
									allFarmVidsList.append(i)
								if i not in allFarmVidsListOre:
									allFarmVidsListOre.append(i)
		if self.farmMobCB.checked==1:
			
			
			ignoreList = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'monsters_to_ignore.txt'
			if not self.fileExists(ignoreList):
				x = open_file(ignoreList, "w")
				x.close()
			
			file_size = os.stat(ignoreList).st_size
		
			for i in vidsListEnd1:
				if chr.IsEnemy(i) and i not in banList and HasInstance(i) and not self.isDead(i): 
					xt, yt = getPos(i)
		
					in_range = (self.fixedRange.checked == 1 and 
								self.inside_circle(xt, yt, rangeX, rangeY, allowedFarmRange)) or self.fixedRange.checked != 1
		
					if file_size == 0:
						if in_range:
							if i not in allFarmVidsList:
								allFarmVidsList.append(i)
							if i not in mobsListVids:
								mobsListVids.append(i)
					else:
						try:
							ignoreMetins = open_file(ignoreList, 'r+').read().rsplit()
							chr.SelectInstance(i)
							race = chr.GetRace(i)
		
							if str(race) not in ignoreMetins:
								if in_range:
									if i not in allFarmVidsList:
										allFarmVidsList.append(i)
									if i not in mobsListVids:
										mobsListVids.append(i)
						except:
							if in_range:
								if i not in allFarmVidsList:
									allFarmVidsList.append(i)
								if i not in mobsListVids:
									mobsListVids.append(i)
			
			
			
			
			
			
			
		try:
			initMiningDelay = int(self.TimeMiningOreVal.GetText())
			randomizeDelay = random.uniform(initMiningDelay - 2, initMiningDelay + 2)
			randomizeDelay = round(randomizeDelay, 2)
		except:
			randomizeDelay = int(self.TimeMiningOreVal.GetText())
		if allFarmVidsList:
			try:
				if eventHandler.has("changeChSequence"):
					eventHandler.remove('changeChSequence')
			except:
				eventHandler.remove('changeChSequence')
			canChangeCH = 0
			debugged = 0
			countVidReset = 0
			try:
				curHP=player.GetStatus(player.HP)
				maxHP=player.GetStatus(player.MAX_HP)
			except:
				curHP=222
				maxHP=222
			myHP = self.hpLower.GetText()
			priority = self.listPriority.GetCurrentText()
			if priority == 'Metins first':
				if allFarmVidsListMetin:
					XDXDXD = allFarmVidsListMetin
				elif allFarmVidsListBoss:
					XDXDXD = allFarmVidsListBoss
				elif allFarmVidsListOre:
					XDXDXD = allFarmVidsListOre
				elif mobsListVids:
					XDXDXD = mobsListVids
				else:
					XDXDXD = allFarmVidsList
			elif priority == 'Bosses first':
				if allFarmVidsListBoss:
					XDXDXD = allFarmVidsListBoss
				elif allFarmVidsListMetin:
					XDXDXD = allFarmVidsListMetin
				elif allFarmVidsListOre:
					XDXDXD = allFarmVidsListOre
				elif mobsListVids:
					XDXDXD = mobsListVids
				else:
					XDXDXD = allFarmVidsList
					
			if self.randomizeMiningTime.checked==1:
				
				try:
					delay = int(self.TimeMiningOreVal.GetText())
				except:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.MINING_WRONG_DELAY1)
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.MINING_WRONG_DELAY2)
					delay = 30
				
				try:
					initMiningDelay = delay
					randomizeDelay = random.uniform(initMiningDelay - 2, initMiningDelay + 2)
					randomizeDelay = round(randomizeDelay, 2)
				except:
					randomizeDelay = delay
			else:
				try:
					delay = int(self.TimeMiningOreVal.GetText())
				except:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.MINING_WRONG_DELAY1)
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.MINING_WRONG_DELAY2)
					randomizeDelay = 30
			try:
				sorted_vids = sorted(XDXDXD, key=lambda vid: GetDis(vid))
			except:
				XDXDXD.sort(compare_vids)
				sorted_vids = XDXDXD[:]
			if not HasInstance(temp_metin_vid):
				temp_metin_vid = sorted_vids[0]
			if canMove:
				temp_metin_vid = sorted_vids[0]
			if isGF:
				if not self.isDead(sorted_vids[0]):
					temp_metin_vid = sorted_vids[0]
			original_metin_vid = temp_metin_vid
			tempDist = GetDis(sorted_vids[0])
			DistanceToNext = GetDis(temp_metin_vid)
			if tempDist < DistanceToNext and not tpTriggered:
				temp_metin_vid = sorted_vids[0]
			neededVid = temp_metin_vid
			attackTime = self.skipMetinDelay.GetText()
			if len(banList) > 50:
				banList = []
				canMove = 1
			if isGF:
				if self.isDead(temp_metin_vid):
					banList.append(temp_metin_vid)
					
	
			if self.skipTarget.checked:
				currentTime = app.GetTime()
				if hasattr(self, "targetAssignedTime") and (currentTime - self.targetAssignedTime >= targetTimeout):
					if temp_metin_vid not in banList:
						banList.append(temp_metin_vid)
					canMove = 1
					del self.targetAssignedTime
					return
	
					
			if DistanceToNext == -1:
				if temp_metin_vid not in banList:
					banList.append(temp_metin_vid)
				SetAttackTime = 1
				canMove = 1
				randomizeMovement = 1
			else:
				x,y  = getPos(temp_metin_vid)
				player_x, player_y, player_z = player.GetMainCharacterPosition()
				if self.checkDistance():
					if self.skipTarget.checked:
						if hasattr(self, "targetAssignedTime"):
							del self.targetAssignedTime
					if self.farmMetinsCB.checked == 1 or self.farmBossCB.checked == 1 or self.farmOreCB.checked == 1:
						if neededVid > 0:
							log_attack_or_mining(neededVid)
					if neededVid > 0:
						global targets_in_progress
					
						if neededVid not in targets_in_progress:
							targets_in_progress[neededVid] = {
								"type": chr.GetInstanceType(neededVid),
								"is_enemy": chr.IsEnemy(neededVid),
								"is_boss": isBoss(neededVid),
							}
					canMove = 0
					randomizeMovement = 1
					if self.initRouteClosest.checked == 1 and self.farmbyRouteCB.checked==1:
						try:
							xx, yy, zz = player.GetMainCharacterPosition()
							player_position = (xx, yy, zz)
							route = self.routeListbox.DropList.GetSelectedItem().textBox.GetText()
							path = st_path + "/Data/Routes" + '/' + route
							closest_position, farmStep = self.get_closest_position(path, (player_position[0], player_position[1]))
							try:
								self.FarmBotStep = farmStep + 1
							except:
								self.FarmBotStep = farmStep
						except:
							pass
					if foundx64PythonList:
						onKeyUp(player.DIR_UP)	
					else:
						onKeyUp(appKey('UP'))
					if self.farmOreCB.checked==1:
						isFarmingOre = 1
						chr.SelectInstance(temp_metin_vid)
						if find_string(st_cur_server, "Rubinum") or find_string(st_cur_server, "saphirus") or find_string(st_cur_server, "m2classic"):
							rarraa=nonplayer.GetRaceNumByVID(temp_metin_vid)
						else:
							rarraa=chr.GetRace(temp_metin_vid)
						if self.NewminingList.GetCurrentText() == lang.MINING_EVERYTHING or self.NewminingList.GetCurrentText() == lang.MINING_CUSTOM:
							for abc in selectedOre:
								if rarraa==int(abc):
									self.farmingx2Func.XX1(randomizeDelay)
						else:
							if rarraa == selectedOre:
								self.farmingx2Func.XX1(randomizeDelay)
						if player.IsMountingHorse():
							mountHorseFunc(0)
						if find_string(st_cur_server, "aleris"):
							setTarget(neededVid)
							Attack(True)
						clickPacket(temp_metin_vid)
						if find_string(st_cur_server, "darksouls") or find_string(st_cur_server, "global2") or autoRemoveWalk:
							scheduleMiningPackets()
							
					else:
						isFarmingOre = 0
						if canSetTarget:
							setTarget(neededVid)
						if 0 < (float(curHP) / float(maxHP) * 100) > int(myHP):
							canTeleportHP = 0
						else:
							canTeleportHP = 1
						if self.tpAway.checked==1:
							if not curHP <= 0:
								if canTeleportHP == 1:
									canTeleportHP = 0
									rnd = getRandom(300, 3000)
									if getRandom(0, 1) < 0.5:
										sign_x = -1
									else:
										sign_x = 1
									if getRandom(0, 1) < 0.5:
										sign_y = -1
									else:
										sign_y = 1
									rnd_x = rnd * sign_x
									rnd_y = rnd * sign_y
									(x, y, z) = player.GetMainCharacterPosition()
									self.TeleportToDest(int(x + rnd_x),int(y + rnd_y))
									temp_metin_vid = original_metin_vid
									tpTriggered = 1
							else:
								tpTriggered = 0
						elif self.relogTp.checked==1:
							if not curHP <= 0:
								if canTeleportHP == 1:
									canTeleportHP = 0
									self.relogMe()
						elif self.hybridTP.checked==1:
							if not curHP <= 0:
								if canTeleportHP == 1:	
									canTeleportHP = 0
									rnd = getRandom(300, 3000)
									if getRandom(0, 1) < 0.5:
										sign_x = -1
									else:
										sign_x = 1
									if getRandom(0, 1) < 0.5:
										sign_y = -1
									else:
										sign_y = 1
									rnd_x = rnd * sign_x
									rnd_y = rnd * sign_y
									(x, y, z) = player.GetMainCharacterPosition()
									self.walkTele(int(x + rnd_x),int(y + rnd_y))
									temp_metin_vid = original_metin_vid
									tpTriggered = 1
							else:
								tpTriggered = 0
						if self.skipMetin.checked==1:
							currentTime = app.GetTime()
							if SetAttackTime == 1:
								tempTimeAttack = app.GetTime() + float(attackTime)
								SetAttackTime = 0
							if currentTime >= tempTimeAttack:
								if canSetTarget:
									setTarget(neededVid)
								Attack(False)
								if temp_metin_vid not in banList:
									banList.append(temp_metin_vid)
								canMove = 1
						else:
							SetAttackTime = 1
						goingType = str(self.farmGoingMethod.GetCurrentText())
						try:
							self.setRot(temp_metin_vid)
						except:
							pass
						if str(goingType) == 'Hybrid' or str(goingType) == 'Teleporting':
							self.setHeight(temp_metin_vid)
						if self.force.checked == 1:
							if find_string(st_cur_server, "campion") or find_string(st_cur_server, "eden2") or find_string(st_cur_server, "oldgeneration") or find_string(st_cur_server, "metin2og"):
								limit = 3
							elif find_string(st_cur_server, "rospeed") or find_string(st_cur_server, "shunzo"):
								limit = 1
							elif find_string(st_cur_server, "calliope"):
								limit = 10
							else:
								limit = 5
							
							if canSetTarget:
								chr.SelectInstance(temp_metin_vid)
								setTarget(neededVid)
								if getHPTarget <= 0:
									
									if self.onlyPickup.checked:
										self.pickupFunc()
									
									checkHPTimes += 1
									if checkHPTimes >= limit:
										if temp_metin_vid not in banList:
											banList.append(temp_metin_vid)
										checkHPTimes = 0
								else:
									checkHPTimes = 0
								canMove = 1
								
								
								
						if self.doNotAttack.checked==1 and not antibanList:
							Attack(False)
						else:
							
							if disableAttack:
								Attack(False)
								return
							
							if self.waitForHPBox.checked == 1:
								Attack(canAttack)
							else:
								Attack(True)
				else:
					if self.skipTarget.checked:
						if not hasattr(self, "targetAssignedTime"):
							self.targetAssignedTime = app.GetTime()
					if isGF and wallhack and self.farmMetinsCB.checked==1:
						distance = GetDis(temp_metin_vid)
						if distance <= 500:
							tmpWall = 1
							self.WallhackOff()
							
							
					Attack(False)
					SetAttackTime = 1
					tempTimeAttack = app.GetTime()
					if self.dontKs.checked == 1:
						if len(allFarmVidsListPlayers) != 0:
							for i in range(0,len(allFarmVidsListPlayers)):
								try:
									plm = allFarmVidsListPlayers[i]
									xPlayer,yPlayer = getPos(plm)
									xMetin,yMetin = getPos(temp_metin_vid)
									if self.inside_circle(xPlayer, yPlayer, int(xMetin), int(yMetin), 350):
										if temp_metin_vid not in banList:
											banList.append(temp_metin_vid)
										canMove = 1
								except:
									pass
					if isGF:
						xgo = x
						ygo = y
							
					else:
						
						
						
						try:
							
	
							if self.farmMetinsCB.checked == 1 or self.farmOreCB.checked == 1 and randomizeMovement:
	
								randomizeMovement = 0
								dxXXX = x - player_x
								dyYYY = y - player_y
								distanceSqrt = math.sqrt(dxXXX**2 + dyYYY**2)
								if distanceSqrt > 0:
									dxXXX /= distanceSqrt
									dyYYY /= distanceSqrt
			
								random_offset = getRandom(1,80)
								
								xgo = int(x - dxXXX * random_offset)
								ygo = int(y - dyYYY * random_offset)
							else:
								xgo = x
								ygo = y
						except:
							if self.farmMetinsCB.checked == 1 or self.farmOreCB.checked == 1:
								xgo1, ygo1 = (50, 150)
							else:
								xgo1, ygo1 = (0, 0)
							xgo = int(xgo1 + x)
							ygo = int(ygo1 + y)
					try:
						self.setRot(temp_metin_vid)
					except:
						pass
					# msg("X: " + str(xgo) + " Y: " + str(ygo))
					# if self.waitAfter.checked==1:
						# try:
							# waitTime = float(self.wait.GetText())
						# except:
							# waitTime = 1
							
					if self.waitAfter.checked == 1:
						try:
							waitTime = float(self.wait.GetText())
						except:
							waitTime = 1.0
					
						max_offset = waitTime
										
						randomGeneratedFloat = getRandom(0, int(max_offset * 10)) / 10.0
						random_offset = getRandom(0, 1) * 2 * randomGeneratedFloat - randomGeneratedFloat
						randomizedWait = waitTime + random_offset
						if randomizedWait < 0:
							randomizedWait = waitTime
							
						# msg(randomizedWait)
						if not eventHandler.has('goingFunc'):
							eventHandler.add(float(randomizedWait), lambda: self.goingFunction(str(self.farmGoingMethod.GetCurrentText()), xgo,ygo, 1), 'goingFunc')
					else:
						self.goingFunction(str(self.farmGoingMethod.GetCurrentText()), xgo, ygo, 1)
					# if self.unstuckCB.checked==1 and str(self.farmGoingMethod.GetCurrentText()) == 'Walking' or str(self.farmGoingMethod.GetCurrentText()) == 'Camera movement':
					xxx, yyy, zz = player.GetMainCharacterPosition()
					distancex = getRandom(50, 1000)
					angle_difference = getRandom(-10, 10) / 100.0
					dxx, dyy = x - xxx, y - yyy
					angle = math.atan2(dyy, dxx) + angle_difference
					new_x = int(xxx + math.cos(angle) * distancex)
					new_y = int(yyy + math.sin(angle) * distancex)
					target_location = (x, y)
					stuck = self.is_character_stuck(target_location)
					if stuck:
						if isGF:
							if not eXLib.IsPositionBlocked(int(new_x), int(new_y)):
								if self.unstuckCB.checked==1:
									self.walkTele(new_x, new_y)
								self.useHorseSkillFunc()
						else:
							if self.unstuckCB.checked==1:
								self.walkTele(new_x, new_y)
							self.useHorseSkillFunc()
					
					if canSetTarget:
						setTarget(neededVid)
		else:
			countVidReset=countVidReset+1
			if isGF and tmpWall and self.farmMetinsCB.checked==1:
				tmpWall = 0
				self.WallhackOn()
			if countVidReset >= 10:
				canMove = 1
				countVidReset = 0
			if canMove == 1:
				Attack(False)
				if self.waitRouteAfter.checked==1:
					waitTime = self.wait.GetText()
					self.farmingx2Func.XX1(int(waitTime))
				if self.farmbyRouteCB.checked==1:
					if self.initRouteClosest.checked == 1 and requiresRouteCheck:
						try:
							xx, yy, zz = player.GetMainCharacterPosition()
							player_position = (xx, yy, zz)
							route = self.routeListbox.DropList.GetSelectedItem().textBox.GetText()
							path = st_path + "/Data/Routes" + '/' + route
							closest_position, farmStep = self.get_closest_position(path, (player_position[0], player_position[1]))
							self.FarmBotStep = farmStep
							requiresRouteCheck = 0
						except:
							requiresRouteCheck = 0
					if self.FarmBotStep + 1 < len(self.FarmCoords):
						if self.inside_circle(player.GetMainCharacterPosition()[0], player.GetMainCharacterPosition()[1], int(FarmCurrCoords[self.FarmBotStep][0]), int(FarmCurrCoords[self.FarmBotStep][1]), 501):
							self.FarmBotStep += 1
						if self.FarmBotStep == len(FarmCurrCoords):
							self.FarmBotStep = 0
						if len(FarmCurrCoords) >= 2 and not self.inside_circle(player.GetMainCharacterPosition()[0], player.GetMainCharacterPosition()[1], int(FarmCurrCoords[self.FarmBotStep][0]), int(FarmCurrCoords[self.FarmBotStep][1]), 501):
							self.goingFunction(str(self.farmGoingMethod.GetCurrentText()), int(FarmCurrCoords[self.FarmBotStep][0]), int(FarmCurrCoords[self.FarmBotStep][1]), 1)
					else:
						if self.runRouteBackwards.checked==1:
							self.FarmCoords.reverse()
						self.FarmBotStep = 0
					if self.changeCHRoute.checked==1 and self.FarmBotStep == 0 and not allFarmVidsList:
						if not eventHandler.has('changeChSequence'):
							eventHandler.add(int(changeCH), self.checkGoCh, 'changeChSequence')
					# if self.unstuckCB.checked==1 and str(self.farmGoingMethod.GetCurrentText()) == 'Walking' or str(self.farmGoingMethod.GetCurrentText()) == 'Camera movement':
					whereX, whereY = (int(FarmCurrCoords[self.FarmBotStep][0]), int(FarmCurrCoords[self.FarmBotStep][1]))
					xx, yy, zz = player.GetMainCharacterPosition()
					distance = getRandom(50, 1000)
					angle_difference = getRandom(-10, 10) / 100.0
					dx, dy = whereX - xx, whereY - yy
					angle = math.atan2(dy, dx) + angle_difference
					new_x = int(xx + math.cos(angle) * distance)
					new_y = int(yy + math.sin(angle) * distance)
					target_location = (whereX), int(whereY)
					stuck = self.is_character_stuck(target_location)
					if stuck:
						if isGF:
							if not eXLib.IsPositionBlocked(int(new_x), int(new_y)):
								if self.unstuckCB.checked==1:
									self.walkTele(new_x, new_y)
								self.useHorseSkillFunc()
						else:
							if self.unstuckCB.checked==1:
								self.walkTele(new_x, new_y)
							self.useHorseSkillFunc()
						
				else:
					if self.fixedRange.checked == 1:
						if self.goToInitial.checked==1:
							(x, y, z) = player.GetMainCharacterPosition()
							if not self.inside_circle(x, y, rangeX, rangeY, 350):
								self.goingFunction(str(self.farmGoingMethod.GetCurrentText()), int(rangeX),int(rangeY), 1)
								# if self.unstuckCB.checked==1 and str(self.farmGoingMethod.GetCurrentText()) == 'Walking' or str(self.farmGoingMethod.GetCurrentText()) == 'Camera movement':
								xx, yy, zz = player.GetMainCharacterPosition()
			
								distance = getRandom(50, 1000)
								angle_difference = getRandom(-10, 10) / 100.0
								dx, dy = rangeX - xx, rangeY - yy
								angle = math.atan2(dy, dx) + angle_difference
								new_x = int(xx + math.cos(angle) * distance)
								new_y = int(yy + math.sin(angle) * distance)
								target_location = (int(rangeX), int(rangeY))
								stuck = self.is_character_stuck(target_location)
								if stuck:
									if isGF:
										if not eXLib.IsPositionBlocked(int(new_x), int(new_y)):
											if self.unstuckCB.checked==1:
												self.walkTele(new_x, new_y)
											self.useHorseSkillFunc()
									else:
										if self.unstuckCB.checked==1:
											self.walkTele(new_x, new_y)
										self.useHorseSkillFunc()
							else:
								if self.farmGoingMethod.GetCurrentText() == 'Camera movement':
									if foundx64PythonList:
										onKeyUp(player.DIR_UP)	
									else:
										onKeyUp(appKey('UP'))
				if self.changeCHNothing.checked==1:
					if not eventHandler.has('changeChSequence'):
						eventHandler.add(int(changeCH), self.checkGoCh, 'changeChSequence')
				if self.relogNothing.checked==1:
					if find_string(st_cur_server, "SoW2") or find_string(st_cur_server, "rubinum") or find_string(st_cur_server, "m2classic") or find_string(st_cur_server, "warcry") or find_string(st_cur_server, "newland") or find_string(st_cur_server, "zenit") or find_string(st_cur_server, "hylox") or find_string(st_cur_server, "ashiro") or find_string(st_cur_server, "Zemia") or find_string(st_cur_server, "Sancy") or find_string(st_cur_server, "lucerna") or find_string(st_cur_server, "veshia") or find_string(st_cur_server, "rhodium") or find_string(st_cur_server, "next2play"):
						try:
							whh = int(self.dungeonNumber.GetText())
						except:
							msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: " + lang.ERR_DUNG_NUMBER)
							whh = 1
						if not eventHandler.has('changeChSequence'):
	
							eventHandler.add(int(changeCH), lambda: self.goToDungFunc(int(whh)), 'changeChSequence')
			
					else:
						if not eventHandler.has('changeChSequence'):
							eventHandler.add(int(changeCH), lambda: self.UnHookQuestWindow(1), 'changeChSequence')
				if self.restartNothing.checked==1:
					eventHandler.add(int(changeCH), self.restartFarmbot, 'changeChSequence')
	def dungeonInfoMsg(self):
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: Use one of the ID's below to enter specific dungeon:")
		msg("")
		if find_string(st_cur_server, "m2classic"):
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 0 goes into dungeon: Demon tower")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 1 goes into dungeon: Spider Queen's nest")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 2 goes into dungeon: Dragon lair")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 3 goes into dungeon: Devils catacomb")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 4 goes into dungeon: Razador")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 5 goes into dungeon: Nemere")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 6 goes into dungeon: Temple of Akzadur")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 7 goes into dungeon: Temple of Wu-Kong")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 8 goes into dungeon: Erebos")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 9 goes into dungeon: Meley")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 10 goes into dungeon: Ignail")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 11 goes into dungeon: Ship defense")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 12 goes into dungeon: Zodiac")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 13 goes into dungeon: Razador RX")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 14 goes into dungeon: Nemere RX")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 15 goes into dungeon: Dragon lair RX")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 16 goes into dungeon: Erebos RX")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 17 goes into dungeon: Exedyar")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 18 goes into dungeon: Blizzard fortress easy")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 19 goes into dungeon: Blizzard fortress hard")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 20 goes into dungeon: Serpent Temple")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 21 goes into dungeon: Enigma Temple")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 22 goes into dungeon: Northwind Deeps")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 23 goes into dungeon: Sungmahi Temple")
		elif find_string(st_cur_server, "hylox"):
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 0 -> Monkey's cave")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 1 -> Ork labyrinth")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 2 -> Death ripper")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 3 -> Spider Queen's nest")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 4 -> Ice dungeon")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 5 -> Devils catacomb")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 6 -> Dragon lair")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 7 -> Razador")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 8 -> Nemere")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 9 -> Jotun")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 10 -> Cursed Christmas Dungeon")
		elif find_string(st_cur_server, "newland"):
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 1 -> Catacombs")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 2 -> Druid")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 3 -> 1st 90 Level Dungeon")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 4 -> 2nd 90 Level Dungeon")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 5 -> 130 Level Dungeon")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 6 -> 70 Level Dungeon")
		elif find_string(st_cur_server, "zenit"):
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 1 -> Orc Maze")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 2 -> Monkey Trails")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 3 -> Spiderbaroness")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 4 -> Devil Tower")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 5 -> Devils Catacomb")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 6 -> Blue Dragon Dungeon")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 7 -> Razador")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 8 -> Nemere")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 9 -> Temple of the Horde")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 10 -> Jungle of Arachnids")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 11 -> Hellish Islands")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 12 -> Purple Crystal Cave")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 13 -> Nightmare Forest")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 14 -> Ship Defense")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 15 -> Meley's Lair")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 16 -> Zodiac Temple")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 17 -> Serpent Temple")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 18 -> Sung Mahi Tower")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 19 -> Palace of Akzadur")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 20 -> Sung Mahi Tower (Mythic)")
		elif find_string(st_cur_server, "warcry"):
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 1 -> Devil Catacomb")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 2 -> Beran-Setaou")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 3 -> Razador")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 4 -> Nemere")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 5 -> Hydra")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRejoin Dungeon: ID: 6 -> Zodiac Temple")
	def goToDungFunc(self, where):
		eventHandler.remove('changeChSequence')
		if find_string(st_cur_server, "lucerna") or find_string(st_cur_server, "next2play"):
			appInst.instance().NewNet().SendRequestDungeonWarp(int(where))
		elif find_string(st_cur_server, "ashiro"):
			quest_id_map = {
				0: 4834,
				1: 1909,
				2: 40026,
				3: 1929,
				4: 40042,
				5: 40033,
				6: 40009,
				7: 1915,
				8: 60038,
				9: 60044,
				10: 60049,
				11: 60549,
				12: 60554,
				13: 40142,
				14: 40166,
				15: 40148,
				16: 40161,
				17: 1918,
				18: 60072,
				19: 60060,
				20: 40126
			}
			def enterDungeon(quest_index):
				if quest_index in quest_id_map:
					quest_id = quest_id_map[quest_index]
					event.QuestButtonClick(16)
					# msg("ID: " + str(quest_index) + " ENTER ID: " + str(quest_id))
					net.SendQuestInputStringPacket('ENTER#' + str(quest_id) + '#0')
					event.SelectAnswer(0, 0)
			enterDungeon(where)
			
		elif find_string(st_cur_server, "hylox"):
			quest_id_map = {
				0: 600,
				1: 694,
				2: 1093,
				3: 2092,
				4: 9700,
				5: 2598,
				6: 2493,
				7: 6091,
				8: 6191,
				9: 6418,
				10: 9704
			}
			def enterDungeon(quest_index):
				if quest_index in quest_id_map:
					quest_id = quest_id_map[quest_index]
					event.QuestButtonClick(100)
					net.SendQuestInputStringPacket('WARP#' + str(quest_id))
			enterDungeon(where)	
			
		elif find_string(st_cur_server, "zenit"):
			quest_id_map = {
				1: 1,
				2: 2,
				3: 3,
				4: 4,
				5: 5,
				6: 6,
				7: 7,
				8: 8,
				9: 9,
				10: 10,
				11: 11,
				12: 12,
				13: 13,
				14: 14,
				15: 15,
				16: 16,
				17: 17,
				18: 18,
				19: 19,
				20: 20
			}
			# msg(quest_id_map)
			def enterDungeon(quest_index):
				# msg(quest_index)
				if quest_index in quest_id_map:
					# msg("1_!")
					quest_id = quest_id_map[quest_index]
					# msg(quest_id)
					event.QuestButtonClick(153, True)
					# msg("2_!")
					net.SendQuestInputStringPacket(str(quest_id))
					# msg("3_!")
					net.SendQuestInputStringPacket('')
					# msg("4_!")
			enterDungeon(where)			
		elif find_string(st_cur_server, "newland"):
			quest_id_map = {
				1: 1,
				2: 2,
				3: 3,
				4: 4,
				5: 5,
				6: 8,
			}
			def enterDungeon(quest_index):
				if quest_index in quest_id_map:
					quest_id = quest_id_map[quest_index]
					net.SendTeleportWarp(4, int(quest_id))
			enterDungeon(where)
			
		elif find_string(st_cur_server, "rubinum"):
			quest_id_map = {
				0 : 'deviltower_new',
				1 : 'sd3_new',
				2 : 'dragon_lair',
				3 : 'devilcatacomb_new',
				4 : 'flame_dungeon',
				5 : 'snow_dungeon',
				6 : 'akzadur_dungeon',
				7 : 'ape_temple',
				8 : 'erebos',
				9 : 'meley_hort',
				10 : 'ignail_dawn',
				11 : 'defensewave',
				12 : 'zodiac_temple',
				13 : 'flame_dungeon_rx',
				14 : 'snow_dungeon_rx',
				15 : 'dragon_lair_rx',
				16 : 'erebos_rx',
				17 : 'exedyar_dungeon',
				18 : 'blizzard_fortress_low',
				19 : 'blizzard_fortress',
				20 : 'serpent_temple',
				21 : 'enigma_temple',
				22 : 'northwind_deeps',
				23 : 'sungmahi_temple'
			}
			def enterDungeon(quest_index):
				if quest_index in quest_id_map:
					quest_id = quest_id_map[quest_index]
					net.SendDungeonJoinRequestPacket(quest_id, 0, True)
			enterDungeon(where)
		elif find_string(st_cur_server, "warcry"):
			quest_id_map = {
				1: 2598,
				2: 2493,
				3: 6091,
				4: 6191,
				5: 3960,
				6: 2900,
			}
			def enterDungeon(quest_index):
				if quest_index in quest_id_map:
					quest_id = quest_id_map[quest_index]
					SendChatPacket('/track_window teleport ' + str(int(quest_id)))
			enterDungeon(where)
		else:
			appInst.instance().GetNet().SendRequestDungeonWarp(int(where))
	def farmingFunc2Off(self):
		global canSearch,tempVid,changeTargetIndex,switchMetin,banList,farmEnable,temp_metin_vid,canMove,countVidReset,callFncList,requiresRouteCheck
		global checkHPTimes,isGF,tpTriggered,vidsListEnd1,restartCounter,current_index
		global globalFarmingKilled, last_counted_targets,globalFarmingStartTime
		globalFarmingKilled = {
			"metins": 0,
			"mobs": 0,
			"bosses": 0,
			"ores": 0,
		}
		last_counted_targets = {}
		globalFarmingStartTime = 0
		
		self.farmingx2Func.XX1(9999999)
		self.farmingx2Func.XX2(self.farmingFunc2Off)
		Attack(False)
		self.Debug()
		canWalkTele = 0
		tempVid = 0
		farmEnable = 0
		switchMetin = 0
		temp_metin_vid = 0
		changeTargetIndex = 0
		countVidReset = 0
		checkHPTimes = 0
		canMove = 1
		
		tpTriggered = 0
		current_index = 0
		requiresRouteCheck = 1
		# vidsListEnd1 = []
		restartCounter = 0
		banList = []
		callFncList = []
		eventHandler.remove("goingFunc")
		eventHandler.remove("farmingFunc2")
		eventHandler.remove("walkTele")
		eventHandler.remove('changeChSequence')
		eventHandler.remove('checkCh')
		UnHookSetHPTargetBoard()
		if foundx64PythonList:
			onKeyUp(player.DIR_UP)	
		else:
			onKeyUp(appKey('UP'))
		self.Debug()
		if isGF:
			self.GoToPositionAvoidingObjectsStop()
	def restartFarmbot(self):	
		self.onOffFarmbot(False, False)
		self.onOffFarmbot(True)
	def setRot(self,vid):		
		myInstance = getCharIndex()
		chr.SelectInstance(myInstance)
		get = self.getDegree(vid)
		chr.SetRotation(get)
	def disableRoute(self):
		self.farmbyRouteCB.OnToggleUp()
		self.newRouteNameLbl.Hide()
		self.newRouteNameVal.Hide()
		self.newrouteName.Hide()
		self.newRouteRecordBtn.Hide()
		self.currentRouteLbl.Hide()
		try:
			self.routeListbox.Hide()
		except:
			pass
		self.newloadRouteBtn.Hide()
		self.newclearRouteBtn.Hide()
		self.newrefreshRouteListBtn.Hide()
		self.runRouteBackwards.Hide()
		self.dontKs.SetPosition(233,30)
		try:
			self.startFarmingBtn.SetPosition(230, 80)
		except:
			pass
		try:
			self.startFarmingBtn2.SetPosition(230, 80)
		except:
			pass
		self.useHorseSkill.SetPosition(230,130)
		self.initRouteClosest.Hide()
	def disableRange(self):
		self.farmInRangeCB.OnToggleUp()			
		self.newRouteNameLbl.Show()
		self.newRouteNameVal.Show()
		self.newrouteName.Show()
		self.newRouteRecordBtn.Show()
		self.currentRouteLbl.Show()
		try:
			self.routeListbox.Show()
		except:
			pass
		self.newloadRouteBtn.Show()
		self.newclearRouteBtn.Show()
		self.newrefreshRouteListBtn.Show()
		self.initRouteClosest.Show()
		self.runRouteBackwards.Show()
		self.dontKs.SetPosition(300,30)
		try:
			self.startFarmingBtn.SetPosition(230, 22)
		except:
			pass
		try:
			self.startFarmingBtn2.SetPosition(230, 40)
		except:
			pass
		if self.farmOreCB.checked==1 and self.farmbyRouteCB.checked==1:
			self.useHorseSkill.SetPosition(120,185)
		else:
			self.useHorseSkill.SetPosition(120,155)
		try:
			self.refreshRouteListFunc()
		except:
			pass
	def hideGoTo(self):
		self.goToInitial.Hide()
		self.decreaseBtn.Hide()
		self.newFarmRangeTxt.Hide()
		self.newFarmRangeVal.Hide()
		self.increaseBtn.Hide()
		self.farmRangeLbl.Hide()
	def showGoTo(self):
		self.goToInitial.Show()
		self.decreaseBtn.Show()
		self.newFarmRangeTxt.Show()
		self.newFarmRangeVal.Show()
		self.increaseBtn.Show()
		self.farmRangeLbl.Show()
	def goToInitialFunc(self):
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: " + lang.FIXED_RANGE_INFO)
	def disableBossFarm(self):
		if self.farmOreCB.checked==1:
			self.farmOreCB.OnToggleUp()
	def disableBoss(self):	
		self.disableOre()
	def disableMetins(self):				
		global temp_metin_vid
		self.disableOre()
	def enableOnlyPick(self):
		orange = "|cFFFF8040|H|h"
		if not self.force.checked:
			self.onlyPickup.OnToggleUp()
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPickup: " + lang.ONLY_PICKUP1)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPickup: " + str(orange) + lang.ONLY_PICKUP2)
			return
	def randomiMiningTimeInfo(self):
		myDelay = str(self.TimeMiningOreVal.GetText())
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.RANDOMIZE_MINING_TIME_INFO + "'" + str(myDelay) + "' " + lang.RANDOMIZE_MINING_TIME_INFO2)
	def disableOre(self):		
		if self.farmOreCB.checked==1:
			self.farmOreCB.OnToggleUp()
		self.hideOreMenu()
	def showOreMenu(self):
		global temp_metin_vid
		if self.farmMobCB.checked==1 or self.farmMetinsCB.checked==1 or self.farmBossCB.checked==1:
			self.farmMobCB.OnToggleUp()
			self.farmMetinsCB.OnToggleUp()
			self.farmBossCB.OnToggleUp()
			self.farmOreCB.OnToggleDown()
		else:
			self.lblWhatToMine.Show()
			try:
				self.NewminingList.Show()
			except:
				pass
			self.randomizeMiningTime.Show()
			self.lblTimeMiningOre.Show()
			self.TimeMiningOreText.Show()
			self.TimeMiningOreVal.Show()
			self.newaddCustomOreBtn.Show()
			if self.farmbyRouteCB.checked==1:
				self.useHorseSkill.SetPosition(120,185)
	def hideOreMenu(self):
		global temp_metin_vid
		self.lblWhatToMine.Hide()
		try:
			self.NewminingList.Hide()
		except:
			pass
		self.randomizeMiningTime.Hide()
		self.lblTimeMiningOre.Hide()
		self.TimeMiningOreText.Hide()
		self.TimeMiningOreVal.Hide()
		self.newaddCustomOreBtn.Hide()
		if self.farmbyRouteCB.checked==1:
			self.useHorseSkill.SetPosition(120,155)
	def classicBtnDisable(self):
		if self.startFarmingBtn2.IsDown:
			self.onOffFarmbot(False)
			self.startFarmingBtn2.SetUp()
			self.startFarmingBtn2.Hide()
			try:
				self.startFarmingBtn.Show()
			except:
				pass
			if self.farmbyRouteCB.checked==1:
				self.startFarmingBtn2.SetPosition(230, 40)
				try:
					self.startFarmingBtn.SetPosition(230, 22)
				except:
					pass
			else:
				try:
					self.startFarmingBtn.SetPosition(230, 80)
				except:
					pass
				self.startFarmingBtn2.SetPosition(230, 80)
		else:
			self.startFarmingBtn2.Hide()
			try:
				self.startFarmingBtn.Show()
			except:
				pass
			if self.farmbyRouteCB.checked==1:
				self.startFarmingBtn2.SetPosition(230, 40)
				try:
					self.startFarmingBtn.SetPosition(230, 22)
				except:
					pass
			else:
				try:
					self.startFarmingBtn.SetPosition(230, 80)
				except:
					pass
				self.startFarmingBtn2.SetPosition(230, 80)
	def classicBtnEnable(self):
		try:
			if self.startFarmingBtn.isOn:
				self.startFarmingBtn.SetOff()
				self.onOffFarmbot(False)
				try:
					self.startFarmingBtn.Hide()
				except:
					pass
				self.startFarmingBtn2.Show()
				if self.farmbyRouteCB.checked==1:
					self.startFarmingBtn2.SetPosition(230, 40)
					try:
						self.startFarmingBtn.SetPosition(230, 22)
					except:
						pass
				else:
					try:
						self.startFarmingBtn.SetPosition(230, 80)
					except:
						pass
					self.startFarmingBtn2.SetPosition(230, 80)
			else:
				try:
					self.startFarmingBtn.Hide()
				except:
					pass
				self.startFarmingBtn2.Show()
				if self.farmbyRouteCB.checked==1:
					self.startFarmingBtn2.SetPosition(230, 40)
					try:
						self.startFarmingBtn.SetPosition(230, 22)
					except:
						pass
				else:
					try:
						self.startFarmingBtn.SetPosition(230, 80)
					except:
						pass
					self.startFarmingBtn2.SetPosition(230, 80)
		except:
			try:
				self.startFarmingBtn.Hide()
			except:
				pass
			self.startFarmingBtn2.Show()
			if self.farmbyRouteCB.checked==1:
				self.startFarmingBtn2.SetPosition(230, 40)
				try:
					self.startFarmingBtn.SetPosition(230, 22)
				except:
					pass
			else:
				try:
					self.startFarmingBtn.SetPosition(230, 80)
				except:
					pass
				self.startFarmingBtn2.SetPosition(230, 80)
			# pass
	def uncheckUseHorse(self):
		global setMountVnumFarm,setMountVnumFarmSlot
		
		if setMountVnumFarm == 0:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hUse mount: " + lang.PLACE_MOUNT_SLOT)
		else:
			self.useHorse_func()
			
		self.useHorseCB.OnToggleUp()
	def disableQuestHorseInfo(self):
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hUse horse: " + lang.NO_MSG_USE_HORSE1)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hUse horse: " + lang.NO_MSG_USE_HORSE2)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hUse horse: " + lang.NO_MSG_USE_HORSE3)
	def uncheckUseMount(self):
		self.useMount.OnToggleUp()
		self.useHorse_func()
	def enableSwitchArmor(self):
		self.skipAnim.OnToggleUp()
	def enableSkipAnim(self):
		self.switchArmor.OnToggleUp()
############ NEW PICK ############
	def SetPickSpeed(self):
		global pickSpeed
		self.pickUpSpeed = round(float(self.pickupSpeed.GetSliderPos()*10),1)
		if find_string(st_cur_server, "Stellaria"):
			if self.pickUpSpeed == 0.00:
				self.pickUpSpeed = 0.30
		else:
			if self.pickUpSpeed == 0.00:
				self.pickUpSpeed = 0.01
		self.lblPickSpeed.SetText('%0.2f s' % self.pickUpSpeed)
		pickSpeed = self.pickUpSpeed
	def pickupFunc(self):
		if not isConnect():
			return
	
		server = st_cur_server.lower()
	
		def has_attr_call(attr):
			if hasattr(player, attr):
				try:
					getattr(player, attr)()
				except:
					pass
	
		try:
			if ("shiro" in server and "ashiro" not in server) or "loranda" in server:
				import cfg
				mode = int(cfg.Get(cfg.SAVE_OPTION, "pickup_filter_mode", "0"))
				flag = int(cfg.Get(cfg.SAVE_OPTION, "pickup_filter_flag", "0"))
				net.PickFilteredItem(mode, flag)
				return
			if "ava" in server and "avaris2" not in server:
				player.PickCloseItemVector()
				return
	
			simple_map = {
				("verion", "requilion"): lambda: player.PickCloseItemVector(),
				("darksouls",): lambda: [player.PickAllItems(), player.PickCloseItem()],
				("legendofmetin",): lambda: net.SendItemPickUpPacket(0),
				("oficial",): lambda: [SendChatPacket("/hair 0 " + str(getRandom(100, 999))), player.PickCloseItem()],
				("dark", "tamidia", "alune"): lambda: player.PickCloseItem(),
				("naira",): lambda: [player.PickCloseItem(0), player.PickCloseItem(1)],
				("neyura",): lambda: [player.PickCloseItemVector(), player.PickCloseItemVectorNew()],
				("atheria",): lambda: [player.PickCloseItemVector(), player.PickCloseItem()],
				("sow2", "zemia", "sancy", "imperiaworld", "lucerna", "veshia", "rhodium", "next2play"): lambda: player.PickCloseItem(),
				("velor",): lambda: player.PickCloseItemAround(),
				("aleris",): lambda: player.PickCloseItemAround(),
				("emerald",): lambda: [player.PickCloseItem(), player.PickCloseItemVector(), net.SendItemPickUpPacket()],
				("emtgen",): lambda: player.PickCloseItemVector(0),
				("metin2br",): lambda: onKeyDown(appKey('Z')),
				("2009", "hardmt2"): lambda: net.SendItemPickUpPacket(1),
				("nova",): lambda: player.PickAroundItems(),
				("rohan",): lambda: [player.PickCloseAutoItem(), player.PickCloseItem(), player.PickCloseItemVector()],
				("aegma",): lambda: [player.PickCloseItem(), player.PickCloseItems()],
				("tzmt",): lambda: player.PickAllCloseItems(),
			}
	
			for keywords, action in simple_map.items():
				for keyword in keywords:
					if keyword in server:
						action()
						return
	
			if "origins" in server:
				has_attr_call('PickCloseItemAround')
				has_attr_call('PickCloseItem')
				return
	
			has_attr_call('PickTheItem')
			has_attr_call('PickAllItems')
			has_attr_call('PickCloseItemVector')
	
			# Fallback logic
			if self.pickItemsAtOnce.checked == 1:
				for func in ['PickCloseItemVector', 'PickCloseItemAll', 'PickAllCloseItems', 'PickCloseItem']:
					has_attr_call(func)
	
				try:
					pickup_whitelist = []
					Picker = textTail.Pick
					for y in range(125, 600, 9):
						for x in range(300, 825, 31):
							iVID = Picker(x, y)
							if iVID != -1 and iVID not in pickup_whitelist:
								pickup_whitelist.append(iVID)
					for i in pickup_whitelist:
						net.SendItemPickUpPacket(i)
				except:
					pass
			else:
				has_attr_call('PickCloseItem')
	
		except:
			pass
	def pickupNormalStop(self):
		global pickupState
		self.pickupNormalxStart.XX1(9999999)
		self.pickupNormalxStart.XX2(self.pickupNormalStop)
		if find_string(st_cur_server, "Metin2BR"):
			onKeyUp(appKey('Z'))
		pickupState = 0
		
	def pickupNormalStart(self):
		global pickupState, farmEnable, antibanList, pausePick
	
		speed = round(float(self.pickupSpeed.GetSliderPos() * 10), 1)
		speed = max(speed, 0.10)  # Ensuring a minimum value of 0.10
	
		self.pickupNormalxStart.XX1(float(speed))
		self.pickupNormalxStart.XX2(self.pickupNormalStart)
	
		if not isConnect():
			self.pickupNormalxStart.XX1(5)
			return
	
		self.filterPickup.OnToggleUp()
		self.pickupFilterFuncOff()
	
		if self.randomizePickup.checked == 1:
			try:
				if 'random' in globals():
					randomGeneratedFloat = random.uniform(0, 0.5)
					random_offset = random.uniform(-randomGeneratedFloat, randomGeneratedFloat)
					speed += random_offset
				else:
					randomInt = getRandom(0, 5)
					randomGeneratedFloat = randomInt / 10.0
					randomIntForOffset = getRandom(0, int(randomGeneratedFloat * 10))
					randomOffsetFloat = randomIntForOffset / 10.0
					random_offset = randomOffsetFloat - randomGeneratedFloat
					speed += random_offset
			except:
				pass
	
		pickupState = 1
	
		if pausePick:
			return
		
	
		if not (self.onlyPickup.checked == 1 and farmEnable == 1):
			self.pickupFunc()
	def pickupFilterFunc(self):
		self.pickupNormalStop()
		self.normalPickup.OnToggleUp()
		global pickupFilterwhitelist,pickupFilter_White_List,ITEM_FILTER_LIST
		speed = round(float(self.pickupSpeed.GetSliderPos()*3),1)
		self.pickupFilterFuncx.XX1(float(speed))
		self.pickupFilterFuncx.XX2(self.pickupFilterFunc)
		if not isConnect():
			self.pickupFilterFuncx.XX1(8)
			self.pickupFilterFuncx.XX2(self.pickupFilterFunc)
			return
		Picker=textTail.Pick
		for y in range(125,600,9):
			for x in range(300,825,31):
				iVID = Picker(x, y)
				if iVID != -1 and iVID not in pickupFilterwhitelist:
					for i in range(35):
						if iVID!=Picker(x-i,y):
							if Picker(x-i+1,y)==iVID:
								itemPosition_onGround=x-i
					for i in range(500):
						if iVID!=Picker(x+i,y):
							if iVID==Picker(x+i-1,y):
								itemPosition_onGround_y=x+i
								f=itemPosition_onGround_y-itemPosition_onGround+1
								for a in self.ITEM_FILTER_LIST:
									if f==a:
										pickupFilter_White_List.append(iVID)
					pickupFilterwhitelist.append(iVID)
		if pickupFilterwhitelist:
			for i in pickupFilter_White_List:
				net.SendItemPickUpPacket(i)
	def pickupFilterFuncOff(self):
		self.pickupFilterFuncx.XX1(9999999)
		self.pickupFilterFuncx.XX2(self.pickupFilterFunc)
	def if_remove_item_btn_func(self):
		global pickupFilterwhitelist
		count = 0
		selItem=self.if_list_list_white.GetSelectedItem()
		if selItem:
			selected = selItem.GetText().split(" : ")
			for i in self.ITEM_FILTER_WHITELIST:
				if selected[0] == i["vnum"]:
					self.ITEM_FILTER_WHITELIST.pop(count)
					self.if_list_list_white.RemoveItem(selItem)
					break
				count += 1
			try:
				self.if_list_list_white.RemoveAllItems()
			except:
				pass
		pickupFilterwhitelist=[]
	def if_add_item_btn_func(self):
		pickupFilterwhitelist=[]
		Picker=textTail.Pick
		for y in range(125,1600,9):
			for x in range(300,1825,31):
				iVID = Picker(x, y)
				if iVID != -1 and iVID not in pickupFilterwhitelist:
					for i in range(500):
						if iVID!=Picker(x-i,y):
							if Picker(x-i+1,y)==iVID:
								itemPosition_onGround=x-i
					for i in range(500):
						if iVID!=Picker(x+i,y):
							itemPosition_onGround_y=x+i
							self.ITEM_FILTER_LIST.append(itemPosition_onGround_y-itemPosition_onGround+1)
							f=str(itemPosition_onGround_y-itemPosition_onGround+1)
							self.if_list_list_white.AppendItem(Item(f))
							break
					pickupFilterwhitelist.append(iVID)
############ NEW PICK ############
	def removeMonsterList(self):
		ignoreFile = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'monsters_to_ignore.txt'
		
		try:
			os.remove(ignoreFile)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.MOB_LIST_REM_OK)
		except:
			pass
			
	def ignoreMonsterFunc(self):
		vid = player.GetTargetVID()
		
		if not vid:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hIgnore monsters: " + lang.NO_TARGET)
			return
			
		chr.SelectInstance(vid)
		mobId=chr.GetRace(vid)
		name = chr.GetNameByVID(vid)
		orange = "|cFFFF8040|H|h"
		yellow = "|cffFFFF00|H|h"
		
		
		dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'monsters_to_ignore.txt'
		
		if not self.fileExists(dirPl):
			non_detect = open_file(dirPl, "w")
			non_detect.close()
		
		file = open_file(dirPl, "r+")
		openedFile = file.read()
		file.close()
		if(str(mobId) in str(openedFile)):
			text =  "[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hIgnore monsters: Mob with name " + orange + str(name) + yellow + " already exists!"
			msg(str(text))
			return
		else:
			non_detect = open_file(dirPl, "a")
			non_detect.write('\n')
			non_detect.write(str(mobId))
			non_detect.close()
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hIgnore monsters: Succesfully added " + orange + str(name) + yellow + " to ignore list.")
			return
	def ignoreMetinFunc(self):
		vid = player.GetTargetVID()
		
		if not vid:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hIgnore metins: " + lang.NO_TARGET)
			return
			
		chr.SelectInstance(vid)
		mobId=chr.GetRace(vid)
		name = chr.GetNameByVID(vid)
		orange = "|cFFFF8040|H|h"
		yellow = "|cffFFFF00|H|h"
		dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'metins_to_ignore.txt'
		
		if not self.fileExists(dirPl):
			non_detect = open_file(dirPl, "w")
			non_detect.close()
		
		file = open_file(dirPl, "r+")
		openedFile = file.read()
		file.close()
		if(str(mobId) in str(openedFile)):
			text =  "[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hIgnore metins: Metin with name " + orange + str(name) + yellow + " already exists!"
			msg(str(text))
			return
		else:
			non_detect = open_file(dirPl, "a")
			non_detect.write('\n')
			non_detect.write(str(mobId))
			non_detect.close()
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hIgnore metins: Succesfully added " + orange + str(name) + yellow + " to ignore list.")
			return
			
			
			
			
			
			
			
	def pullRod(self):
		if self.fix_fishbot.checked==1:
			if find_string(st_cur_server, "tiks") or find_string(st_cur_server, "shinra"):
				skillId = 109
			else:
				skillId = 102
			player.ClickSkillSlot(int(skillId))
		else:
			if find_string(st_cur_server, "oficial"):
				randomInt = getRandom(100, 999)
				SendChatPacket("/hair 1 " + str(randomInt))
			Attack(True)
			Attack(False)
	def set_all_off(self):
		if self.orefarm.checked==1:
			self.orefarm.OnToggleUp()
		if self.metinfarm.checked==1:
			self.metinfarm.OnToggleUp()
		if self.bossfarm.checked==1:
			self.bossfarm.OnToggleUp()
		if self.mobfarm.checked==1:
			self.mobfarm.OnToggleUp()
	def set_ore_off(self):
		global canTeleport
		canTeleport = 0
		self.miningListF3.Hide()
		if self.orefarm.checked==1:
			self.orefarm.OnToggleUp()
		if self.metinfarm.checked==1:
			self.metinfarm.OnToggleUp()
		if self.farmAll.checked==1:
			self.farmAll.OnToggleUp()
		self.farmBotIIStop()
		self.farmOreFunc_Off()
		self.farmbotlolOff()
		self.freeze_funcOff()
		self.startFarm3Btn.SetUp()
	def set_metin_on(self):	
		if self.bossfarm.checked==1:
			self.bossfarm.OnToggleUp()
		if self.mobfarm.checked==1:
			self.mobfarm.OnToggleUp()
		try:
			if self.farmAll.checked==1:
				self.farmAll.OnToggleUp()
			self.miningListF3.Hide()
		except:
			pass
		if self.orefarm.checked==1:
			self.orefarm.OnToggleUp()
	def set_metin_off(self):
		global canTeleport
		canTeleport = 0
		if self.metinfarm.checked==1:
			self.metinfarm.OnToggleUp()
		self.farmBotIIStop()
		self.farmOreFunc_Off()
		self.farmbotlolOff()
		self.freeze_funcOff()
		self.startFarm3Btn.SetUp()
	def hideMiningList(self):	
		self.miningListF3.Hide()
	def set_mobmb_off(self):
		global canTeleport
		canTeleport = 0
		if self.farmAll.checked==1:
			self.farmAll.OnToggleUp()
		if self.metinfarm.checked==1:
			self.metinfarm.OnToggleUp()
		if self.bossfarm.checked==1:
			self.bossfarm.OnToggleUp()
		if self.mobfarm.checked==1:
			self.mobfarm.OnToggleUp()
		if self.orefarm.checked==1:
			self.miningListF3.Show()
		if not self.orefarm.checked==1:
			self.miningListF3.Hide()
		self.farmBotIIStop()
		self.farmOreFunc_Off()
		self.farmbotlolOff()
		self.freeze_funcOff()
		self.startFarm3Btn.SetUp()
	def fishes_Func(self, arg):
		if arg=='on':
			self.pnlFishes.Show()
			self.pnlFishbot.Hide()
			self.fishMain.SetUp()
			self.fishesBtn.Down()
		elif arg=='off':
			self.pnlFishes.Hide()
			self.pnlFishbot.Show()
			self.fishMain.Down()
			self.fishesBtn.SetUp()
	def fishMain_Func(self, arg):
		if arg=='on':
			self.pnlFishes.Hide()
			self.pnlFishbot.Show()
			self.fishMain.Down()
			self.fishesBtn.SetUp()
		elif arg=='off':
			self.pnlFishes.Show()
			self.pnlFishbot.Hide()
			self.fishMain.SetUp()
			self.fishesBtn.Down()
	def isAliveNew(self, vid):
		HookSetHPTargetBoard()
		global getHPTarget
		chr.SelectInstance(vid)
		setTarget(vid)
		if getHPTarget == 0:
			return False
		return True
	def isAlive(self, vid):
		vidInfo = str(chrmgr.GetVIDInfo(vid))
		if string_contains("isAlive=1", vidInfo):
			return True
		elif string_contains("isDead=1", vidInfo):
			return False
	if find_string(st_cur_server, "Esenn"):
		def InstallQuestWindowHook(self):
			game_window_instance = game.GameWindow.instance()
			game_window_instance.OpenQuestWindow = game_window_instance.OpenQuestWindow
			game_window_instance.OpenQuestWindow = self.HookedQuestWindow
		def UnHookQuestWindow(self, relog):
			global OldRecv
			eventHandler.remove('changeChSequence')
			game_window_instance = game.GameWindow.instance()
			game_window_instance.OpenQuestWindow = game_window_instance.OpenQuestWindow
			game_window_instance.OpenQuestWindow = OldRecv
			if relog:
				self.relogMe()
	else:
		def InstallQuestWindowHook(self):
			game.GameWindow.OpenQuestWindow = self.HookedQuestWindow
		def UnHookQuestWindow(self, relog):
			global game,OldRecv
			try:
				if not game:
					import game
				game.GameWindow.OpenQuestWindow = OldRecv
			except:
				pass
			eventHandler.remove('changeChSequence')
			if relog:
				self.relogMe()
	def HookedQuestWindow(self, skin, idx):
		pass
	def plusDist(self):
		initialDelay = self.telDis.GetText()
		setDelay = int(int(initialDelay) + 10)	
		self.telDis.SetText(str(setDelay))
	def minusDist(self):
		initialDelay = self.telDis.GetText()
		if int(initialDelay) > int(10):
			setDelay = int(int(initialDelay) - 10)	
			self.telDis.SetText(str(setDelay))			
		elif int(initialDelay) >= int(10):
			setDelay = int(int(initialDelay) - 9)	
			self.telDis.SetText(str(setDelay))
		else:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hHotkey teleport: " + lang.MIN_DISTANCE_H_TELEP)	
	def plus(self):
		initialDelay = self.newFarmRangeVal.GetText()
		setDelay = int(int(initialDelay) + 10)	
		self.newFarmRangeVal.SetText(str(setDelay))
	def minus(self):
		initialDelay = self.newFarmRangeVal.GetText()
		if int(initialDelay) > int(10):
			setDelay = int(int(initialDelay) - 10)	
			self.newFarmRangeVal.SetText(str(setDelay))			
		elif int(initialDelay) >= int(10):
			setDelay = int(int(initialDelay) - 9)	
			self.newFarmRangeVal.SetText(str(setDelay))
		else:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: " + lang.MIN_FARM_RANGE)	
	def applyVidRangeFunc(self):
		global maxThreshhold
		try:
			initialDelay = int(self.VidRangeVal.GetText())
		except:
			initialDelay = 100.5
		maxThreshhold = initialDelay
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: VID range set to: " + str(maxThreshhold))
	def increaseVidRangeFunc(self):
		try:
			global maxThreshhold
			initialDelay = int(self.VidRangeVal.GetText())
			setDelay = initialDelay + 100
			self.VidRangeVal.SetText(str(setDelay))
			maxThreshhold = setDelay
		except:
			pass
	def disableVidRange(self):
		try:
			global manualVidRange,isGF
			if not isGF:
				self.decreaseVidRangeBtn.Hide()
				self.VidRangeTxt.Hide()
				self.VidRangeVal.Hide()
				self.increaseVidRangeBtn.Hide()
				self.applyVidRangeBtn.Hide()
				manualVidRange = 0
				self.modify_setting(CONFIG, 'ManualVidRange', manualVidRange)
		except:
			pass
	def enableVidRange(self):
		global manualVidRange, isGF
		if not isGF:
			self.decreaseVidRangeBtn.Show()
			self.VidRangeTxt.Show()
			self.VidRangeVal.Show()
			self.increaseVidRangeBtn.Show()
			self.applyVidRangeBtn.Show()
			manualVidRange = 1
			self.modify_setting(CONFIG, 'ManualVidRange', manualVidRange)
			self.applyVidRangeFunc()
	def decreaseVidRangeFunc(self):
		global maxThreshhold
		initialDelay = int(self.VidRangeVal.GetText())
		setDelay = max(initialDelay - 100, 100)
		if setDelay != initialDelay:
			self.VidRangeVal.SetText(str(setDelay))
			maxThreshhold = setDelay
		else:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: " + lang.MIN_VID_RANGE)
	def minToSec(self, minutes):
		seconds = int(float(minutes) * 60)
		return seconds
		
	def useCredentialsInfo(self):
		global username, password
		
		if not username or not password:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.CREDENTIAL_INFO1)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.CREDENTIAL_INFO2)
			self.useCredentials.OnToggleUp()
			return
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.CREDENTIAL_INFO3)
	def relogBtn_func(self):
		global autologin_state,wasKickLogged
		global isGF, isChangingCH
		self.relogBtn.Hide()
		self.relogBtnStop.Show()
		self.autologin_state = 1
	
		curTime = app.GetTime()
		minutes = self.minToSec(self.waitMinutesDelay.GetText())
	
		self.relogBtn_funcx.XX1(3)
		self.relogBtn_funcx.XX2(self.relogBtn_func)
	
	
		if isChangingCH:
			return
		if isConnect():
			wasKickLogged = 0
			return
		if find_string(st_cur_server, "Metin2BR") or isGF:
			self._handle_GF_login()
		else:
			self._handle_default_login(curTime, minutes)
	
	def _handle_GF_login(self):
		global requiresLogin,isTeleporting,wasKickLogged
	
		if not isConnect() and requiresLogin and not isTeleporting:
			
			if not wasKickLogged:
				wasKickLogged = 1
				create_log("Character got kicked.")
			
			net.DirectEnter(0, 0)
			requiresLogin = False
			self.relogBtn_funcx.XX1(10)
		else:
			requiresLogin = True
	
	def _handle_default_login(self, curTime, minutes):
		global requiresLogin, isConnecting, tempRelogTime,wasKickLogged
	
		if not isConnect() and requiresLogin:
			if not wasKickLogged:
				wasKickLogged = 1
				create_log("Character got kicked.")
			eventHandler.remove('useItem')
	
			if self.waitMinCb.checked == 1:
				if curTime >= tempRelogTime:
					self._attempt_autologin()
			else:
				self._attempt_autologin()
	
			requiresLogin = False
	
			if self.useItemRelogBtn.checked == 1 and isConnect():
				eventHandler.add(10, self.use_item_relog_func, 'useItem')
	
			self.relogBtn_funcx.XX1(10)
		else:
			requiresLogin = True
			isConnecting = 0
			tempRelogTime = int(minutes)
	
	def _attempt_autologin(self):
		global username, password, authPort, channels
		if self.useCredentials.checked == 1:
			GetChannels()
			if username and password and authPort and channels:
				doLogin()
			else:
				eventHandler.add(1, self.relogMe, 'relogMe')
		else:
			eventHandler.add(1, self.relogMe, 'relogMe')
				
				
				
	def relogBtn_funcOff(self):
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hAutologin disabled.")
		self.relogBtn_funcx.XX1(9999999)
		self.relogBtn_funcx.XX2(self.relogBtn_funcOff)
		self.relogBtn.Show()
		self.autologin_state=0
		self.relogBtnStop.Hide()
	def quitIfLoggedOff(self):	
		global disconnected_seconds
		disconnected_seconds = 0
		self.quitIfxLogged.XX1(99999999)
		self.quitIfxLogged.XX2(self.quitIfLoggedOff)
	def quitIfLoggedOn(self):	
		global disconnected_seconds
		disconnected_seconds = 0
		self.count_disconnected_seconds()
		minutes = self.minToSec(self.stopquitLogout.GetText())
		try:
			sec = int(minutes)
		except:
			sec = 600
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hQuit bot: \x53\x54\x4d\x6f\x64 will close this client if logged out for more than " + str(self.stopquitLogout.GetText()) + " minutes.")
	def count_disconnected_seconds(self):
		global disconnected_seconds
		self.quitIfxLogged.XX1(1)
		self.quitIfxLogged.XX2(self.count_disconnected_seconds)
		minutes = self.minToSec(self.stopquitLogout.GetText())
		try:
			sec = int(minutes)
		except:
			sec = 600
		if not isConnect():
			disconnected_seconds += 1
			if disconnected_seconds >= sec:
				create_log("\x53\x54\x4d\x6f\x64 was ended by the bot, because was logged out for more than " + str(self.stopquitLogout.GetText()) + " minutes.")
				universalTime(0)
		else:
			disconnected_seconds = 0
	def relogBotFunc(self):
		global tempRelogBotTime
		self.relogBotxFunc.XX1(1)
		self.relogBotxFunc.XX2(self.relogBotFunc)
		curTime = app.GetTime()
		if curTime >= tempRelogBotTime and isConnect():
			if foundx64PythonList:
				self.KickMe()
			else:
				self.UnHookQuestWindow(1)
			create_log("Relogged by the bot.")
			self.relogBotOff()
			self.relogBotOn()
	def relogBotOff(self):	
		global tempRelogBotTime
		tempRelogBotTime = app.GetTime()
		self.relogBotFuncOff()
	def relogBotOn(self):	
		global tempRelogBotTime
		minutes = self.minToSec(self.relogBotDelay.GetText())
		tempRelogBotTime = app.GetTime() + int(minutes)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRelog bot: \x53\x54\x4d\x6f\x64 will relog your character each " + str(self.relogBotDelay.GetText()) + " minutes.")
		self.relogBotFunc()
	def relogBotFuncOff(self):
		self.relogBotxFunc.XX1(9999999)
		self.relogBotxFunc.XX2(self.relogBotFuncOff)
	def relogBotFunc(self):
		global tempRelogBotTime
		self.relogBotxFunc.XX1(1)
		self.relogBotxFunc.XX2(self.relogBotFunc)
		curTime = app.GetTime()
		if curTime >= tempRelogBotTime and isConnect():
			if foundx64PythonList:
				self.KickMe()
			else:
				self.UnHookQuestWindow(1)
			create_log("Relogged by the bot.")
			self.relogBotOff()
			self.relogBotOn()
	def quitBotOff(self):	
		global tempQuitTime
		tempQuitTime = app.GetTime()
		self.quitBotFuncOff()
	def quitBotOn(self):	
		global tempQuitTime
		minutes = self.minToSec(self.quitBotDelay.GetText())
		tempQuitTime = app.GetTime() + int(minutes)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hQuit bot: \x53\x54\x4d\x6f\x64 will close this client in " + str(self.quitBotDelay.GetText()) + " minutes.")
		self.quitBotFunc()
	def quitBotFuncOff(self):
		self.quitBotxFunc.XX1(9999999)
		self.quitBotxFunc.XX2(self.quitBotFuncOff)
	def quitBotFunc(self):
		global tempQuitTime
		self.quitBotxFunc.XX1(1)
		self.quitBotxFunc.XX2(self.quitBotFunc)
		curTime = app.GetTime()
		if curTime >= tempQuitTime:
			create_log("\x53\x54\x4d\x6f\x64 was ended by the bot.")
			universalTime(0)
	def stopBotOff(self):	
		global tempStopTime
		tempStopTime = app.GetTime()
		self.stopBotFuncOff()
	def stopBotOn(self):	
		global tempStopTime
		minutes = self.minToSec(self.stopBotDelay.GetText())
		tempStopTime = app.GetTime() + int(minutes)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hStop bot: Every bot function, such as farmbot, fishbot, levelbot will stop in " + str(self.stopBotDelay.GetText()) + " minutes.")
		self.stopBotFunc()
	def stopBotFuncOff(self):
		self.stopBotxFunc.XX1(9999999)
		self.stopBotxFunc.XX2(self.stopBotFuncOff)
	def stopBotFunc(self):
		global tempStopTime
		self.stopBotxFunc.XX1(1)
		self.stopBotxFunc.XX2(self.stopBotFunc)
		curTime = app.GetTime()
		if curTime >= tempStopTime:
			self.onOffFarmbot(False)
			self.StopFishBot()
			self.selectstopspam()
			self.disableReplyBotFunc()
			self.energyfunc_stop()
			self.skillUsage('off')
			create_log("\x53\x54\x4d\x6f\x64 stopped all functions.")
			self.stopBotFuncOff()
	def waitMinOff(self):	
		global tempRelogTime
		tempRelogTime = app.GetTime()
	def stopquitLevelFuncStop(self):
		self.stopquitxLevelFunc.XX1(99999999)
		self.stopquitxLevelFunc.XX2(self.stopquitLevelFuncStop)		
	def stopquitLevelFunc(self):
		global antiban_state
		self.stopquitxLevelFunc.XX1(1)
		self.stopquitxLevelFunc.XX2(self.stopquitLevelFunc)
		if not isConnect():
			self.stopquitxLevelFunc.XX1(5)
			return
		try:
			currentLevel = player.GetStatus(player.LEVEL)
			try:
				requiredLevel = int(self.stopquitLevel.GetText())
			except:
				requiredLevel = currentLevel + 1
			if currentLevel >= requiredLevel and antiban_state:
				if self.stopBotLevel.checked == 1:
					self.onOffFarmbot(False)
					self.StopFishBot()
					self.selectstopspam()
					self.disableReplyBotFunc()
					self.energyfunc_stop()
					create_log("\x53\x54\x4d\x6f\x64 stopped all functions, reached level " + str(requiredLevel) + ".")
					self.stopquitLevelFuncStop()
				elif self.quitBotLevel.checked==1:
					create_log("\x53\x54\x4d\x6f\x64 ended client, reached level " + str(requiredLevel) + ".")
					universalTime(1)
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.STR_ERR_OCCURED)
			self.stopquitLevelFuncStop()
	def disableQuitLevel(self):
		self.quitBotLevel.OnToggleUp()
		self.stopquitLevelFunc()
	def disableStopLevel(self):		
		self.stopBotLevel.OnToggleUp()
		self.stopquitLevelFunc()
	def waitMinOn(self):	
		global tempRelogTime
		minutes = self.minToSec(self.waitMinutesDelay.GetText())
		tempRelogTime = app.GetTime() + int(minutes)
	def useItemHpLowOff(self):	
		self.useItemHpLowFuncOff()
	def useItemHpLowOn(self):
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.HP_LOWER_ITEM_INFO)
		self.useItemHpLowFuncOn()
	def useItemHpLowFuncOff(self):
		self.useItemHpLowFuncxOn.XX1(9999999)
		self.useItemHpLowFuncxOn.XX2(self.useItemHpLowFuncOff)
	def useItemHpLowFuncOn(self):	
		global useItemHpLowID
		self.useItemHpLowFuncxOn.XX1(float(0.1))
		self.useItemHpLowFuncxOn.XX2(self.useItemHpLowFuncOn)
		if not isConnect():
			self.useItemHpLowFuncxOn.XX1(5)
			return
		try:
			maxhp = player.GetStatus(player.MAX_HP)
			curHp = player.GetStatus(player.HP)
			if self.useHpLower.GetText() != "":
				if (float(curHp) / float(maxhp)) * 100 < int(self.useHpLower.GetText()):
					for i in range(player.INVENTORY_PAGE_SIZE*10):
						item_index = player.GetItemIndex(i)
						if useItemHpLowID != 0:
							if item_index == (int(useItemHpLowID)):
								useItemFunc(i)	
								break
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hUse item when HP lower than: " + lang.STR_ERR_OCCURED)
			self.useItemHpLowFuncOff()
			
			
			
	def windowsNotifyOff(self):	
		global windowsNotifyOnPm
		windowsNotifyOnPm = 0
	def windowsNotifyOn(self):	
		global windowsNotifyOnPm
		windowsNotifyOnPm = 1			
			
	def beepOff(self):	
		global playBeepSound
		playBeepSound = 0
	def beepOn(self):	
		global playBeepSound
		playBeepSound = 1
	def quitifgmOff(self):	
		global quitGameIfGMPM
		quitGameIfGMPM = 0
	def quitifgmOn(self):	
		global quitGameIfGMPM,gmPmCount,gmPmCountMax
		gmPmCount = 0
		try:
			gmPmCountMax = int(self.QuitGMPMTimes.GetText())
		except:
			gmPmCountMax = 1
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBot will end the game when received " + str(gmPmCountMax) + " pm's from GM.")
		quitGameIfGMPM = 1
	def addAllUsers(self):
		try:
			fullDir = st_path + "/Data/Servers/" + str(st_cur_server) + "/Logs/"
			if not os.path.exists(fullDir):
				os.makedirs(fullDir)
			dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'player_whitelist.txt'
			files = os.listdir(fullDir)
			log_files = [f for f in files if f.endswith('.log') and f != '.log']
			log_files_without_extension = [f[:-4] for f in log_files]
			existing_names = []
			file = open_file(dirPl, "r+")
			file_lines = file.read()
			Test = str(file_lines).replace("\n", "")
			Scripts = str(Test).split(",")
			for Testies in range(int(str(file_lines).count(","))):
				if Testies not in existing_names:
					existing_names.append(Scripts[Testies])
			for x in existing_names:
				if x in log_files_without_extension:
					log_files_without_extension.remove(x)
			non_detect = open_file(dirPl, "a")
			for file_name in log_files_without_extension:
				if file_name not in existing_names:
					non_detect.write('\n')
					non_detect.write(file_name + ",")
					existing_names.append(file_name)
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer whitelist: An error occured while trying to add all \x53\x54\x4d\x6f\x64 players to whitelist.")
			pass
	def updateWhitelist(self):	
		try:
			self.addAllUsers()
			dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'player_whitelist.txt'
			if os.path.exists(dirPl):
				try:
					self.PlayersWhiteList.RemoveAllItems()
				except:
					pass
				file = open_file(dirPl, "r+")
				file_lines = file.read()
				Test = str(file_lines).replace("\n", "")
				Scripts = str(Test).split(",")
				for Testies in range(int(str(file_lines).count(","))):
					self.PlayersWhiteList.AppendItem(Item(Scripts[Testies]))
		except:
			pass
	def removeSelectedPlayer(self):
		try:
			DeleteContent = self.PlayersWhiteList.GetSelectedItem()
			if DeleteContent == None:
				return
			DeleteText = DeleteContent.GetText()
			dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'player_whitelist.txt'
			file = open_file(dirPl, "r+")
			FileString = file.read()
			NewFiles = str(FileString).replace(str(DeleteText) + str(",\n"), str(""))
			NewFiles = str(FileString).replace(str(DeleteText) + str(","), str(""))
			file.close()
			f = open_file(dirPl, "w+")
			f.write(NewFiles)
			f.close()
			self.updateWhitelist()
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer whitelist: An error occured while trying to remove selected player from whitelist.")
			return
	def askRemWhitelist(self):
		try:
			if find_string(st_cur_server, "aronix") or  find_string(st_cur_server, "metin2sg") or foundx64PythonList:
				self.QuestionDialog = uiCommon.QuestionDialog()
			else:
				self.QuestionDialog = QuestionDialog()
			self.QuestionDialog.SetText('Are you sure you want to delete entire whitelist?')
			self.QuestionDialog.SetAcceptEvent(__mem_func__(self.remWhiteList))
			self.QuestionDialog.SetCancelEvent(__mem_func__(self.CancelQuestionDialog))
			self.QuestionDialog.Open()
		except:
			pass
	def remWhiteList(self):
		try:
			dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'player_whitelist.txt'
			os.remove(dirPl)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer whitelist: Succesfully removed players whitelist.")
			try:
				self.PlayersWhiteList.RemoveAllItems()
			except:
				pass
			self.CancelQuestionDialog()
			self.updateWhitelist()
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer whitelist: An error occured while trying to remove players whitelist.")
			self.CancelQuestionDialog()
	def addNameWhitelist(self):
		global oldPython
		orange = "|cFFFF8040|H|h"
		yellow = "|cffFFFF00|H|h"
		name = self.addWhitelistName.GetText()
		dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'player_whitelist.txt'
		if not os.path.exists(dirPl):
			non_detect = open_file(dirPl, "w")
			non_detect.write('\n')
			non_detect.close()
		try:
			if self.addWhitelistName.GetText() != "":
				file = open_file(dirPl, "r+")
				currentPlayerList = str(file.read())
				file.close()
				playerFound = False
				if oldPython:
					if string_contains(name, currentPlayerList):
						playerFound = True
				else:
					if(str(name) in str(currentPlayerList)):
						playerFound = True
				if playerFound:
					text =  "[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer whitelist: Player with name " + orange + str(name) + yellow + " already exists!"
					msg(str(text))
					return
				else:	
					non_detect = open_file(dirPl, "a")
					non_detect.write('\n')
					non_detect.write(str(name) + ",")
					non_detect.close()
					self.addWhitelistName.SetText("")
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer whitelist: Succesfully added " + orange + str(name) + yellow + " to whitelist.")
					self.updateWhitelist()
					return
			else:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer whitelist: You must enter a valid name.")
				return
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer whitelist: An error occured while trying to add " + str(name) + " to players whitelist.")
			return
	def addWhitelist(self):
		global oldPython
		try:
			
			vid = player.GetTargetVID()
			name = chr.GetNameByVID(vid)
			orange = "|cFFFF8040|H|h"
			yellow = "|cffFFFF00|H|h"
			dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'player_whitelist.txt'
			if not os.path.exists(dirPl):
				non_detect = open_file(dirPl, "w")
				non_detect.write('\n')
				non_detect.close()
			file = open_file(dirPl, "r+")
			currentPlayerList = str(file.read())
			file.close()
			search_word = name
			a = chr.GetInstanceType(vid)
			
			
			if vid != 0:
				if a==playerType:
					playerFound = False
					if oldPython:
						if string_contains(name, currentPlayerList):
							playerFound = True
					else:
						if(str(name) in str(currentPlayerList)):
							playerFound = True
					if playerFound:
					# if(str(search_word) in str(currentPlayerList)):
						text =  "[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer whitelist: Player with name " + orange + str(name) + yellow + " already exists!"
						msg(str(text))
						return
					else:
						if os.path.exists(dirPl):
							non_detect = open_file(dirPl, "a")
							non_detect.write('\n')
							non_detect.write(str(name) + ",")
							non_detect.close()
							msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer whitelist: Succesfully added " + orange + str(name) + yellow + " to whitelist.")
						else:
							non_detect = open_file(dirPl, "a")
							non_detect.write('\n')
							non_detect.write(str(name) + ",")
							non_detect.close()
							msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer whitelist: Succesfully added " + orange + str(name) + yellow + " to whitelist.")
						self.updateWhitelist()
						return
				else:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer whitelist: " + orange + str(name) + yellow + " is not a player!")
					return
			else:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer whitelist: " + orange + str(name) + yellow + " is not a player!")
				return
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer whitelist: Failed adding " + orange + str(name) + yellow + " to whitelist, please add it manually!")
			return
	try:
		def getArmorInfo(self,_type,invType = 2,slot=item.EQUIPMENT_BODY):
			global armorVal
			idx = player.GetItemIndex(invType,slot)
			armorVal = idx
			if idx != 0:
				selectItem(idx)
				if item.GetItemType() == _type:
					return True
			return False
	except:
		pass
	def get_absolute_path(self, relative_path):
		return os.path.join(os.getcwd(), relative_path)
	def get_script_directory(self):
		return os.path.dirname(os.path.abspath(os.path.realpath(__file__)))
	def shiroMaps(self):
		self.newMap.SetSize(370, 440)
		self.setPoint = STButton()
		self.setPoint.SetParent(self.newMap)
		self.setPoint.SetPosition(10, 75) 
		self.setPoint.SetSize(350, 350)
		self.setPoint.SetEvent(self.SetPoint)
		self.setPoint.Show()
	def loadTeleMap(self):
		map_paths = {
			"map_a2": (1537, 1537),
			"map_n_snowm_01": (1537, 1537),
			"metin2_map_orclabyrinth": (768, 768),
			"metin2_guild_village_01": (512, 512),
			"metin2_guild_village_02": (512, 512),
			"metin2_guild_village_03": (512, 512),
			"metin2_map_a1": (1024, 1280),
			"metin2_map_a3": (1025, 1025),
			"metin2_map_b1": (1025, 1281),
			"metin2_map_b3": (1025, 1025),
			"metin2_map_BayBlackSand": (768, 1536),
			"metin2_map_c1": (1025, 1281),
			"metin2_map_c3": (1025, 1025),
			"Metin2_map_CapeDragonHead": (1536, 1536),
			"metin2_map_dawnmist_dungeon_01": (768, 1024),
			"metin2_map_dawnmistwood": (1792, 1024),
			"metin2_map_devilsCatacomb": (1792, 1792),
			"metin2_map_deviltower1": (769, 769),
			"metin2_map_e1": (512, 512),
			"metin2_map_guild_01": (513, 513),
			"metin2_map_guild_02": (513, 513),
			"metin2_map_guild_03": (513, 513),
			"metin2_map_milgyo": (1025, 1025),
			"metin2_map_monkeydungeon": (769, 769),
			"metin2_map_monkeydungeon_02": (768, 768),
			"metin2_map_monkeydungeon_03": (768, 768),
			"metin2_map_Mt_Th_dungeon_01": (768, 768),
			"metin2_map_MT_Thunder": (1024, 1536),
			"metin2_map_n_desert_01": (1536, 1536),
			"metin2_map_n_flame_01": (1536, 1536),
			"metin2_map_n_flame_dungeon_01": (768, 768),
			"metin2_map_n_snow_dungeon_01": (1024, 768),
			"metin2_map_nusluck01": (512, 512),
			"metin2_map_privateshop": (512, 512),
			"metin2_map_skipia_dungeon_01": (1536, 1536),
			"metin2_map_skipia_dungeon_02": (1536, 1536),
			"metin2_map_spiderdungeon_02": (1024, 1024),
			"metin2_map_spiderdungeon_03": (768, 768),
			"metin2_map_spiderdungeon": (768, 768),
			"metin2_map_trent02": (768, 768),
			"metin2_map_trent": (512, 512),
			"metin2_map_WL_01": (1000, 1000),
			"next_quila": (1024, 1024)
			}
			
		if find_string(st_cur_server, "nextworld"):
			mapsPath = "d:/worktree/ui/atlas/%s/atlas.slc"
		else:
			mapsPath = ymir + 'ui/atlas/%s/atlas.sub'
		def load_map_image(map_name, size, use_fallback):
			if use_fallback:
				try:
					self.MapaSlot.LoadImage(st_path + "/Data/Maps/%s.jpg" % map_name)
				except Exception:
					exc_type, exc_value, exc_traceback = sys.exc_info()
					err = exc_type.__name__
					if str('RuntimeError') in err:
						self.MapaSlot.LoadImage(mapsPath % map_name)
			else:
				self.MapaSlot.LoadImage(mapsPath % map_name)
			self.Teleport_Map_Size = size
			self.newMap.SetSize(int(self.MapaSlot.GetWidth()) + 20, int(self.MapaSlot.GetHeight()) + 86)
			self.setPoint = STButton()
			self.setPoint.SetParent(self.newMap)
			self.setPoint.SetPosition(10, 75)
			self.setPoint.SetSize(int(self.MapaSlot.GetWidth()), int(self.MapaSlot.GetHeight()))
			self.setPoint.SetEvent(self.SetPoint)
			self.setPoint.Show()
		def handle_special_map(map_name, size):
			source_path = os.path.join(st_path + "/Data/Maps/" + str(map_name))
			temp_path = map_name
			src_file = open_file(source_path, 'rb+')
			dest_file = open_file(temp_path, 'wb+')
			dest_file.write(src_file.read())
			dest_file.close()
			src_file.close()
			self.MapaSlot.LoadImage(temp_path)
			os.remove(temp_path)
			self.Teleport_Map_Size = size
			self.shiroMaps()
		try:
			special_map_cases = {
				"map_a2": (1537, 1537),
				"map_n_snowm_01": (1537, 1537),
				"metin2_map_orclabyrinth": (768, 768),
				"metin2_guild_village_01": (512, 512),
				"metin2_guild_village_02": (512, 512),
				"metin2_guild_village_03": (512, 512),
				"metin2_map_a1": (1024, 1280),
				"metin2_map_a3": (1025, 1025),
				"metin2_map_b1": (1025, 1281),
				"metin2_map_b3": (1025, 1025),
				"metin2_map_BayBlackSand": (768, 1536),
				"metin2_map_c1": (1025, 1281),
				"metin2_map_c3": (1025, 1025),
				"Metin2_map_CapeDragonHead": (1536, 1536),
				"metin2_map_dawnmist_dungeon_01": (768, 1024),
				"metin2_map_dawnmistwood": (1792, 1024),
				"metin2_map_devilsCatacomb": (1792, 1792),
				"metin2_map_deviltower1": (769, 769),
				"metin2_map_e1": (512, 512),
				"metin2_map_guild_01": (513, 513),
				"metin2_map_guild_02": (513, 513),
				"metin2_map_guild_03": (513, 513),
				"metin2_map_milgyo": (1025, 1025),
				"metin2_map_monkeydungeon": (769, 769),
				"metin2_map_monkeydungeon_02": (768, 768),
				"metin2_map_monkeydungeon_03": (768, 768),
				"metin2_map_Mt_Th_dungeon_01": (768, 768),
				"metin2_map_MT_Thunder": (1024, 1536),
				"metin2_map_n_desert_01": (1536, 1536),
				"metin2_map_n_flame_01": (1536, 1536),
				"metin2_map_n_flame_dungeon_01": (768, 768),
				"metin2_map_n_snow_dungeon_01": (1024, 768),
				"metin2_map_nusluck01": (512, 512),
				"metin2_map_privateshop": (512, 512),
				"metin2_map_skipia_dungeon_01": (1536, 1536),
				"metin2_map_skipia_dungeon_02": (1536, 1536),
				"metin2_map_spiderdungeon_02": (1024, 1024),
				"metin2_map_spiderdungeon_03": (768, 768),
				"metin2_map_spiderdungeon": (768, 768),
				"metin2_map_trent02": (768, 768),
				"metin2_map_trent": (512, 512),
				"metin2_map_WL_01": (1000, 1000),
				"next_quila": (1024, 1024)
			}
			for special_map, size in special_map_cases.items():
				if str(GetMapName()) == special_map:
					handle_special_map(special_map + ".jpg", size)
					return
			current_map = background.GetCurrentMapName().lower()
			for map_name, size in map_paths.items():
				if string_contains(map_name, current_map):
					load_map_image(map_name, size, 1)
					self.shiroMaps()
					return
			Handle = app.OpenTextFile(str(GetMapName()) + '/setting.txt')
			CountLines = app.GetTextFileLineCount(Handle)
			for i in range(CountLines):
				s = app.GetTextFileLine(Handle, i)
				if string_contains("MapSize", str(s)):
					self.Teleport_Map_Size = (int(s.split()[1]) * 256, int(s.split()[2]) * 256)
			load_map_image(GetMapName(), self.Teleport_Map_Size, 0)
		except:
			pass
			# self.shiroMaps()
			# msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hAn error occurred while trying to read current map.")
			# self.autoRefreshOff()
	def loadPlayerPos(self):
		global rangeX, rangeY
		try:
			self.playerDot.Show()
			x, y = self.MapaSlot.GetGlobalPosition()
			wx = float(self.MapaSlot.GetWidth())
			hy = float(self.MapaSlot.GetHeight())
			apointX = (float(self.Teleport_Map_Size[0]) / wx)
			apointY = (float(self.Teleport_Map_Size[1] / hy))
			PlayerX, PlayerY, PlayerZ = player.GetMainCharacterPosition()
			xxx = (PlayerX / 100) / apointX
			yyy = (PlayerY / 100) / apointY
			
			if rangeX:
				xxx2 = (rangeX / 100) / apointX
				yyy2 = (rangeY / 100) / apointY
			
			self.playerDot.SetPosition(int(xxx), int(yyy))
			self.rangeDots = []
			if self.drawFarmRange.checked==1:
				self.autoRefreshMapFunc.XX1(0.3)
				self.autoRefreshMapFunc.XX2(self.autoRefreshOn)
				def drawCircle(centerX, centerY, radius, dotList):
					num_points = 180
					angle_step = 2 * math.pi / num_points
					if os.path.exists(CONFIG_FOLDER):
						btnLoc = CONFIG_FOLDER + '/img/'
					else:
						btnLoc = st_path + '/Data/rascal2/img/'
					for i in range(num_points):
						angle = i * angle_step
						x_offset = radius * math.cos(angle)
						y_offset = radius * math.sin(angle)
						dot = self.comp.Button(self.MapaSlot, '', '', 0, 0, self.emtpyFunc, btnLoc + 'routeDot.tga', btnLoc + 'routeDot.tga', btnLoc + 'routeDot.tga')
						dot.SetPosition(int(centerX + x_offset), int(centerY + y_offset))
						dotList.append(dot)
				try:
					allowedFarmRange = int(self.newFarmRangeVal.GetText())
				except:
					allowedFarmRange = 100
				circle_radius = allowedFarmRange / 5
				drawCircle(xxx, yyy, circle_radius, self.rangeDots)
			if self.drawInitialFarmRange.checked==1:
				
				if not rangeX:
					newMsgSimple("You currently do not have an initial farming range yet!\nStart farmbot with Fixed Range box checked first.")
					self.drawInitialFarmRange.OnToggleUp()
					return
				
				def drawCircle(centerX, centerY, radius, dotList):
					num_points = 180
					angle_step = 2 * math.pi / num_points
					if os.path.exists(CONFIG_FOLDER):
						btnLoc = CONFIG_FOLDER + '/img/'
					else:
						btnLoc = st_path + '/Data/rascal2/img/'
					for i in range(num_points):
						angle = i * angle_step
						x_offset = radius * math.cos(angle)
						y_offset = radius * math.sin(angle)
						dot = self.comp.Button(self.MapaSlot, '', '', 0, 0, self.emtpyFunc, btnLoc + 'routeDot2.tga', btnLoc + 'routeDot2.tga', btnLoc + 'routeDot2.tga')
						dot.SetPosition(int(centerX + x_offset), int(centerY + y_offset))
						dotList.append(dot)
				try:
					allowedFarmRange = int(self.newFarmRangeVal.GetText())
				except:
					allowedFarmRange = 100
				circle_radius = allowedFarmRange / 5
				drawCircle(xxx2, yyy2, circle_radius, self.rangeDots)
				
				
				
		except:
			pass
	def autoRefreshOff(self):
		global bossesLoaded
		self.autoRefreshMapFunc.XX1(9999999)
		self.autoRefreshMapFunc.XX2(self.autoRefreshOff)
		try:
			del self.metinDots
			del self.playerDots
			del self.bossDots
			del self.oreDots
			del self.gmDots
			del self.npcDots
			del self.mobsDots
			del self.portalDots
			self.metinDots = []
			self.playerDots = []
			self.bossDots = []
			self.oreDots = []
			self.gmDots = []
			self.npcDots = []
			self.mobsDots = []
			self.portalDots = []
		except:
			pass
		# bossesLoaded = 0
	def readRoute(self):
		routeDir = os.listdir(st_path + "/Data/Routes")
		selectedRoute = self.routeListbox.DropList.GetSelectedItem()
		if selectedRoute:
			route = str(selectedRoute.textBox.GetText())
		else:
			route = ""
		try:
			if str(route) == "empty_route":
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: " + lang.DUMMY_ROUTE)
				return
			elif str(route) == "":
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: " + lang.FARM_NO_ROUTE)
				return
			else:
				if len(routeDir) != 0:
					path = st_path + "/Data/Routes" + '/' + route
					waypoints = self.LoadListFile(path)
					xxx = []
					for point in waypoints:
						points = point.split(' ')
						x = points[0]
						y = points[1]
						xxx.append(x + "|" + y)
					return xxx
				else:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: " + lang.NO_ROUTE)
					return
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: Cannot load route " + route + ".")
			return
	def autoRefreshOn(self):
		global radarEntities
		radarEntities = {
			"metins": {},
			"players": {},
			"bosses": {},
			"gms": {},
			"ores": {},
			"npcs": {},
			"mobs": {},
			"portals": {}
		}
		self.autoRefreshMapFunc.XX1(0.15)
		self.autoRefreshMapFunc.XX2(self.autoRefreshOn)
		if not isConnect():
			self.autoRefreshMapFunc.XX1(5)
			return
	
		def createDot(instance_id, btnLoc, icon, dotList, category):
			x, y = getPos(instance_id)
			xxx = (x / 100.0) / apointX
			yyy = (y / 100.0) / apointY
			dot = self.comp.Button(self.MapaSlot, '', '', 0, 0, self.emtpyFunc, btnLoc + icon, btnLoc + icon, btnLoc + icon)
			dot.SetPosition(int(xxx), int(yyy))
			dotList.append(dot)
		
			radarEntities[category][instance_id] = (int(x), int(y))
		
			if find_string(icon, "gm"):
				try: 
					dot.Flash()
				except:
					pass
	
		def createRouteDot(btnLoc, icon, dotList):
			wx = float(self.MapaSlot.GetWidth())
			hy = float(self.MapaSlot.GetHeight())
			apointX = float(self.Teleport_Map_Size[0]) / wx
			apointY = float(self.Teleport_Map_Size[1]) / hy
			route = self.readRoute()
			if not route:
				return
			for point in route:
				try:
					x, y = map(float, point.split('|'))
					
				except ValueError:
					continue
				xxx = (x / 100.0) / apointX
				yyy = (y / 100.0) / apointY
				dot = self.comp.Button(self.MapaSlot, '', '', 0, 0, self.emtpyFunc, btnLoc + icon, btnLoc + icon, btnLoc + icon)
				dot.SetPosition(int(xxx), int(yyy))
				dotList.append(dot)
	
		try:
			if self.newMap.IsShow():
				self.loadTeleMap()
				wx = float(self.MapaSlot.GetWidth())
				hy = float(self.MapaSlot.GetHeight())
				apointX = float(self.Teleport_Map_Size[0]) / wx
				apointY = float(self.Teleport_Map_Size[1]) / hy
				self.metinDots = []
				self.playerDots = []
				self.bossDots = []
				self.oreDots = []
				self.gmDots = []
				self.npcDots = []
				self.mobsDots = []
				self.portalDots = []
				self.routeDots = []
				if os.path.exists(CONFIG_FOLDER):
					btnLoc = CONFIG_FOLDER + '/img/'
				else:
					btnLoc = st_path + '/Data/rascal2/img/'
				if self.drawRoute.checked == 1:
					createRouteDot(btnLoc, 'self.tga', self.routeDots)
				for i in vidsListEnd1:
					chr.SelectInstance(i)
					a = chr.GetInstanceType(i)
					if self.showMobs.checked == 1 and a == mobType and not self.isDead(i):
						createDot(i, btnLoc, 'mob.tga', self.mobsDots, 'mobs')
					if self.showBoss.checked == 1 and a == mobType and not self.isDead(i):
						if chr.GetRace(i) in bossIds + boss_list:
							createDot(i, btnLoc, 'boss.tga', self.bossDots, 'bosses')
					if self.showOre.checked == 1 and a == oreType:
						if chr.GetRace(i) in [30302, 30303, 30304, 30305, 30306, 20059, 20054, 20047, 20056, 30301, 20051, 20048, 20049, 20050, 20052, 20053, 20055, 20057, 20058]:
							createDot(i, btnLoc, 'ore.tga', self.oreDots, 'ores')
					if self.showPortals.checked == 1 and a == 3:
						createDot(i, btnLoc, 'portal.tga', self.portalDots, 'portals')
					if self.showNPC.checked == 1 and a == npcType:
						createDot(i, btnLoc, 'npc.tga', self.npcDots, 'npcs')
					if self.showMetins.checked == 1 and a == metinType and not self.isDead(i):
						createDot(i, btnLoc, 'metin.tga', self.metinDots, 'metins')
					if self.showPlayer.checked == 1 and a == playerType:
						name = chr.GetNameByVID(i)
						myName = str(getcharName())
						if name != "None" and name != str(myName):
							createDot(i, btnLoc, 'player.tga', self.playerDots, 'players')
					if self.showGM.checked == 1:
						if self.isAdmin(i):
							createDot(i, btnLoc, 'gm.tga', self.gmDots, 'gms')
					
				self.loadPlayerPos()
		except:
			pass
	
			
			
			
			
			
			
	def getTmpTel(self, DestX, DestY, cos=2000):
		(PlayerX, PlayerY, PlayerZ) = player.GetMainCharacterPosition()
		DifX = int(str(int(DestX - PlayerX)))
		DifY = int(str(int(DestY - PlayerY)))
		Vektor = self.DivideToFloat(cos, math.sqrt(DifX**2 + DifY**2))
		Count = int(str(int(self.DivideToFloat((int(str(int(DestX))) - int(str(int(PlayerX)))), (Vektor * int(str(int(DifX)))))))) + 1
		return (PlayerX + int(str(int((Vektor * DifX)))),PlayerY + int(str(int((Vektor * DifY)))), Count)
	def goBack(self):		
		x, y = self.MapaSlot.GetGlobalPosition()
		xMouse, yMouse = wndMgr.GetMousePosition()
		wx = (float(self.MapaSlot.GetWidth()))
		hy = (float(self.MapaSlot.GetHeight()))
		pointX = (float(self.Teleport_Map_Size[0])/wx) * (xMouse - x)
		pointY = (float(self.Teleport_Map_Size[1]/hy)) * (yMouse - y)
		point2X = pointX+15
		point2Y = pointY+15
		myVid = getCharIndex()
		walkFunc(int(point2X),int(point2Y))
		eventHandler.add(1.5, self.Debug, 'debug')
	def telepX(self,aimx, aimy):
		global Debug, GetTmpTeleport, TeleportState
		(TmpX, TmpY, Count) = self.GetTmpTeleport(aimx, aimy)
		TmpCount = 0
		myVid = getCharIndex()
		while TmpCount < Count:
			chr.SelectInstance(myVid)
			(TmpX, TmpY, Crap) = self.GetTmpTeleport(aimx, aimy)
			setPixelPos(int(TmpX), int(TmpY))
			TmpCount += 1
			self.Debug()
		setPixelPos(int(aimx), int(aimy))
		#self.Debug()
		TeleportState = 1
		chr.SelectInstance(myVid)
	def setPathFindingOn(self):
		global pathFindingVar
		pathFindingVar = 1
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hMap teleport: Path finding enabled.")
	def setPathFindingOff(self):
		global pathFindingVar
		pathFindingVar = 0
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hMap teleport: Path finding disabled.")
	def SetPoint(self):
		global canWalkTele,pathFindingVar
		try:
			x, y = self.MapaSlot.GetGlobalPosition()
			xMouse, yMouse = wndMgr.GetMousePosition()
			o = getCharIndex()
			wx = (float(self.MapaSlot.GetWidth()))
			hy = (float(self.MapaSlot.GetHeight()))
			pointX = (float(self.Teleport_Map_Size[0])/wx) * (xMouse - x)
			pointY = (float(self.Teleport_Map_Size[1]/hy)) * (yMouse - y)
			(PosX, PosY) = self.GetGlobalPosition()
			(mouseX, mouseY) = wndMgr.GetMousePosition()
			xxx = mouseX - x
			yyy = mouseY - y
			self.playerDot.Show()
			self.playerDot.SetPosition(xxx, yyy)
			if self.newMap.IsShow():
				self.goingFunction(str(self.mapTeleWalk.GetCurrentText()), int(pointX) * 100,int(pointY) * 100, int(pathFindingVar), 1)
				if str(self.mapTeleWalk.GetCurrentText()) != 'Teleporting':
					self.cancelMovement.Show()
		except:
			pass	
	def cancelMovementFunc(self):
		global canWalkTele
		canWalkTele = 0
		self.GoToPositionAvoidingObjectsStop()
		self.cancelMovement.Hide()
	def fillPoly(self):
		mobsids = st_path + '/Data/rascal2/mosbIds.txt'
		try:
			self.polyList.RemoveAllItems()
		except:
			pass
		if os.path.exists(mobsids):
			f = open_file(mobsids,'r+')
			for line in f:
				line = line.rstrip()
				mobName = line.split("|")
				msg(mobName[0])
				msg(mobName[1])
				self.polyList.AppendItem(Item(str(mobName[0]) + str('|') + str(mobName[1])))
		# else:
			# dumpMob()
	def polyFunc(self, arg):
		global originalRace, canRefreshList
		if arg == 'on':
			myVid = getCharIndex()
			chr.SelectInstance(myVid)
			aa = setTarget(myVid)
			originalRace = chr.GetRace(aa)
			msg(originalRace)
			ItemIndex = self.polyList.GetSelectedItem()
			if not ItemIndex:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPolymorph: Please select first a mob.")
				return
			mobName = ItemIndex.GetText().split("|")
			msg("Poly into: " + str(mobName[0]) + " with ID: " + str(mobName[1]))
			chr.SetRace(int(mobName[1]))
			chr.Refresh()
		elif arg == 'off':
			canRefreshList = 1
			chr.SetRace(originalRace)
			msg('Please mount your horse to get back to your initial form')
	def tesss(self):
		handle = open_file(CONFIG, 'r+').read()
		count = app.GetTextFileLineCount(handle)
		for i in range(count):
			line = app.GetTextFileLine(handle, i)
			return line.split('=')[1]
	def getVidFromID(self, vid):
		vidInfo = list(str(str(chrmgr.GetVIDInfo(vid)).split('VID')[1]).split(' '))
		vidx = vidInfo[1]
		return vidx
	try:
		def getArmorInfo(self,_type,invType = 2,slot=item.EQUIPMENT_BODY):
			global armorVal
			idx = player.GetItemIndex(invType,slot)
			armorVal = idx
			if idx != 0:
				selectItem(idx)
				if item.GetItemType() == _type:
					return True
			return False
	except:
		pass

	def RotateMainCharacter(self, x,y):
		my_x,my_y,my_z = player.GetMainCharacterPosition()
		chr.SelectInstance(getCharIndex())
		rot = GetRotation(my_x,my_y,x,y)
		chr.SetRotation(rot)

		
	def test_fnc(self):
		slot = 1
		main_stream_instance.SetCharacterSlot(int(slot))
		net.DirectEnter(int(slot))
	def getArmorDownUp(self):
		global armorVal
		val = self.getArmorInfo(item.ITEM_TYPE_ARMOR,2,item.EQUIPMENT_BODY)
		if val:
			# slot = self.GetItemByType(item.ITEM_TYPE_ARMOR)
			# useItemFunc(180)
			slot = self.GetItemByType(item.ITEM_TYPE_ARMOR)
			if slot != -1:
				useItemFunc(slot)
			if not eventHandler.has('use_back'):
				eventHandler.add(0.3, lambda: self.use_back(armorVal), 'use_back')
		else:
			val = self.isItemTypeOnSlot(item.ITEM_TYPE_ARMOR,2,item.EQUIPMENT_BODY)
			if val == 0:
				slot = self.GetItemByType(item.ITEM_TYPE_ARMOR)
				if slot != -1:
					useItemFunc(slot)
	def use_back(self, ite):
		useSlot = 0
		eventHandler.remove('use_back')
		for InventorySlot in range(player.INVENTORY_PAGE_SIZE*10):
			ItemValue = player.GetItemIndex(InventorySlot)
			if ItemValue == int(ite):
				useSlot = InventorySlot
				
		if useSlot:
			useItemFunc(useSlot)
	def load_locFunc(self):
		self.npcVnum.SetText('9001')
		if self.listLocations.GetCurrentText() == 'Map1 Blue':
			self.alchemistLocX.SetText('292')
			self.alchemistLocY.SetText('815')
			self.npctoBuyLocX.SetText('425')
			self.npctoBuyLocY.SetText('609')
		elif self.listLocations.GetCurrentText() == 'Map1 Yellow':
			self.alchemistLocX.SetText('617')
			self.alchemistLocY.SetText('563')
			self.npctoBuyLocX.SetText('674')
			self.npctoBuyLocY.SetText('660')
		elif self.listLocations.GetCurrentText() == 'Map1 Red':
			self.alchemistLocX.SetText('622')
			self.alchemistLocY.SetText('511')
			self.npctoBuyLocX.SetText('595')
			self.npctoBuyLocY.SetText('561')
	def sell_sel_item2(self):			
		if not shop.IsOpen():
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h Inventory manager: " + lang.STR_INV_MANAGER1)
			return
		fromSlot = self.sellItemsFrom.GetText()
		toSlot = self.sellItemsTo.GetText()
		for Slot in range(int(fromSlot), int(toSlot)):
			net.SendShopSellPacketNew(Slot,player.GetItemCount(Slot),1)	
	def sell_sel_item(self):
		ItemIndex = self.inv_list_items.GetSelectedItem()
		if not ItemIndex:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hInventory manager: " + lang.STR_INV_MANAGER2)
			return
		try:
			SearchedName = ItemIndex.GetText().split("	")[2].split("+")[0]
		except:
			SearchedName = ItemIndex.GetText().split("	")[2]
		for Slot in range(0, 300):
			ItemValue = player.GetItemIndex(Slot)
			try:
				ItemName = item.GetItemName(selectItem(ItemValue)).split("+")[0]
			except:
				ItemName = item.GetItemName(selectItem(ItemValue))
			if ItemName == SearchedName:
				sellItemFunction(Slot)
		if self.autoRefreshInventory.checked == 1:
			eventHandler.add(0.3, self.refresh_item_list)
	def sell_all_items(self):
		if find_string(st_cur_server, "aronix") or  find_string(st_cur_server, "metin2sg") or foundx64PythonList:
			self.QuestionDialog = uiCommon.QuestionDialog()
		else:
			self.QuestionDialog = QuestionDialog()
		self.QuestionDialog.SetText(lang.STR_CONFIRM_SELL)
		self.QuestionDialog.SetAcceptEvent(__mem_func__(self.SellAll))
		self.QuestionDialog.SetCancelEvent(__mem_func__(self.CancelQuestionDialog))
		self.QuestionDialog.Open()
	def SellAll(self):
		for i in range(player.INVENTORY_PAGE_SIZE * 10):
			sellItemFunction(i)
		self.CancelQuestionDialog()
	def playerHaveEmptySlot(self):
		a=False
		for Slot in range(player.INVENTORY_PAGE_SIZE * 10):
			if player.GetItemIndex(Slot)==0:
				a=True
				break
		return a
	def GetSameItem(self,id,actualSlot):
		res=-1
		selectItem(int(id))
		actualCount=player.GetItemCount(actualSlot)
		for slot in range(player.INVENTORY_PAGE_SIZE * 10):
			slotCount=player.GetItemCount(slot)
			if player.GetItemIndex(slot)==int(id) and int(slot)!=int(actualSlot) and player.GetItemCount(slot)<200 and int(actualCount)<200 and item.IsFlag(item.ITEM_FLAG_STACKABLE):
				res=slot
				break
		return res
	def GetLastItem(self):
		res=-1
		for slot in range(player.INVENTORY_PAGE_SIZE * 10):
			itemid=player.GetItemIndex(int(89-slot))
			selectItem(itemid)
			(w,h)=item.GetItemSize()
			if itemid!=0:
				res=int(89-slot)
				break
		return (res,h)
	def getLastEmptySlot(self):
		res=-1
		for slot in range(player.INVENTORY_PAGE_SIZE * 10):
			if player.GetItemIndex(int(89-slot))==0:
				res=int(89-slot)
				break
		return res
	def getFirstEmptySlot(self):
		res=-1
		for slot in range(player.INVENTORY_PAGE_SIZE * 10):
			if player.GetItemIndex(slot)==0:
				res=slot
				break
		return res
	def GetBestSloth(self):
		res=-1
		for slot in range(player.INVENTORY_PAGE_SIZE * 10):
			if player.GetItemIndex(slot)==0:
				if slot>4:
					prevItemId=player.GetItemIndex(int(slot)-5)
					selectItem(prevItemId)
					(w,h)=item.GetItemSize()
					if player.GetItemIndex(int(slot)-5)==0:
						res=slot
						break
					else:
						if int(h)==1:
							res=slot
							break
				else:
					res=slot
					break
		return res
	def GetBestSlothh(self):
		res=-1
		for slot in range(4,90):
			if player.GetItemIndex(slot)==0 and player.GetItemIndex(slot-5)==0:
				res=slot-5
				break
		return res
	def GetBestSlothhh(self):
		res=-1
		for slot in range(9,90):
			if player.GetItemIndex(slot)==0 and player.GetItemIndex(slot-5)==0 and player.GetItemIndex(slot-10)==0:
				res=slot
				break
		return res
	def SortItems(self):
		global sortIndex,isSorting,sortDelay
		if self.playerHaveEmptySlot()==False:
			isSorting=0
			return
		isDone=1
		for checkSlot in range(int(sortIndex),90):
			if player.GetItemIndex(checkSlot)!=0:
				isDone=0
				break
		if int(isDone)==1:
			sortIndex=0
			isSorting=0
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hItem sorter: All items processed.")
			return
		if self.playerHaveEmptySlot()==False:
			isSorting=0
			return
		for slot in range(int(sortIndex),90):
			firstSlot=self.getFirstEmptySlot()
			itemid=player.GetItemIndex(slot)
			itemct=player.GetItemCount(slot)
			selectItem(itemid)
			(w,h)=item.GetItemSize()
			if int(h)==1:
				sameItem=self.GetSameItem(itemid,slot)
				if sameItem!=-1:
					net.SendItemMovePacket(slot,sameItem,0)
				else:
					bestSlot=self.GetBestSloth()
					if int(slot)>int(bestSlot):
						net.SendItemMovePacket(slot,bestSlot,0)
			if int(h)==2:
				bestSlot=self.GetBestSlothh()
				if bestSlot!=-1:
					if int(slot)>int(bestSlot):
						net.SendItemMovePacket(slot,bestSlot,0)
			if int(h)>2:
				bestSlot=self.GetBestSlothhh()
				if bestSlot!=-1:
					if int(slot)>int(bestSlot):
						net.SendItemMovePacket(slot,bestSlot,0)
		sortIndex+=1
		self.sortUpdate.XX1(sortDelay)
		self.sortUpdate.XX2(self.SortItems)
	def sort_func(self):		
		global sortDelay,isGF
		try:
			sortDelay = float(self.sortDelayTxt.GetText())
		except:
			sortDelay = 0.6
		if isGF:
			xsort_items()
		elif sortDelay == 0:
			handler = ItemHandlerx()
			handler.sort()
		else:
			# self.SortItems()
			xsort_items()
	def sort_auto_on(self):
		global sortDelay
		self.sortx.XX1(10)
		self.sortx.XX2(self.sort_auto_on)
		if not isConnect():
			return
		self.sort_func()
	def sort_auto_off(self):
		self.sortx.XX1(9999999)
		self.sortx.XX2(self.sort_auto_off)
	def stoneBotStart(self):
		global select_stonetoitemID,select_stonetoitemIndex
		global select_stoneID,select_stoneSlotID
		global select_brokenstone,select_brokenstoneSlot
		self.stoneBotx.XX1(0.2)
		self.stoneBotx.XX2(self.stoneBotStart)		
		if not isConnect():
			self.stoneBotx.XX1(5)
			return
		SelectedIndex = int(select_stonetoitemIndex)
		Slot = SelectedIndex
		for eachSlot in range(player.INVENTORY_PAGE_SIZE * 10):
			itemVNum = player.GetItemIndex(eachSlot)
			SendItemUseToItemPacket(int(select_stoneSlotID), int(Slot))
			break
		for eachSlot in range(player.INVENTORY_PAGE_SIZE * 10):
			itemVNum = player.GetItemIndex(eachSlot)
			SendItemUseToItemPacket(int(select_stoneSlotID), int(Slot))
			break
		for InventorySlot in range(player.METIN_SOCKET_MAX_NUM):
			Value = player.GetItemMetinSocket(int(Slot), InventorySlot)
			for brokenslot in range(Value):
				broked = player.GetItemMetinSocket(int(Slot), brokenslot)
				if broked == 28960:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hAdd stone bot: " + lang.STR_ADD_STONE1)
					for amk in range(player.INVENTORY_PAGE_SIZE * 10):
						itemVNum = player.GetItemIndex(amk)
						if itemVNum == select_brokenstone:
							removeBroken = item.GetItemName(selectItem(int(select_brokenstone)))
							brokenstoneVal = player.GetItemCountByVnum
							if brokenstoneVal(int(select_brokenstone)) > 0:
								SendItemUseToItemPacket(amk, int(Slot))
							else:
								msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hAdd stone bot: " + lang.STR_ADD_STONE2)
								self.stoneBotStop()
		for InventorySlot in range(player.METIN_SOCKET_MAX_NUM):
			Value = player.GetItemMetinSocket(int(Slot), InventorySlot)
			for successfulslot in range(Value):
				successful = player.GetItemMetinSocket(int(Slot), successfulslot)
				if successful == int(select_stoneID):
					stoneName = item.GetItemName(selectItem(int(select_stoneID)))
					itemName = item.GetItemName(selectItem(int(select_stonetoitemID)))
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hAdd stone bot: " + lang.STR_ADD_STONE3)
					self.stoneBotStop()
	def stoneBotStop(self):
		self.stoneBotx.XX1(9999999)
		self.stoneBotx.XX2(self.stoneBotStop)
		self.stoneBotBtn.SetUp()
	def drop_all_items(self):
		if find_string(st_cur_server, "aronix") or  find_string(st_cur_server, "metin2sg") or foundx64PythonList:
			self.QuestionDialog = uiCommon.QuestionDialog()
		else:
			self.QuestionDialog = QuestionDialog()
		self.QuestionDialog.SetText(lang.STR_CONFIRM_DROP)
		self.QuestionDialog.SetAcceptEvent(__mem_func__(self.DropAllItems))
		self.QuestionDialog.SetCancelEvent(__mem_func__(self.CancelQuestionDialog))
		self.QuestionDialog.Open()
	def openItemSellerWindow(self):
		if self.sellItemsWindow.IsShow():
			self.closeItemsWindow()
			self.btnItemSeller.SetText(lang.STR_OPEN)
		else:
			self.sellItemsWindow.Show()
			self.keepItemsAttachedFuncOn()
			self.btnItemSeller.SetText('Close')
	def disableSell(self):
		global isGF
		try:
			self.extractShards.OnToggleUp()
		except:
			pass
		self.sellThem.OnToggleUp()
		try:
			self.feedPet.OnToggleUp()
		except:
			pass
	def disableDestroy(self):
		global isGF
		self.destroyThem.OnToggleUp()
		try:
			self.extractShards.OnToggleUp()
		except:
			pass
		try:
			self.feedPet.OnToggleUp()
		except:
			pass
	def enableShards(self):
		self.destroyThem.OnToggleUp()
		self.sellThem.OnToggleUp()
		try:
			self.feedPet.OnToggleUp()
		except:
			pass
	def enablePetFeed(self):
		self.destroyThem.OnToggleUp()
		self.sellThem.OnToggleUp()
		try:
			self.extractShards.OnToggleUp()
		except:
			pass
	def SellItemsFunctionOff(self):
		self.SellItemsFuxnction.XX1(9999999)
		self.SellItemsFuxnction.XX2(self.SellItemsFunctionOff)
		
	def getBonusCount(self, slot):
		bnsList = []
		try:
			for i in range(5):
				bonus_id, bonus_value = player.GetItemAttribute(slot, i)
				if bonus_id and bonus_id not in bnsList:
					bnsList.append(bonus_id)
		except:
			pass
		return bnsList
		
	def SellItemsFunctionOn(self):
		global pauseAutoSell,shardBox, feedBox
		try:
			delay = int(self.SellItemsDelay.GetText())
		except:
			delay = 10
		self.SellItemsFuxnction.XX1(delay)
		self.SellItemsFuxnction.XX2(self.SellItemsFunctionOn)
		if not isConnect():
			return
		try:
			if pauseAutoSell:
				return
			for i in range(player.INVENTORY_PAGE_SIZE*10):
				for item in self.sellItems:
					if player.GetItemIndex(i) == item:
						
						if self.onlyItemsWithout.checked and isValItem(i):
							continue
						if self.checkBonusCount.checked == 1:
							currentBonuses = len(self.getBonusCount(i))
							try:
								minBonusesRequired = int(self.sellBonusCount.GetText())
							except ValueError:
								minBonusesRequired = 0
		
							if currentBonuses >= minBonusesRequired:
								# msg("[DEBUG] Skipping item in slot {}: Too many bonuses ({}/{})".format(i, currentBonuses, minBonusesRequired))
								continue
							
						if self.sellThem.checked==1:
							sellItemFunction(i)
						elif self.destroyThem.checked==1:
							destroyItemFunction(i)
						elif shardBox:
							if self.extractShards.checked==1:
								extractShardsSlot(i)
						elif feedBox:
							if self.feedPet.checked==1:
								player.SetOpenPetFeedWindow(True)
								net.SendPetFeedPacket(2, [i], [1])
								player.SetOpenPetFeedWindow(False)
		except:
			pass
	def SellItemsFunction(self, arg):
		global sellItemsFunction
		if arg == 'off':
			sellItemsFunction = 0
			self.SellItemsFunctionOff()
			self.startStopSellItems.SetText('Start')
		elif arg == 'on':
			sellItemsFunction = 1
			self.SellItemsFunctionOn()
			self.startStopSellItems.SetText('Stop')
	def UpdateSellFilterList(self):
		global isGF
		try:
			try:
				self.ShopFileListBox.RemoveAllItems()
			except:
				pass
			dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'item_list.txt'
			if os.path.exists(dirPl) and os.path.getsize(dirPl) > 0:
				try:
					self.ShopFileListBox.RemoveAllItems()
				except:
					pass
				file = open_file(dirPl, "r+")
				file_lines = file.read()
				Test = str(file_lines).replace("\n", "")
				Scripts = str(Test).split(",")
				for filterItem in sort_items(self.sellItems):
					selectItem(filterItem)
					
					itemIcon = item.GetIconImageFileName()
					if itemIcon is None:
						continue
					name = item.GetItemName()
					self.ShopFileListBox.AppendItem(Item(str(filterItem)+" "+name))
			else:
			
				if find_string(st_cur_server, "helles"):
					f = open_file(dirPl,'w+')
					for i in range(0,80000):
						selectItem(i)
						itemIcon = item.GetIconImageFileName()
						if itemIcon is None:
							continue
							
						if item.GetItemType() != 6:
							n = item.GetItemName()
							if n!= "":
								f.write(n + "\n" + str(i) + "\n")
					f.close()
				else:
			
			
					lines = None
					try:
						lines = open_file(app.GetLocalePath()+"/item_list.txt", "r+").readlines()
					except:
						pass
					if not lines:
						f = open_file(dirPl,'w+')
						for i in range(0,100000):
							selectItem(i)
							itemIcon = item.GetIconImageFileName()
							if itemIcon is None:
								continue
							
							
							if item.GetItemType() != 6:
								n = item.GetItemName()
								if n!= "":
									f.write(n + "\n" + str(i) + "\n")
						f.close()
					else:
						results = []
						for line in lines:
							tokens = str(line).split("\t")
							Index = str(tokens[0])
							try:
								Itemname = item.GetItemName(selectItem(int(Index)))
								results.append((Itemname, Index))
							except:
								continue
						f = open_file(dirPl, 'w+')
						for Itemname, Index in results:
							f.write(Itemname + "\n" + str(Index) + "\n")
						f.close()
		except:
			pass
	def UIAddSellFilterItem(self,item):
		try:
			self.sellItems.add(item)
			self.UpdateSellFilterList()
		except:
			pass
	def OpenSellItemDialog(self):
		try:
			pos = self.sellItemsWindow.GetGlobalPosition()
			ItemListDialog(self.UIAddSellFilterItem,pos[0]+self.sellItemsWindow.GetWidth(),pos[1])
		except:
			pass
			
	def OpenBonusFilterWindow(self):
		bonusFilterUI = BonusFilterDialog()
		bonusFilterUI.Open()
			
	def UISellRemoveFilterItem(self):
		_item = self.ShopFileListBox.GetSelectedItem()
		if _item == None:
			return
		item_name = _item.GetText()
		idx = item_name.split()[0]
		try:
			self.sellItems.remove(int(idx))
		except:
			pass
		dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'item_list.txt'
		file = open_file(dirPl, "r+")
		FileString = file.read()
		NewFiles = str(FileString).replace(str(item_name) + str(",\n"), str(""))
		NewFiles = str(FileString).replace(str(item_name) + str(","), str(""))
		file.close()
		f = open_file(dirPl, "w+")
		f.write(NewFiles)
		f.close()
		self.UpdateSellFilterList()
	def destroy_all_items(self):
		if find_string(st_cur_server, "aronix") or  find_string(st_cur_server, "metin2sg") or foundx64PythonList:
			self.QuestionDialog = uiCommon.QuestionDialog()
		else:
			self.QuestionDialog = QuestionDialog()
		self.QuestionDialog.SetText(lang.STR_CONFIRM_DROP)
		self.QuestionDialog.SetAcceptEvent(__mem_func__(self.DestroyAllItems))
		self.QuestionDialog.SetCancelEvent(__mem_func__(self.CancelQuestionDialog))
		self.QuestionDialog.Open()
	def DestroyAllItems(self):
		for i in range(player.INVENTORY_PAGE_SIZE * 10):
			destroyItemFunction(i)
		self.CancelQuestionDialog()
	def DropAllItems(self):
		for i in range(player.INVENTORY_PAGE_SIZE * 10):
			net.SendItemDropPacketNew(i,player.GetItemCount(i))
		self.CancelQuestionDialog()
	def CancelQuestionDialog(self):
		self.QuestionDialog.Close()
		self.QuestionDialog = None
	def ScanBlacksmiths(self, race):
		o = getCharIndex()
		closest_instance = 0
		closest_distance = float('inf')  # Start with a large number to ensure the first comparison succeeds
		for i in eXLib.InstancesList:
			if chr.INSTANCE_TYPE_NPC == chr.GetInstanceType(i):
				chr.SelectInstance(i)
				for rr in race:
					if chr.GetRace() == rr:
						distance = GetDis(i)
						if distance < closest_distance:
							closest_distance = distance
							closest_instance = i
		return closest_instance
	def upAll(self, Slot, Count):
		global special_itemID,isGF
		if isGF:
			vlist = [20016, 20043, 20044, 20045, 20046]
			vnum = self.ScanBlacksmiths(vlist)
			for i in range(int(Count)):
				if self.upList.GetCurrentText() == 'Blacksmith':
					net.SendGiveItemPacket(vnum, 1, Slot, 1)
					sendRefinePacket(Slot, -2)
				if self.upList.GetCurrentText() == 'Scroll of Blessing':
					for InventorySlot in range(player.INVENTORY_PAGE_SIZE*10):
						ItemValue = player.GetItemIndex(InventorySlot)
						if ItemValue == 25040:
							SendItemUseToItemPacket(InventorySlot, Slot)
							sendRefinePacket(Slot, 0)
							break
				if self.upList.GetCurrentText() == 'Magic Metal':
					for InventorySlot in range(player.INVENTORY_PAGE_SIZE*10):
						ItemValue = player.GetItemIndex(InventorySlot)
						if ItemValue == 25041:
							SendItemUseToItemPacket(InventorySlot, Slot)
							sendRefinePacket(Slot, 0)
							break
				if self.upList.GetCurrentText() == 'Special item':
					for InventorySlot in range(player.INVENTORY_PAGE_SIZE*10):
						ItemValue = player.GetItemIndex(InventorySlot)
						if ItemValue == int(special_itemID):
							SendItemUseToItemPacket(InventorySlot, Slot)
							sendRefinePacket(Slot, 0)
		else:
			for i in range(int(Count)):
				if self.upList.GetCurrentText() == 'Blacksmith':
					if self.refineNewWindow.checked==1:
						sendRefinePacket(Slot, 0, 0, 0, 0, 100)
					else:
						sendRefinePacket(Slot, 0)
				if self.upList.GetCurrentText() == 'Guild Blacksmith':
					if self.refineNewWindow.checked==1:
						sendRefinePacket(Slot, 1, 0, 0, 0, 100)
					else:
						sendRefinePacket(Slot, 1)
				if self.upList.GetCurrentText() == 'Scroll of Blessing':
					for InventorySlot in range(player.INVENTORY_PAGE_SIZE*10):
						ItemValue = player.GetItemIndex(InventorySlot)
						if ItemValue == 25040:
							SendItemUseToItemPacket(InventorySlot, Slot)
							if self.refineNewWindow.checked==1:
								sendRefinePacket(Slot, 2, 0, 0, 0, 100)
							else:
								sendRefinePacket(Slot, 2)
							break
				if self.upList.GetCurrentText() == 'Magic Metal':
					for InventorySlot in range(player.INVENTORY_PAGE_SIZE*10):
						ItemValue = player.GetItemIndex(InventorySlot)
						if ItemValue == 25041:
							SendItemUseToItemPacket(InventorySlot, Slot)
							if self.refineNewWindow.checked==1:
								sendRefinePacket(Slot, 2, 0, 0, 0, 100)
							else:
								sendRefinePacket(Slot, 2)
							break
				if self.upList.GetCurrentText() == 'DT':
					if self.refineNewWindow.checked==1:
						sendRefinePacket(Slot, 4, 0, 0, 0, 100)
					else:
						sendRefinePacket(Slot, 4)
				if self.upList.GetCurrentText() == 'Special item':
					for InventorySlot in range(player.INVENTORY_PAGE_SIZE*10):
						ItemValue = player.GetItemIndex(InventorySlot)
						if ItemValue == int(special_itemID):
							SendItemUseToItemPacket(InventorySlot, Slot)
							if self.refineNewWindow.checked==1:
								sendRefinePacket(Slot, 2, 0, 0, 0, 100)
							else:
								sendRefinePacket(Slot, 2)
							break
	def upgrade_all_items(self):
		ItemIndex = self.inv_list_items.GetSelectedItem()
		global select_item_refineID, select_item_refineCount
		a = int(self.textUpTo.GetText())
		for i in range(player.INVENTORY_PAGE_SIZE * 10):
			if player.GetItemIndex(i) == int(select_item_refineCount):
				self.upAll(i, a)
	def use_selectedItem(self):				
		try:
			ItemIndex = self.inv_list_items.GetSelectedItem()
			if not ItemIndex:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hInventory manager: " + lang.STR_INV_MANAGER2)
				return
			SelectedItem = ItemIndex.GetText().split("	")
			try:
				SearchedName = ItemIndex.GetText().split("	")[2].split("+")[0]
			except:
				SearchedName = ItemIndex.GetText().split("	")[2]
			for Slot in range(0, 300):
				ItemValue = player.GetItemIndex(Slot)
				try:
					ItemName = item.GetItemName(selectItem(ItemValue)).split("+")[0]
				except:
					ItemName = item.GetItemName(selectItem(ItemValue))
				if ItemName == SearchedName:
					useItemFunc(Slot)
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hInventory manager: Failed using item.")
			return
	def drop_sel_item(self):
		try:
			ItemIndex = self.inv_list_items.GetSelectedItem()
			if not ItemIndex:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hInventory manager: " + lang.STR_INV_MANAGER2)
				return
			SelectedItem = ItemIndex.GetText().split("	")
			try:
				SearchedName = ItemIndex.GetText().split("	")[2].split("+")[0]
			except:
				SearchedName = ItemIndex.GetText().split("	")[2]
			for Slot in range(0, 300):
				ItemValue = player.GetItemIndex(Slot)
				try:
					ItemName = item.GetItemName(selectItem(ItemValue)).split("+")[0]
				except:
					ItemName = item.GetItemName(selectItem(ItemValue))
				if ItemName == SearchedName:
					try:
						net.SendItemDropPacketNew(Slot,player.GetItemCount(Slot))
					except:
						net.SendItemDropPacket(Slot)
			if self.autoRefreshInventory.checked == 1:
				eventHandler.add(0.3, self.refresh_item_list)
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hInventory manager: Failed dropping item.")
	def destroy_sel_item(self):
		try:
			ItemIndex = self.inv_list_items.GetSelectedItem()
			if not ItemIndex:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hInventory manager: " + lang.STR_INV_MANAGER2)
				return
			SelectedItem = ItemIndex.GetText().split("	")
			try:
				SearchedName = ItemIndex.GetText().split("	")[2].split("+")[0]
			except:
				SearchedName = ItemIndex.GetText().split("	")[2]
			for Slot in range(0, 300):
				ItemValue = player.GetItemIndex(Slot)
				try:
					ItemName = item.GetItemName(selectItem(ItemValue)).split("+")[0]
				except:
					ItemName = item.GetItemName(selectItem(ItemValue))
				if ItemName == SearchedName:
					destroyItemFunction(Slot)
			if self.autoRefreshInventory.checked == 1:
				eventHandler.add(0.3, self.refresh_item_list)
		except:
			if not find_string(st_cur_server, "legendofmetin"):
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hInventory manager: Failed deleting item.")
	def run1(self):		
		myVid = getCharIndex()
		targetVID = self.ScanForNPCByRace(int(self.npcVnum.GetText()))
		chr.SelectInstance(targetVID)
		mX, mY, _ = player.GetMainCharacterPosition()
		x,y  = getPos(targetVID)
		npcX_total = int(x)*100
		npcY_total = int(y)*100
		walkFunc(int(npcX_total + 500),int(npcY_total + 500))
		eventHandler.add(1, self.run2)
	def run2(self):		
		myVid = getCharIndex()
		targetVID = self.ScanForNPCByRace(int(self.npcVnum.GetText()))
		chr.SelectInstance(targetVID)
		mX, mY, _ = player.GetMainCharacterPosition()
		x,y  = getPos(targetVID)
		walkFunc(x, y)
		npcX_total = int(x)*100
		npcY_total = int(y)*100
		walkFunc(int(npcX_total),int(npcY_total))
		self.Debug()
	if isGF:
		def refresh_item_list(self):
			try:
				self.inv_list_items.RemoveAllItems()
				for i in range(500):
					ItemIndex = player.GetItemIndex(i)
					if ItemIndex != 0:
						selectItem(ItemIndex)
						item.GetItemName(ItemIndex)
						if st_cur_server.find("Alune")!=-1:
							ItemName = item.GetItemNameByVnum(ItemIndex)
						else:
							ItemName = item.GetItemName()
						self.inv_list_items.AppendItem(Item(str(i) + "	" + str(ItemIndex) + "	" + ItemName))
			except:
				pass
	else:
		def refresh_item_list(self):
			try:
				self.inv_list_items.RemoveAllItems()
			except:
				pass
			for i in range(500):
				ItemIndex = player.GetItemIndex(i)
				if ItemIndex != 0:
					selectItem(ItemIndex)
					item.GetItemName(ItemIndex)
					if find_string(st_cur_server, "Alune"):
						ItemName = item.GetItemNameByVnum(ItemIndex)
					else:
						ItemName = item.GetItemName()
					self.inv_list_items.AppendItem(Item(str(i) + "	" + str(ItemIndex) + "	" + ItemName))
	def energyRouteInfoFunc(self):
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hEnergy: " + lang.NEW_ROUTE_INFO)
	def readCurrentEnergyRoute(self):
		try:
			os.mkdir(st_path + "/Data/Routes")
		except:
			pass
		routeDir = os.listdir(st_path + "/Data/Routes")
		if len(routeDir) == 0:
			ignoreList = st_path + "/Data/Routes/empty_route"
			save = open_file(ignoreList, 'w')
			save.close()
		selectedRoute = self.energyRouteListbox.DropList.GetSelectedItem()
		if selectedRoute:
			routex = str(selectedRoute.textBox.GetText())
		else:
			routex = ""
		if str(routex) == "empty_route":
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hEnergy: " + lang.DUMMY_ROUTE)
			return
		elif str(routex) == "":
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hEnergy: " + lang.FARM_NO_ROUTE)
			return
		else:
			if os.stat(st_path + "/Data/Routes/" + routex).st_size != 0:
				file = open_file(st_path + "/Data/Routes/" + routex, 'r+')
				route = []
				for line in file:
					x, y = map(int, line.strip().split())
					route.append((x, y))
				return route
			else:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hEnergy: " + lang.EMPTY_ROUTE)
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hEnergy: " + lang.EMPTY_ROUTE_MSG2)
				return	
	def hideRouteEnergy(self):
		self.refreshEnergyRouteBtn.Hide()
		self.loadEnergyRouteBtn.Hide()
		self.energyRouteListbox.Hide()
		self.energyRouteInfo.Hide()			
	def showRouteEnergy(self):
		self.refreshEnergyRouteBtn.Show()
		self.loadEnergyRouteBtn.Show()
		self.energyRouteListbox.Show()
		self.energyRouteInfo.Show()
		self.refreshEnergyRouteList()
	def refreshEnergyRouteList(self):
		try:
			os.mkdir(st_path + "/Data/Routes")
		except:
			pass
		if not find_string(st_cur_server, "levia"):
			self.energyRouteListbox.DropList.RemoveAllItems()
		self.energyRouteListbox.maxh = 95
		self.energyRouteListbox.c = 0
		last_used_route = str(ReadConfig("Last_Used_Energy_Route"))
		selected_index = -1
		index = 0 
		for routeName in os.listdir(st_path + "/Data/Routes"):
			if not routeName.startswith("empty_route"):
				self.energyRouteListbox.AppendItem(str(routeName))
				if str(routeName) == last_used_route:
					selected_index = index
				index += 1
		if selected_index != -1:
			self.energyRouteListbox.DropList.SelectIndex(selected_index)
			selected_item = self.energyRouteListbox.DropList.GetSelectedItem()
			self.energyRouteListbox.SetTitle(selected_item)
	
	def execute_route(self, reverse=False):
		if not self.current_route:
			self.current_route = self.readCurrentEnergyRoute()
			return
		# if reverse:
			# self.current_route.reverse()
				
		xx, yy, zz = player.GetMainCharacterPosition()
		current_position = (xx, yy, zz)
		self.move_character(self.current_route, current_position)
	def move_character(self, route, current_position):
		global select_item_toGiveID, energy_state
		x_current, y_current, _ = current_position
		step_tolerance = 5000
		deadzone = 3000
		
		if self.buyAvailable.checked == 1:
			howMany = self.GetNumberOfFreeSlots()
		else:
			try:
				howMany = int(self.buyFromShopValue.GetText())
			except:
				howMany = 5
		items_to_give = player.GetItemCountByVnum(int(select_item_toGiveID))
	
		if self.current_route_step < len(route):
			x_target, y_target = route[self.current_route_step]
			distance_to_target = ((x_target - x_current) ** 2 + (y_target - y_current) ** 2) ** 0.5
			
			if distance_to_target > step_tolerance:
				closest_step = self.find_closest_step(route, x_current, y_current)
				if closest_step is not None and closest_step != self.current_route_step:
					self.current_route_step = closest_step
			else:
				if self.inside_circle(x_current, y_current, x_target, y_target, 300):
					if distance_to_target < deadzone:
						self.current_route_step += 1
						if self.current_route_step < len(route):
							pass  # Move to the next step
						else:
							msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hEnergy bot: Route complete. Checking actions.")
							
							if items_to_give <= howMany:
								energy_state = 'gotoshop'
							else:
								energy_state = 'gotoalc'
	
							# **FIX: Call `give_all_items_to_alchemist` when at alchemist**
							if energy_state == 'gotoalc':
								msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hEnergy bot: Reached alchemist. Starting item giving.")
								self.energyfunc_startx.XX1(0.7)  # Small delay
								self.energyfunc_startx.XX2(self.give_all_items_to_alchemist)
								return
	
							route.reverse()
							self.current_route_step = 0
					else:
						pass
				else:
					self.goingFunction(self.gotoEnergy.GetCurrentText(), int(x_target), int(y_target), 1)
		else:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hEnergy bot: Route complete. Reversing.")
			
			if items_to_give <= howMany:
				energy_state = 'gotoshop'
			else:
				energy_state = 'gotoalc'
	
			# **FIX: Call `give_all_items_to_alchemist`**
			if energy_state == 'gotoalc':
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hEnergy bot: Reached alchemist. Starting item giving.")
				self.energyfunc_startx.XX1(0.2)  # Small delay
				self.energyfunc_startx.XX2(self.give_all_items_to_alchemist)
				return
	
			route.reverse()
			self.current_route_step = 0
		# msg("Current route step: " + str(self.current_route_step))
	def find_closest_step(self, route, x_current, y_current):
		closest_step = None
		min_distance = float('inf')
		for i, (step_x, step_y) in enumerate(route):
			distance = ((step_x - x_current) ** 2 + (step_y - y_current) ** 2) ** 0.5
			if distance < min_distance:
				min_distance = distance
				closest_step = i
		return closest_step
	def go_to_alchemist2(self):
		global canWalkTele
		goingTo = self.gotoEnergy.GetCurrentText()
		if self.energyRoute.checked == 1:
			self.execute_route(True)
		else:
			alcX = int(self.alchemistLocX.GetText())
			alcY = int(self.alchemistLocY.GetText())
			myVid = getCharIndex()
			if alcX == "0" or alcX == "":
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hEnergy bot: " + lang.STR_NOT_ALCHEMIST)
			else:
				alcX_total = int(alcX)*100
				alcY_total = int(alcY)*100
				self.goingFunction(goingTo, int(alcX_total),int(alcY_total), 1)
	def go_to_npc2(self):
		global canWalkTele
		npcX = self.npctoBuyLocX.GetText()
		npcY = self.npctoBuyLocY.GetText()
		myVid = getCharIndex()
		goingTo = self.gotoEnergy.GetCurrentText()
		if self.energyRoute.checked == 1:
			self.execute_route(False)
		else:
			if npcX == "0" or npcX == "":
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hEnergy bot: " + lang.STR_NOT_NPC)
			else:
				npcX_total = int(npcX)*100
				npcY_total = int(npcY)*100
				self.goingFunction(goingTo, int(npcX_total),int(npcY_total), 1)
	def getAlcLoc_func(self):
		(x,y,z) = player.GetMainCharacterPosition()
		lowX = int(x)/100
		lowY = int(y)/100
		self.alchemistLocX.SetText(str(lowX))
		self.alchemistLocY.SetText(str(lowY))
	def getFishes(self):		
####################	FISHES	######################
		self.catches = {}
		for key in range(27803, 27824):
			self.catches[key] = {}
		self.toFryFish = [fish for fish in range(27833, 27862)]
		self.deadFish = [fish for fish in range(27833, 27862)]
		self.liveFish = [fish for fish in range(27803, 27824)]
		self.friedFish = [fish for fish in range(27863, 27892)]
		self.HAIR1 = 70201
		self.HAIR2 = 70202
		self.HAIR3 = 70203
		self.HAIR4 = 70204
		self.HAIR5 = 70205
		self.HAIR6 = 70206
		# self.HAIR7 = 70207
		# self.HAIR8 = 70208
		self.catches[70049] = {}
		self.catches[70051] = {}
		self.catches[70050] = {}
		self.catches[70048] = {}
		self.catches[self.HAIR1] = {}
		self.catches[self.HAIR2] = {}
		self.catches[self.HAIR3] = {}
		self.catches[self.HAIR4] = {}
		self.catches[self.HAIR5] = {}
		self.catches[self.HAIR6] = {}
		# self.catches[self.HAIR7] = {}
		# self.catches[self.HAIR8] = {}
		self.campFire = 27600
		self.campFireRace = 12000
		step_x = 44
		step_y = 60
		min_x = 25
		min_y = 25
		max_x = 540
		current_x = min_x
		current_y = min_y
		self.images = []
		self.minnowID = 27802
		try:
			# Ensure consistent types
			self.hairIDs = set(range(70201, 70209))
			self.fishIds = set(range(27803, 27824))
		
			for id in self.catches.keys():
				if id:
					id = int(id)
		
					if current_x > max_x:
						current_x = min_x
						current_y += step_y
		
					selectItem(id)
					itemIcon = item.GetIconImageFileName()
					if itemIcon is None:
						continue
		
					self.images.append(self.comp.ExpandedImage(self.pnlFishes, current_x, current_y, str(itemIcon)))
		
					try:
						if id in self.fishIds:
							self.catches[id]['buttonOpen'] = self.comp.OnOffButton(
								self.pnlFishes, '', lang.TAB_FISH_KILL, current_x, current_y + 30
							)
					except:
						pass
		
					if (
						id == GOLD_RING or id == 70049 or id == 70051 or id == 70050 or id == 70048 or 
						(id in self.hairIDs and id != 27987)
					):
						self.catches[id]['buttonDrop'] = self.comp.OnOffButton(
							self.pnlFishes, '', lang.TAB_FISH_DROP, current_x, current_y + 30
						)
		
					if (
						id != GOLD_RING and id != GOLD_PIECE or 
						id == 70049 or id == 70051 or id == 70050 or id == 70048 or 
						(id in self.hairIDs and id != 27987)
					):
						self.catches[id]['buttonSell'] = self.comp.OnOffButton(
							self.pnlFishes, '', lang.TAB_FISH_SELL, current_x + 15, current_y + 30
						)
		
					current_x += step_x
		except:
			pass
		####################	FISHES	######################
	def getFishermanVnum(self):
		npc = self.fisherVnum.GetText()
		vid = player.GetTargetVID()
		race=chr.GetRace(vid)
		if vid != -1 or vid != 0:
			chr.SelectInstance(vid)
			race=chr.GetRace(vid)
		self.fisherVnum.SetText(str(race))
	def getNpcVnum_Func(self):
		npc = self.npcVnum.GetText()
		vid = player.GetTargetVID()
		race=chr.GetRace(vid)
		if vid != -1 or vid != 0:
			chr.SelectInstance(vid)
			race=chr.GetRace(vid)
		self.npcVnum.SetText(str(race))
	def getNpcLoc_func(self):
		(x,y,z) = player.GetMainCharacterPosition()
		lowX = int(x)/100
		lowY = int(y)/100
		self.npctoBuyLocX.SetText(str(lowX))
		self.npctoBuyLocY.SetText(str(lowY))
	def energyfunc_start(self):
		global select_item_toGiveID, inv, pauseEnergy, debugged,energy_state,energyBotState
		delay = self.energyDelay.GetText()
		self.energy_Stop.Show()
		self.energy_Start.Hide()
		energy_state = 'start'
		energyBotState = 1
		self.energyfunc()
	def energyfunc(self):
		global select_item_toGiveID, inv, pauseEnergy, debugged,energy_state
		self.energy_Stop.Show()
		self.energy_Start.Hide()
		try:
			delay = float(self.energyDelay.GetText())
		except:
			delay = 1
		self.energyfunc_startx.XX1(float(delay))
		self.energyfunc_startx.XX2(self.energyfunc)
		if pauseEnergy:
			self.GoToPositionAvoidingObjectsStop()
			return
		if self.buyAvailable.checked == 1:
			howMany = self.GetNumberOfFreeSlots()
		else:
			howMany = int(self.buyFromShopValue.GetText())
		self.InstallQuestWindowHook()
		yang = player.GetMoney()
		if select_item_toGiveID is None:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h Energy bot: " + lang.NO_ENERGY_ITEM)
			return
		if self.stopYang.checked == 1:
			try:
				neededYang = int(self.yangval.GetText())
			except:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hEnergy bot: " + lang.NO_ENERGY_YANG_TYPED)
				self.energyfunc_stop()
				return
			if yang < neededYang:
				self.energyfunc_stop()
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hEnergy bot: " + lang.ENERGY_STOP_YANG)
				return
		items_to_give = player.GetItemCountByVnum(int(select_item_toGiveID))
		if items_to_give <= howMany:
			energy_state = 'gotoshop'
		else:
			energy_state = 'gotoalc'
			
		if energy_state == 'gotoshop':
			npc_buy = self.scan_for_alchemist(int(self.npcVnum.GetText()))
			if GetDis(int(npc_buy)) == -1 or GetDis(int(npc_buy)) > 1000:
				self.energyfunc_startx.XX1(0.2)
				self.go_to_npc2()
			else:
				self.buy_items()
				if items_to_give >= howMany:
					energy_state = 'gotoalc'
		if energy_state == 'gotoalc':
			alchemistVID = self.scan_for_alchemist(20001)
			if GetDis(int(alchemistVID)) == -1 or GetDis(int(alchemistVID)) > 1000:
				self.energyfunc_startx.XX1(0.2)
				self.go_to_alchemist2()
			else:
				self.energyfunc_startx.XX1(float(delay))
				self.give_all_items_to_alchemist()
				if items_to_give == 0:
					energy_state = 'gotoshop'
					
					
	def buy_items(self):
		global select_item_toGiveID
		global energy_state,isGF
		item_to_buy = player.GetItemCountByVnum
		if self.buyAvailable.checked==1:
			howMany = self.GetNumberOfFreeSlots()
		else:
			howMany = self.buyFromShopValue.GetText()
		npc = self.npcVnum.GetText()
		oi = self.shopIndex.GetText()
		self.InstallQuestWindowHook()
		if npc == "0" or npc == "":
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hEnergy bot: " + lang.NO_ENERGY_NPC)
		else:
			if not shop.IsOpen():
				npc_vnum = self.scan_for_alchemist(int(npc))
				
				
				if isGF:
					clickPacket(npc_vnum)
					event.SelectAnswer(0, 0)
					
					clickPacket(npc_vnum)
					event.SelectAnswer(0, 1)
					event.ClearEventSet(1)
				else:
					clickPacket(npc_vnum)
					event.SelectAnswer(0, int(oi))
					event.ClearEventSet(1)
				
				
				
			for i in range(0,shop.SHOP_SLOT_COUNT):
				me = shop.GetItemID(i)
				if me == int(select_item_toGiveID):
					itemToBuy = player.GetItemCountByVnum
					if self.giveAllItems.checked == 1 and not isGF:
						if itemToBuy(int(select_item_toGiveID)) <= int(howMany):
							for x in range(int(howMany)):
								net.SendShopBuyPacket(i)
						else:
							net.SendShopEndPacket()
					else:
						if itemToBuy(int(select_item_toGiveID)) <= int(howMany):
							net.SendShopBuyPacket(i)
						else:
							net.SendShopEndPacket()
	def GetNumberOfFreeSlots(self):
		INV_FULL_MIN_EMPTY = 2
		MAX_INVENTORY_SIZE = 90
		numItems = MAX_INVENTORY_SIZE
		for i in range(0,MAX_INVENTORY_SIZE):
			curr_id = player.GetItemIndex(i)
			if curr_id != 0:
				selectItem(curr_id)
				s = item.GetItemSize()
				numItems-=s[0]*s[1]
		if numItems < INV_FULL_MIN_EMPTY:
			return 0
		else:
			return numItems - INV_FULL_MIN_EMPTY
	def showBuyItems(self):
		try:
			self.buyFromShopTxt.Show()
			self.buyFromShopValue.Show()
			self.buyFromShopLblItems.Show()
		except:
			pass
	def hideBuyItems(self):
		try:
			self.buyFromShopTxt.Hide()
			self.buyFromShopValue.Hide()
			self.buyFromShopLblItems.Hide()
		except:
			pass
	def transform_to_crystals_on(self):
		self.transform_to_crystalsx.XX1(1)
		self.transform_to_crystalsx.XX2(self.transform_to_crystals_on)
		self.InstallQuestWindowHook()
		getSplitter = player.GetItemCountByVnum
		self.transformStop.Show()
		self.transformStart.Hide()
		alchemistVID = self.scan_for_alchemist(20001)
		clickPacket(alchemistVID)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h Energy bot: " + lang.TRY_ENERGY_CRYSTAL)
		if getSplitter(51001) >= 30:
			event.SelectAnswer(0, 5)
			event.SelectAnswer(0, 254)
			event.SelectAnswer(0, 254)
			event.SelectAnswer(0, 0)
			event.SelectAnswer(0, 0)
		event.ClearEventSet(1)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h Energy bot: " + lang.FINISH_ENERGY_CRYSTAL)
	def transform_to_crystals_off(self):
		self.transform_to_crystalsx.XX1(9999999)
		self.transform_to_crystalsx.XX2(self.transform_to_crystals_off)
		self.transformStop.Hide()
		self.transformStart.Show()
		self.UnHookQuestWindow(0)
	def process_item_count(self, vnum):
		times_to_act = 1
		getSplitter = player.GetItemCountByVnum
		item_count = getSplitter(vnum)
		if item_count % 30 != 0 and item_count > 0:
			times_to_act = item_count // 30
		return times_to_act
		
	def give_all_items_to_alchemist(self):
		global select_item_toGiveID, energy_state
		self.InstallQuestWindowHook()
		alchemistVID = self.scan_for_alchemist(20001)
		frag = self.fragval.GetText()
		getSplitters = self.process_item_count(51001)
		try:
			delay = float(self.energyDelay.GetText())
		except:
			delay = 0.6
		DistanceToNext = GetDis(alchemistVID)
		if DistanceToNext > 1200 or DistanceToNext == -1:
			return  
		items_to_give = player.GetItemCountByVnum(int(select_item_toGiveID))
		if items_to_give == 0:
			energy_state = 'gotoshop'
			self.energyfunc_startx.XX1(delay)
			self.energyfunc_startx.XX2(self.energyfunc)
			return 
		for i in range(player.INVENTORY_PAGE_SIZE * 10):
			a = player.GetItemIndex(i)
			if a == int(select_item_toGiveID):
				if self.giveAllItems.checked == 0:
					net.SendGiveItemPacket(alchemistVID, i, 1)
					event.SelectAnswer(1, 0)
					event.SelectAnswer(1, 0)
					event.ClearEventSet(1)
					self.energyfunc_startx.XX1(delay)
					self.energyfunc_startx.XX2(self.give_all_items_to_alchemist)
					return
				net.SendGiveItemPacket(alchemistVID, i, player.GetItemCount(i))
				event.SelectAnswer(1, 0)
				event.SelectAnswer(1, 0)
				event.ClearEventSet(1)
		if self.crystal.checked == 1 and player.GetItemCountByVnum(51001) > int(frag):
			for i in range(getSplitters):
				clickPacket(alchemistVID)
				event.SelectAnswer(0, 5)
				event.SelectAnswer(0, 254)
				event.SelectAnswer(0, 254)
				event.SelectAnswer(0, 0)
				event.SelectAnswer(0, 0)
				event.ClearEventSet(1)
		items_remaining = player.GetItemCountByVnum(int(select_item_toGiveID))
		if items_remaining == 0:
			energy_state = 'gotoshop'
			self.energyfunc_startx.XX1(delay)
			self.energyfunc_startx.XX2(self.energyfunc)
	def energyfunc_stop(self):
		global game,OldRecv,energy_state,energyBotState
		self.energyfunc_startx.XX1(9999999)
		self.energyfunc_startx.XX2(self.energyfunc_stop)
		self.energy_Stop.Hide()
		self.energy_Start.Show()
		self.Debug()
		try:
			if not game:
				import game
			game.GameWindow.OpenQuestWindow = OldRecv
		except:
			pass
		self.current_route_step = 0
		energyBotState = 0
		energy_state = 'stop'
		create_log("Energy bot: Stopped.")
		self.GoToPositionAvoidingObjectsStop()
	def disable_qestion(self):
		if find_string(st_cur_server, "aronix") or  find_string(st_cur_server, "metin2sg") or foundx64PythonList:
			self.QuestionDialog = uiCommon.QuestionDialog()
		else:
			self.QuestionDialog = QuestionDialog()
		self.QuestionDialog.Close()
		self.QuestionDialog = None
	def drop_items_f(self):
		fromSlot = self.destroyFrom.GetText()
		toSlot = self.destroyTo.GetText()
		for i in range(int(fromSlot), int(toSlot)):
			net.SendItemDropPacketNew(i,player.GetItemCount(i))
			self.QuestionDialog.Close()
			self.QuestionDialog = None
	def drop_dest_func(self):
		if find_string(st_cur_server, "aronix") or  find_string(st_cur_server, "metin2sg") or foundx64PythonList:
			self.QuestionDialog = uiCommon.QuestionDialog()
		else:
			self.QuestionDialog = QuestionDialog()
		self.QuestionDialog.SetText(lang.STR_DROP_INSTEAD)
		self.QuestionDialog.SetAcceptEvent(__mem_func__(self.drop_items_f))
		self.QuestionDialog.SetCancelEvent(__mem_func__(self.disable_qestion))
		self.QuestionDialog.Open()
	def ask_destroy(self):
		fromSlot = self.destroyFrom.GetText()
		toSlot = self.destroyTo.GetText()
		if find_string(st_cur_server, "aronix") or  find_string(st_cur_server, "metin2sg") or foundx64PythonList:
			self.QuestionDialog = uiCommon.QuestionDialog()
		else:
			self.QuestionDialog = QuestionDialog()
		self.QuestionDialog.SetText(lang.STR_CONFIRM_DESTROY)
		self.QuestionDialog.SetAcceptEvent(__mem_func__(self.destroy_func))
		self.QuestionDialog.SetCancelEvent(__mem_func__(self.disable_qestion))
		self.QuestionDialog.Open()
	def destroy_func(self):
		fromSlot = self.destroyFrom.GetText()
		toSlot = self.destroyTo.GetText()
		try:
			for i in range(int(fromSlot), int(toSlot)):
				destroyItemFunction(i)
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hItem destroyer: " + lang.STR_DEL_OK)
				self.QuestionDialog.Close()
				self.QuestionDialog = None
			if self.autoRefreshInventory.checked == 1:
				eventHandler.add(0.3, self.refresh_item_list)
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hItem destroyer: " + lang.STR_SOME_WENT_WRONG)
	def use_dews(self):
		if foundx64PythonList:
			for Slot in range(player.INVENTORY_PAGE_SIZE * 10):
				try:
					if player.GetItemIndex(Slot) >= 50801 and player.GetItemIndex(Slot) <= 50826:
						eventHandler.add(0.5 * Slot, lambda Slot=Slot: useItemFunc(Slot), 'useItemFunc')
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(Slot) >= 71044 and player.GetItemIndex(Slot) <= 71046:
						eventHandler.add(0.5 * Slot, lambda Slot=Slot: useItemFunc(Slot), 'useItemFunc')
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(Slot) >= 72025 and player.GetItemIndex(Slot) <= 72042:
						eventHandler.add(0.5 * Slot, lambda Slot=Slot: useItemFunc(Slot), 'useItemFunc')
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(Slot) >= 39024 and player.GetItemIndex(Slot) <= 39026:
						eventHandler.add(0.5 * Slot, lambda Slot=Slot: useItemFunc(Slot), 'useItemFunc')
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(Slot) >= 71044 and player.GetItemIndex(Slot) <= 71045:
						eventHandler.add(0.5 * Slot, lambda Slot=Slot: useItemFunc(Slot), 'useItemFunc')
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(Slot) >= 39017 and player.GetItemIndex(Slot) <= 39021:
						eventHandler.add(0.5 * Slot, lambda Slot=Slot: useItemFunc(Slot), 'useItemFunc')
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(Slot) >= 71027 and player.GetItemIndex(Slot) <= 71031:
						eventHandler.add(0.5 * Slot, lambda Slot=Slot: useItemFunc(Slot), 'useItemFunc')
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(Slot) >= 27863 and player.GetItemIndex(Slot) <= 27892:
						eventHandler.add(0.5 * Slot, lambda Slot=Slot: useItemFunc(Slot), 'useItemFunc')
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(Slot) >= 27863 and player.GetItemIndex(Slot) <= 27892:
						eventHandler.add(0.5 * Slot, lambda Slot=Slot: useItemFunc(Slot), 'useItemFunc')
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(51002):
						eventHandler.add(0.5, lambda: useItemFunc(51002), 'useItemFunc')
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(71101) or player.GetItemIndex(76003) or player.GetItemIndex(39031):
						eventHandler.add(0.5, lambda: useItemFunc(71101), 'useItemFunc')
						eventHandler.add(0.5, lambda: useItemFunc(76003), 'useItemFunc')
						eventHandler.add(0.5, lambda: useItemFunc(39031), 'useItemFunc')
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
				except:
					pass
		else:
			try:
				for Slot in range(player.INVENTORY_PAGE_SIZE * 10):
					getItemCount = player.GetItemCount(Slot)
					if player.GetItemIndex(Slot) >= 50801 and player.GetItemIndex(Slot) <= 50826:
						useItemFunc(Slot)
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(Slot) >= 71044 and player.GetItemIndex(Slot) <= 71046:
						useItemFunc(Slot)
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(Slot) >= 72025 and player.GetItemIndex(Slot) <= 72042:
						useItemFunc(Slot)
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(Slot) >= 39024 and player.GetItemIndex(Slot) <= 39026:
						useItemFunc(Slot)
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(Slot) >= 71044 and player.GetItemIndex(Slot) <= 71045:
						useItemFunc(Slot)
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(Slot) >= 39017 and player.GetItemIndex(Slot) <= 39021:
						useItemFunc(Slot)
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(Slot) >= 71027 and player.GetItemIndex(Slot) <= 71031:
						useItemFunc(Slot)
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(Slot) >= 27863 and player.GetItemIndex(Slot) <= 27892:
						useItemFunc(Slot)
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(Slot) >= 27863 and player.GetItemIndex(Slot) <= 27892:
						useItemFunc(Slot)
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(51002):
						useItemFunc(51002)
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
					if player.GetItemIndex(71101) or player.GetItemIndex(76003) or player.GetItemIndex(39031):
						useItemFunc(71101)
						useItemFunc(76003)
						useItemFunc(39031)
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDews manager: " + lang.STR_DEWS_MANAGER + " " + str(Slot) + " -> " + str(item.GetItemName(selectItem(player.GetItemIndex(Slot)))))
			except:
				pass
	def yangBtn_func(self):
		if find_string(st_cur_server, "Guabina"):
			net.SendWonExchangeSellPacket(1)
		else:
			if self.fix_questCB.checked==1:
				self.InstallQuestWindowHook()
			else:
				pass
			slotChange = self.changeSlot.GetText()
			storeHouse_vid = self.ScanForNPCByRace(9005)
			chr.SelectInstance(storeHouse_vid)
			clickPacket(storeHouse_vid)
			event.SelectAnswer(0, int(slotChange))
			event.SelectAnswer(0, 0)
			net.SendQuestInputStringPacket(str(1))	
			event.SelectAnswer(1, 0)
			event.ClearEventSet(1)
	def wonBtn_func(self):
		if find_string(st_cur_server, "Guabina"):
			net.SendWonExchangeBuyPacket(1)
		else:
			if self.fix_questCB.checked==1:
				self.InstallQuestWindowHook()
			else:
				pass
			slotChange = self.changeSlot.GetText()
			storeHouse_vid = self.ScanForNPCByRace(9005)
			chr.SelectInstance(storeHouse_vid)
			clickPacket(storeHouse_vid)
			event.SelectAnswer(0, int(slotChange))
			event.SelectAnswer(1, 1)
			net.SendQuestInputStringPacket(str(1))	
			event.SelectAnswer(1, 0)
			event.ClearEventSet(1)
	def GetPositiveValue(self, value):
		if value < 0:
			return value - (2*value)
		else:
			return value
	def GetDistance(self, x, y):
		(PlayerX, PlayerY, PlayerZ) = player.GetMainCharacterPosition()	
		(TmpX, TmpY) = (self.GetPositiveValue(PlayerX - x) ** 2, self.GetPositiveValue(PlayerY - y) ** 2)
		return(math.sqrt(TmpX + TmpY))
	def GetClass(self):
		race = int(net.GetMainActorRace())
		group = int(net.GetMainActorSkillGroup())
		if find_string(st_cur_server, "Nw2Online") or find_string(st_cur_server, "nextworld"):
			war = 'warrior'
			ninja = 'Assassin'
			sura = 'ezra'
			shaman = 'mage'
		else:
			war = 'warrior'
			ninja = 'assassin'
			sura = 'sura'
			shaman = 'shaman'
		if group==2:
			group=0
		if race == 0 or race == 4:
			return str(war) + '|' + str(group)
		elif race == 1 or race == 5:
			return str(ninja) + '|' + str(group)
		elif race == 2 or race == 6:
			return str(sura) + '|' + str(group)
		elif race == 3 or race == 7:
			return str(shaman) + '|' + str(group)
		elif race == 8:
			return 'Wolfman' + '|' + str(group)
	def NewSkillsEnable(self):
		playersettingmodule = EterPackOperator("playersettingmodule.py").read()
		RaceGroupInfo = self.GetClass()
		Class = str(RaceGroupInfo).split("/")[0]
		#msg("Class: " + str(Class))
		if str(Class) == "Shaman" or str(Class) == "Sura":
			return 6
		else:
			if str(playersettingmodule).count("36") >= 4:
				return 6
			else:
				return 5
	def GetSkillIcon(self):
		try:
			playerClass = self.GetClass()
			playerSkills = {}
			try:
				skills = self.NewSkillsEnable()
			except:
				skills = 6
			if find_string(st_cur_server, "Nw2Online") or find_string(st_cur_server, "nextworld"):
				war = 'warrior'
				ninja = 'Assassin'
				sura = 'ezra'
				shaman = 'mage'
			else:
				war = 'warrior'
				ninja = 'assassin'
				sura = 'sura'
				shaman = 'shaman'
			playerSkills[str(war) + '|0'] = ['gigongcham', 'gyeoksan','daejin', 'cheongeun', 'geompung','noegeom']
			playerSkills[str(war) + '|1'] = ['samyeon', 'palbang','jeongwi', 'geomgyeong', 'tanhwan','gihyeol']
			playerSkills[str(ninja) + '|0'] = ['yeonsa', 'gwangyeok','hwajo', 'gyeonggong', 'gigung', 'dokgigung']
			playerSkills[str(ninja) + '|1'] = ['amseup', 'gungsin','charyun', 'eunhyeong', 'sangong','seomjeon']
			playerSkills[str(sura) + '|0'] = ['maryeong', 'hwayeom','muyeong', 'heuksin', 'tusok', 'mahwan']
			playerSkills[str(sura) + '|1'] = ['swaeryeong', 'yonggwon','gwigeom', 'gongpo', 'jumagap', 'pabeop']
			playerSkills[str(shaman) + '|0'] = ['noejeon', 'byeorak', 'pokroe','jeongeop_target', 'kwaesok', 'jeungryeok']
			playerSkills[str(shaman) + '|1'] = ['bipabu', 'yongpa','paeryong', 'hosin', 'boho', 'gicheon']
			playerSkills['Wolfman|0'] = ['split_slash', 'wind_death', 'reef_attack','wreckage', 'red_possession', 'blue_possession']
			playerSkills['Wolfman|1'] = ['split_slash', 'wind_death', 'reef_attack','wreckage', 'red_possession', 'blue_possession']
			self.skillBtns = {}
			idx = 0
			for val in playerSkills.get(playerClass, []):
				button_id = 'AutoSkillUse%d' % (idx + 1)
				button = getattr(self, button_id)
				image_path = ymir + uiskill + '%s/%s_03.sub' % (playerClass.split('|')[0], val)
				button.LoadImage(image_path)
				idx += 1
		except:
			pass
	def OpenWindowShopScanner(self):
		searchDialog = SearchDialog()
		searchDialog.Board.Show()
		searchDialog.Show()
	def OpenWindowShopCreator(self):
		_shop = ShopDialog()
		_shop.Shopw_UI()
	def OpenWindowAutoMetin(self):
		pos = self.metin2_window.GetGlobalPosition()
		self.BoardAutoMetin.SetPosition(pos[0] + (self.metin2_window.GetWidth() - self.metin2_window.GetWidth() - self.BoardAutoMetin.GetWidth()),pos[1])
		try:
			self.readCurrentRoute()
		except:
			pass
		if self.BoardAutoMetin.IsShow():
			self.BoardAutoMetin.Hide()
		else:
			self.BoardAutoMetin.Show()
	def save_boss_cfg(self):
		plm = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'custom_bosses.cfg'
		if not os.path.exists(plm):
			open_file(plm, "a").close()
	
		cusboss = open_file(plm, "r+")
		vid = player.GetTargetVID()
	
		if vid != -1 and vid != 0:
			chr.SelectInstance(vid)
			race = chr.GetRace(vid)
		else:
			race = None
	
		search_word = self.more_boss.GetText()
		if string_contains(search_word, cusboss.read()):
			text = "[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCustom bosses: Mob with ID: " + str(race) + " already exists!"
			msg(str(text))
			try:
				cusboss.close()
			except:
				pass
			return
	
		if race is not None:
			chr.SelectInstance(vid)
			race = chr.GetRace(vid)
			monster_name = nonplayer.GetMonsterName(race)
			text = "[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCustom bosses: " + lang.STR_ADD_BOSS + " " + str(monster_name) + " " + lang.STR_ADD_BOSSID + " " + str(race)
			msg(str(text))
	
			save = open_file(plm, "a")
			lol = self.more_boss.GetText()
			save.write(str(lol) + "\n")
			save.close()
	
		try:
			cusboss.close()
		except:
			pass
	def rem_ignore_metin_func(self):
		global temp_metin_vid
		ignoreFile = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'metins_to_ignore.txt'
		try:
			os.remove(ignoreFile)
			if not self.fileExists(ignoreFile):
				x = open_file(ignoreFile, "w")
				x.close()
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hIgnore metin list removed succesfully.")
		except Exception:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hIgnore metin list already removed.")
			
	### PLAYERS ONLINE ###
	
	def disablePlayersOnline(self):
		self.PlayersxOnline.XX1(999999)
		self.PlayersxOnline.XX2(self.disablePlayersOnline)
		pauseFuncs(0)
		ResetFlags()
	def enablePlayersOnline(self):
		self.PlayersxOnline.XX1(0.5)
		self.PlayersxOnline.XX2(self.enablePlayersOnline)
		if not canCheckForOnlineUsers:
			return
		if not isConnect():
			self.PlayersxOnline.XX1(5)
			return
		self.checkUsersOnline()
		
	def checkUsersOnline(self):
		global finishedChecking,playerOnline,antiban_state,tempAntiBan
	
		if not finishedChecking:
			return
		if playerOnline:
			if antiban_state:
				tempAntiBan = 1
				self.antibanStop()
			pauseFuncs(1, debug=False)
		self.refreshOnlinePlayersList()
		StartUserCheck()
		
		
	def showPlayerOnlineWindow(self):
		if self.playersOnlineWindow.IsShow():
			self.playersOnlineWindow.Hide()
			self.keepPlayersWindowOff()
		else:
			self.keepPlayersWindowOn()
			self.playersOnlineWindow.Show()
			
	def keepPlayersWindowOff(self):
		self.keepPlayersxWindowOff.XX1(9999999)
		self.keepPlayersxWindowOff.XX2(self.keepPlayersWindowOff)
	def keepPlayersWindowOn(self):
		global isAntiBanTab
		self.keepPlayersxWindowOff.XX1(0.01)
		self.keepPlayersxWindowOff.XX2(self.keepPlayersWindowOn)
		try:
			if not isAntiBanTab:
				self.playersOnlineWindow.Hide()
				return
		
			if self.metin2_window.IsShow() and isAntiBanTab:
				pos = self.metin2_window.GetGlobalPosition()
				self.playersOnlineWindow.SetPosition(pos[0]+self.playersOnlineWindow.GetWidth() + 500,pos[1] + self.playersOnlineWindow.GetHeight() + 50)
		except:
			self.keepPlayersWindowOff()
			
	def funcAddTargetPlayerOnline(self):
		vid = player.GetTargetVID()
		
		orange = "|cFFFF8040|H|h"
		yellow = "|cffFFFF00|H|h"
		
		if not vid:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlease select a target first!")
			return
			
		player_name = chr.GetNameByVID(vid)			
		a = chr.GetInstanceType(vid)
		if a != playerType:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + orange + str(player_name) + yellow + " is not a player!")
			return
		myName = str(getcharName())
		
		if player_name == myName:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hYou can't add yourself to online players list!")
			return
			
		if player_name in self.onlinePlayersList:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer already exists in the list.")
			return
		self.refreshOnlinePlayersList()
		self.onlinePlayersList.append(player_name)
		self.SavePlayersToFile()
		self.refreshOnlinePlayersList()
		self.playerOnlineText.SetText("")
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer " + orange + str(player_name) + yellow + " added to the list.")	
		
		
		
			
	def addPlayerToOnlineList(self):
		
		player_name = self.playerOnlineText.GetText().strip()
		if not player_name:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer name cannot be empty!")
			
			return
	
		if player_name in self.onlinePlayersList:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer already exists in the list.")
			return
		orange = "|cFFFF8040|H|h"
		yellow = "|cffFFFF00|H|h"
		self.onlinePlayersList.append(player_name)
		self.SavePlayersToFile()
		self.refreshOnlinePlayersList()
		self.playerOnlineText.SetText("")
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer " + orange + str(player_name) + yellow + " added to the list.")
	def removePlayerFromOnlineList(self):
		global playerOnline
		
		selected_index = self.playersOnlineList.GetSelectedItem()
		if selected_index is None:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hNo player selected to remove!")
			return
		orange = "|cFFFF8040|H|h"
		yellow = "|cffFFFF00|H|h"
		selected_player = selected_index.GetText()  # Get player name (string)
		
		if selected_player not in self.onlinePlayersList:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlayer not found in the list!")
			return
		self.onlinePlayersList.remove(selected_player)
		self.SavePlayersToFile()
		self.refreshOnlinePlayersList()
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRemoved player: " + orange + str(selected_player))
		if not any([checkedUsers.get(player, False) for player in self.onlinePlayersList]):
			playerOnline = False
			pauseFuncs(0)
	
	
	def onlinePlayersInfo(self):
		newMsg("STMod will detect all users specified in your list if they are online or not, if any of them is found online, will toggle automatically the Panic mode, when no user is found online, will resume botting.\n\nKeep in mind that you MUST use CASE SENSITIVE for names, in order to be detected correctly!\nNOTICE: This can't work if your character is muted!", "down", 15, "box_blue", "text_white", 500, 200)
		
	def askdeleteOnlinePlayersList(self):
		try:
			if find_string(st_cur_server, "aronix") or  find_string(st_cur_server, "metin2sg") or foundx64PythonList:
				self.QuestionDialog = uiCommon.QuestionDialog()
			else:
				self.QuestionDialog = QuestionDialog()
			self.QuestionDialog.SetText('Are you sure you want to delete entire list?')
			self.QuestionDialog.SetAcceptEvent(__mem_func__(self.deleteOnlinePlayersList))
			self.QuestionDialog.SetCancelEvent(__mem_func__(self.CancelQuestionDialog))
			self.QuestionDialog.Open()
		except:
			pass
		
		
	def deleteOnlinePlayersList(self):
		try:
			self.playersOnlineList.RemoveAllItems()
		except:
			pass
		file = open_file(st_path + "/Data/Servers/" + str(st_cur_server) + '/playersList.cfg', "w")
		file.close()
		self.disablePlayersOnline()
		self.stopBotIfPlayerOnline.OnToggleUp()
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hAll players have been removed.")
		self.CancelQuestionDialog()
	def refreshOnlinePlayersList(self):
		try:
			self.playersOnlineList.RemoveAllItems()
		except:
			pass
	
		self.LoadPlayersFromFile()
		
		userQueue[:] = self.onlinePlayersList[:]
	
		for player in self.onlinePlayersList:
			self.playersOnlineList.AppendItem(Item(player))
	
	def SavePlayersToFile(self):
		try:
			file = open_file(st_path + "/Data/Servers/" + str(st_cur_server) + '/playersList.cfg', "w")
			for player in self.onlinePlayersList:
				file.write(player + "\n")
			file.close()
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFF0000|H|hError saving players list!")
	
	
	def LoadPlayersFromFile(self):
		global userQueue
	
		file_path = st_path + "/Data/Servers/" + str(st_cur_server) + '/playersList.cfg'
		
		if not os.path.exists(file_path):
			return
		
		try:
			file = open_file(file_path, "r+")
			self.onlinePlayersList = [line.strip() for line in file.readlines()]
			file.close()
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFF0000|H|hError loading players list!")
	
		userQueue[:] = self.onlinePlayersList[:]
			
	### PLAYERS ONLINE ###		
			
	def showBossWindow(self):
		if self.bossEditorWindow.IsShow():
			self.bossEditorWindow.Hide()
			self.keepBossWindowOff()
		else:
			self.keepBossWindowOn()
			self.bossEditorWindow.Show()
			
	def keepBossWindowOff(self):
		self.keepBossXWindow.XX1(9999999)
		self.keepBossXWindow.XX2(self.keepBossWindowOff)
	def keepBossWindowOn(self):
		global isFarmingTab
		self.keepBossXWindow.XX1(0.01)
		self.keepBossXWindow.XX2(self.keepBossWindowOn)
		try:
			if not isFarmingTab:
				self.bossEditorWindow.Hide()
				return
		
			if self.metin2_window.IsShow() and isFarmingTab:
				pos = self.metin2_window.GetGlobalPosition()
				self.bossEditorWindow.SetPosition(pos[0]+self.bossEditorWindow.GetWidth() + 55,pos[1] + self.bossEditorWindow.GetHeight())
		except:
			self.keepBossWindowOff()
			
			
	def removeExistingBossIgnoreList(self):
		ignoreFile = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'bosses_to_ignore.txt'
		try:
			os.remove(ignoreFile)
			if not self.fileExists(ignoreFile):
				x = open_file(ignoreFile, "w")
				x.close()
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hIgnore bosses list removed succesfully.")
		except Exception:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hIgnore bosses list already removed.")
			
	def ignoreBossFunc(self):
		vid = player.GetTargetVID()
		if not vid:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hIgnore bosses: " + lang.NO_TARGET)
			return
			
		chr.SelectInstance(vid)
		mobId=chr.GetRace(vid)
		name = chr.GetNameByVID(vid)
		orange = "|cFFFF8040|H|h"
		yellow = "|cffFFFF00|H|h"
		dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'bosses_to_ignore.txt'
		
		if not self.fileExists(dirPl):
			non_detect = open_file(dirPl, "w")
			non_detect.close()
		
		file = open_file(dirPl, "r+")
		search_word = mobId
		if os.stat(dirPl).st_size == 0:
			non_detect = open_file(dirPl, "a")
			non_detect.write('\n')
			non_detect.write(str(mobId))
			non_detect.close()
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hIgnore bosses: Succesfully added " + orange + str(name) + yellow + " to ignore list.")
		else:
			if(str(search_word) in file.read()):
				text =  "[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hIgnore bosses: Boss with name " + orange + str(name) + yellow + " already exists!"
				msg(str(text))
				return
			else:
				if os.path.exists(dirPl):
					non_detect = open_file(dirPl, "a")
					non_detect.write('\n')
					non_detect.write(str(mobId))
					non_detect.close()
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hIgnore bosses: Succesfully added " + orange + str(name) + yellow + " to ignore list.")
				else:
					non_detect = open_file(dirPl, "w")
					non_detect.write('\n')
					non_detect.write(str(mobId))
					non_detect.close()
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hIgnore bosses: Succesfully added " + orange + str(name) + yellow + " to ignore list.")
			
			
			
			
			
			
	def rem_boss_func(self):
		global temp_metin_vid,boss_list
		try:
			boss_list = []
			os.remove(st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'custom_bosses.cfg')
			self.more_boss.SetText("")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.STR_REM_BOSS)
		except Exception:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCustom boss list already removed.")
	def load_boss(self):
		global boss_list,bossesLoaded
		try:
			import os
		except:
			return
		try:
			if os.path.exists(st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'custom_bosses.cfg'):
				if os.stat(st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'custom_bosses.cfg').st_size != 0:
					bosses = open_file(st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'custom_bosses.cfg', 'r+').read().split()
					for x in range(len(bosses)):
						lol = self.more_boss.GetText()
						self.more_boss.SetText('')
						self.more_boss.SetText(str(lol+' '+bosses[x]))
						boss_list.append(bosses[x])
						bossesLoaded = 1
				else:
					non_detect = open_file(st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'custom_bosses.cfg', "a")
					non_detect.write("\n")
					non_detect.close()
				#bosses.close()
		except:
			pass
	def load_metinandboss(self):
		self.load_boss()
	def nextInListPlayer(self):		
		for i in range(3):
			self.playerList.SetCurrentItem(i)
		self.CloseListBox()
	def add_boss_func(self):
		global temp_metin_vid,boss_list
		self.more_boss.SetText('')
		vid = player.GetTargetVID()
		if vid != -1 or vid != 0:
			chr.SelectInstance(vid)
			race=chr.GetRace(vid)
			if race not in boss_list:
				boss_list.append(race)
		lol = self.more_boss.GetText()
		self.more_boss.SetText(str(lol)+ ' ' + str(race))
		self.save_boss_cfg()
	def keepChAttachedWindowMBFuncOff(self):
		self.keepChAttachedWindowMBxFunc.XX1(9999999)
		self.keepChAttachedWindowMBxFunc.XX2(self.keepChAttachedWindowMBFuncOff)
	def keepChAttachedWindowMBFuncOn(self):
		self.keepChAttachedWindowMBxFunc.XX1(0.01)
		self.keepChAttachedWindowMBxFunc.XX2(self.keepChAttachedWindowMBFuncOn)
		try:
			if self.metin2_window.IsShow():
				pos = self.metin2_window.GetGlobalPosition()
				self.mb_detector.SetPosition(pos[0],pos[1]+self.metin2_window.GetHeight())
			else:
				self.keepChAttachedWindowMBFuncOff()
		except:
			self.keepChAttachedWindowMBFuncOff()
	def OpenWindowMB_Detect(self):
		pos = self.metin2_window.GetGlobalPosition()
		self.mb_detector.SetPosition(pos[0],pos[1]+self.metin2_window.GetHeight())
		if self.mb_detector.IsShow():
			self.mb_detector.Hide()
			self.keepChAttachedWindowMBFuncOff()
		else:
			self.mb_detector.Show()
			self.keepChAttachedWindowMBFuncOn()
			try:
				self.load_metinandboss()
				create_log("Loaded succesfully custom bosses ids.")
			except Exception:
				create_log("Cannot import custom bosses ids list, " + lang.STR_ERR_MSG)
	def CloseMB_Detect(self):
		self.mb_detector.Hide()
	def confirmRouteFunc(self):
		global confirmRoute
		confirmRoute = 1
		route = self.newrouteName.GetText()
		try:
			os.mkdir(st_path + "/Data/Routes")
		except:
			pass
		path = st_path + "/Data/Routes" + '/' + route
		self.confirmRouteFuncX.XX1(1)
		self.confirmRouteFuncX.XX2(self.confirmRouteFunc)
		self.QuestionDialog.Close()
		self.QuestionDialog = None
		try:
			os.remove(path)
		except:
			pass
		self.recordRouteFuncOn()
	def unconfirmRoute(self):
		global confirmRoute
		self.QuestionDialog.Close()
		self.QuestionDialog = None
		self.newRouteRecordBtn.SetUp()
		confirmRoute = 0
		self.recordRouteFuncOff()
	def CloseAutoMetin(self):
		self.BoardAutoMetin.Hide()
	def recordRoute(self, arg):
		global confirmRoute
		route = self.newrouteName.GetText()
		try:
			os.mkdir(st_path + "/Data/Routes")
		except:
			pass
		path = st_path + "/Data/Routes" + '/' + route
		if arg=='on':
			if os.path.exists(path):
				if confirmRoute == 1:
					self.QuestionDialog.Close()
					self.QuestionDialog = None
					self.recordRouteFuncOn()
					self.routeCoords.SetText("")
				else:
					if find_string(st_cur_server, "aronix") or  find_string(st_cur_server, "metin2sg") or foundx64PythonList:
						self.QuestionDialog = uiCommon.QuestionDialog()
					else:
						self.QuestionDialog = QuestionDialog()
					self.QuestionDialog.SetText("Route with name " + str(route) + " already exists, overwrite it?")
					self.QuestionDialog.SetAcceptEvent(__mem_func__(self.confirmRouteFunc))
					self.QuestionDialog.SetCancelEvent(__mem_func__(self.unconfirmRoute))
					self.QuestionDialog.Open()
			else:
				self.recordRouteFuncOn()
				confirmRoute = 1
				self.routeCoords.SetText("")
		elif arg=='off':
			self.recordRouteFuncOff()
			confirmRoute = 0
	def clearRoute(self):
		if find_string(st_cur_server, "aronix") or  find_string(st_cur_server, "metin2sg") or foundx64PythonList:
			self.QuestionDialog = uiCommon.QuestionDialog()
		else:
			self.QuestionDialog = QuestionDialog()
		self.QuestionDialog.SetText(lang.STR_REM_ROUTE)
		self.QuestionDialog.SetAcceptEvent(__mem_func__(self.clearRouteFunc))
		self.QuestionDialog.SetCancelEvent(__mem_func__(self.endClientStop))
		self.QuestionDialog.Open()
	def clearRouteFunc(self):
		try:
			route = self.routeListbox.DropList.GetSelectedItem().textBox.GetText()
			try:
				import os
			except:
				pass
			try:
				os.mkdir(st_path + "/Data/Routes")
			except:
				pass
			if os.path.exists(st_path + "/Data/Routes" + '/' + route):
				try:
					os.remove(st_path + "/Data/Routes" + '/' + route)
					create_log("Farmbot: Removed '" + str(route) + "' route")
				except Exception:
					create_log("Farmbot: Can't remove '" + str(route) + "' route, " + lang.STR_ERR_MSG)
			else:
				pass
			self.routeCoords.SetText("")
			self.endClientStop()
			try:
				self.listCoord.RemoveAllItems()
			except:
				pass
			self.path = []
			self.refreshRouteListFunc()
		except:
			self.endClientStop()
	def recordRouteFuncOff(self):
		route = self.newrouteName.GetText()
		self.recordRouteFuncX.XX1(9999999)
		self.recordRouteFuncX.XX2(self.recordRouteFuncOff)
		self.confirmRouteFuncX.XX1(9999999)
		self.confirmRouteFuncX.XX2(self.recordRouteFuncOff)
		self.refreshRouteListFunc()
		self.readCurrentRoute()
		if self.farmInRangeCB.checked==1:
			self.routeListbox.Hide()
	def saveRoute(self):
		route = self.newrouteName.GetText()
		try:
			os.mkdir(st_path + "/Data/Routes")
		except:
			pass
		path = st_path + "/Data/Routes" + '/' + route
		if os.path.exists(path):
			save = open_file(path, 'a')
			save.write(self.routeCoords.GetText())
			save.write("\n")
			save.close()
		else:
			save = open_file(path, 'w')
			save.close()
	def recordRouteFuncOn(self):
		global confirmRoute
		confirmRoute = 1
		route = self.newrouteName.GetText()
		self.recordRouteFuncX.XX1(1)
		self.recordRouteFuncX.XX2(self.recordRouteFuncOn)
		x1, y1, z1 = player.GetMainCharacterPosition()
		x, y, z = player.GetMainCharacterPosition()
		x = x / 100
		y = y / 100
		existing_coords = []
		for coord in self.routeCoords.GetText().split("\n"):
			parts = coord.split()
			if len(parts) == 2:
				x_coord, y_coord = parts
				existing_coords.append((int(x_coord), int(y_coord)))
		for coord in existing_coords:
			if self.inside_circle(x1, y1, coord[0], coord[1], 500):
				return
		self.listCoord.AppendItem(Item(str(int(GetMainPos()[0])) + str(' ') + str(int(GetMainPos()[1]))))
		self.routeCoords.SetText((str(int(GetMainPos()[0])) + str(' ') + str(int(GetMainPos()[1]))))
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: Added to route: " + str(route) + " " + "|cffFFFF00|H|h" +  lang.STR_FARMCOORD + " |cff00FF00|H|hX: " + str(int(x)) + ' Y: ' + str(int(y)) + "|cffFFFF00|H|h " + lang.STR_FARMCOORDOK)
		create_log("Farmbot: Recording route, added coordinates - X: " + str(x) + ' Y: ' + str(y))
		self.saveRoute()
	def addCustomOre(self):
		vid = player.GetTargetVID()
		name = chr.GetNameByVID(vid)
		orange = "|cFFFF8040|H|h"
		yellow = "|cffFFFF00|H|h"
		dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'custom_ore.txt'
		file = open_file(dirPl, "r+")
		chr.SelectInstance(vid)
		race=chr.GetRace(vid)
		search_word = str(race)
		a = chr.GetInstanceType(vid)
		if vid != 0:
			if(search_word in file.read()):
				text =  "[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCustom ore: Ore with name " + orange + str(name) + yellow + " with ID: "  + orange + str(race) + yellow +  " already exists!"
				msg(str(text))
			else:
				if os.path.exists(dirPl):
					non_detect = open_file(dirPl, "a")
					non_detect.write(str(race))
					non_detect.write('\n')
					non_detect.close()
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCustom ore: Succesfully added " + orange + str(name) + yellow + " with ID: "  + orange + str(race) + yellow +  " to whitelist.")
				else:
					non_detect = open_file(dirPl, "a")
					non_detect.write(str(race))
					non_detect.write('\n')
					non_detect.close()
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCustom ore: Succesfully added " + orange + str(name) + yellow + " with ID: "  + orange + str(race) + yellow +  " to whitelist.")
		else:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCustom ore: " + orange + str(name) + yellow + " with ID: "  + orange + str(race) + yellow +  " is invalid!")
	def addCoord(self):
		route = self.newrouteName.GetText()
		x, y, z = player.GetMainCharacterPosition()
		x = x / 100
		y = y / 100
		self.listCoord.AppendItem(Item(str(int(GetMainPos()[0])) + str(' ') + str(int(GetMainPos()[1]))))
		self.routeCoords.SetText((str(int(GetMainPos()[0])) + str(' ') + str(int(GetMainPos()[1]))))
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: Added to route: " + str(route) + " " + "|cffFFFF00|H|h" +  lang.STR_FARMCOORD + " |cff00FF00|H|hX: " + str(int(x)) + ' Y: ' + str(int(y)) + "|cffFFFF00|H|h " + lang.STR_FARMCOORDOK)
		create_log("Farmbot: Recording route, added coordinates - X: " + str(x) + ' Y: ' + str(y))
		self.saveRoute()
	def fileExists(self, file):
		if os.path.exists(file):
			return 1
		else:
			return 0
	def inside_circle(self, x, y, a, b, r):
		return (x - a) * (x - a) + (y - b) * (y - b) < r * r
	def readCurrentRoute(self):
		try:
			os.mkdir(st_path + "/Data/Routes")
		except:
			pass
		routeDir = os.listdir(st_path + "/Data/Routes")
		if len(routeDir) == 0:
			ignoreList = st_path + "/Data/Routes/empty_route"
			save = open_file(ignoreList, 'w')
			save.close()
		selectedRoute = self.routeListbox.DropList.GetSelectedItem()
		if selectedRoute:
			route = str(selectedRoute.textBox.GetText())
		else:
			route = ""
		try:
			try:
				self.listCoord.RemoveAllItems()
			except:
				pass
			self.FarmCoords = []
			if str(route) == "empty_route":
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: " + lang.DUMMY_ROUTE)
			elif str(route) == "":
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: " + lang.FARM_NO_ROUTE)
			else:
				if len(routeDir) != 0:
					path = st_path + "/Data/Routes" + '/' + route
					waypoints = self.LoadListFile(path)
					for point in waypoints:
						points = point.split(' ')
						x = points[0]
						y = points[1]
						self.FarmCoords.append((int(x), int(y)))
					self.update_points_list()
					self.routeCoords.SetText("")
					if os.stat(st_path + "/Data/Routes" + '/' + route).st_size != 0:
						coordsFromFarmbot = open_file(st_path + "/Data/Routes" + '/' + route, 'r+').read().split()
						for x in range(len(coordsFromFarmbot)):
							getCoords = self.routeCoords.GetText()
							self.routeCoords.SetText(str(getCoords+' '+coordsFromFarmbot[x]))
					else:
						non_detect = open_file(st_path + "/Data/Routes" + '/' + route, "a")
						non_detect.write("\n")
						non_detect.close()
					# dbg.LogBox("1")
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.STR_ROUTE_NAME1 + " |cff00FF00|H|h" + route + " |cffFFFF00|H|h" + lang.STR_ROUTE_OK)
				else:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: " + lang.NO_ROUTE)
		except Exception:
			create_log("Cannot load route, " + lang.STR_ERR_MSG)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFarmbot: Cannot load " + lang.STR_ROUTE_NAME1 + " |cff00FF00|H|h" + route + ", |cffFFFF00|H|h " + lang.STR_ERR_MSG)
	def LoadListFile(self, file):
		lst = []
		f = open_file(file,'r+')
		for line in f:
			line = line.rstrip()
			lst.append(line)
		return lst
	def update_points_list(self):
		try:
			self.listCoord.RemoveAllItems()
		except:
			pass
		for position in self.FarmCoords:
			x, y = int(position[0]), int(position[1])
			self.listCoord.AppendItem(Item(str(x) + ' ' + str(y)))
	def read_current_map(self, map_name):
		if background.GetCurrentMapName() == "metin2_map_a1":
			return "map1_red"
		elif background.GetCurrentMapName() == "metin2_map_a3":
			return "map2_red"
		elif background.GetCurrentMapName() == "metin2_map_b1":
			return "map1_yellow"
		elif background.GetCurrentMapName() == "metin2_map_b3":
			return "map2_yellow"
		elif background.GetCurrentMapName() == "metin2_map_c1":
			return "map1_blue"
		elif background.GetCurrentMapName() == "metin2_map_c3":
			return "map2_blue"
		elif background.GetCurrentMapName() == "map_a2":
			return "ork_valley"
		elif background.GetCurrentMapName() == "map_n_snowm_01":
			return "mt_sohan"
		elif background.GetCurrentMapName() == "metin2_map_n_desert_01":
			return "yongbi_desert"
		elif background.GetCurrentMapName() == "metin2_map_deviltower1":
			return "devils_tower"
		elif background.GetCurrentMapName() == "metin2_map_guild_01":
			return "jungrang"
		elif background.GetCurrentMapName() == "metin2_map_guild_02":
			return "waryong"
		elif background.GetCurrentMapName() == "metin2_map_guild_03":
			return "imha"
		elif background.GetCurrentMapName() == "metin2_guild_village_01":
			return "miryan"
		elif background.GetCurrentMapName() == "metin2_guild_village_02":
			return "songpa"
		elif background.GetCurrentMapName() == "metin2_guild_village_03":
			return "daeyami"
		elif background.GetCurrentMapName() == "metin2_map_milgyo":
			return "hwang_temple"
		elif background.GetCurrentMapName() == "metin2_map_monkeydungeon":
			return "monkey_easy"
		elif background.GetCurrentMapName() == "metin2_map_monkeydungeon_02":
			return "monkey_normal"
		elif background.GetCurrentMapName() == "metin2_map_monkeydungeon_03":
			return "monkey_expert"
		elif background.GetCurrentMapName() == "metin2_map_n_flame_01":
			return "doyumhwan"
		elif background.GetCurrentMapName() == "metin2_map_spiderdungeon":
			return "sd_1"
		elif background.GetCurrentMapName() == "metin2_map_spiderdungeon_02":
			return "sd_2"
		elif background.GetCurrentMapName() == "metin2_map_spiderdungeon_03":
			return "sd_3"
		elif background.GetCurrentMapName() == "metin2_map_trent":
			return "forest"
		elif background.GetCurrentMapName() == "metin2_map_trent02":
			return "red_forest"
		elif background.GetCurrentMapName() == "metin2_map_skipia_dungeon_01":
			return "v3"
		elif background.GetCurrentMapName() == "metin2_map_skipia_dungeon_02":
			return "v4"
		elif background.GetCurrentMapName() == "metin2_map_devilscatacomb":
			return "catacombs"
		elif background.GetCurrentMapName() == "metin2_map_capedragonhead":
			return "capedragonhead"
		elif background.GetCurrentMapName() == "metin2_map_bayblacksand":
			return "bayblacksand"
		elif background.GetCurrentMapName() == "metin2_map_mt_thunder":
			return "mt_thunder"
		elif background.GetCurrentMapName() == "metin2_map_dawnmistwood":
			return "dawnmistwood"
		elif background.GetCurrentMapName() == "season1/metin2_map_nusluck01":
			return "land_of_giants"
		elif background.GetCurrentMapName() == "season1/metin2_map_wl_01":
			return "snake_valley"
		else:
			return background.GetCurrentMapName()
	def refresh_scripts_list(self):
		display_scripts = os.listdir(st_path + "/Data/Python/Community")
		if not find_string(st_cur_server, "levia"):
			self.scripts_list.DropList.RemoveAllItems()
		self.scripts_list.maxh = 95
		self.scripts_list.c = 0
		x = None
		for scripts_list in display_scripts:
			self.scripts_list.AppendItem(str(scripts_list))
			x = scripts_list
		if len(display_scripts) > 0:
			self.scripts_list.DropList.SelectIndex(0)
			selected_item = self.scripts_list.DropList.GetSelectedItem()
			self.scripts_list.SetTitle(selected_item)
	def refreshRouteListFunc(self):
		try:
			os.mkdir(st_path + "/Data/Routes")
		except:
			pass
		routeListAppend = os.listdir(st_path + "/Data/Routes")
		if not find_string(st_cur_server, "levia"):
			self.routeListbox.DropList.RemoveAllItems()
		self.routeListbox.maxh = 95
		self.routeListbox.c = 0
		mapName = self.read_current_map(background.GetCurrentMapName())
		mapName = mapName.replace("/", "_")
		mapName = mapName.replace("\\", "_")
		self.newrouteName.SetText(str(mapName))
		routeName = self.newrouteName.GetText()
		if self.farmInRangeCB.checked==1:
			self.routeListbox.Hide()
		last_used_route = str(ReadConfig("Last_Used_Route"))
		selected_index = -1
		index = 0 
		for routeName in os.listdir(st_path + "/Data/Routes"):
			if not routeName.startswith("empty_route"):
				self.routeListbox.AppendItem(str(routeName))
				if str(routeName) == last_used_route:
					selected_index = index
				index += 1
		if selected_index != -1:
			self.routeListbox.DropList.SelectIndex(selected_index)
			selected_item = self.routeListbox.DropList.GetSelectedItem()
			self.routeListbox.SetTitle(selected_item)
	def saveCurrentRoute(self):
		route = self.newrouteName.GetText()
		try:
			os.mkdir(st_path + "/Data/Routes")
		except:
			pass
		save = open_file(st_path + "/Data/Routes" + '/' + route, 'w')
		getCoords = self.routeCoords.GetText()
		save.write(str(getCoords))
		save.close()
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.STR_ROUTE_NAME1 + " |cff00FF00|H|h" + route + " |cffFFFF00|H|h" + lang.STR_ROUTE_SAVED_OK)
		self.refreshRouteListFunc()
	def Close(self):
		self.kill_fishes = 0
		self.open_clams = 0
		self.drop_dead_fish = 0
		self.drop_hair_dye = 0
		self.sell_dead_fish = 0
		buy_bait = 0
		self.state = 'stop'
		stop_gm_whisper = 0
	def pickRandomColor(self):
		global initialColorSeed
		colors = ['|cff00FF00|H|h','|cFFFF0000|Hitem|h','|cffFFFF00|H|h','|cFFFF00FF|Hitem|h','|cFF804000|Hitem|h','|cffffc700|Hitem|h','|cff800080|H|h','|cFF0080FF|Hitem|h','|cFFFF8040|Hitem|h','|cFF000000|Hitem|h','|cFFC0C0C0|Hitem|h']
		selected_color_index = (initialColorSeed + id(colors[0])) % len(colors)
		color = colors[selected_color_index]
		initialColorSeed += 1
		return color
	def sendSpamTextFunc(self):
		typeSpam = self.spamType.GetCurrentText()
		chattext = self.spamtexteditline.GetText()
		chatdelay = self.spamdelayeditline.GetText()
		colorText = self.spamColor.GetCurrentText()
		global canUseVid, vidsListEnd1, targetVID_Start, targetVID_End, restartCounter, isGF
		if typeSpam == 'Chat':
			self.spamingduration()
		if typeSpam == 'Shout':
			self.shoutspam()
		if typeSpam == 'PM':
			self.pnduration()
		if typeSpam == 'Merchant':
			self.merchant_spam()
	def selectstartspam(self):
		global pauseSpam,spamState
		spamState = 1
		try:
			chatdelay = int(self.spamdelayeditline.GetText())
		except:
			chatdelay = 15
		self.selectstartspamx.XX1(chatdelay)
		self.selectstartspamx.XX2(self.selectstartspam)
		if not isConnect():
			self.selectstartspamx.XX1(5)
			return
		typeSpam = self.spamType.GetCurrentText()
		if pauseSpam:
			return
		if typeSpam == 'Chat':
			self.spamingduration()
		if typeSpam == 'Shout':
			self.shoutspam()
		if typeSpam == 'PM':
			self.pnduration()
		if typeSpam == 'Merchant':
			self.merchant_spam()
	def selectstopspam(self):
		global spamState
		spamState = 0
		self.selectstartspamx.XX1(9999999)
		self.selectstartspamx.XX2(self.selectstartspam)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hSpambot disabled.")
	def merchant_spam(self):
		if hasattr(chat, 'CHAT_TYPE_SHOUT_TRADE'):
			text, delay, color_text = self.spamtexteditline.GetText(), self.spamdelayeditline.GetText(), self.spamColor.GetCurrentText()
			colors = {
				'Normal': '',
				'Green': '|cff00FF00|H|h',
				'Red': '|cFFFF0000|Hitem|h',
				'Yellow': '|cffFFFF00|H|h',
				'Pink': '|cFFFF00FF|Hitem|h',
				'Brown': '|cFF804000|Hitem|h',
				'Golden': '|cffffc700|Hitem|h',
				'Violet': '|cff800080|H|h',
				'Blue': '|cFF0080FF|Hitem|h',
				'Orange': '|cFFFF8040|Hitem|h',
				'Black': '|cFF000000|Hitem|h',
				'Gray': '|cFFC0C0C0|Hitem|h'
			}
			if color_text == 'Random':
				color = self.pickRandomColor()
			else:
				color = colors.get(color_text, '')
			SendChatPacket(color + text, chat.CHAT_TYPE_SHOUT_TRADE)
		else:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hSpambot: " + lang.STR_SV_NOT_TRADE)
			self.selectstopspam()
	def shoutspam(self):
		text, delay, color_text = self.spamtexteditline.GetText(), self.spamdelayeditline.GetText(), self.spamColor.GetCurrentText()
		colors = {
			'Normal': '',
			'Green': '|cff00FF00|H|h',
			'Red': '|cFFFF0000|Hitem|h',
			'Yellow': '|cffFFFF00|H|h',
			'Pink': '|cFFFF00FF|Hitem|h',
			'Brown': '|cFF804000|Hitem|h',
			'Golden': '|cffffc700|Hitem|h',
			'Violet': '|cff800080|H|h',
			'Blue': '|cFF0080FF|Hitem|h',
			'Orange': '|cFFFF8040|Hitem|h',
			'Black': '|cFF000000|Hitem|h',
			'Gray': '|cFFC0C0C0|Hitem|h'
		}
		if color_text == 'Random':
			color = self.pickRandomColor()
		else:
			color = colors.get(color_text, '')
		if foundx64PythonList:
			if find_string(st_cur_server, "lucerna") or find_string(st_cur_server, "next2play"):
				appInst.instance().NewNet().SendChatPacketWithType(color + text, chat.CHAT_TYPE_SHOUT)
			else:
				appInst.instance().GetNet().SendChatPacketWithType(color + text, chat.CHAT_TYPE_SHOUT)
		else:
			SendChatPacket(color + text, chat.CHAT_TYPE_SHOUT)
	def spamingduration(self):
		text, delay, color_text = self.spamtexteditline.GetText(), self.spamdelayeditline.GetText(), self.spamColor.GetCurrentText()
		colors = {
			'Normal': '',
			'Green': '|cff00FF00|H|h',
			'Red': '|cFFFF0000|Hitem|h',
			'Yellow': '|cffFFFF00|H|h',
			'Pink': '|cFFFF00FF|Hitem|h',
			'Brown': '|cFF804000|Hitem|h',
			'Golden': '|cffffc700|Hitem|h',
			'Violet': '|cff800080|H|h',
			'Blue': '|cFF0080FF|Hitem|h',
			'Orange': '|cFFFF8040|Hitem|h',
			'Black': '|cFF000000|Hitem|h',
			'Gray': '|cFFC0C0C0|Hitem|h'
		}
		if color_text == 'Random':
			color = self.pickRandomColor()
		else:
			color = colors.get(color_text, '')
		if foundx64PythonList:
			if find_string(st_cur_server, "lucerna") or find_string(st_cur_server, "next2play"):
				appInst.instance().NewNet().SendChatPacket(color + text)
				# appInst.instance().NewNet().SendChatPacketWithType(color + text, chat.CHAT_TYPE_TALKING)
			else:
				appInst.instance().GetNet().SendChatPacket(color + text)
				# appInst.instance().GetNet().SendChatPacketWithType(color + text, chat.CHAT_TYPE_TALKING)
		else:
			SendChatPacket(color + text, chat.CHAT_TYPE_TALKING)
	def pnduration(self):
		global canUseVid, vidsListEnd1, targetVID_Start, targetVID_End, restartCounter
		text, delay, color_text = self.spamtexteditline.GetText(), self.spamdelayeditline.GetText(), self.spamColor.GetCurrentText()
		for i in vidsListEnd1:
			name = chr.GetNameByVID(i)
			if (chr.INSTANCE_TYPE_PLAYER == chr.GetInstanceType(i) and not name == "None" and not name[0] == "["):
				colors = {
					'Normal': '',
					'Green': '|cff00FF00|H|h',
					'Red': '|cFFFF0000|Hitem|h',
					'Yellow': '|cffFFFF00|H|h',
					'Pink': '|cFFFF00FF|Hitem|h',
					'Brown': '|cFF804000|Hitem|h',
					'Golden': '|cffffc700|Hitem|h',
					'Violet': '|cff800080|H|h',
					'Blue': '|cFF0080FF|Hitem|h',
					'Orange': '|cFFFF8040|Hitem|h',
					'Black': '|cFF000000|Hitem|h',
					'Gray': '|cFFC0C0C0|Hitem|h'
				}
				if color_text == 'Random':
					color = self.pickRandomColor()
				else:
					color = colors.get(color_text, '')
				if foundx64PythonList:
					if find_string(st_cur_server, "lucerna") or find_string(st_cur_server, "next2play"):
						appInst.instance().NewNet().SendWhisperPacket(name, color + text)
					else:
						appInst.instance().GetNet().SendWhisperPacket(name, color + text)
				else:
					SendWhisper(name, color + text)
	def disableStunOn(self):
		try:
			self.disableStunxOn.XX1(1)
			self.disableStunxOn.XX2(self.disableStunOn)
			# for i in range(100):
				# chrmgr.SetAffect(-i, 5, 0)
			chrmgr.SetAffect(-1, 5, 0)
		except:
			self.disableStunOff()
	def disableStunOff(self):
		self.disableStunxOn.XX1(9999999)
		self.disableStunxOn.XX2(self.disableStunOff)
	def strongBody_funcOn(self):
		global str_body_state
		self.strongBody_funcOnx.XX1(0.1)
		self.strongBody_funcOnx.XX2(self.strongBody_funcOn)
		if not isConnect():
			self.strongBody_funcOnx.XX1(5)
			return
		try:
			chr.SelectInstance(getCharIndex())
			chrmgr.SetAffect(-1, 16, 1)
			vid = player.GetTargetVID()
			chr.SelectInstance(vid)
			chrmgr.SetAffect(-1, 16, 1)
			str_body_state = 1
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hStrong body: " + lang.STR_ERR_OCCURED2)
			self.strongBody_funcOff()
	def strongBody_funcOff(self):
		global str_body_state
		self.strongBody_funcOnx.XX1(9999999)
		self.strongBody_funcOnx.XX2(self.strongBody_funcOff)
		chr.SelectInstance(getCharIndex())
		str_body_state = 0
		# chrmgr.SetAffect(-1, 16, 0)
	def ActivFunc(self):
		global pick1_state
		self.btnActiv.Hide()
		self.btnDeactiv.Show()
		self.pick1_state=1
	def DeactivFunc(self):
		global pick1_state
		self.btnDeactiv.Hide()
		self.btnActiv.Show()
		self.pick1_state=0
######################################################################
	def readBtn_func(self):
		global isGF,isGeneralTab,isFarmingTab,isAntiBanTab
		try:
			self.readBtn.ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
			if not isGF:
				self.fishBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
				self.shopBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.buffBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.miscBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.spamBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.energyBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.invBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.newFarmTabBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		except:
			pass
		self.farmPanel.Hide()
		self.pnlShop.Hide()
		self.pnlOthers.Hide()
		self.pnlFishbot.Hide()
		self.pnlSpam.Hide()
		self.pnlBuff.Hide()
		self.pnlRead.Show()
		self.pnlEnergy.Hide()
		self.pnlInventory.Hide()
		self.fishMain.Hide()
		self.fishesBtn.Hide()
		self.pnlFishes.Hide()
		self.tabFarmToggle.Hide()
		self.tabPickToggle.Hide()
		self.classicStartCB.Hide()
		self.pickPanel.Hide()
		self.tabReplyToggle.Hide()
		self.tabSpamToggle.Hide()
		self.pnlReply.Hide()
		self.lblPriority.Hide()
		self.listPriority.Hide()
		self.waitRouteAfter.Hide()
		self.waitAfter.Hide()
		self.waitAfterLbl.Hide()
		self.wait.Hide()
		self.waitInfo.Hide()
		self.pnlChanger.Hide()
		self.tabGeneralToggle.Hide()
		self.tabAntiToggle.Hide()
		self.pnlAntiBan.Hide()
		self.force.Hide()
		self.forcelbl.Hide()
		self.pnlDungeon.Hide()
		self.tabSolversToggle.Hide()
		self.tabDungeonToggle.Hide()
		self.tabDungeonToggle.Hide()
		self.vidRangeLbl1.Hide()
		self.decreaseVidRangeBtn.Hide()
		self.VidRangeTxt.Hide()
		self.VidRangeVal.Hide()
		self.increaseVidRangeBtn.Hide()
		self.applyVidRangeBtn.Hide()
		self.pnlSolvers.Hide()
		isGeneralTab = 0
		isFarmingTab = 0
		isAntiBanTab = 0
		if isGF:
			self.pnlPickup.Hide()
			self.pnlWaithack.Hide()
			self.pickupBotBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.waithackBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
	def fishBtn_func(self):
		global isGF,isGeneralTab,isFarmingTab,isAntiBanTab
		try:
			self.fishBtn.ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
			self.buffBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.miscBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.spamBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.readBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.shopBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.energyBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.invBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.newFarmTabBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		except:
			pass
		self.farmPanel.Hide()
		self.pnlShop.Hide()
		self.pnlRead.Hide()
		self.pnlOthers.Hide()
		self.pnlFishbot.Show()
		self.pnlSpam.Hide()
		self.pnlBuff.Hide()
		self.pnlEnergy.Hide()
		self.pnlInventory.Hide()
		self.fishMain.Show()
		self.fishesBtn.Show()
		self.fishMain_Func('on')
		self.tabFarmToggle.Hide()
		self.tabPickToggle.Hide()
		self.pickPanel.Hide()
		self.classicStartCB.Hide()
		self.tabReplyToggle.Hide()
		self.tabSpamToggle.Hide()
		self.pnlReply.Hide()
		self.lblPriority.Hide()
		self.listPriority.Hide()
		self.waitRouteAfter.Hide()
		self.waitAfter.Hide()
		self.waitAfterLbl.Hide()
		self.wait.Hide()
		self.waitInfo.Hide()
		self.pnlChanger.Hide()
		self.tabGeneralToggle.Hide()
		self.tabAntiToggle.Hide()
		self.pnlAntiBan.Hide()
		self.force.Hide()
		self.forcelbl.Hide()
		self.pnlSolvers.Hide()
		self.pnlDungeon.Hide()
		self.tabSolversToggle.Hide()
		self.tabDungeonToggle.Hide()
		self.tabDungeonToggle.Hide()
		self.vidRangeLbl1.Hide()
		self.decreaseVidRangeBtn.Hide()
		self.VidRangeTxt.Hide()
		self.VidRangeVal.Hide()
		self.increaseVidRangeBtn.Hide()
		self.applyVidRangeBtn.Hide()
		isGeneralTab = 0
		isFarmingTab = 0
		isAntiBanTab = 0
		if isGF:
			self.pnlPickup.Hide()
			self.pnlWaithack.Hide()
			self.pickupBotBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.waithackBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
	def pickup_tab_func(self):
		global isGeneralTab, isFarmingTab,isAntiBanTab
		self.pickupBotBtn.ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
		self.buffBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		self.miscBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		self.spamBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		self.readBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		self.waithackBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		self.energyBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		self.invBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		self.newFarmTabBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		self.farmPanel.Hide()
		self.pnlWaithack.Hide()
		self.pnlRead.Hide()
		self.pnlOthers.Hide()
		self.pnlPickup.Show()
		self.pnlSpam.Hide()
		self.pnlBuff.Hide()
		self.pnlEnergy.Hide()
		self.pnlInventory.Hide()
		self.classicStartCB.Hide()
		self.tabReplyToggle.Hide()
		self.tabSpamToggle.Hide()
		self.pnlReply.Hide()
		self.lblPriority.Hide()
		self.listPriority.Hide()
		self.waitAfter.Hide()
		self.waitAfterLbl.Hide()
		self.wait.Hide()
		self.waitInfo.Hide()
		self.pnlChanger.Hide()
		self.tabGeneralToggle.Hide()
		self.tabAntiToggle.Hide()
		self.pnlAntiBan.Hide()
		self.force.Hide()
		self.forcelbl.Hide()
		self.vidRangeLbl1.Hide()
		self.waitRouteAfter.Hide()
		self.pnlDungeon.Hide()
		self.pnlSolvers.Hide()
		self.tabSolversToggle.Hide()
		self.tabDungeonToggle.Hide()
		self.tabDungeonToggle.Hide()
		self.vidRangeLbl1.Hide()
		self.decreaseVidRangeBtn.Hide()
		self.VidRangeTxt.Hide()
		self.VidRangeVal.Hide()
		self.increaseVidRangeBtn.Hide()
		self.applyVidRangeBtn.Hide()
		isGeneralTab = 0
		isFarmingTab = 0
		isAntiBanTab = 0
	def buffBtn_func(self):
		global isGF,isGeneralTab,isFarmingTab,isAntiBanTab
		try:
			if not isGF:
				self.fishBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
				self.shopBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.buffBtn.ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
			self.miscBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.spamBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.readBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.energyBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.invBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.newFarmTabBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		except:
			pass
		self.farmPanel.Hide()
		self.pnlShop.Hide()
		self.pnlRead.Hide()
		self.pnlBuff.Show()
		self.pnlOthers.Hide()
		self.pnlSpam.Hide()
		self.pnlFishbot.Hide()
		self.pnlEnergy.Hide()
		self.pnlInventory.Hide()
		self.fishMain.Hide()
		self.fishesBtn.Hide()
		self.pnlFishes.Hide()
		self.tabFarmToggle.Hide()
		self.tabPickToggle.Hide()
		self.pickPanel.Hide()
		self.classicStartCB.Hide()
		self.tabReplyToggle.Hide()
		self.tabSpamToggle.Hide()
		self.pnlReply.Hide()
		self.lblPriority.Hide()
		self.listPriority.Hide()
		self.waitRouteAfter.Hide()
		self.waitAfter.Hide()
		self.waitAfterLbl.Hide()
		self.wait.Hide()
		self.waitInfo.Hide()
		self.pnlChanger.Hide()
		self.tabGeneralToggle.Hide()
		self.tabAntiToggle.Hide()
		self.pnlAntiBan.Hide()
		self.force.Hide()
		self.forcelbl.Hide()
		self.pnlDungeon.Hide()
		self.pnlSolvers.Hide()
		self.tabSolversToggle.Hide()
		self.tabDungeonToggle.Hide()
		self.tabDungeonToggle.Hide()
		self.vidRangeLbl1.Hide()
		self.decreaseVidRangeBtn.Hide()
		self.VidRangeTxt.Hide()
		self.VidRangeVal.Hide()
		self.increaseVidRangeBtn.Hide()
		self.applyVidRangeBtn.Hide()
		if isGF:
			self.pnlPickup.Hide()
			self.pnlWaithack.Hide()
			self.pickupBotBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.waithackBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		isGeneralTab = 0
		isFarmingTab = 0
		isAntiBanTab = 0
	def shopManager_func(self):
		global isGF,isGeneralTab,isFarmingTab,isAntiBanTab
		try:
			if not isGF:
				self.shopBtn.ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
				self.fishBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.buffBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.miscBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.spamBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.readBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.energyBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.invBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.newFarmTabBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		except:
			pass
		self.farmPanel.Hide()
		self.pnlRead.Hide()
		self.pnlBuff.Hide()
		self.pnlOthers.Hide()
		self.pnlSpam.Hide()
		self.pnlFishbot.Hide()
		self.pnlShop.Show()
		self.pnlEnergy.Hide()
		self.pnlInventory.Hide()
		self.fishMain.Hide()
		self.fishesBtn.Hide()
		self.pnlFishes.Hide()
		self.tabFarmToggle.Hide()
		self.tabPickToggle.Hide()
		self.pickPanel.Hide()
		self.classicStartCB.Hide()
		self.tabReplyToggle.Hide()
		self.tabSpamToggle.Hide()
		self.pnlReply.Hide()
		self.lblPriority.Hide()
		self.listPriority.Hide()
		self.waitRouteAfter.Hide()
		self.waitAfter.Hide()
		self.waitAfterLbl.Hide()
		self.wait.Hide()
		self.waitInfo.Hide()
		self.pnlChanger.Hide()
		self.tabGeneralToggle.Hide()
		self.tabAntiToggle.Hide()
		self.pnlAntiBan.Hide()
		self.force.Hide()
		self.forcelbl.Hide()
		self.pnlDungeon.Hide()
		self.pnlSolvers.Hide()
		self.tabSolversToggle.Hide()
		self.tabDungeonToggle.Hide()
		self.tabDungeonToggle.Hide()
		self.vidRangeLbl1.Hide()
		self.decreaseVidRangeBtn.Hide()
		self.VidRangeTxt.Hide()
		self.VidRangeVal.Hide()
		self.increaseVidRangeBtn.Hide()
		self.applyVidRangeBtn.Hide()
		if isGF:
			self.pnlPickup.Hide()
			self.pnlWaithack.Hide()
			self.pickupBotBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.waithackBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		isGeneralTab = 0
		isFarmingTab = 0
		isAntiBanTab = 0
	def Waithack_Tab_Func(self):
		global isGeneralTab, isFarmingTab,isAntiBanTab
		self.waithackBtn.ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
		self.pickupBotBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		self.buffBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		self.miscBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		self.spamBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		self.readBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		self.energyBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		self.invBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		self.newFarmTabBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		self.farmPanel.Hide()
		self.pnlRead.Hide()
		self.pnlBuff.Hide()
		self.pnlOthers.Hide()
		self.pnlSpam.Hide()
		self.pnlPickup.Hide()
		self.pnlWaithack.Show()
		self.pnlEnergy.Hide()
		self.pnlInventory.Hide()
		self.classicStartCB.Hide()
		self.tabReplyToggle.Hide()
		self.tabSpamToggle.Hide()
		self.pnlReply.Hide()
		self.lblPriority.Hide()
		self.listPriority.Hide()
		self.waitAfter.Hide()
		self.waitAfterLbl.Hide()
		self.wait.Hide()
		self.waitInfo.Hide()
		self.pnlChanger.Hide()
		self.tabGeneralToggle.Hide()
		self.tabAntiToggle.Hide()
		self.pnlAntiBan.Hide()
		self.force.Hide()
		self.forcelbl.Hide()
		self.tabSolversToggle.Hide()
		self.tabDungeonToggle.Hide()
		self.pnlDungeon.Hide()
		self.pnlSolvers.Hide()
		self.tabDungeonToggle.Hide()
		self.vidRangeLbl1.Hide()
		self.decreaseVidRangeBtn.Hide()
		self.VidRangeTxt.Hide()
		self.VidRangeVal.Hide()
		self.increaseVidRangeBtn.Hide()
		self.applyVidRangeBtn.Hide()
		self.waitRouteAfter.Hide()
		isGeneralTab = 0
		isFarmingTab = 0
		isAntiBanTab = 0
	def miscBtn_func(self):
		global isGF,isGeneralTab,isFarmingTab,isAntiBanTab
		try:
			if not isGF:
				self.fishBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
				self.shopBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.buffBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.miscBtn.ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
			self.spamBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.readBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.energyBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.invBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.newFarmTabBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		except:
			pass
		self.farmPanel.Hide()
		self.pnlShop.Hide()
		self.pnlRead.Hide()
		self.pnlBuff.Hide()
		self.pnlOthers.Show()
		self.pnlSpam.Hide()
		self.pnlFishbot.Hide()
		self.pnlEnergy.Hide()
		self.pnlInventory.Hide()
		self.fishMain.Hide()
		self.fishesBtn.Hide()
		self.pnlFishes.Hide()
		self.tabFarmToggle.Hide()
		self.tabPickToggle.Hide()
		self.pickPanel.Hide()
		self.classicStartCB.Hide()
		self.tabReplyToggle.Hide()
		self.tabSpamToggle.Hide()
		self.pnlReply.Hide()
		self.lblPriority.Hide()
		self.listPriority.Hide()
		self.waitRouteAfter.Hide()
		self.waitAfter.Hide()
		self.waitAfterLbl.Hide()
		self.wait.Hide()
		self.waitInfo.Hide()
		self.pnlChanger.Show()
		self.tabGeneralToggle.Show()
		self.tabAntiToggle.Show()
		self.generalTab_Func('on')
		self.pnlAntiBan.Hide()
		self.force.Hide()
		self.forcelbl.Hide()
		self.pnlDungeon.Hide()
		self.pnlSolvers.Hide()
		self.tabSolversToggle.Show()
		self.tabDungeonToggle.Hide()
		self.tabDungeonToggle.Show()
		self.vidRangeLbl1.Hide()
		self.decreaseVidRangeBtn.Hide()
		self.VidRangeTxt.Hide()
		self.VidRangeVal.Hide()
		self.increaseVidRangeBtn.Hide()
		self.applyVidRangeBtn.Hide()
		isGeneralTab = 1
		isFarmingTab = 0
		isAntiBanTab = 0
		if isGF:
			self.pnlPickup.Hide()
			self.pnlWaithack.Hide()
			self.pickupBotBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.waithackBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
	def newFarmingTab_func(self):
		global isGF,isGeneralTab,isFarmingTab,isAntiBanTab
		try:
			if not isGF:
				self.fishBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
				self.shopBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.buffBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.miscBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.newFarmTabBtn.ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
			self.spamBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.readBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.energyBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.invBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		except:
			pass
		self.pnlShop.Hide()
		self.pnlRead.Hide()
		self.pnlBuff.Hide()
		self.pnlOthers.Hide()
		self.farmPanel.Show()
		self.pnlSpam.Hide()
		self.pnlFishbot.Hide()
		self.pnlEnergy.Hide()
		self.pnlInventory.Hide()
		self.fishMain.Hide()
		self.fishesBtn.Hide()
		self.pnlFishes.Hide()
		if not isGF:
			self.tabFarmToggle.Show()
			self.tabPickToggle.Show()
			self.vidRangeLbl1.Show()
		self.attackingTab_Func('on')
		self.pickPanel.Hide()
		self.classicStartCB.Show()
		self.tabReplyToggle.Hide()
		self.tabSpamToggle.Hide()
		self.pnlReply.Hide()
		self.lblPriority.Show()
		self.listPriority.Show()
		self.waitRouteAfter.Show()
		self.waitAfter.Show()
		self.waitAfterLbl.Show()
		self.wait.Show()
		self.waitInfo.Show()
		self.pnlChanger.Hide()
		self.tabGeneralToggle.Hide()
		self.tabAntiToggle.Hide()
		self.pnlAntiBan.Hide()
		self.pnlDungeon.Hide()
		self.pnlSolvers.Hide()
		self.tabSolversToggle.Hide()
		self.tabDungeonToggle.Hide()
		self.tabDungeonToggle.Hide()
		self.force.Show()
		self.forcelbl.Show()
		
		
		
		
		if isGF:
			self.pnlPickup.Hide()
			self.pnlWaithack.Hide()
			self.pickupBotBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.waithackBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		isGeneralTab = 0
		isAntiBanTab = 0
		isFarmingTab = 1
	def spamBtn_func(self):
		global isGF,isGeneralTab,isFarmingTab,isAntiBanTab
		try:
			if not isGF:
				self.fishBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
				self.shopBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.buffBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.miscBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.spamBtn.ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
			self.readBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.energyBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.invBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.newFarmTabBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		except:
			pass
		self.farmPanel.Hide()
		self.pnlShop.Hide()
		self.pnlRead.Hide()
		self.pnlBuff.Hide()
		self.pnlOthers.Hide()
		self.pnlSpam.Show()
		self.pnlFishbot.Hide()
		self.pnlEnergy.Hide()
		self.pnlInventory.Hide()
		self.fishMain.Hide()
		self.fishesBtn.Hide()
		self.pnlFishes.Hide()
		self.tabFarmToggle.Hide()
		self.tabPickToggle.Hide()
		self.pickPanel.Hide()
		self.classicStartCB.Hide()
		self.spamTab_Func('on')
		self.tabReplyToggle.Show()
		self.tabSpamToggle.Show()
		self.pnlReply.Hide()
		self.lblPriority.Hide()
		self.listPriority.Hide()
		self.waitRouteAfter.Hide()
		self.waitAfter.Hide()
		self.waitAfterLbl.Hide()
		self.wait.Hide()
		self.waitInfo.Hide()
		self.pnlChanger.Hide()
		self.tabGeneralToggle.Hide()
		self.tabAntiToggle.Hide()
		self.pnlAntiBan.Hide()
		self.force.Hide()
		self.forcelbl.Hide()
		self.pnlDungeon.Hide()
		self.pnlSolvers.Hide()
		self.tabSolversToggle.Hide()
		self.tabDungeonToggle.Hide()
		self.vidRangeLbl1.Hide()
		self.decreaseVidRangeBtn.Hide()
		self.VidRangeTxt.Hide()
		self.VidRangeVal.Hide()
		self.increaseVidRangeBtn.Hide()
		self.applyVidRangeBtn.Hide()
		if isGF:
			self.pnlPickup.Hide()
			self.pnlWaithack.Hide()
			self.pickupBotBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.waithackBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		isGeneralTab = 0
		isFarmingTab = 0
		isAntiBanTab = 0
	def energyBtn_func(self):
		global isGF,isGeneralTab,isFarmingTab,isAntiBanTab
		try:
			if not isGF:
				self.fishBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
				self.shopBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.buffBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.miscBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.spamBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.readBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.invBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.energyBtn.ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
			self.newFarmTabBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		except:
			pass
		self.farmPanel.Hide()
		self.pnlShop.Hide()
		self.pnlRead.Hide()
		self.pnlBuff.Hide()
		self.pnlOthers.Hide()
		self.pnlEnergy.Show()
		self.pnlSpam.Hide()
		self.pnlFishbot.Hide()
		self.pnlInventory.Hide()
		self.fishMain.Hide()
		self.fishesBtn.Hide()
		self.pnlFishes.Hide()
		self.tabFarmToggle.Hide()
		self.tabPickToggle.Hide()
		self.pickPanel.Hide()
		self.classicStartCB.Hide()
		self.tabReplyToggle.Hide()
		self.tabSpamToggle.Hide()
		self.pnlReply.Hide()
		self.lblPriority.Hide()
		self.listPriority.Hide()
		self.waitRouteAfter.Hide()
		self.waitAfter.Hide()
		self.waitAfterLbl.Hide()
		self.wait.Hide()
		self.waitInfo.Hide()
		self.pnlChanger.Hide()
		self.tabGeneralToggle.Hide()
		self.tabAntiToggle.Hide()
		self.pnlAntiBan.Hide()
		self.force.Hide()
		self.forcelbl.Hide()
		self.pnlDungeon.Hide()
		self.pnlSolvers.Hide()
		self.tabSolversToggle.Hide()
		self.tabDungeonToggle.Hide()
		self.vidRangeLbl1.Hide()
		self.decreaseVidRangeBtn.Hide()
		self.VidRangeTxt.Hide()
		self.VidRangeVal.Hide()
		self.increaseVidRangeBtn.Hide()
		self.applyVidRangeBtn.Hide()
		if isGF:
			self.pnlPickup.Hide()
			self.pnlWaithack.Hide()
			self.pickupBotBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.waithackBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		isGeneralTab = 0
		isFarmingTab = 0
		isAntiBanTab = 0
	def inventory_Func(self):
		global isGF, isGeneralTab,isFarmingTab,isAntiBanTab
		try:
			if not isGF:
				self.fishBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
				self.shopBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.buffBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.miscBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.spamBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.readBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.invBtn.ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
			self.energyBtn.ButtonText.SetFontColor(*self.comp.RGB(200, 200, 200))
			self.newFarmTabBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		except:
			pass
		self.farmPanel.Hide()
		self.pnlShop.Hide()
		self.pnlRead.Hide()
		self.pnlBuff.Hide()
		self.pnlOthers.Hide()
		self.pnlEnergy.Hide()
		self.pnlSpam.Hide()
		self.pnlFishbot.Hide()
		self.pnlInventory.Show()
		self.fishMain.Hide()
		self.fishesBtn.Hide()
		self.pnlFishes.Hide()
		self.tabFarmToggle.Hide()
		self.tabPickToggle.Hide()
		self.pickPanel.Hide()
		self.classicStartCB.Hide()
		self.tabReplyToggle.Hide()
		self.tabSpamToggle.Hide()
		self.pnlReply.Hide()
		self.lblPriority.Hide()
		self.listPriority.Hide()
		self.waitRouteAfter.Hide()
		self.waitAfter.Hide()
		self.waitAfterLbl.Hide()
		self.wait.Hide()
		self.waitInfo.Hide()
		self.pnlChanger.Hide()
		self.tabGeneralToggle.Hide()
		self.tabAntiToggle.Hide()
		self.pnlAntiBan.Hide()
		self.force.Hide()
		self.forcelbl.Hide()
		self.pnlDungeon.Hide()
		self.pnlSolvers.Hide()
		self.tabSolversToggle.Hide()
		self.tabDungeonToggle.Hide()
		self.vidRangeLbl1.Hide()
		self.decreaseVidRangeBtn.Hide()
		self.VidRangeTxt.Hide()
		self.VidRangeVal.Hide()
		self.increaseVidRangeBtn.Hide()
		self.applyVidRangeBtn.Hide()
		if isGF:
			self.pnlPickup.Hide()
			self.pnlWaithack.Hide()
			self.pickupBotBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.waithackBtn.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		isGeneralTab = 0
		isFarmingTab = 0
		isAntiBanTab = 0
########################### OTHER SCRIPTS FUNCS ###########################
	def spamTab_Func(self, arg):
		if arg=='on':
			self.pnlSpam.Show()
			self.pnlReply.Hide()
			self.tabReplyToggle.SetUp()
			self.tabSpamToggle.Down()
		elif arg=='off':
			self.pnlSpam.Hide()
			self.pnlReply.Show()
			self.tabReplyToggle.Down()
			self.tabSpamToggle.SetUp()
	def replyTab_Func(self, arg):
		if arg=='on':
			self.pnlSpam.Hide()
			self.pnlReply.Show()
			self.tabReplyToggle.Down()
			self.tabSpamToggle.SetUp()
		elif arg=='off':
			self.pnlSpam.Show()
			self.pnlReply.Hide()
			self.tabReplyToggle.SetUp()
			self.tabSpamToggle.Down()
	def attackingTab_Func(self, arg):
		global isGF,isFarmingTab
		if arg=='on':
			isFarmingTab = 1
			self.farmPanel.Show()
			self.pickPanel.Hide()
			self.tabPickToggle.SetUp()
			self.tabFarmToggle.Down()
			self.lblPriority.Show()
			self.listPriority.Show()
			self.waitRouteAfter.Show()
			self.waitAfter.Show()
			self.waitAfterLbl.Show()
			self.wait.Show()
			self.waitInfo.Show()
			self.force.Show()
			self.forcelbl.Show()
			self.classicStartCB.Show()
			if not isGF:
				self.vidRangeLbl1.Show()
		elif arg=='off':
			isFarmingTab = 0
			if not isGF:
				self.farmPanel.Hide()
				self.pickPanel.Show()
				self.tabPickToggle.Down()
				self.tabFarmToggle.SetUp()
				self.lblPriority.Hide()
				self.listPriority.Hide()
				self.waitRouteAfter.Hide()
				self.waitAfter.Hide()
				self.waitAfterLbl.Hide()
				self.wait.Hide()
				self.waitInfo.Hide()
				self.force.Hide()
				self.forcelbl.Hide()
				self.classicStartCB.Hide()
				self.vidRangeLbl1.Hide()
	def pickupTab_Func(self, arg):
		global isGF, isFarmingTab
		if arg=='on':
			isFarmingTab = 0
			if not isGF:
				self.farmPanel.Hide()
				self.pickPanel.Show()
				self.tabPickToggle.Down()
				self.tabFarmToggle.SetUp()
				self.lblPriority.Hide()
				self.listPriority.Hide()
				self.waitRouteAfter.Hide()
				self.waitAfter.Hide()
				self.waitAfterLbl.Hide()
				self.wait.Hide()
				self.waitInfo.Hide()
				self.force.Hide()
				self.forcelbl.Hide()
				self.classicStartCB.Hide()
				self.vidRangeLbl1.Hide()
		elif arg=='off':
			isFarmingTab = 1
			self.farmPanel.Show()
			self.pickPanel.Hide()
			self.tabPickToggle.SetUp()
			self.tabFarmToggle.Down()
			self.lblPriority.Show()
			self.listPriority.Show()
			self.waitRouteAfter.Show()
			self.waitAfter.Show()
			self.waitAfterLbl.Show()
			self.wait.Show()
			self.waitInfo.Show()
			self.force.Show()
			self.forcelbl.Show()
			self.classicStartCB.Show()
			if not isGF:
				self.vidRangeLbl1.Show()
	def generalTab_Func(self, arg):
		global isAntiBanTab
		isAntiBanTab = 0
		if arg=='on':
			self.pnlOthers.Show()
			self.pnlAntiBan.Hide()
			self.pnlDungeon.Hide()
			self.pnlSolvers.Hide()
			self.tabGeneralToggle.Down()
			self.tabDungeonToggle.SetUp()
			self.tabAntiToggle.SetUp()
			self.tabSolversToggle.SetUp()
			# self.pnlChanger.Show()
		elif arg=='off':
			self.pnlDungeon.Hide()
			self.pnlOthers.Hide()
			self.pnlSolvers.Hide()
			self.pnlAntiBan.Show()
			self.tabDungeonToggle.SetUp()
			self.tabGeneralToggle.SetUp()
			self.tabAntiToggle.Down()
			self.tabSolversToggle.SetUp()
			# self.pnlChanger.Hide()
		
	def antibanTab_Func(self, arg):
		global isAntiBanTab
		if arg=='on':
			self.pnlDungeon.Hide()
			self.pnlOthers.Hide()
			self.pnlSolvers.Hide()
			self.pnlAntiBan.Show()
			self.tabDungeonToggle.SetUp()
			self.tabGeneralToggle.SetUp()
			self.tabAntiToggle.Down()
			self.tabSolversToggle.SetUp()
			# self.pnlChanger.Hide()
			isAntiBanTab = 1
		elif arg=='off':
			self.pnlOthers.Hide()
			self.pnlDungeon.Show()
			self.pnlAntiBan.Hide()
			self.pnlSolvers.Hide()
			self.tabGeneralToggle.SetUp()
			self.tabDungeonToggle.Down()
			self.tabAntiToggle.SetUp()
			self.tabSolversToggle.SetUp()
			# self.pnlChanger.Show()
			isAntiBanTab = 0
	def dungeonTab_Func(self, arg):
		global isAntiBanTab
		isAntiBanTab = 0
		if arg=='on':
			self.pnlOthers.Hide()
			self.pnlAntiBan.Hide()
			self.pnlSolvers.Hide()
			self.pnlDungeon.Show()
			self.tabSolversToggle.SetUp()
			self.tabGeneralToggle.SetUp()
			self.tabAntiToggle.SetUp()
			self.tabDungeonToggle.Down()
			
			# self.pnlChanger.Hide()
		elif arg=='off':
			self.pnlOthers.Hide()
			self.pnlAntiBan.Hide()
			self.pnlDungeon.Hide()
			self.pnlSolvers.Show()
			self.tabGeneralToggle.SetUp()
			self.tabSolversToggle.Down()
			self.tabAntiToggle.SetUp()
			self.tabDungeonToggle.SetUp()
			# self.pnlChanger.Show()
	def eventSolverTab_Func(self, arg):
		global isAntiBanTab
		isAntiBanTab = 0
		if arg=='on':
			self.pnlOthers.Hide()
			self.pnlAntiBan.Hide()
			self.pnlSolvers.Show()
			self.pnlDungeon.Hide()
			self.tabGeneralToggle.SetUp()
			self.tabAntiToggle.SetUp()
			self.tabDungeonToggle.SetUp()
			self.tabSolversToggle.Down()
			# self.pnlChanger.Hide()
		elif arg=='off':
			self.pnlOthers.Show()
			self.pnlAntiBan.Hide()
			self.pnlDungeon.Hide()
			self.pnlSolvers.Hide()
			self.tabGeneralToggle.Down()
			self.tabAntiToggle.SetUp()
			self.tabDungeonToggle.SetUp()
			self.tabSolversToggle.SetUp()
			# self.pnlChanger.Show()
	def getDegree(self, vid):
		try:
			mobX, mobY  = getPos(vid)
			playerX, playerY, _ = player.GetMainCharacterPosition()
			rada = 180 * (math.acos((mobY-playerY)/math.sqrt((mobX - playerX)**2 + (mobY - playerY)**2))) / math.pi + 180
			if playerX >= mobX:
				rada = 360 - rada
			return round(int(rada))
		except:
			return 0
	def UseHorseOnOff(self,val):
		self.UseHorse = val
	def HotkeyShowSTStop(self):
		self.HotkeyShowxST.XX1(9999999)
		self.HotkeyShowxST.XX2(self.HotkeyShowSTStop)
	def HotkeyShowST(self):
		global streamer,panicMode,antiban_state,tempAntiBan,isFarmingTab
		self.HotkeyShowxST.XX1(0.01)
		self.HotkeyShowxST.XX2(self.HotkeyShowST)
		
		try:
			if not isFarmingTab:
				self.approachTarget.Hide()
			if not IsWeaponArch():
				self.approachTarget.Hide()
			if IsWeaponArch() and isFarmingTab:
				self.approachTarget.Show()
		except:
			pass
		
		
		# INSERT / F12 men amyor (devre d)
		pass
	def streamerOff(self):
		global streamer
		streamer = 0
	def streamerOn(self):
		global streamer
		streamer = 1
	def populate_dropdown_with_keys(self, dropdown, action, index):
		global hotkeyList
		possible_keys = get_possible_keys()
		dropdown.DropList.RemoveAllItems()
		for key in possible_keys:
			dropdown.AppendItem(str(key))
		current_keys = hotkeyList.get(action)
		if isinstance(current_keys, tuple):
			key_to_select = current_keys[index]
		else:
			key_to_select = current_keys
		dropdown.SetTitle(dropdown.Item(dropdown, key_to_select))
	def create_hotkey_dropdown(self, label_text, position, action):
		global hotkeyList
		label = self.comp.TextLine(self.hotkeysWindow, label_text + ': ', 20, position, self.comp.RGB(255, 255, 255))
		dropdown1 = DropDown(self.hotkeysWindow, '', 0, 85)
		dropdown1.SetParent(self.hotkeysWindow)
		dropdown1.SetPosition(100, position)
		dropdown1.Show()
		self.populate_dropdown_with_keys(dropdown1, action, 0)
		if isinstance(hotkeyList[action], tuple):
			plus_label = self.comp.TextLine(self.hotkeysWindow, '+', 189, position, self.comp.RGB(255, 255, 255))
			dropdown2 = DropDown(self.hotkeysWindow, '', 0, 85)
			dropdown2.SetParent(self.hotkeysWindow)
			dropdown2.SetPosition(200, position)
			dropdown2.Show()
			self.populate_dropdown_with_keys(dropdown2, action, 1)
			return label, dropdown1, plus_label, dropdown2
		return label, dropdown1
	def setup_event_handlers(self):
		global isGF
		self.setup_dropdown_event('relog', self.relogCtrlCombo, self.relogCombo)
		self.setup_dropdown_event('refine', self.refineCtrlCombo, self.refineCombo)
		self.setup_dropdown_event('zoomfog', self.zoomfogCtrlCombo, self.zoomfogCombo)
		self.setup_dropdown_event('day', self.dayCtrlCombo, self.dayCombo)
		self.setup_dropdown_event('night', self.nightCtrlCombo, self.nightCombo)
		self.setup_dropdown_event('sort', self.sortCtrlCombo, self.sortCombo)
		self.setup_dropdown_event('donate', self.donateCtrlCombo, self.donateCombo)
		self.setup_dropdown_event('spam_text', self.spamTextCtrlCombo, self.spamTextCombo)
		self.setup_dropdown_event('show_map', self.showMapCtrlCombo, self.showMapCombo)
		self.setup_dropdown_event('use_dews', self.useDewsCtrlCombo, self.useDewsCombo)
		self.setup_dropdown_event('save_settings', self.saveSettingsCtrlCombo, self.saveSettingsCombo)
		self.setup_dropdown_event('load_settings', self.loadSettingsCtrlCombo, self.loadSettingsCombo)
		self.setup_dropdown_event('lock_target', self.lockTargetTabCombo, self.lockTargetQCombo)
		self.setup_dropdown_event('toggle_farm', self.toggleFarmCombo)
		self.setup_dropdown_event('toggle_pickup', self.togglePickupCombo)
		self.setup_dropdown_event('toggle_panic', self.togglePanicCombo)
		self.setup_dropdown_event('toggle_item_user', self.toggleItemUserCombo)
		self.setup_dropdown_event('tptotarget', self.toggleTpTargetCombo)
		if isGF:
			self.setup_dropdown_event('waithack', self.toggleWaithackCombo)
	def setup_dropdown_event(self, action, ctrl_dropdown=None, key_dropdown=None):
		if ctrl_dropdown:
			ctrl_dropdown.OnChange = lambda: self.handle_dropdown_change(action, ctrl_dropdown, key_dropdown)
		if key_dropdown:
			key_dropdown.OnChange = lambda: self.handle_dropdown_change(action, ctrl_dropdown, key_dropdown)
	def handle_dropdown_change(self, action, ctrl_dropdown=None, key_dropdown=None):
		global hotkeyList
		if ctrl_dropdown and key_dropdown:
			key_combination = (ctrl_dropdown.GetText(), key_dropdown.GetText())
		elif key_dropdown:
			key_combination = key_dropdown.GetText()
		elif ctrl_dropdown:
			key_combination = ctrl_dropdown.GetText()
		else:
			key_combination = None
		if self.is_hotkey_in_use(key_combination, action):
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hHotkey manager: The key combination " + str(key_combination) + " is already in use.")
			self.loadHotkeys(0)
			return
		if ctrl_dropdown and key_dropdown:
			hotkeyList[action] = ctrl_dropdown.GetText() + ';' + key_dropdown.GetText()
		elif key_dropdown:
			hotkeyList[action] = key_dropdown.GetText()
		self.saveHotkeys(0)
	def create_initial_dropdowns(self):
		global isGF
		self.relogHotkey, self.relogCtrlCombo, self.relogPlus, self.relogCombo = self.create_hotkey_dropdown('Autologin', 90, 'relog')
		self.refineHotkey, self.refineCtrlCombo, self.refinePlus, self.refineCombo = self.create_hotkey_dropdown('Refine item', 120, 'refine')
		self.zoomfogHotkey, self.zoomfogCtrlCombo, self.zoomfogPlus, self.zoomfogCombo = self.create_hotkey_dropdown('Zoom & no fog', 150, 'zoomfog')
		self.dayHotkey, self.dayCtrlCombo, self.dayPlus, self.dayCombo = self.create_hotkey_dropdown('Set day', 180, 'day')
		self.nightHotkey, self.nightCtrlCombo, self.nightPlus, self.nightCombo = self.create_hotkey_dropdown('Set night', 210, 'night')
		self.sortHotkey, self.sortCtrlCombo, self.sortPlus,  self.sortCombo = self.create_hotkey_dropdown('Sort inventory', 240, 'sort')
		self.donateHotkey, self.donateCtrlCombo, self.donatePlus, self.donateCombo = self.create_hotkey_dropdown('Exp donator', 270, 'donate')
		self.spamTextHotkey, self.spamTextCtrlCombo, self.spamTextPlus, self.spamTextCombo = self.create_hotkey_dropdown('Send spam text', 300, 'spam_text')
		self.showMapHotkey, self.showMapCtrlCombo, self.showMapPlus, self.showMapCombo = self.create_hotkey_dropdown('Map teleport', 330, 'show_map')
		self.useDewsHotkey, self.useDewsCtrlCombo, self.useDewsPlus, self.useDewsCombo = self.create_hotkey_dropdown('Use dews', 360, 'use_dews')
		self.saveSettingsHotkey, self.saveSettingsCtrlCombo, self.saveSettingsPlus, self.saveSettingsCombo = self.create_hotkey_dropdown('Save settings', 390, 'save_settings')
		self.loadSettingsHotkey, self.loadSettingsCtrlCombo, self.loadSettingsPlus, self.loadSettingsCombo = self.create_hotkey_dropdown('Load settings', 420, 'load_settings')
		self.lockTargetHotkey, self.lockTargetTabCombo, self.lockTargetPlus, self.lockTargetQCombo = self.create_hotkey_dropdown('Lock target', 450, 'lock_target')
		self.toggleFarmHotkey, self.toggleFarmCombo = self.create_hotkey_dropdown('Toggle farmbot', 480, 'toggle_farm')
		self.togglePickupHotkey, self.togglePickupCombo = self.create_hotkey_dropdown('Toggle pickup', 510, 'toggle_pickup')
		self.togglePanicHotkey, self.togglePanicCombo = self.create_hotkey_dropdown('Panic mode', 540, 'toggle_panic')
		self.toggleItemUserHotkey, self.toggleItemUserCombo = self.create_hotkey_dropdown('Item user', 570, 'toggle_item_user')
		self.toggleTpTargetHotkey, self.toggleTpTargetCombo = self.create_hotkey_dropdown('Teleport to target', 600, 'tptotarget')
		if isGF:
			self.toggleWaithackHotkey, self.toggleWaithackCombo = self.create_hotkey_dropdown('Toggle waithack', 630, 'waithack')
	def update_gui_dropdowns(self):
		global hotkeyList, isGF
		self.update_dropdown('relog', self.relogCtrlCombo, self.relogCombo)
		self.update_dropdown('refine', self.refineCtrlCombo, self.refineCombo)
		self.update_dropdown('zoomfog', self.zoomfogCtrlCombo, self.zoomfogCombo)
		self.update_dropdown('day', self.dayCtrlCombo, self.dayCombo)
		self.update_dropdown('night', self.nightCtrlCombo, self.nightCombo)
		self.update_dropdown('sort', self.sortCtrlCombo, self.sortCombo)
		self.update_dropdown('donate', self.donateCtrlCombo, self.donateCombo)
		self.update_dropdown('spam_text', self.spamTextCtrlCombo, self.spamTextCombo)
		self.update_dropdown('show_map', self.showMapCtrlCombo, self.showMapCombo)
		self.update_dropdown('use_dews', self.useDewsCtrlCombo, self.useDewsCombo)
		self.update_dropdown('save_settings', self.saveSettingsCtrlCombo, self.saveSettingsCombo)
		self.update_dropdown('load_settings', self.loadSettingsCtrlCombo, self.loadSettingsCombo)
		self.update_dropdown('lock_target', self.lockTargetTabCombo, self.lockTargetQCombo)
		self.update_dropdown('toggle_farm', None, self.toggleFarmCombo)
		self.update_dropdown('toggle_pickup', None, self.togglePickupCombo)
		self.update_dropdown('toggle_panic', None, self.togglePanicCombo)
		self.update_dropdown('toggle_item_user', None, self.toggleItemUserCombo)
		self.update_dropdown('tptotarget', None, self.toggleTpTargetCombo)
		if isGF:
			self.update_dropdown('waithack', None, self.toggleWaithackCombo)
	def update_dropdown(self, action, ctrl_dropdown=None, key_dropdown=None):
		global hotkeyList
		try:
			current_keys = hotkeyList.get(action)
			possible_keys = get_possible_keys()
			if isinstance(current_keys, tuple):
				ctrl_key, main_key = current_keys
			else:
				ctrl_key, main_key = None, current_keys
			if ctrl_dropdown:
				if ctrl_dropdown.GetText() != ctrl_key:
					for item in ctrl_dropdown.DropList.itemList:
						if item.textBox.GetText() == ctrl_key:
							ctrl_dropdown.SetTitle(item)
							break
			if key_dropdown:
				if key_dropdown.GetText() != main_key:
					for item in key_dropdown.DropList.itemList:
						if item.textBox.GetText() == main_key:
							key_dropdown.SetTitle(item)
							break
		except:
			pass
	def saveHotkeys(self, arg):
		global hotkeyList,isGF
		try:
			dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + '/hotkey_settings.st_set'
			hotkeyList['relog'] = self.relogCtrlCombo.GetText() + ';' + self.relogCombo.GetText()
			hotkeyList['refine'] = self.refineCtrlCombo.GetText() + ';' + self.refineCombo.GetText()
			hotkeyList['zoomfog'] = self.zoomfogCtrlCombo.GetText() + ';' + self.zoomfogCombo.GetText()
			hotkeyList['day'] = self.dayCtrlCombo.GetText() + ';' + self.dayCombo.GetText()
			hotkeyList['night'] = self.nightCtrlCombo.GetText() + ';' + self.nightCombo.GetText()
			hotkeyList['sort'] = self.sortCtrlCombo.GetText() + ';' + self.sortCombo.GetText()
			hotkeyList['donate'] = self.donateCtrlCombo.GetText() + ';' + self.donateCombo.GetText()
			hotkeyList['spam_text'] = self.spamTextCtrlCombo.GetText() + ';' + self.spamTextCombo.GetText()
			hotkeyList['show_map'] = self.showMapCtrlCombo.GetText() + ';' + self.showMapCombo.GetText()
			hotkeyList['use_dews'] = self.useDewsCtrlCombo.GetText() + ';' + self.useDewsCombo.GetText()
			hotkeyList['save_settings'] = self.saveSettingsCtrlCombo.GetText() + ';' + self.saveSettingsCombo.GetText()
			hotkeyList['load_settings'] = self.loadSettingsCtrlCombo.GetText() + ';' + self.loadSettingsCombo.GetText()
			hotkeyList['lock_target'] = self.lockTargetTabCombo.GetText() + ';' + self.lockTargetQCombo.GetText()
			hotkeyList['toggle_farm'] = self.toggleFarmCombo.GetText()
			hotkeyList['toggle_pickup'] = self.togglePickupCombo.GetText()
			hotkeyList['toggle_panic'] = self.togglePanicCombo.GetText()
			hotkeyList['toggle_item_user'] = self.toggleItemUserCombo.GetText()
			hotkeyList['tptotarget'] = self.toggleTpTargetCombo.GetText()
			if isGF:
				hotkeyList['waithack'] = self.toggleWaithackCombo.GetText()
			file = open_file(dirPl, 'w')
			for action, keys in hotkeyList.items():
				if not find_string(action, "ch"):
					if ';' in keys:
						file.write(action + ': [' +  str(keys) + ']\n')
					else:
						file.write(action + ': [' + str(keys) + ']\n')
			file.close()
			self.loadHotkeys(0)
			if arg:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hHotkey manager: Hotkeys saved succesfully.")
		except:
			pass
	def loadHotkeys(self, ms):
		global hotkeyList
		try:
			dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + '/hotkey_settings.st_set'
			file = open_file(dirPl, 'r+')
			for line in file:
				line = line.strip()
				action, keys = line.split(': ')
				keys = keys.replace('[', '').replace(']', '')
				if find_string(keys, ";"):
					keys = tuple(keys.split(';'))
				else:
					keys = keys
				hotkeyList[action] = keys
				if isinstance(keys, tuple):
					self.set_hotkey(action, keys[0], keys[1])
				else:
					self.set_hotkey(action, keys)
			file.close()
			self.update_gui_dropdowns()
			if ms:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hHotkey manager: Hotkeys loaded succesfully.")
		except:
			pass
	def closeHotkeys(self, arg):
		if arg:
			self.hotkeysWindow.Hide()
		try:
			self.QuestionDialog.Close()
			self.QuestionDialog = None
		except:
			pass
	def exit_without_saving(self):
		self.closeHotkeys(1)
	def is_hotkey_in_use(self, key_combination, current_action):
		global hotkeyList
		for action, keys in hotkeyList.items():
			if action != current_action and keys == key_combination:
				return True
		return False
	def set_hotkey(self, action, key1, key2=None):
		global hotkeyList
		if key2 is not None:
			hotkeyList[action] = (key1, key2)
		else:
			hotkeyList[action] = key1
	def HotkeyRelogStop(self):
		self.HotkeyRelogx.XX1(9999999)
		self.HotkeyRelogx.XX2(self.HotkeyRelogStop)
	def HotkeyRelog(self):
		global hotkeyList
		self.HotkeyRelogx.XX1(0.01)
		self.HotkeyRelogx.XX2(self.HotkeyRelog)
	
		if self.hotKeyCB.checked == 1:
			for action, keys in hotkeyList.items():
				if isinstance(keys, tuple):
					# Convert key names to key codes
					key1 = getKeyCode(keys[0])
					key2 = getKeyCode(keys[1])
	
					if key1 is None or key2 is None:
						continue  # Skip invalid keys
	
					# Handle single-key shortcuts with 'None' as a placeholder
					if keys[1] == 'None':
						if isKeyPress(keys[0]):
							self.execute_action(action)
							return
					else:
						# Ensure both keys are pressed at the same time
						if app.IsPressed(key1) and isKeyPress(keys[1]):
							self.execute_action(action)
							return
				else:
					# Convert single key names to key codes
					key_code = getKeyCode(keys)
					if key_code is None:
						continue  # Skip invalid keys
	
					if isKeyPress(keys):
						self.execute_action(action)
						return
	def execute_action(self, action):
		global farmEnable, pickupState,lockTarget,isGF,waithackState,panicMode,tempAntiBan,antiban_state,item_user_state
		if action == 'relog':
			if self.relogBtn.IsShow():
				self.relogBtn_func()
			else:
				self.relogBtn_funcOff()
		elif action == 'zoomfog':
			if self.zoomfogBtn.IsShow():
				self.zoomfog_func()
			else:
				self.zoomfog_funcOff()
		elif action == 'day':
			self.day_func()
		elif action == 'refine':
			self.refine_func()
		elif action == 'night':
			self.night_func()
		elif action == 'sort':
			self.sort_func()
		elif action == 'donate':
			if self.donateBtn.IsShow():
				self.donate_func()
			else:
				self.donate_funcOff()
		elif action == 'spam_text':
			self.sendSpamTextFunc()
		elif action == 'show_map':
			pos = self.metin2_window.GetGlobalPosition()
			self.newMap.SetPosition(pos[0] + (self.metin2_window.GetWidth() - self.metin2_window.GetWidth() - self.newMap.GetWidth()), pos[1])
			if self.newMap.IsShow():
				self.newMap.Hide()
				self.keepChAttachedMapFuncOff()
			else:
				self.newMap.Show()
				self.loadTeleMap()
				self.keepChAttachedMapFuncFuncOn()
		elif action == 'use_dews':
			self.use_dews()
		elif action == 'save_settings':
			self.saveSettings()
		elif action == 'load_settings':
			try:
				self.loadSettings()
			except:
				pass
		elif action == 'ch1':	
			self.OnConnectButton(1)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCH Changer: Going to CH 1.")
			return
		elif action == 'ch2':
			self.OnConnectButton(2)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCH Changer: Going to CH 2.")
			return
		elif action == 'ch3':
			self.OnConnectButton(3)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCH Changer: Going to CH 3.")
			return
		elif action == 'ch4':
			self.OnConnectButton(4)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCH Changer: Going to CH 4.")
			return
		elif action == 'ch5':
			self.OnConnectButton(5)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCH Changer: Going to CH 5.")
			return
		elif action == 'ch6':
			self.OnConnectButton(6)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCH Changer: Going to CH 6.")
			return
		elif action == 'ch7':
			self.OnConnectButton(7)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCH Changer: Going to CH 7.")
			return
		elif action == 'ch8':
			self.OnConnectButton(8)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCH Changer: Going to CH 8.")
			return
		elif action == 'toggle_farm':
			if farmEnable == 1:
				self.onOffFarmbot(False)
				if self.classicStartCB.checked == 1:
					self.startFarmingBtn2.SetUp()
				else:
					self.startFarmingBtn.SetOff()
			else:
				if self.classicStartCB.checked == 1:
					self.startFarmingBtn2.Down()
				else:
					self.startFarmingBtn.SetOn()
				self.onOffFarmbot(True)
				
		elif action == 'toggle_item_user':
			if item_user_state == 1:
				self.itemuse_funcStop()
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hItem user stopped.")
			else:
				self.itemuse_func()
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hItem user started.")
				
		elif action == 'toggle_panic':
			if not panicMode:
				panicMode = 1
				if antiban_state:
					tempAntiBan = 1
					self.antibanStop()
				pauseFuncs(1)
				self.panicBtn.Show()
				try:
					self.panicBtn.Flash()
				except:
					pass
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPANIC: Enabled!")
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPANIC: " + lang.PANIC_INFO)
			elif panicMode:
				panicMode = 0
				pauseFuncs(0)
				if tempAntiBan:
					self.funcAntiBanStart()
					tempAntiBan = 0
				self.panicBtn.Hide()
				try:
					self.panicBtn.Flash()
				except:
					pass
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPANIC: Disabled!")
		elif action == 'toggle_pickup':
			if isGF:
				if pickupState == 1:
					self.pickupNormalStopGF()
					self.normalPickup.OnToggleUp()
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hNormal pickup: Stopped")
				else:
					self.pickupNormalStartGF()
					self.normalPickup.OnToggleDown()
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hNormal pickup: Started")
			else:
				if pickupState == 1:
					self.pickupNormalStop()
					self.normalPickup.OnToggleUp()
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hNormal pickup: Stopped")
				else:
					self.pickupNormalStart()
					self.normalPickup.OnToggleDown()
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hNormal pickup: Started")
		elif action == 'lock_target':
			if lockTarget == 1:
				self.lockTargetOff()
			else:
				self.lockTargetOn()					
		elif action == 'waithack':
			if isGF:
				if waithackState:
					waithackState = 0
					eXLib.UnblockAttackPackets()
					self.enableButton.SetUp()
					self.waithackStop()
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h Waithack: Stopped")
				else:
					waithackState = 1
					eXLib.BlockAttackPackets()
					self.enableButton.Down()
					self.waithackCheck()
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h Waithack: Started")
					
		elif action == 'lucernafix':
			if find_string(st_cur_server, "lucerna"):
				self.lucernaAdd()
				return					
		elif action == 'tptotarget':
			try:
				
				vid = player.GetTargetVID()
				
				if not vid:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlease select a target first!")
					return
				me = getCharIndex()
				x,y = getPos(vid)
				
				chr.SelectInstance(me)
				player_x, player_y = getPos(me)
				
				dxXXX = x - player_x
				dyYYY = y - player_y
				distanceSqrt = math.sqrt(dxXXX**2 + dyYYY**2)
				if distanceSqrt > 0:
					dxXXX /= distanceSqrt
					dyYYY /= distanceSqrt
			
				random_offset = getRandom(1,80)
				
				xgo = int(x - dxXXX * random_offset)
				ygo = int(y - dyYYY * random_offset)
				
				self.goingFunction('Teleporting', xgo, ygo, 0)
			except:
				pass
				
				
	def openMetin2Window(self):
		pass  # Men almyor
	def GetVID(self):
		global buffbotTarget
		try:
			vid = player.GetTargetVID()
			a = chr.GetInstanceType(vid)
			if a == playerType:
				name = chr.GetNameByVID(vid)
				self.followTargetName.SetText(str(name))
				buffbotTarget = vid
			else:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBuffbot: " + lang.NO_PLAYER_TARGET)
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBuffbot: " + lang.STR_NO_TARGET)
	def StartBuffbot(self):
		global isGF,canSearchPlayerVids
		if str(self.followTargetName.GetText()) != "":
			o = getCharIndex()
			x, y, z = player.GetMainCharacterPosition()
			vid = self.followTargetName.GetText()
			target = 0
			for i in vidsListEnd1:
				name = chr.GetNameByVID(i)
				if name != "None" and name == str(vid):
					target = i
			if target:
				setTarget(target)
		else:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBuffbot: " + lang.STR_NO_TARGET)
			return
	def openClams(self):
		for Slot in range(player.INVENTORY_PAGE_SIZE * 10):
			if player.GetItemIndex(Slot) == 27987:
				useItemFunc(Slot)
				create_log("Fishbot: Opening clams")
				
				
	if find_string(st_cur_server, "aegis"):
		def ScanForNPCByRace(self, race):
			global npcList, vidsListEnd1,searchNpc,isGF
			o=getCharIndex()
			for u in range(o-75000, o+75000):
				if chr.INSTANCE_TYPE_NPC == chr.GetInstanceType(u):
					chr.SelectInstance(u)
					if chr.GetRace() == race:
						return u
			for i in range(150000):
				if chr.INSTANCE_TYPE_NPC == chr.GetInstanceType(i):
					chr.SelectInstance(i)
					if chr.GetRace() == race:
						return i
			return 0
	else:
				
		def ScanForNPCByRace(self, race):
			global canUseVid, vidsListEnd1, targetVID_Start, targetVID_End, restartCounter, isGF
			o=getCharIndex()
			vid = 0
	
			if isGF:
				for i in eXLib.InstancesList:
					
					DistanceToNext = GetDis(i)
					if chr.INSTANCE_TYPE_NPC == chr.GetInstanceType(i):
						chr.SelectInstance(i)
						if chr.GetRace() == race:
							
							vid = i
				
				return vid
			else:
				for i in vidsListEnd1:
					
					DistanceToNext = GetDis(i)
					if chr.INSTANCE_TYPE_NPC == chr.GetInstanceType(i):
						chr.SelectInstance(i)
						if chr.GetRace() == race:
	
							vid = i
				
				return vid
	def scan_for_alchemist(self, race):
		global canUseVid, vidsListEnd1, targetVID_Start, targetVID_End, restartCounter, isGF
		o=getCharIndex()
		vid = 0
		# self.msxg(vidsListEnd1)
		
		
		if isGF:
			for i in eXLib.InstancesList:
				
				DistanceToNext = GetDis(i)
				if chr.INSTANCE_TYPE_NPC == chr.GetInstanceType(i):
					chr.SelectInstance(i)
					if chr.GetRace() == race:
						if DistanceToNext < 10000:
							vid = i
			
			return vid
		else:
			for i in vidsListEnd1:
				
				DistanceToNext = GetDis(i)
				if chr.INSTANCE_TYPE_NPC == chr.GetInstanceType(i):
					chr.SelectInstance(i)
					if chr.GetRace() == race:
						if DistanceToNext < 10000:
							vid = i
			
			return vid
	def sellMinnowFunc(self):
		index = self.fishshopIndex.GetText()
		for Slot in range(player.INVENTORY_PAGE_SIZE * 10):
			getItemCount = player.GetItemCount(Slot)
			if player.GetItemIndex(Slot) == 27802:
				fisherman_vid = self.ScanForNPCByRace(int(self.fisherVnum.GetText()))
				if self.fix_quest.checked==1:
					self.InstallQuestWindowHook()
				else:
					pass
				chr.SelectInstance(fisherman_vid)
				clickPacket(fisherman_vid)
				event.SelectAnswer(0, int(index))
				event.SelectAnswer(0, 0)
				event.ClearEventSet(1)
				if find_string(st_cur_server, "2009") or find_string(st_cur_server, "hardmt2"):
					SendChatPacket('/sell_items ' + str(Slot) + " " + str(player.GetItemCount(Slot)) + " 1")
				else:
					sellItemFunction(Slot)
				net.SendShopEndPacket()
				create_log("Fishbot: Selling minnow")
	def GetItemByType(self,_id):
		for i in range(player.INVENTORY_PAGE_SIZE * 10):
			curr_id = player.GetItemIndex(i)
			if curr_id == 0:
				continue
			selectItem(curr_id)
			if item.GetItemType() == _id:
				return i
		return -1
	try:
		def isItemTypeOnSlot(self,_type,invType = 2,slot=item.EQUIPMENT_WEAPON):
			idx = player.GetItemIndex(invType,slot)
			if idx != 0:
				selectItem(idx)
				if item.GetItemType() == _type:
					return True
			return False
	except:
		pass
	def use_blue(self):
		for i in range(player.INVENTORY_PAGE_SIZE * 10):
			a = player.GetItemIndex(i)
			if a == 27004 or a == 27005 or a == 27006 :
				useItemFunc(i)
				break
	def buybaitQ(self):
		global Bait_Alternative_ID
		fisherman_vid = self.ScanForNPCByRace(int(self.fisherVnum.GetText()))
		index = self.buyBaitIndex.GetText()
		chr.SelectInstance(fisherman_vid)
		clickPacket(fisherman_vid)
		if self.fix_quest.checked==1:
			self.InstallQuestWindowHook()
		else:
			pass
		event.SelectAnswer(0, int(index))
		event.SelectAnswer(0, 254)
		event.SelectAnswer(0, 0)
		event.ClearEventSet(1)
		if find_string(st_cur_server, "Vertas"):
			for i in range(player.INVENTORY_PAGE_SIZE*10):
				item_index = player.GetItemIndex(i)
				if item_index == (99954):
					useItemFunc(i)
					event.SelectAnswer(0, 1)
					event.SelectAnswer(0, 0)
					event.ClearEventSet(1)
					return
	def should_buy_bait(self, item_id):
		global Bait_Alternative_ID
		if self.alternativeBtn.checked and item_id == Bait_Alternative_ID:
			return True
		if self.wormCb.checked and item_id == 27801:
			return True			
		if self.pasteCb.checked and item_id == 27800:
			return True
	def purchase_bait_if_needed(self, fisherman_vid):
		global Bait_Alternative_ID, initX, initY
		index = int(self.buyBaitIndex.GetText())
		chr.SelectInstance(fisherman_vid)
		clickPacket(fisherman_vid)
		if self.fix_quest.checked==1:
			self.InstallQuestWindowHook()
		chr.SelectInstance(fisherman_vid)	
		event.SelectAnswer(0, int(index))
		event.ClearEventSet(1)
		self.newFishingFunc()
		X,Y,Z = player.GetMainCharacterPosition()
		if self.alternativeBtn.checked == 1:
			invId = player.GetItemCountByVnum(int(Bait_Alternative_ID))
		else:
			if self.wormCb.checked == 1:
				invId = player.GetItemCountByVnum(int(27801))
			if self.pasteCb.checked == 1:
				invId = player.GetItemCountByVnum(int(27800))
		for i in range(45):
			item_id = shop.GetItemID(i)
			if invId <= 0:
				if self.should_buy_bait(item_id):
					net.SendShopBuyPacket(i)
		net.SendShopEndPacket()
		if invId:
			if self.goToFisherman.checked==1:
				if initX != 0 or initY != 0:
					if not self.inside_circle(X, Y, initX, initY, 50):
						self.goingFunction(str(self.gotoFisher.GetCurrentText()), int(initX),int(initY), 1)
						self.Debug()
		self.buyxbait.XX1(9999999)
		self.buyxbait.XX2(self.buybait)
	def buybait(self):
		global Bait_Alternative_ID, canWalkTele, initX, initY
		self.buyxbait.XX1(0.5)
		self.buyxbait.XX2(self.buybait)
		o = getCharIndex()
		Bait = player.GetItemCountByVnum
		index = self.buyBaitIndex.GetText()
		try:
			vnumx = int(self.fisherVnum.GetText())
		except:
			vnumx = 9009
		fisherman_vid = self.ScanForNPCByRace(vnumx)
		dist = GetDis(fisherman_vid)
		X,Y,Z = player.GetMainCharacterPosition()
		fishermanX,fishermanY = getPos(fisherman_vid)
		if not dist <= 1000:
			if self.goToFisherman.checked==1:
				x, y = getPos(fisherman_vid)
				self.goingFunction(str(self.gotoFisher.GetCurrentText()), int(x),int(y), 1)
				if self.inside_circle(X, Y, fishermanX, fishermanY, 500):
					self.Debug()
					self.purchase_bait_if_needed(fisherman_vid)
			else:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: " + lang.FAR_AWAY_FISHERMAN)
				self.buyxbait.XX1(9999999)
				self.buyxbait.XX2(self.buybait)
		else:
			self.purchase_bait_if_needed(fisherman_vid)
	def equipRod(self):		
		undita = self.isItemTypeOnSlot(item.ITEM_TYPE_ROD,2,item.EQUIPMENT_WEAPON)
		if undita != 1:
			slot = self.GetItemByType(item.ITEM_TYPE_ROD)
			if slot != -1:
				useItemFunc(slot)
			else:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: " + lang.NO_FISH_ROD)
	def upgradeRodFunc(self):
		fisherman_vid = self.ScanForNPCByRace(int(self.fisherVnum.GetText()))
		if self.fix_quest.checked==1:
			self.InstallQuestWindowHook()
		else:
			pass
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: " + lang.STR_UPGRADE_ROD1)
		for i in range(player.INVENTORY_PAGE_SIZE*10):
			if player.GetItemIndex(i) >= 27400 and player.GetItemIndex(i) <= 27580:
				net.SendGiveItemPacket(fisherman_vid,player.SLOT_TYPE_INVENTORY,i,player.GetItemCount(i))
		event.SelectAnswer(0, 0)
		event.SelectAnswer(0, 0)
		event.ClearEventSet(1)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: " + lang.STR_UPGRADE_ROD2)
		create_log("Fishbot: Fishing rod was upgraded succesfully.")
		eventHandler.add(1, self.equipRod)
		create_log("Fishbot: Equiped back the fishing rod.")
	def unequipRod(self):
		val = self.isItemTypeOnSlot(item.ITEM_TYPE_ROD,2,item.EQUIPMENT_WEAPON)
		if val:
			useItemFunc(item.EQUIPMENT_WEAPON)
			return
	def LevelUpRod(self):
		val = self.isItemTypeOnSlot(item.ITEM_TYPE_ROD,2,item.EQUIPMENT_WEAPON)
		if val:
			self.unequipRod()
			eventHandler.add(3, self.upgradeRodFunc)
		else:
			self.upgradeRodFunc()
	def isRodAbleToLevelUp(self):
		try:
			idx = player.GetItemIndex(2,item.EQUIPMENT_WEAPON)
			selectItem(idx)
			currPoints = player.GetItemMetinSocket(2,item.EQUIPMENT_WEAPON,0)
			maxPoints = item.GetValue(2)
			if currPoints == maxPoints and item.GetItemType() == item.ITEM_TYPE_ROD:
				if self.upgradeRod.checked == 1:
					
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: " + lang.STR_UPGRADE_ROD3)
					create_log("Fishbot: Fishing rod can be upgraded.")
					
					self.LevelUpRod()
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: An error occured while checking if the rod can be upgraded.")
	def UseBait(self):
		self.equipRod()
		global Bait_Alternative_ID, baitUsed
		baitUsed = 0
		bait_types = []
		if self.alternativeBtn.checked:
			bait_types.append(Bait_Alternative_ID)
		if self.pasteCb.checked:
			bait_types.append(27800)
		if self.wormCb.checked:
			bait_types.append(27801)
		if self.minnowCb.checked:
			bait_types.append(27802)
		baitSlot = None
			
		for bait_type in bait_types:
			if player.GetItemCountByVnum(int(bait_type)) > 0:
				for InventorySlot in range(player.INVENTORY_PAGE_SIZE * 10):
					ItemValue = player.GetItemIndex(InventorySlot)
					if ItemValue == int(bait_type):
						baitSlot = InventorySlot
						break
		if baitSlot:
			useItemFunc(baitSlot)
			return
		else:
			baitUsed = 0
		if not baitUsed:
			if self.buyBaitQBtn.checked:
				self.buybaitQ()
				return
			if self.buyBaitBtn.checked:
				self.buybait()
				return
	def newFishingFunc(self):
		global canWalkTele
		global initX, initY
		try:
			fishIds = self.catches.keys()
			dropFish = False
			for i in range(player.INVENTORY_PAGE_SIZE * 10):
				id = player.GetItemIndex(i)
				if id in self.deadFish:
					id -=30
					isDeadFish = True
				else:
					isDeadFish = False
				if id in self.friedFish:
					id-=60
					isFryFish = True
				else:
					isFryFish = False
				if id in fishIds:
					fishOptions = self.catches[id]
					if 'buttonOpen' in fishOptions.keys() and fishOptions['buttonOpen'].isOn:
						useItemFunc(i)
					if 'buttonDrop' in fishOptions.keys() and fishOptions['buttonDrop'].isOn:
						net.SendItemDropPacketNew(i,player.GetItemCount(i))
					if 'buttonSell' in fishOptions.keys() and fishOptions['buttonSell'].isOn:
						if hasattr(net, 'SendShopNewSellPacket'):
							net.SendShopNewSellPacket(i, player.GetItemCount(i), player.INVENTORY)
						else:
							sellItemFunction(i)
		except:
			pass
	def RandomTolerance(self):
		Tolerance = float(self.fbot_delay.GetText())
		Rnd = getRandom(0, int(Tolerance))
		return DivideToFloat1(Rnd, 10)
	def fishChecks(self):		
		Bait = player.GetItemCountByVnum
		self.newFishingFunc()
		if find_string(st_cur_server, "Vertas"):
			for i in range(player.INVENTORY_PAGE_SIZE*10):
				item_index = player.GetItemIndex(i)
				if item_index == (99954):
					useItemFunc(i)
					event.SelectAnswer(0, 0)
					event.SelectAnswer(0, 0)
					event.ClearEventSet(1)
		if self.switchArmor.checked == 1:
			# msg('yes')
			val = self.isItemTypeOnSlot(item.ITEM_TYPE_ARMOR,2,item.EQUIPMENT_BODY)
			# msg(val)
			if val != 1:
				slot = self.GetItemByType(item.ITEM_TYPE_ARMOR)
				if slot != -1:
					useItemFunc(slot)
		undita = self.isItemTypeOnSlot(item.ITEM_TYPE_ROD,2,item.EQUIPMENT_WEAPON)
		if undita == 0:
			slot = self.GetItemByType(item.ITEM_TYPE_ROD)
			if slot == -1:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: " + lang.STR_UPGRADE_ROD4)
				self.StopFishBot()
			else:
				useItemFunc(slot)
		try:
			if self.openclamhBtn.checked == 1:
				self.openClams()
		except:
			pass
		try:
			if self.sellminnowCb.checked == 1:
				self.sellMinnowFunc()
		except:
			pass
		# try:
			# net.SendShopEndPacket()
		# except:
			# pass
	def changeFishState(self, arg):
		global fishbot_state
		fishbot_state = str(arg)
		eventHandler.remove('changeFishState')
	def pullrodFunc(self):
		global canSkipAnimation, setMountVnum
		eventHandler.remove('pullrodFunc')
		if canSkipAnimation == 1:
			self.isRodAbleToLevelUp()
			if self.switchArmor.checked == 1:
				self.getArmorDownUp()
			if self.fix_fishbot.checked==1:
				if self.skipAnim.checked == 1:
					if setMountVnum != 0:
						for i in range(player.INVENTORY_PAGE_SIZE * 10):
							a = player.GetItemIndex(i)
							if a == setMountVnum:
								useItemFunc(i)
								if not player.IsMountingHorse():
									mountHorseFunc(0)
									break
								break
						if player.IsMountingHorse():
							mountHorseFunc(0)
					else:
						mountHorseFunc(0)
				if find_string(st_cur_server, "tiks") or find_string(st_cur_server, "shinra"):
					skillId = 109
				else:
					skillId = 102
				player.ClickSkillSlot(int(skillId))
				if self.skipAnim.checked == 1:
					if setMountVnum != 0:
						for i in range(player.INVENTORY_PAGE_SIZE * 10):
							a = player.GetItemIndex(i)
							if a == setMountVnum:
								useItemFunc(i)
								if not player.IsMountingHorse():
									mountHorseFunc(0)
								break
						if player.IsMountingHorse():
							mountHorseFunc(0)
					else:
						mountHorseFunc(0)
			else:
				if self.skipAnim.checked == 1:
					if setMountVnum != 0:
						for i in range(player.INVENTORY_PAGE_SIZE * 10):
							a = player.GetItemIndex(i)
							if a == setMountVnum:
								useItemFunc(i)
								if not player.IsMountingHorse():
									mountHorseFunc(0)
								break
						if player.IsMountingHorse():
							mountHorseFunc(0)
					else:
						mountHorseFunc(0)
				Attack(True)
				Attack(False)
				if self.skipAnim.checked == 1:
					if setMountVnum != 0:
						for i in range(player.INVENTORY_PAGE_SIZE * 10):
							a = player.GetItemIndex(i)
							if a == setMountVnum:
								useItemFunc(i)
								if not player.IsMountingHorse():
									mountHorseFunc(0)
								break
						if player.IsMountingHorse():
							mountHorseFunc(0)
					else:
						mountHorseFunc(0)
			canSkipAnimation = 0
	def get_direction(self, angle):
		if angle >= 337.5 or angle < 22.5:
			return 180
		elif angle >= 22.5 and angle < 67.5:
			return 180
		elif angle >= 67.5 and angle < 112.5:
			return 85
		elif angle >= 112.5 and angle < 157.5:
			return 85
		elif angle >= 157.5 and angle < 202.5:
			return 360
		elif angle >= 202.5 and angle < 247.5:
			return 360
		elif angle >= 247.5 and angle < 337.4:
			return 260
		else:
			return 1
	def isPossibleEmoticon(self):	
		if find_string(st_cur_server, "oficial"):
			return chrmgr.IsPossibleEmoticon(-1,oficialARG)
		else:
			return chrmgr.IsPossibleEmoticon(-1)
	def pauseFishInfo(self):
		try:
			foor = int(self.pauseFishFor.GetText())
		except:
			foor = 'x'
		try:
			each = int(self.pauseFishEach.GetText())
		except:
			each = 'y'
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: Checking this box, \x53\x54\x4d\x6f\x64 will pause fishbot for " + str(foor) + " minutes, each " + str(each) + " minutes.")
	def randomizeFishFunc(self):	
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: Checking this box, \x53\x54\x4d\x6f\x64 will randomize the fish delay.")
	def schedule_pause(self):
		global initFishTime, startFishTime
		try:
			forx = int(self.pauseFishFor.GetText())
		except:
			forx = 5 * 60
		pause_duration = forx * 60 
		try:
			interval = int(self.pauseFishEach.GetText())
		except:
			interval = 15 * 60
		pause_interval = interval * 60 
		if self.pauseFishing.checked == 1:
			elapsed_time = app.GetTime() - initFishTime
			if elapsed_time >= pause_interval:
				self.StopFishBot()
				create_log("Paused fishbot for " + str(forx) + " minutes.")
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: Paused fishbot for " + str(forx) + " minutes.")
				eventHandler.add(pause_duration, self.resume_fishbot, "resume_fishbot")
				startFishTime = app.GetTime()
	def callFishClick(self):
		player.FishingGameGoal(1)
		player.FishingGameGoal(2)
		player.FishingGameGoal(3)
		if hasattr(player, 'FishingGameQuit'):
			player.FishingGameQuit()
			player.FishingGameQuit()
		eventHandler.add(3, lambda: self.changeFishState('useBait'))
	def resume_fishbot(self):
		self.StartFishBot()
		try:
			forx = int(self.pauseFishFor.GetText())
		except:
			forx = 5 * 60
		create_log("Resumed fishbot after " + str(forx) + " minutes.")
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: Resumed fishbot after " + str(forx) + " minutes.")
	def parse_delay_value(self):
		try:
			return float(self.delay_textbox.GetText())
		except:
			return 2.5
	
	def get_bot_delay(self, st_cur_server, autoRemoveWalk, uiFishGame):
		bot_delay_text = self.fbot_delay.GetText()
		if (find_string(st_cur_server, "ageofmagis") or
			find_string(st_cur_server, "eternal") or
			find_string(st_cur_server, "global2") or
			autoRemoveWalk):
			if bot_delay_text == "0.01":
				return 1.0
	
		elif uiFishGame and not find_string(st_cur_server, "m2brasil"):
			if bot_delay_text == "0.01":
				return 1.0
	
		elif (hasattr(player, 'FishingGameGoal') and
			not (find_string(st_cur_server, "Guabina") or find_string(st_cur_server, "m2brasil"))):
			if bot_delay_text == "0.01":
				return 1.0
		try:
			return float(bot_delay_text)
		except:
			return 0.01
	
	def apply_random_offset(self, st_cur_server, delay_value, bot_delay_value, randomize_checked):
		"""
		If randomizeFish is checked, add a random offset to both delay_value and
		optionally bot_delay_value (on specific servers). Return updated values.
		"""
		if not randomize_checked:
			return delay_value, bot_delay_value
	
		try:
			# If 'random' is available in globals(), we assume from 'import random'
			if 'random' in globals():
				random_generated = random.uniform(0, 0.9)
				random_offset = random.uniform(-random_generated, random_generated)
			else:
				# Fallback to getRandom(...) logic
				random_int = getRandom(0, 9)
				random_generated = random_int / 10.0
				random_int_for_offset = getRandom(0, int(random_generated * 10))
				random_offset = (random_int_for_offset / 10.0) - random_generated
	
			delay_value += random_offset
			if find_string(st_cur_server, "ageofmagis") or find_string(st_cur_server, "eternal"):
				bot_delay_value += random_offset
	
		except:
			pass
	
		return delay_value, bot_delay_value
	def rotate_character(self, default_rotation):
		try:
			char_index = getCharIndex()
			if default_rotation not in (-1, None, "None"):
				chr.SetRotation(default_rotation)
			else:
				current_rot = chr.GetRotation(int(char_index))
				default_rotation = self.get_direction(current_rot)
				chr.SetRotation(default_rotation)
		except:
			pass
	def start_fishing(self):
		global fishbot_state, tempTime
		tempTime = app.GetTime() + 48
		self.UseBait()
		self.pullRod()
		fishbot_state = "wait"
	
	def wait_fishing(self, delay_value):
		global fishbot_state, canSkipAnimation, fishCheck
		global debugged, pauseFishbot, startFish
		if not isConnect():
			self.fishingxBot.XX1(3)
			return
	
		if pauseFishbot:
			if not debugged:
				self.Debug()
				debugged = 1
			return
		self.schedule_pause()
		my_instance = getCharIndex()
		chr.SelectInstance(my_instance)
		debugged = 0
	
		if fishbot_state == 'useBait':
			fishbot_state = 'startFishing'
	
		if fishbot_state == 'startFishing':
			self.start_fishing()
			return
	
		if fishbot_state == 'wait':
			timeWaitMax = app.GetTime()
	
			if hasattr(net, 'CatchFishingNew'):
				try:
					net.CatchFishingNew()
				except:
					pass
			self.handle_server_specific_wait()
			if fishCheck == 0:
				self.fishChecks()
				fishCheck = 1
			if not self.isPossibleEmoticon():
				if canSkipAnimation == 0:
					canSkipAnimation = 1
					
				if not eventHandler.has('pullrodFunc'):
					eventHandler.add(int(delay_value), self.pullrodFunc, 'pullrodFunc')
				half_delay = float(delay_value) / 2.0
				restart_in = half_delay + 5
				
				if not eventHandler.has('changeFishState'):
					eventHandler.add(restart_in, lambda: self.changeFishState('restart'), 'changeFishState')
				return
			if timeWaitMax >= tempTime:
				if canSkipAnimation == 0:
					canSkipAnimation = 1
				self.StopFishBot()
				if not eventHandler.has('StartFishBot'):
					eventHandler.add(2, self.StartFishBot, 'StartFishBot')
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: Unfortunately you didn't catch anything.")
				create_log("Fishbot: Unfortunately you didn't catch anything.")
				return
	
	def restart_fishing(self):
		global fishbot_state, fishCheck
		self.fishingxBot.XX1(2)
		self.fishingxBot.XX2(self.fishbotFunc)
		fishbot_state = 'startFishing'
		fishCheck = 0
	def sendFishAvaris(self):
		global avarisFishId
		
		if avarisFishId:
			player.FishingGameGoal(1, int(avarisFishId))
			player.FishingGameGoal(2, int(avarisFishId))
			player.FishingGameGoal(3, int(avarisFishId))
			player.FishingGameQuit()
			player.FishingGameQuit()
	
	def handle_server_specific_wait(self):
		global avarisFishId
		if find_string(st_cur_server, "avaris"):
			if avarisFishId:
				eventHandler.add(1, self.sendFishAvaris)
			return
		if find_string(st_cur_server, "levia"):
			import constInfo
			SendChatPacket("/cmd_fish_event " + str(constInfo.fishVnum))
			SendChatPacket("/cmd_fish_event " + str(constInfo.fishVnum))
			SendChatPacket("/cmd_fish_event " + str(constInfo.fishVnum))
			SendChatPacket("/cmd_fish_event " + str(constInfo.fishVnum))
			SendChatPacket("/cmd_fish_event "+str(constInfo.fishVnum+1))
			SendChatPacket("/cmd_fish_event "+str(constInfo.fishVnum+2))
			return
		if find_string(st_cur_server, "GoodTimes"):
			SendChatPacket("/cmd_fish_event 1")
			return
		if find_string(st_cur_server, "global2") or autoRemoveWalk:
			SendChatPacket('/fishing_renewal a')
			SendChatPacket('/fishing_renewal a')
			SendChatPacket('/fishing_renewal a')
			SendChatPacket('/fishing_renewal s')
			eventHandler.add(2, lambda: self.changeFishState('useBait'))
			return
		if find_string(st_cur_server, "Wom"):
			player.QuitFishing(3, 3, 3)
			return
		if (hasattr(player, 'FishingGameGoal') and not (find_string(st_cur_server, "Guabina") or find_string(st_cur_server, "m2brasil"))):
			try:
				eventHandler.add(1, self.callFishClick)
			except:
				pass
			return
		if uiFishGame and not find_string(st_cur_server, "m2brasil"):
			self.handle_ui_fish_game()
			return
		if hasattr(player, 'QuitFishing'):
			try:
				player.QuitFishing(3)
				if find_string(st_cur_server, "ROP2"):
					eventHandler.add(4, lambda: self.changeFishState('useBait'))
			except:
				pass
			return
		if (find_string(st_cur_server, "Xhelia") or
			find_string(st_cur_server, "forsaken") or
			find_string(st_cur_server, "caris") or
			find_string(st_cur_server, "capital")):
			eventHandler.add(0.5, self.fishXhelia)
			return
	def handle_ui_fish_game(self):
		global argDumped, fishArg, canCallAgain, startFish
	
		try:
			def hooked_open(self_, gameKey):
				global fishArg
				fishArg = gameKey
				self_._original_open(gameKey)
	
			def attach_hook():
				global argDumped
				original_open = uiFishGame.FishGameWindow.Open
				uiFishGame.FishGameWindow._original_open = original_open
				setattr(uiFishGame.FishGameWindow, 'Open', hooked_open)
				argDumped = 1
	
			if not argDumped:
				attach_hook()
	
			def send_score(arg):
				global fishArg
				cmd = "/" + str(uiFishGame.game_command)
				SendChatPacket(cmd + " " + str(fishArg) + " score 1")
				SendChatPacket(cmd + " " + str(fishArg) + " score 1")
				if find_string(st_cur_server, "eternal"):
					SendChatPacket(cmd + " " + str(fishArg) + " score 1")
	
			def schedule_call(arg, delay):
				eventHandler.add(delay, lambda: send_score(arg))
	
			def schedule_calls(args, delay=1):
				global canCallAgain, startFish
				if args:
					current_arg = args.pop(0)
					schedule_call(current_arg, delay)
					eventHandler.add(delay, lambda: schedule_calls(args, delay))
				else:
					canCallAgain = 1
					startFish = 1
					self.pullrodFunc()
					eventHandler.add(4, lambda: self.changeFishState('useBait'))
	
			def try_schedule_calls(args):
				global canCallAgain, fishArg
				if canCallAgain and fishArg:
					canCallAgain = 0
					startFish = 0
					schedule_calls(args)
	
			if startFish:
				try_schedule_calls([1, 2, 3])
	
		except:
			pass
	def fishbotFunc(self):
		global fishbot_state
		delay_value = self.parse_delay_value()
		bot_delay_value = self.get_bot_delay(st_cur_server, autoRemoveWalk, uiFishGame)
		delay_value, bot_delay_value = self.apply_random_offset(
			st_cur_server,
			delay_value,
			bot_delay_value,
			(self.randomizeFish.checked == 1)
		)
		self.rotate_character(defaultRot)
		self.fishingxBot.XX1(bot_delay_value)
		self.fishingxBot.XX2(self.fishbotFunc)
		if fishbot_state == 'restart':
			self.restart_fishing()
		else:
			self.wait_fishing(delay_value)
	def modify_setting(self, setting_file, setting_name, new_value):
		try:
			file = open_file(setting_file, 'r+')
			lines = file.readlines()
			count = 0
			setting_found = False
			for line in lines:
				if line.startswith(setting_name + "="):
					lines[count] = '%s=%s\n' % (setting_name, new_value)
					setting_found = True
					break
				count += 1
			if not setting_found:
				lines.append('%s=%s\n' % (setting_name, new_value))
			filex = open_file(setting_file, 'w')
			filex.writelines(lines)
			file.close()
			filex.close()
		except:
			pass
	def is_disabled(self, server, disabled_list):
		for disabled_server in disabled_list:
			if find_string(server, disabled_server):
				return True
		try:
			if fishing:
				return True
		except:
			pass
		return False
	def StartFishBot(self):
		global fishbot_state, tempTime, canSkipAnimation,fish_state,startFish,canCallAgain
		global defaultRot,disabledFishbot,initX,initY,initFishTime,fishbotState
		xx,yy,zz = player.GetMainCharacterPosition()
		initX = xx
		initY = yy
		startFish = 1
		fishbotState = 1
		canCallAgain = 1
		eventHandler.remove('StartFishBot')
		if self.is_disabled(st_cur_server, disabledFishbot):
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: " + lang.FISHBOT_DISABLED)
			return
		try:
			o = getCharIndex()
			defaultRot = self.get_direction(chr.GetRotation(int(o)))
			self.modify_setting(CONFIG, 'Fishbot_CharacterRotation', defaultRot)
		except:
			pass
		self.fishbotBtnStop.Show()
		self.fishbotBtn.Hide()
		fishbot_state='useBait'
		tempTime = app.GetTime()
		initFishTime = app.GetTime()
		canSkipAnimation=0
		fish_state=1
		self.equipRod()
		if find_string(st_cur_server, "Azyrah"):
			self.fishbotFuncAzyrah()
		else:
			self.fishbotFunc()
	def setStatus(self, sts):		
		global currentStatus
		currentStatus = str(sts)
	def fishXhelia(self):
		global canSkipAnimation
		if find_string(st_cur_server, "capital"):
			what = getRandom(1, 3)
			event.SelectAnswer(int(what),0)
			event.ClearEventSet(1)
		SendChatPacket("/cmd_fish_event 58236")
		SendChatPacket("/cmd_fish_event 58236")
		SendChatPacket("/cmd_fish_event 58236")
		SendChatPacket("/cmd_fish_event 78531")
		SendChatPacket("/cmd_fish_event 90295")
		canSkipAnimation = 1
		self.fishChecks()
		self.pullrodFunc()
		eventHandler.add(2, lambda: self.changeFishState('useBait'))
	def fishbotFuncAzyrah(self):
		global canStart,currentStatus
		self.fishbotxFuncAzyrah.XX1(0.1)
		self.fishbotxFuncAzyrah.XX2(self.fishbotFuncAzyrah)
		canStart = True
		myInstance = getCharIndex()
		chr.SelectInstance(myInstance)
		if currentStatus == 'stop' or currentStatus == None:
			currentStatus = 'start'
		if currentStatus == 'start':
			self.doOnceFunc()
		elif currentStatus == 'redo':
			self.doOnceFunc()
	def fishFunc(self):
		global currentStatus
		player.QuitFishing(3)
		eventHandler.add(6, lambda: self.setStatus('redo'))
	def doOnceFunc(self):
		global canStart,currentStatus
		if canStart == True:
			self.UseBait()
			self.pullRod()
			currentStatus = 'wait'
			eventHandler.add(6, self.fishFunc)
	def freezeFishFunc(self):
		try:
			fishing.StopFishMovement()
		except:
			pass
	def StopFishBot(self):
		global fishbot_state,fish_state,fishbotState
		self.fishingxBot.XX1(9999999)
		self.fishingxBot.XX2(self.StopFishBot)
		self.fishbotxFuncAzyrah.XX1(9999999)
		self.fishbotxFuncAzyrah.XX2(self.StopFishBot)
		self.fishbotBtnStop.Hide()
		self.fishbotBtn.Show()
		eventHandler.remove("resume_fishbot")
		fishbot_state = "stop"
		fish_state = 0
		fishbotState = 0
		self.Debug()
		self.buyxbait.XX1(99999999)
		self.buyxbait.XX2(self.buybait)
		self.UnHookQuestWindow(0)
	def MallOutFunc(self):
		for i in range(180):
			net.SendMallCheckoutPacket(i , i)
	def storeInFunc2(self):
		try:
			slot=self.StoreInFrom.GetText()
			upto = self.StoreInTo.GetText()
			for i in range(int(slot),int(upto)):
				net.SendSafeboxCheckinPacket(i , i)
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|Move items to storehouse: " + lang.STR_ERR_OCCURED)
	def storeOutFunc(self):
		try:
			empty_inventory_slots = self.getFreeSlots()
			from_slot = int(self.StoreInFrom.GetText())
			to_slot = int(self.StoreInTo.GetText())
			for i in range(from_slot, to_slot + 1):
				safebox_item_id = safebox.GetItemID(i)
				if safebox_item_id > 0:
					empty_slot = empty_inventory_slots.pop(0)
					net.SendSafeboxCheckoutPacket(i, empty_slot)
		except:
			pass
	def storeInFuncStart(self):
		try:
			ItemToStoreList = []
			SlotSBAvailable = []
			from_slot = int(self.StoreInFrom.GetText())
			to_slot = int(self.StoreInTo.GetText())
			for slot in range(from_slot, to_slot + 1):
				SBItems = safebox.GetItemID(slot)
				if SBItems > 0:
					selectItem(SBItems)
					SBItemSize = item.GetItemSize()[1]
					if SBItemSize == 2:
						SlotSBAvailable.append(slot + 5)
					elif SBItemSize == 3:
						SlotSBAvailable.extend([slot + 5, slot + 10])
				elif SBItems == 0 and slot not in SlotSBAvailable:
					ItemToStoreList.append(slot)
			if len(ItemToStoreList) > 0:
				for slot in range(from_slot, to_slot + 1):
					if slot not in SlotSBAvailable:
						empty_slot = ItemToStoreList.pop(0)
						net.SendSafeboxCheckinPacket(slot, empty_slot)
						SlotSBAvailable.append(slot)
		except:
			pass
	def storeInFuncStop(self):
		self.storeInFuncStartx.XX1(9999999)
		self.storeInFuncStartx.XX2(self.storeInFuncStart)
	def buyuseFunc(self):
		try:
			self.buyuseFuncx.XX1(float(0.1))
			self.buyuseFuncx.XX2(self.buyuseFunc)
			self.buyUseBtnOff.Show()
			self.buyUseBtnOn.Hide()
			for i in range(int(self.delayUseBot.GetText())):
				if shop.IsOpen():	
					net.SendShopBuyPacket(int(self.slotUseBot.GetText()))
					useItemFunc(int(self.delayUseBot.GetText()))
				else:
					self.buyuseFuncOff()
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBuy & use: " + lang.STR_INV_MANAGER1)
					return
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|Buy & use: " + lang.STR_ERR_OCCURED)
			self.buyuseFuncOff()
	def buyuseFuncOff(self):
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBuy & use bot stopped.")
		self.buyuseFuncx.XX1(9999999)
		self.buyuseFuncx.XX2(self.buyuseFuncOff)
		self.buyUseBtnOff.Hide()
		self.buyUseBtnOn.Show()
	def buySellPgmFunc(self):
		try:
			self.buySellPgmFuncx.XX1(float(self.AVGdelayBuyBot.GetText()))
			self.buySellPgmFuncx.XX2(self.buySellPgmFunc)
			self.buysellPGMOff.Show()
			self.buysellPGMOn.Hide()
			SelectedIndex = self.bonusListforBS.GetCurrentText()
			MinValue = self.minimumValue.GetText()
			Slot = int(self.buyFromSlot.GetText())
			val0, bon0 = player.GetItemAttribute(Slot, 0)
			val1, bon1 = player.GetItemAttribute(Slot, 1)
			if SelectedIndex == "Average damage":
				if val0 == 72 and bon0 >= int(MinValue):
					self.buySellPgmFuncOff()
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBuy & sell items: " + lang.STR_AVG_OK + " |cFFC0C0C0|H|h" + str(bon0))
					net.SendShopEndPacket()
				else:
					if self.dropItemCB.checked==1:
						if hasattr(net, 'SendItemDestroyPacket'):
							destroyItemFunction(Slot)
						else:
							net.SendItemDropPacketNew(Slot,player.GetItemCount(Slot))
					else:
						sellItemFunction(Slot)
			if SelectedIndex == "Skill damage":
				if val1 == 71 and bon1 >= int(MinValue):
					self.buySellPgmFuncOff()
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBuy & sell items: " + lang.STR_SD_OK + " |cFFC0C0C0|H|h" + str(bon1))
					net.SendShopEndPacket()
				else:
					if self.dropItemCB.checked==1:
						if hasattr(net, 'SendItemDestroyPacket'):
							destroyItemFunction(Slot)
						else:
							net.SendItemDropPacketNew(Slot,player.GetItemCount(Slot))
					else:
						sellItemFunction(Slot)
			if shop.IsOpen():	
				net.SendShopBuyPacket(Slot)
			else:
				self.buySellPgmFuncOff()
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBuy & sell items: " + lang.STR_INV_MANAGER1)
				return
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|Buy & sell items: " + lang.STR_ERR_OCCURED)
			self.buySellPgmFuncOff()
	def buySellPgmFuncOff(self):
		self.buySellPgmFuncx.XX1(9999999)
		self.buySellPgmFuncx.XX2(self.buySellPgmFuncOff)
		self.buysellPGMOff.Hide()
		self.buysellPGMOn.Show()
	def buybotFunc(self):
		try:
			self.buybotFuncx.XX1(float(self.delayBuyBot.GetText()))
			self.buybotFuncx.XX2(self.buybotFunc)
			self.buybotBtnOff.Show()
			self.buybotBtnOn.Hide()
			for i in range(90):
				if shop.IsOpen():	
					net.SendShopBuyPacket(int(self.slotBuyBot.GetText()))
					sellItemFunction(i)
				else:
					self.buybotFuncOff()
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBuy & sell items: " + lang.STR_INV_MANAGER1)
					return
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|Buy & sell: " + lang.STR_ERR_OCCURED)
			self.buybotFuncOff()
	def buybotFuncOff(self):
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBuy & sell bot stopped.")
		self.buybotFuncx.XX1(9999999)
		self.buybotFuncx.XX2(self.buybotFuncOff)
		self.buybotBtnOff.Hide()
		self.buybotBtnOn.Show()
	def split_item_slot(self):
		global slot_item_split,id_item_split
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			id_item_split = GetAttachedItemIndex()
			slot_item_split = GetAttachedSlotNumber()
			selectItem(id_item_split)
		self.itemSplitterSlotIcon.LoadImage(str(item.GetIconImageFileName()))
		DeattachObject()
	def getFreeSlots(self):
		global SLOTS_PER_PAGE, SLOTS
		items_arr = dict()
		toStackMoveActions = []
		for i in range(-1,200):
			idx = player.GetItemIndex(i)
			if idx == 0:
				if idx not in items_arr:
					items_arr[idx] = [player.GetItemCount(i),i]
					continue
				count = player.GetItemCount(i)
				total_sum = count + items_arr[idx][0]
				if count == 0:
					toStackMoveActions.append(i)
		return toStackMoveActions
	def split_item_func(self):
		global slot_item_split, id_item_split
		try:
			slots = self.getFreeSlots()
			item_split_into = self.split_item_to_value.GetText()
			for slot in slots:
				MoveItem(slot_item_split, slot, int(item_split_into))
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hItem splitter: " + lang.STR_NO_ITEM_SELECTED)
			
			
	def RealSkillSlotToSourceSlot(self, realSkillSlot):
		if realSkillSlot > 100:
			return realSkillSlot
		return realSkillSlot % skill.SKILL_GRADE_STEP_COUNT
	def shouldLevelUpSkill(self, slotNumber):
		try:
			srcSlotIndex = self.RealSkillSlotToSourceSlot(slotNumber)
			curLevel = player.GetSkillLevel(srcSlotIndex)
			if curLevel < 17:
				return 1
			return 0
		except:
			return 1
	def skillplus1(self):
		if not self.shouldLevelUpSkill(1):
			return
		if foundx64PythonList or find_string(st_cur_server, "rodnia"):
			for i in range(5):
				SendChatPacket('/skillup 1',0)
		else:
			try:
				for i in range(5):
					#
					skillGrade = player.GetSkillGrade(2)
					if skill.CanLevelUpSkill(2, skillGrade):
						charmenu = uiCharacter.CharacterWindow()
						charmenu.OnPressedSlotButton(1)
						charmenu.Hide()
						del charmenu
			except:
				pass
	def skillplus2(self):
		if not self.shouldLevelUpSkill(2):
			return
		
		
		if foundx64PythonList or find_string(st_cur_server, "rodnia"):
			for i in range(5):
				SendChatPacket('/skillup 2',0)
		else:
			try:
				for i in range(5):
					#
					skillGrade = player.GetSkillGrade(2)
					if skill.CanLevelUpSkill(2, skillGrade):
						charmenu = uiCharacter.CharacterWindow()
						charmenu.OnPressedSlotButton(2)
						charmenu.Hide()
						del charmenu
			except:
				pass
	def skillplus3(self):
		if not self.shouldLevelUpSkill(3):
			return
		if foundx64PythonList or find_string(st_cur_server, "rodnia"):
			for i in range(5):
				SendChatPacket('/skillup 3',0)
		else:
			try:
				for i in range(5):
					#
					skillGrade = player.GetSkillGrade(2)
					if skill.CanLevelUpSkill(2, skillGrade):
						charmenu = uiCharacter.CharacterWindow()
						charmenu.OnPressedSlotButton(3)
						charmenu.Hide()
						del charmenu
			except:
				pass
	def skillplus4(self):
		if not self.shouldLevelUpSkill(4):
			return
		if foundx64PythonList or find_string(st_cur_server, "rodnia"):
			for i in range(5):
				SendChatPacket('/skillup 4',0)
		else:
			try:
				for i in range(5):
					#
					skillGrade = player.GetSkillGrade(2)
					if skill.CanLevelUpSkill(2, skillGrade):
						charmenu = uiCharacter.CharacterWindow()
						charmenu.OnPressedSlotButton(4)
						charmenu.Hide()
						del charmenu
			except:
				pass
	def skillplus5(self):
		if not self.shouldLevelUpSkill(5):
			return
		if foundx64PythonList or find_string(st_cur_server, "rodnia"):
			for i in range(5):
				SendChatPacket('/skillup 5',0)
		else:
			try:
				for i in range(5):
					#
					skillGrade = player.GetSkillGrade(2)
					if skill.CanLevelUpSkill(2, skillGrade):
						charmenu = uiCharacter.CharacterWindow()
						charmenu.OnPressedSlotButton(5)
						charmenu.Hide()
						del charmenu
			except:
				pass
	def skillplus6(self):
		if not self.shouldLevelUpSkill(6):
			return
		if foundx64PythonList or find_string(st_cur_server, "rodnia"):
			for i in range(5):
				SendChatPacket('/skillup 6',0)
		else:
			try:
				for i in range(5):
					skillGrade = player.GetSkillGrade(2)
					if skill.CanLevelUpSkill(2, skillGrade):
						charmenu = uiCharacter.CharacterWindow()
						charmenu.OnPressedSlotButton(6)
						charmenu.Hide()
						del charmenu
			except:
				pass
	def skillplus1_func(self, arg):
		global p1_state
		if arg=='on':
			self.skillplus1_funcx()
			self.p1_state=1
		elif arg=='off':
			self.skillplus1_funcxstop()
			self.p1_state=0
	def skillplus1_funcx(self):
		self.skillplus1_funcxx.XX1(7)
		self.skillplus1_funcxx.XX2(self.skillplus1_funcx)
		if not isConnect():
			return
		if not self.shouldLevelUpSkill(1):
			self.btnSkill1.SetUp()
			self.skillplus1_func('off')
			return
		if foundx64PythonList or find_string(st_cur_server, "rodnia"):
			SendChatPacket('/skillup 1',0)
		else:
			try:
				skillGrade = player.GetSkillGrade(2)
				if skill.CanLevelUpSkill(2, skillGrade):
					charmenu = uiCharacter.CharacterWindow()
					charmenu.OnPressedSlotButton(1)
					charmenu.Hide()
					del charmenu
			except:
				pass
	def skillplus1_funcxstop(self):
		self.skillplus1_funcxx.XX1(9999999)
		self.skillplus1_funcxx.XX2(self.skillplus1_funcxstop)
	def skillplus2_func(self, arg):
		global p2_state
		if arg=='on':
			self.skillplus2_funcx()
			self.p2_state=1
		elif arg=='off':
			self.skillplus2_funcxstop()
			self.p2_state=0
	def skillplus2_funcx(self):
		self.skillplus2_funcxx.XX1(7)
		self.skillplus2_funcxx.XX2(self.skillplus2_funcx)
		if not isConnect():
			return
		if not self.shouldLevelUpSkill(2):
			self.btnSkill2.SetUp()
			self.skillplus2_func('off')
			return
		if foundx64PythonList or find_string(st_cur_server, "rodnia"):
			SendChatPacket('/skillup 2',0)
		else:
			try:
				skillGrade = player.GetSkillGrade(2)
				if skill.CanLevelUpSkill(2, skillGrade):
					charmenu = uiCharacter.CharacterWindow()
					charmenu.OnPressedSlotButton(2)
					charmenu.Hide()
					del charmenu
			except:
				pass
	def skillplus2_funcxstop(self):
		self.skillplus2_funcxx.XX1(9999999)
		self.skillplus2_funcxx.XX2(self.skillplus2_funcxstop)
	def skillplus3_func(self, arg):
		global p3_state
		if arg=='on':
			self.skillplus3_funcx()
			self.p3_state=1
		elif arg=='off':
			self.skillplus3_funcxstop()
			self.p3_state=0
			
	def skillplus3_funcx(self):
		self.skillplus3_funcxx.XX1(7)
		self.skillplus3_funcxx.XX2(self.skillplus3_funcx)
		if not isConnect():
			return
			
		if not self.shouldLevelUpSkill(3):
			self.btnSkill3.SetUp()
			self.skillplus3_func('off')
			return
		if foundx64PythonList or find_string(st_cur_server, "rodnia"):
			SendChatPacket('/skillup 3',0)
		else:
			try:
				skillGrade = player.GetSkillGrade(2)
				if skill.CanLevelUpSkill(2, skillGrade):
					charmenu = uiCharacter.CharacterWindow()
					charmenu.OnPressedSlotButton(3)
					charmenu.Hide()
					del charmenu
			except:
				pass
	def skillplus3_funcxstop(self):
		self.skillplus3_funcxx.XX1(9999999)
		self.skillplus3_funcxx.XX2(self.skillplus3_funcxstop)
	def skillplus4_func(self, arg):
		global p4_state
		if arg=='on':
			self.skillplus4_funcx()
			self.p4_state=1
		elif arg=='off':
			self.skillplus4_funcxstop()
			self.p4_state=0
	def skillplus4_funcx(self):
		self.skillplus4_funcxx.XX1(7)
		self.skillplus4_funcxx.XX2(self.skillplus4_funcx)
		if not isConnect():
			return
		if not self.shouldLevelUpSkill(4):
			self.btnSkill4.SetUp()
			self.skillplus4_func('off')
			return
		if foundx64PythonList or find_string(st_cur_server, "rodnia"):
			SendChatPacket('/skillup 4',0)
		else:
			try:
				skillGrade = player.GetSkillGrade(2)
				if skill.CanLevelUpSkill(2, skillGrade):
					charmenu = uiCharacter.CharacterWindow()
					charmenu.OnPressedSlotButton(4)
					charmenu.Hide()
					del charmenu
			except:
				pass
	def skillplus4_funcxstop(self):
		self.skillplus4_funcxx.XX1(9999999)
		self.skillplus4_funcxx.XX2(self.skillplus4_funcxstop)
	def skillplus5_func(self, arg):
		global p5_state
		if arg=='on':
			self.skillplus5_funcx()
			self.p5_state=1
		elif arg=='off':
			self.skillplus5_funcxstop()
			self.p5_state=0
	def skillplus5_funcx(self):
		self.skillplus5_funcxx.XX1(7)
		self.skillplus5_funcxx.XX2(self.skillplus5_funcx)
		if not isConnect():
			return
		if not self.shouldLevelUpSkill(5):
			self.btnSkill5.SetUp()
			self.skillplus5_func('off')
			return
		if foundx64PythonList or find_string(st_cur_server, "rodnia"):
			SendChatPacket('/skillup 5',0)
		else:
			try:
				skillGrade = player.GetSkillGrade(2)
				if skill.CanLevelUpSkill(2, skillGrade):
					charmenu = uiCharacter.CharacterWindow()
					charmenu.OnPressedSlotButton(5)
					charmenu.Hide()
					del charmenu
			except:
				pass
	def skillplus5_funcxstop(self):
		self.skillplus5_funcxx.XX1(9999999)
		self.skillplus5_funcxx.XX2(self.skillplus5_funcxstop)
	def skillplus6_func(self, arg):
		global p6_state
		if arg=='on':
			self.skillplus6_funcx()
			self.p6_state=1
		elif arg=='off':
			self.skillplus6_funcxstop()
			self.p6_state=0
	def skillplus6_funcx(self):
		self.skillplus6_funcxx.XX1(7)
		self.skillplus6_funcxx.XX2(self.skillplus6_funcx)
		if not isConnect():
			return
		if not self.shouldLevelUpSkill(6):
			self.btnSkill6.SetUp()
			self.skillplus6_func('off')
			return
		if foundx64PythonList or find_string(st_cur_server, "rodnia"):
			SendChatPacket('/skillup 6',0)
		else:
			try:
				skillGrade = player.GetSkillGrade(2)
				if skill.CanLevelUpSkill(2, skillGrade):
					charmenu = uiCharacter.CharacterWindow()
					charmenu.OnPressedSlotButton(6)
					charmenu.Hide()
					del charmenu
			except:
				pass
	def skillplus6_funcxstop(self):
		self.skillplus6_funcxx.XX1(9999999)
		self.skillplus6_funcxx.XX2(self.skillplus6_funcxstop)
	def GetKeyValue(self, key):
		if key == 'HTH':
			return player.GetStatus(player.HT)
		if key == 'INT':
			return player.GetStatus(player.IQ)
		if key == 'STR':
			return player.GetStatus(player.ST)
		if key == 'DEX':
			return player.GetStatus(player.DX)
	def vit_func2(self):
		if foundx64PythonList:
			SendChatPacket('/con+ 5',0)
		elif find_string(st_cur_server, "rodnia"):
			SendChatPacket('/stat ht 5',0)
		else:
			try:
				for x in range(5):
					#
					statusPlusPoint = player.GetStatus(player.STAT)
					if statusPlusPoint > 0:
						key = 'HTH'
						for i in range(len(statuDict)):
							key = statuDict[i]
							value = self.GetKeyValue(key)
							if value < 90:
								break
						try:
							charmenu = uiCharacter.CharacterWindow()
							charmenu._CharacterWindow__OnClickStatusPlusButton(key)
							charmenu.Hide()
							del charmenu
						except:
							pass
			except:
				pass
	def int_func2(self):
		if foundx64PythonList:
			SendChatPacket('/int+ 5',0)
		elif find_string(st_cur_server, "rodnia"):
			SendChatPacket('/stat iq 5',0)
		else:
			try:
				for x in range(5):
					#
					statusPlusPoint = player.GetStatus(player.STAT)
					if statusPlusPoint > 0:
						key = 'INT'
						for i in range(len(statuDict)):
							key = statuDict[i]
							value = self.GetKeyValue(key)
							if value < 90:
								break
						try:
							charmenu = uiCharacter.CharacterWindow()
							charmenu._CharacterWindow__OnClickStatusPlusButton(key)
							charmenu.Hide()
							del charmenu
						except:
							pass
			except:
				pass
	def str_func2(self):
		if foundx64PythonList:
			SendChatPacket('/str+ 5',0)
		elif find_string(st_cur_server, "rodnia"):
			SendChatPacket('/stat st 5',0)
		else:
			try:
				for x in range(5):
					#
					statusPlusPoint = player.GetStatus(player.STAT)
					if statusPlusPoint > 0:
						key = 'STR'
						for i in range(len(statuDict)):
							key = statuDict[i]
							value = self.GetKeyValue(key)
							if value < 90:
								break
						try:
							charmenu = uiCharacter.CharacterWindow()
							charmenu._CharacterWindow__OnClickStatusPlusButton(key)
							charmenu.Hide()
							del charmenu
						except:
							pass
			except:
				pass
	def dex_func2(self):
		if foundx64PythonList:
			SendChatPacket('/dex+ 5',0)
		elif find_string(st_cur_server, "rodnia"):
			SendChatPacket('/stat dx 5',0)
		else:
			try:
				for x in range(5):
					#
					statusPlusPoint = player.GetStatus(player.STAT)
					if statusPlusPoint > 0:
						key = 'DEX'
						for i in range(len(statuDict)):
							key = statuDict[i]
							value = self.GetKeyValue(key)
							if value < 90:
								break
						try:
							charmenu = uiCharacter.CharacterWindow()
							charmenu._CharacterWindow__OnClickStatusPlusButton(key)
							charmenu.Hide()
							del charmenu
						except:
							pass
			except:
				pass
	def vit_func(self, arg):
		global vit_state
		if arg=='on':
			self.vit_funcx()
			self.vit_state=1
		elif arg=='off':
			self.vit_funcxstop()
			self.vit_state=0
	def vit_funcx(self):
		self.vit_funcxx.XX1(7)
		self.vit_funcxx.XX2(self.vit_funcx)
		if not isConnect():
			return
		if foundx64PythonList:
			SendChatPacket('/con+ 1',0)
		elif find_string(st_cur_server, "rodnia"):
			SendChatPacket('/stat ht 1',0)
		else:
			try:
				#
				statusPlusPoint = player.GetStatus(player.STAT)
				if statusPlusPoint > 0:
					key = 'HTH'
					for i in range(len(statuDict)):
						key = statuDict[i]
						value = self.GetKeyValue(key)
						if value < 90:
							break
					try:
						charmenu = uiCharacter.CharacterWindow()
						charmenu._CharacterWindow__OnClickStatusPlusButton(key)
						charmenu.Hide()
						del charmenu
					except:
						pass
			except:
				pass
	def vit_funcxstop(self):
		self.vit_funcxx.XX1(9999999)
		self.vit_funcxx.XX2(self.vit_funcxstop)
	def int_func(self, arg):
		global int_state
		if arg=='on':
			self.int_funcx()
			self.int_state=1
		elif arg=='off':
			self.int_funcxstop()
			self.int_state=0
	def int_funcx(self):
		self.int_funcxx.XX1(7)
		self.int_funcxx.XX2(self.int_funcx)
		if not isConnect():
			return
		if foundx64PythonList:
			SendChatPacket('/int+ 1',0)
		elif find_string(st_cur_server, "rodnia"):
			SendChatPacket('/stat iq 1',0)
		else:
			try:
				statusPlusPoint = player.GetStatus(player.STAT)
				if statusPlusPoint > 0:
					key = 'INT'
					for i in range(len(statuDict)):
						key = statuDict[i]
						value = self.GetKeyValue(key)
						if value < 90:
							break
					try:
						charmenu = uiCharacter.CharacterWindow()
						charmenu._CharacterWindow__OnClickStatusPlusButton(key)
						charmenu.Hide()
						del charmenu
					except:
						pass
			except:
				pass
	def int_funcxstop(self):
		self.int_funcxx.XX1(9999999)
		self.int_funcxx.XX2(self.int_funcxstop)
	def str_func(self, arg):
		global str_state
		if arg=='on':
			self.str_funcx()
			self.str_state=1
		elif arg=='off':
			self.str_funcxstop()
			self.str_state=0
	def str_funcx(self):
		self.str_funcxx.XX1(7)
		self.str_funcxx.XX2(self.str_funcx)
		if not isConnect():
			return
		if foundx64PythonList:
			SendChatPacket('/str+ 1',0)
		elif find_string(st_cur_server, "rodnia"):
			SendChatPacket('/stat st 1',0)
		else:
			try:
				statusPlusPoint = player.GetStatus(player.STAT)
				if statusPlusPoint > 0:
					key = 'STR'
					for i in range(len(statuDict)):
						key = statuDict[i]
						value = self.GetKeyValue(key)
						if value < 90:
							break
					try:
						charmenu = uiCharacter.CharacterWindow()
						charmenu._CharacterWindow__OnClickStatusPlusButton(key)
						charmenu.Hide()
						del charmenu
					except:
						pass
			except:
				pass
#Drag item
	def SetDragItem(self):
		global dragItem, dragItemId
		if isAttached():
			attachedSlotVnum = GetAttachedItemIndex()
			dragItem = GetAttachedSlotNumber()
			dragItemId = attachedSlotVnum
			selectItem(attachedSlotVnum)		
			DeattachObject()
			itemToDragIcon = item.GetIconImageFileName()
			self.itemToDragIcon.LoadImage(str(itemToDragIcon))		
	def DeleteDragItem(self):
		global dragItem,dragItemId
		dragItem = 0
		dragItemId = 0
		self.itemToDragIcon.LoadImage(slot_base)
#Drag item
#Drag item2
	def SetDragItem2(self):
		global dragItem2, dragItemId2
		if isAttached():
			attachedSlotVnum = GetAttachedItemIndex()
			dragItem2 = GetAttachedSlotNumber()
			dragItemId2 = attachedSlotVnum
			selectItem(attachedSlotVnum)		
			DeattachObject()
			itemToDragIcon2 = item.GetIconImageFileName()
			self.itemToDragIcon2.LoadImage(str(itemToDragIcon2))		
	def DeleteDragItem2(self):
		global dragItem2,dragItemId2
		dragItem2 = 0
		dragItemId2 = 0
		self.itemToDragIcon2.LoadImage(slot_base)
#Drag item2
#Drag item3
	def SetDragItem3(self):
		global dragItem3, dragItemId3
		if isAttached():
			attachedSlotVnum = GetAttachedItemIndex()
			dragItem3 = GetAttachedSlotNumber()
			dragItemId3 = attachedSlotVnum
			selectItem(attachedSlotVnum)		
			DeattachObject()
			itemToDragIcon3 = item.GetIconImageFileName()
			self.itemToDragIcon3.LoadImage(str(itemToDragIcon3))		
	def DeleteDragItem3(self):
		global dragItem3,dragItemId3
		dragItem3 = 0
		dragItemId3 = 0
		self.itemToDragIcon3.LoadImage(slot_base)
#Drag item3
#USE ITEM RELOG
	def Set_ItemUserRelog_Item(self):
		global Item_User_Relog_ID
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			selectItem(attachedSlotVnum)
			Item_User_Relog_ID = GetAttachedItemIndex()				
			DeattachObject()
			selectItem(int(attachedSlotVnum))
			itemUserRelog_Item_Icon = item.GetIconImageFileName()
			self.itemUserRelog_Item_Icon.LoadImage(str(itemUserRelog_Item_Icon))		
	def Delete_ItemUserRelog_Item(self):
		global Item_User_Relog_ID	
		Item_User_Relog_ID = 0
		#
		self.itemUserRelog_Item_Icon.LoadImage(slot_base)
#USE ITEM RELOG
#USE ITEM HP LOW
	def Set_usehplow_Item(self):
		global useItemHpLowID
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			selectItem(attachedSlotVnum)
			useItemHpLowID = GetAttachedItemIndex()				
			DeattachObject()
			selectItem(int(attachedSlotVnum))
			UseHpLowIcon = item.GetIconImageFileName()
			self.UseHpLowIcon.LoadImage(str(UseHpLowIcon))		
	def Delete_usehplow_Item(self):
		global useItemHpLowID	
		useItemHpLowID = 0
		#
		self.UseHpLowIcon.LoadImage(slot_base)
#USE ITEM HP LOW
	def str_funcxstop(self):
		self.str_funcxx.XX1(9999999)
		self.str_funcxx.XX2(self.str_funcxstop)
	def dex_func(self, arg):
		global dex_state
		if arg=='on':
			self.dex_funcx()
			self.dex_state=1
		elif arg=='off':
			self.dex_funcxstop()
			self.dex_state=0
	def dex_funcx(self):
		self.dex_funcxx.XX1(7)
		self.dex_funcxx.XX2(self.dex_funcx)	
		if not isConnect():
			return
		if foundx64PythonList:
			SendChatPacket('/dex+ 1',0)
		elif find_string(st_cur_server, "rodnia"):
			SendChatPacket('/stat dx 1',0)
		else:
			try:
				statusPlusPoint = player.GetStatus(player.STAT)
				if statusPlusPoint > 0:
					key = 'DEX'
					for i in range(len(statuDict)):
						key = statuDict[i]
						value = self.GetKeyValue(key)
						if value < 90:
							break
					try:
						charmenu = uiCharacter.CharacterWindow()
						charmenu._CharacterWindow__OnClickStatusPlusButton(key)
						charmenu.Hide()
						del charmenu
					except:
						pass
			except:
				pass
	def dex_funcxstop(self):
		self.dex_funcxx.XX1(9999999)
		self.dex_funcxx.XX2(self.dex_funcxstop)
#SET ITEM TO STONE ITEM
	def set_stoneItem_item(self):
		global select_stonetoitemID,select_stonetoitemIndex
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			selectItem(attachedSlotVnum)
			select_stonetoitemID = GetAttachedItemIndex()				
			select_stonetoitemIndex = GetAttachedSlotNumber()				
			DeattachObject()
			selectItem(int(attachedSlotVnum))
			itemStoneIcon = item.GetIconImageFileName()
			self.itemStoneIcon.LoadImage(str(itemStoneIcon))		
	def delete_stoneItem_item(self):
		global select_stonetoitemID, select_stonetoitemIndex
		select_stonetoitemID = 0
		self.itemStoneIcon.LoadImage(slot_base)
#SET ITEM TO STONE ITEM
#SET STONE
	def set_stone(self):
		global select_stoneID,select_stoneSlotID
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			selectItem(attachedSlotVnum)
			select_stoneSlotID = GetAttachedSlotNumber()				
			select_stoneID = GetAttachedItemIndex()				
			DeattachObject()
			selectItem(int(attachedSlotVnum))
			StoneIcon = item.GetIconImageFileName()
			self.StoneIcon.LoadImage(str(StoneIcon))		
	def delete_stone(self):
		global select_stoneID,select_stoneSlotID
		select_stoneID = 0
		select_stoneSlotID = 0
		self.StoneIcon.LoadImage(slot_base)
#SET STONE
#SET broken
	def set_brokenstone(self):
		global select_brokenstone,select_brokenstoneSlot
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			selectItem(attachedSlotVnum)
			select_brokenstone = GetAttachedItemIndex()				
			select_brokenstoneSlot = GetAttachedSlotNumber()				
			DeattachObject()
			selectItem(int(attachedSlotVnum))
			brokenIcon = item.GetIconImageFileName()
			self.brokenIcon.LoadImage(str(brokenIcon))		
	def delete_brokenstone(self):
		global select_brokenstone,select_brokenstoneSlot
		select_brokenstone = 0
		select_brokenstoneSlot = 0
		self.brokenIcon.LoadImage(slot_base)
#SET broken
#SET ITEM TO REFINE
	def select_item_refine(self):
		global select_item_refineID,select_item_refineCount
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			select_item_refineID = GetAttachedSlotNumber()
			select_item_refineCount = GetAttachedItemIndex()
			selectItem(attachedSlotVnum)
			selectItem(int(attachedSlotVnum))
			self.refineIcon.LoadImage(str(item.GetIconImageFileName()))
			DeattachObject()
	def delete_item_refine(self):
		global select_item_refineID,select_item_refineCount
		select_item_refineID = 0
		select_item_refineCount = 0
		self.refineIcon.LoadImage(slot_base)
#SET ITEM TO REFINE
#SET SPECIAL ITEM
	def fishdelay_msg(self):
		try:
			o = "|cFFFF8040|H|h"
			y = "|cffFFFF00|H|h"
			g = "|cff00FF00|H|h"
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing delay info - based on Rod value")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+1 " + o + "-> " + g + "2.70")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+2 " + o + " -> " + g + "2.65")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+3 " + o + " -> " + g + "2.63")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+4 " + o + " -> " + g + "2.60")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+5 " + o + " -> " + g + "2.55")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+6 " + o + " -> " + g + "2.51")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+7 " + o + " -> " + g + "2.45")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+8 " + o + " -> " + g + "2.40")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+9 " + o + " -> " + g + "2.36")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+10 " + o + "-> " + g + "2.32")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+11 " + o + "-> " + g + "2.26")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+12 " + o + "-> " + g + "2.22")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+13 " + o + "-> " + g + "2.17")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+14 " + o + "-> " + g + "2.12")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+15 " + o + "-> " + g + "2.08")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+16 " + o + "-> " + g + "2.05")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+17 " + o + "-> " + g + "2.00")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+18 " + o + "-> " + g + "1.95")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+19 " + o + "-> " + g + "1.92")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: " + y + "+20 " + o + "-> " + g + "1.85")
			msg("")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishing rod: Those values are hypothetical, they may not correspond to your needs.")
		except:
			pass
	def fishdelay_tipShow(self):
		o = "|cFFFF8040|H|h"
		y = "|cffFFFF00|H|h"
		g = "|cff00FF00|H|h"
		try:
			self.txttooltip.ClearToolTip()
			self.txttooltip.AppendTextLine("Fishing delay info - based on Rod value", grp.GenerateColor(0.9490, 0.9058, 0.7568, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+1 " + o + "-> " + g + "2.70", grp.GenerateColor(0.2, 0.9, 0.9, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+2 " + o + " -> " + g + "2.65", grp.GenerateColor(0.2, 0.9, 0.9, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+3 " + o + " -> " + g + "2.63", grp.GenerateColor(0.2, 0.9, 0.9, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+4 " + o + " -> " + g + "2.60", grp.GenerateColor(0.2, 0.9, 0.9, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+5 " + o + " -> " + g + "2.55", grp.GenerateColor(0.2, 0.9, 0.9, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+6 " + o + " -> " + g + "2.51", grp.GenerateColor(0.2, 0.9, 0.9, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+7 " + o + " -> " + g + "2.45", grp.GenerateColor(0.2, 0.9, 0.9, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+8 " + o + " -> " + g + "2.40", grp.GenerateColor(0.2, 0.9, 0.9, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+9 " + o + " -> " + g + "2.36", grp.GenerateColor(0.2, 0.9, 0.9, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+10 " + o + "-> " + g + "2.32", grp.GenerateColor(0.2, 0.9, 0.9, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+11 " + o + "-> " + g + "2.26", grp.GenerateColor(0.2, 0.9, 0.9, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+12 " + o + "-> " + g + "2.22", grp.GenerateColor(0.2, 0.9, 0.9, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+13 " + o + "-> " + g + "2.17", grp.GenerateColor(0.2, 0.9, 0.9, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+14 " + o + "-> " + g + "2.12", grp.GenerateColor(0.2, 0.9, 0.9, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+15 " + o + "-> " + g + "2.08", grp.GenerateColor(0.2, 0.9, 0.9, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+16 " + o + "-> " + g + "2.05", grp.GenerateColor(0.2, 0.9, 0.9, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+17 " + o + "-> " + g + "2.00", grp.GenerateColor(0.2, 0.9, 0.9, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+18 " + o + "-> " + g + "1.95", grp.GenerateColor(0.2, 0.9, 0.9, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+19 " + o + "-> " + g + "1.92", grp.GenerateColor(0.2, 0.9, 0.9, 1.0)) 
			self.txttooltip.AppendTextLine("Fishing rod: " + y + "+20 " + o + "-> " + g + "1.85", grp.GenerateColor(0.2, 0.9, 0.9, 1.0))  
			self.txttooltip.AppendTextLine("", grp.GenerateColor(0.2, 0.9, 0.9, 1.0))  
			self.txttooltip.AppendTextLine("Those values are hypothetical,", grp.GenerateColor(0.9490, 0.9058, 0.7568, 1.0))  
			self.txttooltip.AppendTextLine("they may not correspond to your needs.", grp.GenerateColor(0.9490, 0.9058, 0.7568, 1.0))  
			self.txttooltip.Show()
		except:
			pass
	def fishdelay_tipHide(self):
		try:
			self.txttooltip.ClearToolTip()
			self.txttooltip.Hide()	
		except:
			pass
	def set_special_item(self):
		global special_itemID
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			selectItem(attachedSlotVnum)
			special_itemID = GetAttachedItemIndex()				
			DeattachObject()
			selectItem(int(attachedSlotVnum))
			specialItemIcon = item.GetIconImageFileName()
			self.specialItemIcon.LoadImage(str(specialItemIcon))		
	def delete_special_item(self):
		global special_itemID	
		special_itemID = 0
		self.specialItemIcon.LoadImage(slot_base)
#SET SPECIAL ITEM
#SET EXO
	def set_exo(self):
		global exo_id
		global exo_vnum
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			selectItem(attachedSlotVnum)
			exo_id = GetAttachedItemIndex()				
			exo_vnum = GetAttachedSlotNumber()				
			DeattachObject()
			selectItem(int(attachedSlotVnum))
			exorcism_Icon = item.GetIconImageFileName()
			self.exorcism_Icon.LoadImage(str(exorcism_Icon))		
	def del_exo(self):
		global exo_id,exo_vnum
		exo_id = 0
		exo_vnum = 0
		self.exorcism_Icon.LoadImage(slot_base)
#SET EXO
#SET CC
	def set_cc(self):
		global cc_id
		global cc_vnum
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			selectItem(attachedSlotVnum)
			cc_id = GetAttachedItemIndex()				
			cc_vnum = GetAttachedSlotNumber()				
			DeattachObject()
			selectItem(int(attachedSlotVnum))
			hermit_Icon = item.GetIconImageFileName()
			self.hermit_Icon.LoadImage(str(hermit_Icon))		
	def del_cc(self):
		global cc_id,cc_vnum
		cc_id = 0
		cc_vnum = 0
		self.hermit_Icon.LoadImage(slot_base)
#SET CC
#SET SS
	def set_ss(self):
		global ss_id
		global ss_vnum
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			selectItem(attachedSlotVnum)
			ss_id = GetAttachedItemIndex()				
			ss_vnum = GetAttachedSlotNumber()				
			DeattachObject()
			selectItem(int(attachedSlotVnum))
			ss_Icon = item.GetIconImageFileName()
			self.ss_Icon.LoadImage(str(ss_Icon))		
	def del_ss(self):
		global ss_id,ss_vnum
		ss_id = 0
		ss_vnum = 0
		self.ss_Icon.LoadImage(slot_base)
#SET SS
#SET ZEN
	def set_zen(self):
		global zen_id
		global zen_vnum
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			selectItem(attachedSlotVnum)
			zen_id = GetAttachedItemIndex()				
			zen_vnum = GetAttachedSlotNumber()				
			DeattachObject()
			selectItem(int(attachedSlotVnum))
			zen_Icon = item.GetIconImageFileName()
			self.zen_Icon.LoadImage(str(zen_Icon))		
	def del_zen(self):
		global zen_id,zen_vnum
		zen_id = 0
		zen_vnum = 0
		self.zen_Icon.LoadImage(slot_base)
#SET ZEN
#SET ITEM TO GIVE AT ALCHEMIST
	def select_item_toGive(self):
		global select_item_toGiveID
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			selectItem(attachedSlotVnum)
			select_item_toGiveID = GetAttachedItemIndex()				
			DeattachObject()
			selectItem(int(attachedSlotVnum))
			itemToGiveIcon = item.GetIconImageFileName()
			self.itemToGiveIcon.LoadImage(str(itemToGiveIcon))		
	def delete_item_toGive(self):
		global select_item_toGiveID	
		select_item_toGiveID = 0
		self.itemToGiveIcon.LoadImage(slot_base)
#SET ITEM TO GIVE AT ALCHEMIST
	def Set_ItemUser_Item(self):
		global Item_User_ID
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			Item_User_ID = GetAttachedItemIndex()				
			DeattachObject()
			selectItem(int(attachedSlotVnum))
			itemUser_Item_Icon = item.GetIconImageFileName()
			self.itemUser_Item_Icon.LoadImage(str(itemUser_Item_Icon))		
	### Book Reader Delete Item ###
	def Delete_ItemUser_Item(self):
		global Item_User_ID	
		Item_User_ID = 0
		self.itemUser_Item_Icon.LoadImage(slot_base)
	def EnableItemUser(self):
		global Item_User_Status
		self.itemUser_BtnOn.Hide()
		self.itemUser_BtnOff.Show()
		try:
			delay = float(self.itemUseDelay.GetText())
		except:
			delay = 0.1
		Item_User_Status = 1
		self.itemUserFunc.XX1(delay)
		self.itemUserFunc.XX2(self.EnableItemUser)		
		if not isConnect():
			self.itemUserFunc.XX1(5)
			return
		self.ItemUser_use()
	def DisableItemUser(self):
		self.itemUser_BtnOn.Show()
		self.itemUser_BtnOff.Hide()
		global Item_User_Status
		self.itemUserFunc.XX1(9999999)
		self.itemUserFunc.XX2(self.DisableItemUser)		
		Item_User_Status = 0
	def ItemUser_use(self):
		global Item_User_ID
		for i in range(player.INVENTORY_PAGE_SIZE*10):
			Book_Reader_Book_Index = player.GetItemIndex(i)
			if Book_Reader_Book_Index == (int(Item_User_ID)):
				useItemFunc(i)
				break	
# SET SKIP ANIM MOUNT
	def Set_Mount_Skip_Anim(self):
		global setMountVnum
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			selectItem(attachedSlotVnum)
			setMountVnum = GetAttachedItemIndex()				
			DeattachObject()
			selectItem(int(attachedSlotVnum))
			iconMount = item.GetIconImageFileName()
			self.iconMount.LoadImage(str(iconMount))
	def Delete_Mount_Skip_Anim(self):
		global setMountVnum	
		setMountVnum = 0
		self.iconMount.LoadImage(slot_base)
# SET SKIP ANIM MOUNT
# SET MOUNT
	def Set_Mount_Farm(self):
		global setMountVnumFarm,setMountVnumFarmSlot
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			selectItem(attachedSlotVnum)
			setMountVnumFarm = GetAttachedItemIndex()				
			setMountVnumFarmSlot = GetAttachedSlotNumber()	
			DeattachObject()
			selectItem(int(attachedSlotVnum))
			iconMountFarm = item.GetIconImageFileName()
			self.iconMountFarm.LoadImage(str(iconMountFarm))
	def Delete_Mount_Farm(self):
		global setMountVnumFarm, setMountVnumFarmSlot
		setMountVnumFarm = 0
		setMountVnumFarmSlot = 0
		self.iconMountFarm.LoadImage(slot_base)
# SET MOUNT
# ALT BAIT
	def Set_Bait_Reader_Item(self):
		global Bait_Alternative_ID
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			selectItem(attachedSlotVnum)
			Bait_Alternative_ID = GetAttachedItemIndex()				
			DeattachObject()
			selectItem(int(attachedSlotVnum))
			bait_Reader_Item_Icon = item.GetIconImageFileName()
			self.bait_Reader_Item_Icon.LoadImage(str(bait_Reader_Item_Icon))
	def Delete_Bait_Reader_Item(self):
		global Bait_Alternative_ID	
		Bait_Alternative_ID = 0
		self.bait_Reader_Item_Icon.LoadImage(slot_base)
# ALT BAIT ################
	def Set_Book_Reader_Item(self):
		global Book_Reader_Book_ID,Book_Reader_Book_Slot
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			selectItem(attachedSlotVnum)
			if item.GetItemType() != 1 and item.GetItemType() != 2:
				Book_Reader_Book_ID = GetAttachedItemIndex()				
				Book_Reader_Book_Slot = GetAttachedSlotNumber()				
				DeattachObject()
				selectItem(int(attachedSlotVnum))
				Book_Reader_Item_Icon = item.GetIconImageFileName()
				self.Book_Reader_Item_Icon.LoadImage(str(Book_Reader_Item_Icon))
			else:
				DeattachObject()
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBook reader: " + lang.STR_CANT_INSERT_ITEM)		
	### Book Reader Delete Item ###
	def Delete_Book_Reader_Item(self):
		global Book_Reader_Book_ID,Book_Reader_Book_Slot
		Book_Reader_Book_ID = 0
		Book_Reader_Book_Slot = 0
		self.Book_Reader_Item_Icon.LoadImage(slot_base)
	def Book_Reader_Status_func(self):
		global Book_Reader_Status
		if Book_Reader_Status == 0:
			Book_Reader_Status = 1
			self.Enable_Book_Reader()
			self.Book_Reader_Status_Button.SetText('Stop book reader')
		else:
			Book_Reader_Status = 0
			self.Book_Reader_Status_Button.SetText('Read books')
			self.Delay_Book_Reader.XX1(9999999)
			
			
	def Enable_Book_Reader(self):	
		global Book_Reader_Status
		if Book_Reader_Status == 1:
			self.Book_Reader_Read()	
		
		self.Delay_Book_Reader.XX1(float(0.1))
		self.Delay_Book_Reader.XX2(self.Enable_Book_Reader)	
	def Book_Reader_Read(self):
		global Book_Reader_Status
		global Book_Reader_Book_ID
		global Book_Reader_Book_Slot
		global exo_id
		global ss_id
		global cc_id
		global zen_id
		global cc_id
		global exo_slot
		global ss_slot
		global cc_slot
		global zen_slot
		SelectedIndex = int(Book_Reader_Book_Slot)
		Slot = SelectedIndex
		if shop.IsOpen():
			for eachSlot in range(player.INVENTORY_PAGE_SIZE * 10):
				getShopItemID = shop.GetItemID(eachSlot)
				if getShopItemID == int(Book_Reader_Book_ID):
					net.SendShopBuyPacket(eachSlot)	
		for i in range(player.INVENTORY_PAGE_SIZE*10):
			Book_Reader_Item_1_Index = player.GetItemIndex(i)
			if Book_Reader_Item_1_Index == (int(exo_id)):
				useItemFunc(i)	
				break
		for i in range(player.INVENTORY_PAGE_SIZE*10):
			Book_Reader_Item_2_Index = player.GetItemIndex(i)
			if Book_Reader_Item_2_Index == (int(cc_id)):
				useItemFunc(i)	
				break			
		for i in range(player.INVENTORY_PAGE_SIZE*10):
			Book_Reader_Book_Index = player.GetItemIndex(i)
			if Book_Reader_Book_Index == (int(Book_Reader_Book_ID)):
				useItemFunc(i)	
				break	
	def ReadQuest(self):
		skillValue = self.SkillValue.GetText()
		try:
			event.SelectAnswer(1, 254)
			event.SelectAnswer(0, int(skillValue))
			event.SelectAnswer(1, 0)
			net.SendQuestInputStringPacket(self.StringEditline.GetText())
			event.SelectAnswer(1, 0)
			event.ClearEventSet(1)
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRead SS bot: " + lang.STR_ERR_OCCURED)
			self.readss_functionstop()
	def readss_func(self, arg):
		if arg=='on':
			self.InstallQuestWindowHook()
			self.readss_function()
		elif arg=='off':
			self.readss_functionstop()
	def readss_function(self):
		global exo_id
		global ss_id
		global cc_id
		global zen_id
		global cc_id
		global exo_slot
		global ss_slot
		global cc_slot
		global zen_slot
	
		
		self.readss_functionx.XX1(0.3)
		self.readss_functionx.XX2(self.readss_function)
	
		if not isConnect():
			self.readss_functionx.XX1(5)
			return
		exo_index = None
		cc_index = None
		zen_index = None
		ss_index = None
		for i in range(player.INVENTORY_PAGE_SIZE * 10):
			item_id = player.GetItemIndex(i)
			if exo_index is None and item_id == int(exo_id):
				exo_index = i
			if cc_index is None and item_id == int(cc_id):
				cc_index = i
			if zen_index is None and item_id == int(zen_id):
				zen_index = i
			if ss_index is None and item_id == int(ss_id):
				ss_index = i
			if (exo_index is not None and 
				cc_index is not None and 
				zen_index is not None and 
				ss_index is not None):
				break
	
		if exo_index is not None:
			useItemFunc(exo_index)
		if cc_index is not None:
			useItemFunc(cc_index)
		if zen_index is not None:
			for _ in range(11):
				useItemFunc(zen_index)
		if ss_index is not None:
			msg('[DEBUG] - Found SS on slot: ' + str(ss_index) + ' with ID: ' + str(ss_id))
			useItemFunc(ss_index)
			self.ReadQuest()
		else:
			msg('[DEBUG] - Not SS found')
	def readss_functionstop(self):
		self.UnHookQuestWindow(0)
		self.readss_functionx.XX1(9999999)
		self.readss_functionx.XX2(self.readss_function)
	def speedFunc1(self):
		global speed_state
		self.speed_state=1
		self.speedFuncx.XX1(float(0.001))
		self.speedFuncx.XX2(self.speedFunc1)
		self.speedBtnStop.Show()
		self.speedBtn.Hide()
		if not isConnect():
			self.speedFuncx.XX1(2)
			return
		if find_string(st_cur_server, "nextworld"):
			keyToPress = "TAB"
		else:
			keyToPress = shiftKey
		if find_string(st_cur_server, "nextworld") and isKeyPressed(shiftKey):
			self.speedFuncx.XX1(1)
			self.speedFuncx.XX2(self.speedFunc1)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hMove speed: On this server use TAB + W/A/S/D.")
			return
		if isKeyPressed(keyToPress):
			chr.SelectInstance(getCharIndex())
			rotation = getCamRot()
			x, y, z = player.GetMainCharacterPosition()
			try:
				xd = int(self.SpeedValue.GetText()) / 2
			except:
				xd = 100
			rad_rotation = rotation * 0.0174533
			xx = xd * math.sin(rad_rotation)
			yy = xd * math.cos(rad_rotation)
			move_x, move_y = 0, 0
			if isKeyPressed('W'):
				try:
					chr.SetLoopMotion(chr.MOTION_WAIT)
				except:
					pass
				chr.SetRotation(-rotation)
				move_x += xx
				move_y -= yy
			if isKeyPressed('S'):
				try:
					chr.SetLoopMotion(chr.MOTION_WAIT)
				except:
					pass
				chr.SetRotation(-rotation)
				move_x -= xx
				move_y += yy
			if isKeyPressed('A'):
				try:
					chr.SetLoopMotion(chr.MOTION_WAIT)
				except:
					pass
				chr.SetRotation(-rotation)
				move_x -= yy
				move_y -= xx
			if isKeyPressed('D'):
				try:
					chr.SetLoopMotion(chr.MOTION_WAIT)
				except:
					pass
				chr.SetRotation(-rotation)
				move_x += yy
				move_y += xx
			new_x = x + move_x
			new_y = y + move_y
			setPixelPos(int(new_x), int(new_y))
	def speedFunc1Stop(self):
		global speed_state
		self.speedFuncx.XX1(9999999)
		self.speedFuncx.XX2(self.speedFunc1)
		self.speed_state=0
		self.speedBtnStop.Hide()
		self.speedBtn.Show()
		if find_string(st_cur_server, "nextworld"):
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hMove speed: On this server use TAB + W/A/S/D.")
			
			
	def wrap_function(self, func_name, func):
		def wrapper(*args):
			global last_arg, hasBioModule
			orange = "|cFFFF8040|H|h"
			if func_name in whatToLog_net:
				if last_arg is None:
					if args and isinstance(args[0], basestring):
						command = args[0]
						for intercept in intercept_commands:
							if intercept.lower() in command.lower():
								for ignore in ignore_commands:
									if ignore.lower() in command.lower():
										return func(*args)
								last_arg = command
								msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBiologist bot: Found possible biologist command: " + str(orange) + str(last_arg))
								self.bioTxt.SetText(str(last_arg))
								break
			elif func_name in whatToLog_biolog:
				hasBioModule = 1
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBiologist bot: Found possible biologist command.")
			elif func_name in whatToLog_biologist:
				hasBioModule = 1
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBiologist bot: Found possible biologist command.")
				# log_message("Intercepted biolog function: " + func_name + " with args: " + str(args))
			return func(*args)
		return wrapper
	
	def apply_wrappers(self, module, module_backup, whatToLog, is_hooked_flag):
		if is_hooked_flag[0]:
			return
		module_backup.clear()
		for func_name in whatToLog:
			if hasattr(module, func_name):
				original_func = getattr(module, func_name)
				module_backup[func_name] = original_func
				wrapped_func = self.wrap_function(func_name, original_func)
				setattr(module, func_name, wrapped_func)
		is_hooked_flag[0] = True
	
	def restore_original_functions(self, module, module_backup, is_hooked_flag):
		if not is_hooked_flag[0]:
			return
		for func_name, original_func in module_backup.items():
			setattr(module, func_name, original_func)
		is_hooked_flag[0] = False
			
			
			
			
			
			
	def cmdHelp(self):
		global last_arg
		if hasattr(net, "SendBiologPacket"):
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBiologist bot: Command found already, no dumping needed, select your settings (use elixir/reset time item) and press on start button.")
			return
		try:
			last_arg = None
			self.apply_wrappers(net, net_backup, whatToLog_net, [is_hooked_net])
			
			if 'biolog' in globals() and hasattr(biolog, "DeliveryItem"):
				self.apply_wrappers(biolog, biolog_backup, whatToLog_biolog, [is_hooked_biolog])			
			if 'biologist' in globals() and hasattr(biologist, "SendProvidesMaterialRequest"):
				self.apply_wrappers(biologist, biolog_backup, whatToLog_biologist, [is_hooked_biolog])
				
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBiologist bot: " + lang.BIO_CMD_INFO1)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBiologist bot: " + lang.BIO_CMD_INFO2)
		except:
			try:
				self.restore_original_functions(net, net_backup, [is_hooked_net])
				if 'biolog' in globals() and hasattr(biolog, "DeliveryItem"):
					self.restore_original_functions(biolog, biolog_backup, [is_hooked_biolog])
					
				if 'biologist' in globals() and hasattr(biologist, "SendProvidesMaterialRequest"):
					self.restore_original_functions(biologist, biolog_backup, [is_hooked_biolog])
					
					
			except:
				pass
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBiologist bot: " + lang.FAIL_BIO_HOOK)
	def stopBio(self):
		global bioBotStatus
		self.StartBioButton.Show()
		self.StopBioButton.Hide()
		self.startBiox.XX1(9999999)
		self.startBiox.XX2(self.stopBio)
		bioBotStatus = 0
		self.UnHookQuestWindow(0)
			
			
			
	def startBio(self):
		global elixirItem, bioItemReset, bioBotStatus, hasBioModule
	
		self.StartBioButton.Hide()
		self.StopBioButton.Show()
		delay = self.get_bio_delay()
	
		self.startBiox.XX1(delay)
		self.startBiox.XX2(self.startBio)
	
		if not isConnect():
			self.startBiox.XX1(5)
			return
	
		if find_string(st_cur_server, "raventor"):
			self.findQuestBioQuest('Chaeg')
			return
	
	
		cmd = self.bioTxt.GetText()
		bioBotStatus = 1
		useElixirStatus = False
		resetTimeStatus = False
		if self.useElixir.checked == 1:
			self.use_item(elixirItem)
			useElixirStatus = True
		if self.resetTime.checked == 1:
			resetTimeStatus = True
			self.use_item(bioItemReset)
	
		if find_string(st_cur_server, "obscure"):
			self.handle_obscure_server()	
			
		if find_string(st_cur_server, "warcry"):
			try:
				import biologmgr
				biologmgr.SendPacketItem(useElixirStatus, resetTimeStatus)
			except:
				pass
				
		if hasattr(net, "SendBiologPacket"):
			net.SendBiologPacket(1, useElixirStatus, resetTimeStatus)
		elif self.newBio.checked == 1:
			self.handle_new_bio_system(cmd)
		else:
			self.handle_classic_bio_system()
	
	def get_bio_delay(self):
		try:
			return float(self.bioDelay.GetText())
		except ValueError:
			return 10
	
	def use_item(self, item_id):
		for InventorySlot in range(player.INVENTORY_PAGE_SIZE * 10):
			if player.GetItemIndex(InventorySlot) == int(item_id):
				useItemFunc(InventorySlot)
				break
	
	def handle_obscure_server(self):
		try:
			import biologmgr
			biologmgr.SendPacketItem()
			event.SelectAnswer(0, 0)
			event.ClearEventSet(1)
		except ImportError:
			pass
	
	def handle_new_bio_system(self, cmd):
		if find_string(st_cur_server, "2009"):
			self.InstallQuestWindowHook()
			event.QuestButtonClick(30)
			event.SelectAnswer(0, 0)
			event.SelectAnswer(0, 254)
			event.ClearEventSet(1)
		elif hasBioModule:
			try:
				biologist.SendProvidesMaterialRequest(0, 0)
			except:
				pass			
			try:
				biolog.DeliveryItem(0, 0, 0)
			except:
				pass
		else:
			SendChatPacket(str(cmd))
	
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBiologist bot: " + lang.BIO_GIVE_SUCCESS)
	
	def handle_classic_bio_system(self):
		bioVID = self.ScanForNPCByRace(20084)
		distance = GetDis(bioVID)
	
		if distance == -1 or distance > 3000:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBiologist bot: " + lang.FAR_BIOLOGIST)
			self.stopBio()
		else:
			self.GiveItem()
			
	def GiveItem(self):
		self.InstallQuestWindowHook()
		bioVID = self.ScanForNPCByRace(20084)
		chr.SelectInstance(bioVID)
		clickPacket(bioVID)
		event.SelectAnswer(1, 0)
		event.SelectAnswer(1, 254)
		event.SelectAnswer(1, 1)
		event.ClearEventSet(1)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBiologist bot: " + lang.BIO_GIVE_SUCCESS)
	def newbio_on(self):
		self.bioCom.Show()
		self.bioText.Show()
		self.bioTxt.Show()
		self.helpCmd.Show()
	def newbio_off(self):
		self.bioCom.Hide()
		self.bioText.Hide()
		self.bioTxt.Hide()
		self.helpCmd.Hide()
	def Set_Switch_Reader_Item(self):
		global elixirItem
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			elixirItem = attachedSlotVnum
			selectItem(attachedSlotVnum)
			selectItem(int(attachedSlotVnum))
			self.switchIcon.LoadImage(str(item.GetIconImageFileName()))
			DeattachObject()
	def Delete_Switch_Reader_Item(self):
		global elixirItem
		elixirItem = 0
		self.switchIcon.LoadImage(slot_base)
	def Set_reset_Item(self):
		global bioItemReset
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			bioItemReset = attachedSlotVnum
			selectItem(attachedSlotVnum)
			selectItem(int(attachedSlotVnum))
			self.resetIcon.LoadImage(str(item.GetIconImageFileName()))
			DeattachObject()
	def Delete_reset_Item(self):
		global bioItemReset
		bioItemReset = 0
		self.resetIcon.LoadImage(slot_base)
	def Exit(self):
		self.uiBioBoard.Hide()
	def onehand_func(self):
		global oneh_state
		try:
			self.oneh_state=1
			self.onehand_funcx.XX1(0.1)
			self.onehand_funcx.XX2(self.onehand_func)
			if not isConnect():
				self.onehand_funcx.XX1(3)
				return
			chr.SetMotionMode(chr.MOTION_MODE_ONEHAND_SWORD)
		except:	
			self.onehand_funcend()
			self.btnoneHand.SetUp()
	def onehand_funcend(self):
		global oneh_state
		self.onehand_funcx.XX1(9999999)
		self.onehand_funcx.XX2(self.onehand_funcend)
		self.oneh_state=0
	def twohand_funcend(self):
		global twoh_state
		self.twohand_funcx.XX1(9999999)
		self.twohand_funcx.XX2(self.twohand_funcend)
		self.twoh_state=0
	def twohand_func(self):
		global twoh_state
		try:
			self.twoh_state=1
			self.twohand_funcx.XX1(1)
			self.twohand_funcx.XX2(self.twohand_func)
			if not isConnect():
				return
			chr.SetMotionMode(chr.MOTION_MODE_TWOHAND_SWORD)
		except:	
			self.twohand_funcend()
			self.btntwoHand.SetUp()
	def refineAlchemy_func(self, arg):
		if arg=='on':
			self.refineAlchemy_function()
		elif arg=='off':
			self.refineAlchemy_functionstop()
	def refineAlchemy_function(self):
		self.refineAlchemy_functionx.XX1(float(0.5))
		self.refineAlchemy_functionx.XX2(self.refineAlchemy_function)
		if not isConnect():
			self.refineAlchemy_functionx.XX1(3)
			return
		try:
			bot = RefineDragonStoneBot()
			bot.start()
		except:
			self.refineAlchemy_functionstop()
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hAlchemy refiner: " + lang.STR_ERR_OCCURED2)
	def refineAlchemy_functionstop(self):
		self.refineAlchemy_functionx.XX1(9999999)
		self.refineAlchemy_functionx.XX2(self.refineAlchemy_functionstop)
	def night_func(self):
		global night_state,day_state
		if not find_string(st_cur_server, "kronius"):
			if isConnect():
				self.night_funcx.XX1(10)
				self.night_funcx.XX2(self.night_func)
				self.night_state=1
				self.day_funcx.XX1(9999999)
				self.day_funcx.XX2(self.day_func)
				self.day_state=0
				background.SetEnvironmentData(1)
			else:
				self.night_funcx.XX1(15)
				self.night_funcx.XX2(self.night_func)
		else:
			background.SetEnvironmentData(1)
			self.night_state=1
			self.day_state=0
	def day_func(self):
		global night_state,day_state
		if not find_string(st_cur_server, "kronius"):
			if isConnect():
				self.day_funcx.XX1(10)
				self.day_funcx.XX2(self.day_func)
				self.day_state=1
				self.night_funcx.XX1(9999999)
				self.night_funcx.XX2(self.night_func)
				self.night_state=0
				background.SetEnvironmentData(0)
			else:
				self.day_funcx.XX1(15)
				self.day_funcx.XX2(self.day_func)
		else:
			background.SetEnvironmentData(0)
			self.night_state=0
			self.day_state=1
	def biologistFunc(self):
		if self.uiBioBoard.IsShow():
			self.uiBioBoard.Hide()
		else:
			self.uiBioBoard.Show()
	def import_module(self, module_name):
		namespace = {}
		file = open_file(extPath + '/%s' % (module_name), 'r+')
		script_code = file.read()
		file.close()
		exec(script_code, namespace)
	def switchbot_func(self):
		global switchbot_instances
		
		x = switchbot()
		x.Board.Show()
		x.Show()
		
		switchbot_instances.append(x)
	def redElixir_func(self):
		global red_e_state
		try:
			self.redElixir_funcx.XX1(5)
			self.redElixir_funcx.XX2(self.redElixir_func)
			if not isConnect():
				return
			red_active = 0
			self.btn_redElixirStop.Show()
			self.btn_redElixir.Hide()
			self.red_e_state=1
			for i in range(player.INVENTORY_PAGE_SIZE * 10):
				if player.GetItemIndex(i) >= 72723 and player.GetItemIndex(i) <= 72726 or player.GetItemIndex(i) >= 39037 and player.GetItemIndex(i) <= 39039 or player.GetItemIndex(i) >= 76021 and player.GetItemIndex(i) <= 76022 or player.GetItemIndex(i) == 72724:
					if player.GetItemMetinSocket(i, 0) == 1:
						red_active = 1
						break
			if red_active == 0:
				for i in range(player.INVENTORY_PAGE_SIZE * 10):
					if player.GetItemIndex(i) >= 72723 and player.GetItemIndex(i) <= 72726 or player.GetItemIndex(i) >= 39037 and player.GetItemIndex(i) <= 39039 or player.GetItemIndex(i) >= 76021 and player.GetItemIndex(i) <= 76022 or player.GetItemIndex(i) == 72724:
						useItemFunc(i)
						break
		except:
			self.redElixir_funcOff()
	def blueElixir_funcOff(self):
		global blue_e_state
		self.blueElixir_funcx.XX1(9999999)
		self.blueElixir_funcx.XX2(self.blueElixir_funcOff)
		self.blue_e_state=0
		self.btn_blueElixirStop.Hide()
		self.btn_blueElixir.Show()
	def blueElixir_func(self):
		global blue_e_state
		try:
			self.blueElixir_funcx.XX1(5)
			self.blueElixir_funcx.XX2(self.blueElixir_func)
			if not isConnect():
				return
			self.blue_e_state=1
			blue_active = 0
			self.btn_blueElixirStop.Show()
			self.btn_blueElixir.Hide()
			for i in range(player.INVENTORY_PAGE_SIZE * 10):
				if player.GetItemIndex(i) >= 72727 and player.GetItemIndex(i) <= 72730 or player.GetItemIndex(i) >= 39040 and player.GetItemIndex(i) <= 39042 or player.GetItemIndex(i) >= 76004 and player.GetItemIndex(i) <= 76005 or player.GetItemIndex(i) == 72728:
					if player.GetItemMetinSocket(i, 0) == 1:
						blue_active = 1
						break
			if blue_active == 0:
				for i in range(player.INVENTORY_PAGE_SIZE * 10):
					if player.GetItemIndex(i) >= 72727 and player.GetItemIndex(i) <= 72730 or player.GetItemIndex(i) >= 39040 and player.GetItemIndex(i) <= 39042 or player.GetItemIndex(i) >= 76004 and player.GetItemIndex(i) <= 76005 or player.GetItemIndex(i) == 72728:
						useItemFunc(i)
						break
		except:
			self.blueElixir_funcOff()
	def redElixir_funcOff(self):
		global red_e_state
		self.redElixir_funcx.XX1(9999999)
		self.redElixir_funcx.XX2(self.redElixir_funcOff)
		self.red_e_state=0
		self.btn_redElixirStop.Hide()
		self.btn_redElixir.Show()
	def red_func(self):
		global red_state
		try:
			self.red_state=1
			self.red_funcx.XX1(float(0.1))
			self.red_funcx.XX2(self.red_func)
			if not isConnect():
				self.red_funcx.XX1(3)
				return
			maxhp = player.GetStatus(player.MAX_HP)
			curHp = player.GetStatus(player.HP)
			if self.textRed.GetText() != "":
				if (float(curHp) / float(maxhp)) * 100 < int(self.textRed.GetText()):
					for i in range(player.INVENTORY_PAGE_SIZE * 10):
						a = player.GetItemIndex(i)
						if a == 27001 or a == 27002 or a == 27003 or a == 27007:
							useItemFunc(i)
							break
				self.redBtn.Hide()
				self.redBtnStop.Show()
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRed pot bot: " + lang.STR_ERR_OCCURED)
			self.red_funcOff()
	def red_funcOff(self):
		global red_state
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRed potting bot disabled.")
		self.red_funcx.XX1(9999999)
		self.red_funcx.XX2(self.red_funcOff)
		self.redBtn.Show()
		self.redBtnStop.Hide()
		self.red_state=0
	def WallhackOn(self):
		global wallhack
		self.btnWallhack.SetText("Stop")
		self.btnWallhack.Down()
		self.wallhackFunc.XX1(0.1)
		self.wallhackFunc.XX2(self.WallhackOn)
		wallhack = 1
		eXLib.DisableCollisions()
	def WallhackOff(self):
		global wallhack
		self.wallhackFunc.XX1(9999999)
		self.wallhackFunc.XX2(self.WallhackOff)
		self.btnWallhack.SetText("Start")
		self.btnWallhack.SetUp()
		wallhack = 0
		eXLib.EnableCollisions()
	def blue_func(self):
		global blue_state
		try:
			self.blue_funcx.XX1(float(0.1))
			self.blue_funcx.XX2(self.blue_func)
			self.blue_state=1
			try:
				perc = int(self.textBlue.GetText())
			except:
				perc = 30
			if not isConnect():
				self.blue_funcx.XX1(5)
				return
			maxMp = player.GetStatus(player.MAX_SP)
			curMp = player.GetStatus(player.SP)
			self.BlueBtn.Hide()
			self.BlueBtnStop.Show()
			if (float(curMp) / float(maxMp)) * 100 < int(perc):
				for i in range(player.INVENTORY_PAGE_SIZE * 10):
					a = player.GetItemIndex(i)
					if a == 27004 or a == 27005 or a == 27006 or a == 27008:
						useItemFunc(i)
						break
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBlue pot bot: " + lang.STR_ERR_OCCURED)
			self.blue_funcOff()
	def blue_funcOff(self):
		global blue_state
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBlue potting bot disabled.")
		self.blue_funcx.XX1(9999999)
		self.blue_funcx.XX2(self.blue_funcOff)
		self.BlueBtn.Show()
		self.BlueBtnStop.Hide()
		self.blue_state=0
	def fish_func(self):
		global fishInstance
		try:
			self.lblFantoma.Hide()
			self.fantomaBtn.Hide()
			fishInstance = FishingBotDialog()
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFailed loading fishing window.")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlease restart client.")
	def metinx_func(self):
		global state_fantom
		self.fantomaBtn.Hide()
		self.fantomaBtnStop.Show()
		self.state_fantom=1
		self.metinx_funcx.XX1(3)
		self.metinx_funcx.XX2(self.metinx_func)
		if not isConnect():
			return
		if player.GetStatus(player.HP) < 1:
			try:
				chr.Revive()
			except:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h\x47\x68\x6f\x73\x74 mode: " + lang.STR_ERR_OCCURED)
				self.metinx_funcOff()
	def metinx_funcOff(self):
		global state_fantom
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h\x47\x68\x6f\x73\x74 mode disabled.")
		self.metinx_funcx.XX1(9999999)
		self.metinx_funcx.XX2(self.metinx_funcOff)
		self.fantomaBtn.Show()
		self.fantomaBtnStop.Hide()
		self.state_fantom=0
	def orSkill(self, skillIndex):
		if find_string(st_cur_server, "King2") or find_string(st_cur_server, "rodnia"):
			try:
				player.ClickSkillSlot(skillIndex)
				if self.useInstant.checked==1:
					try:
						chr.SetLoopMotion(chr.MOTION_WAIT)
					except:
						pass
			except:
				pass
		else:
			try:
				if find_string(st_cur_server, "origins"):
					char_vid = getCharIndex()
					setTarget(char_vid)
				player.ClickSkillSlot(skillIndex)
				if self.useInstant.checked==1:
					try:
						chr.SetLoopMotion(chr.MOTION_WAIT)
					except:
						pass
			except:
				import uiCharacter
				charmenu = uiCharacter.CharacterWindow()
				charmenu.ClickSkillSlot(skillIndex)
				if self.useInstant.checked==1:
					try:
						chr.SetLoopMotion(chr.MOTION_WAIT)
					except:
						pass
				charmenu.Hide()
				del charmenu
	def skillsStop(self):	
		self.skillxUsage.XX1(9999999)
		self.skillxUsage.XX2(self.skillsStop)
	def skillsStart(self):
		global skillsList
		try:
			delay = self.skillbotDelay.GetText()
		except:
			delay = 5
		self.skillxUsage.XX1(int(delay))
		self.skillxUsage.XX2(self.skillsStart)		
		if not isConnect():
			return
		if skillsList:
			self.UseSkilsFunc()
	def skillUsage(self, arg):
		global skillBotState
		if arg == 'off':
			skillBotState = 0
			self.skillsStop()
			self.startSkillbot.SetText('Start')
		elif arg == 'on':
			skillBotState = 1
			self.startSkillbot.SetText('Stop')
			self.skillsStart()
################BUFF#####################
	def goToBuffTarget(self):
		global canWalkTele, buffbotTarget
		if buffbotTarget and HasInstance(buffbotTarget):
			x, y = getPos(buffbotTarget)
			method = self.followMethod.GetCurrentText()
			if method == 'Hybrid':
				canWalkTele = 1
				self.walkTele(int(x), int(y))
			elif method == 'Walking':
				walkFunc(x, y)
			elif method == 'Camera movement':
				self.cameraMove(int(x), int(y))
			elif method == 'Teleporting':
				self.TeleportToDest(int(x), int(y))
	
	def BuffskillsStop(self):
		self.buffBotState.XX1(9999999)
		self.buffBotState.XX2(self.BuffskillsStop)
		self.Debug()
	
	def isCharStuck(self, target_location):
		global curFollowX, curFollowY, lastStuckCheckTime, stuckFollowTimes
		check_interval = 1  # seconds
		threshold_distance = 150
		iterations_to_check = 2
	
		myx, myy, _ = GetMainPos()
		now = app.GetTime()
	
		if curFollowX is None or curFollowY is None or lastStuckCheckTime is None:
			curFollowX, curFollowY = myx, myy
			lastStuckCheckTime = now
			stuckFollowTimes = 0
			return False
	
		if now - lastStuckCheckTime >= check_interval:
			distance_moved = math.sqrt((myx - curFollowX) ** 2 + (myy - curFollowY) ** 2)
			if distance_moved < threshold_distance:
				stuckFollowTimes += 1
				# msg("[\x53\x54\x4d\x4f\x44] |cffFF0000|H|h[BuffBot] Small movement detected (" + str(int(distance_moved)) + " units)")
	
				if stuckFollowTimes >= iterations_to_check:
					stuckFollowTimes = 0
					# msg("[\x53\x54\x4d\x4f\x44] |cffFF0000|H|h[BuffBot] Detected as STUCK! Attempting to unstuck...")
					return True
			else:
				curFollowX, curFollowY = myx, myy
				stuckFollowTimes = 0
	
			lastStuckCheckTime = now
		return False
	
	
	
	def followTarget_func(self):
		global canWalkTele, followTargetStatus, pauseFollow, debugged, isGF
		global canSearchPlayerVids, buffbotTarget,lastKnownTargetPos,notFoundMessageShown
	
		followTargetStatus = 1
		self.followTarget_funcx.XX1(0.1)
		self.followTarget_funcx.XX2(self.followTarget_func)
	
		if not isConnect():
			self.followTarget_funcx.XX1(3)
			return
	
		vid_name = self.followTargetName.GetText()
		if not vid_name:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBuffbot: " + lang.STR_NO_TARGET)
			self.followTarget_funcOff()
			return
	
		self.followTargetBtn.Hide()
		self.followTargetBtnStop.Show()
	
		if pauseFollow:
			if not debugged:
				self.Debug()
				debugged = 1
			return
	
		char_vid = getCharIndex()
		char_x, char_y, _ = player.GetMainCharacterPosition()
	
		target_vid = 0
		if buffbotTarget and HasInstance(buffbotTarget):
			target_vid = buffbotTarget
		else:
			for i in vidsListEnd1:
				name = chr.GetNameByVID(i)
				if name != "None" and name == str(vid_name):
					target_vid = i
	
		if target_vid:
			target_x, target_y = getPos(target_vid)
			lastKnownTargetPos = (target_x, target_y)
			notFoundMessageShown = 0
			
			setTarget(target_vid)
	
			if GetDis(target_vid) >= 1000:
				
				rnd_x = 1000
				rnd_y = 2000
               # rnd_x = 500
			   # rnd_y = 1000
				method = self.followMethod.GetCurrentText()
	
				if method == 'Hybrid':
					canWalkTele = 1
					self.walkTele(int(target_x + rnd_x), int(target_y + rnd_y))
				elif method == 'Walking':
					walkFunc(target_x + rnd_x, target_y + rnd_y)
				elif method == 'Camera movement':
					self.cameraMove(int(target_x + rnd_x), int(target_y + rnd_y))
				elif method == 'Teleporting':
					self.TeleportToDest(int(target_x + rnd_x), int(target_y + rnd_y))
	
				distance = getRandom(1500, 2000)
				angle_offset = getRandom(-10, 10) / 100.0
				dx, dy = target_x - char_x, target_y - char_y
				angle = math.atan2(dy, dx) + angle_offset
				new_x = int(char_x + math.cos(angle) * distance)
				new_y = int(char_y + math.sin(angle) * distance)
				if self.isCharStuck((target_x, target_y)):
					canWalkTele = 1
					if isGF:
						if not eXLib.IsPositionBlocked(int(new_x), int(new_y)):
							if self.unstuckCB.checked == 1:
								self.walkTele(new_x, new_y)
							self.useHorseSkillFunc()
					else:
						if self.unstuckCB.checked == 1:
							self.walkTele(new_x, new_y)
						self.useHorseSkillFunc()
			else:
				if self.followMethod.GetCurrentText() == 'Camera movement':
					if foundx64PythonList:
						onKeyUp(player.DIR_UP)
					else:
						onKeyUp(appKey('UP'))
		else:
			if lastKnownTargetPos:
				px, py, _ = player.GetMainCharacterPosition()
				target_x, target_y = lastKnownTargetPos
		
				# Only go if not already nearby
				if not self.inside_circle(px, py, target_x, target_y, 300):
					method = self.followMethod.GetCurrentText()
		
					if not notFoundMessageShown:
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBuffbot: Target not found, going to last known location...")
						notFoundMessageShown = True
		
					if method == 'Hybrid':
						canWalkTele = 1
						self.walkTele(int(target_x), int(target_y))
					elif method == 'Walking':
						walkFunc(target_x, target_y)
					elif method == 'Camera movement':
						self.cameraMove(int(target_x), int(target_y))
					elif method == 'Teleporting':
						self.TeleportToDest(int(target_x), int(target_y))
					
					distance = getRandom(50, 1000)
					angle_offset = getRandom(-10, 10) / 100.0
					dx, dy = target_x - char_x, target_y - char_y
					angle = math.atan2(dy, dx) + angle_offset
					new_x = int(char_x + math.cos(angle) * distance)
					new_y = int(char_y + math.sin(angle) * distance)
	
					if self.isCharStuck((target_x, target_y)):
						canWalkTele = 1
						if isGF:
							if not eXLib.IsPositionBlocked(int(new_x), int(new_y)):
								if self.unstuckCB.checked == 1:
									self.walkTele(new_x, new_y)
								self.useHorseSkillFunc()
						else:
							if self.unstuckCB.checked == 1:
								self.walkTele(new_x, new_y)
							self.useHorseSkillFunc()
	
	
	def followTarget_funcOff(self):
		global canWalkTele, followTargetStatus, debugged, buffbotTarget
		followTargetStatus = 0
		self.followTarget_funcx.XX1(9999999)
		self.followTarget_funcx.XX2(self.followTarget_funcOff)
		self.followTargetBtn.Show()
		self.followTargetBtnStop.Hide()
		canWalkTele = 0
		debugged = 0
		buffbotTarget = 0
		self.Debug()
	
	def BuffskillsStart(self):
		global skillsBuffList, buffbotTarget, vidsListEnd1, pauseBuffbot, isGF, canSearchPlayerVids
	
		try:
			delay = int(self.buffBotDelayTxt.GetText())
		except:
			delay = 3
	
		self.buffBotState.XX1(delay)
		self.buffBotState.XX2(self.BuffskillsStart)
	
		if not isConnect() or pauseBuffbot:
			return
	
		vid_name = self.followTargetName.GetText()
		char_vid = getCharIndex()
		char_x, char_y, _ = player.GetMainCharacterPosition()
		target_vid = 0
	
		if buffbotTarget and HasInstance(buffbotTarget):
			target_vid = buffbotTarget
		else:
			for i in vidsListEnd1:
				name = chr.GetNameByVID(i)
				if name != "None" and name == str(vid_name):
					target_vid = i
	
		if target_vid and HasInstance(target_vid):
			buffbotTarget = target_vid
			if GetDis(target_vid) <= 1000:
				if skillsBuffList:
					setTarget(target_vid)
					if self.useInstant.checked == 0:
						if len(skillsBuffList) == 3:
							callFnc(1, self.UseBuffSkilsFunc)
							callFnc(3, self.UseBuffSkilsFunc)
							callFnc(5, self.UseBuffSkilsFunc)
						elif len(skillsBuffList) == 2:
							callFnc(1, self.UseBuffSkilsFunc)
							callFnc(3, self.UseBuffSkilsFunc)
						elif len(skillsBuffList) == 1:
							callFnc(0, self.UseBuffSkilsFunc)
					else:
						self.UseBuffSkilsFunc()
			else:
				self.goToBuffTarget()
	
	def BuffBotUsage(self, arg):
		global skillsBuffList, BuffBotState, buffbotTarget, vidsListEnd1, isGF, canSearchPlayerVids
		vid = self.followTargetName.GetText()
	
		if arg == 'off':
			BuffBotState = 0
			self.BuffskillsStop()
			self.startBuffbot.SetText('Start')
			self.startBuffbot.SetUp()
		elif arg == 'on':
			if not vid:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hBuffbot: " + lang.NO_BUFF_TARGET)
				self.BuffBotUsage('off')
				self.startBuffbot.SetUp()
				return
	
			char_vid = getCharIndex()
			char_x, char_y, _ = player.GetMainCharacterPosition()
	
			for i in vidsListEnd1:
				name = chr.GetNameByVID(i)
				if name != "None" and name == str(vid):
					setTarget(i)
					buffbotTarget = i
	
			BuffBotState = 1
			self.startBuffbot.SetText('Stop')
			self.BuffskillsStart()
	
	def SetBuffSkill(self, arg):
		global skillsBuffList
		if skillsBuffList is None:
			skillsBuffList = []
	
		if arg not in skillsBuffList:
			skillsBuffList.append(arg)
			try:
				skill_name = skill.GetSkillName(player.GetSkillIndex(arg))
			except:
				skill_name = "Skill " + str(arg)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hSkillbot: " + str(skill_name) + " " + lang.SKILL_ADDED)
	
	def SetBuffSkillOFF(self, arg):
		global skillsBuffList
		if skillsBuffList is None:
			skillsBuffList = []
	
		if arg in skillsBuffList:
			skillsBuffList.remove(arg)
			try:
				skill_name = skill.GetSkillName(player.GetSkillIndex(arg))
			except:
				skill_name = "Skill " + str(arg)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hSkillbot: " + str(skill_name) + " " + lang.SKILL_REMOVED)
	
	def buffSkill(self, skill_id):
		global skillsBuffList
		try:
			player.ClickSkillSlot(skill_id)
			if hasattr(self.useInstant, "checked") and self.useInstant.checked == 1:
				my_vid = getCharIndex()
				chr.SelectInstance(my_vid)
				chr.SetLoopMotion(chr.MOTION_WAIT)
		except:
			pass
	
	def UseBuffSkilsFunc(self):
		global skillsBuffList, buffbotTarget
		delay = 0.5
		skill_used = False
	
		for skill_id in skillsBuffList:
			if player.IsMountingHorse() and not skill_used:
				if self.pauseAttack.checked == 1:
					unMountAndMount(1)
				else:
					unMountAndMount(0)
				skill_used = True
			if buffbotTarget:
				setTarget(buffbotTarget)
				self.buffSkill(skill_id)
				skill_used = True
	
################BUFF#####################
	def SetSkill(self, arg):
		global skillsList
		try:
			if skillsList is None:
				skillsList = []
			if arg not in skillsList:
				skillsList.append(arg)
				try:
					xxx = skill.GetSkillName(player.GetSkillIndex(arg))
				except:
					xxx = "Skill " + str(arg)
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hSkillbot: " + str(xxx) + " " + lang.SKILL_ADDED)
			# msg(skillsList)
		except:
			pass
	def SetSkillOFF(self, arg):
		global skillsList
		try:
			if skillsList is None:
				skillsList = []
			if arg in skillsList:
				skillsList.remove(arg)
				try:
					xxx = skill.GetSkillName(player.GetSkillIndex(arg))
				except:
					xxx = "Skill " + str(arg)
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hSkillbot: " + str(xxx) + " " + lang.SKILL_REMOVED)
		except:
			pass
	def UseSkilsFunc(self):
		global skillsList,vidsListEnd1,pauseSkill
		if pauseSkill:
			return
		if isConnect():
			skill_used = False
			for skillx in skillsList:
				if hasattr(skill, 'CanUseSkill'):
					canUseSkill = skill.CanUseSkill(skillx)
				else:
					canUseSkill = 1
				
				if int(player.IsSkillCoolTime(skillx)) == 0 and int(player.IsSkillActive(skillx)) == 0 and canUseSkill:
					if player.IsMountingHorse() and not skill_used:
						if self.pauseAttack.checked==1:
							unMountAndMount(1)
						else:
							unMountAndMount(0)
						skill_used = True
					callFnc(1, self.orSkill, int(skillx))
					skill_used = True
	def TeleUp_func(self):
		try:
			val = int(self.telDis.GetText()) * 10
		except:
			val = 100
		chr.SelectInstance(getCharIndex())
		rotation = int(str(int(getCamRot())))
		x, y, z = player.GetMainCharacterPosition()
		self.Debug()
		chr.SetRotation(-getCamRot())
		xx = int(str(int(val * math.sin(rotation * 0.017453))))
		yy = int(str(int(val * math.cos(rotation * 0.017453))))
		x = int(str(int(x)))
		y = int(str(int(y)))
		try:
			chr.SetLoopMotion(chr.MOTION_WAIT)
		except:
			pass
		setPixelPos(int(x + xx), int(y - yy))
		if isKeyPress('S'):
			setPixelPos(int(x - xx), int(y + yy))
		if isKeyPress('A'):
			setPixelPos(int(x - yy), int(y - xx))
		if isKeyPress('D'):
			setPixelPos(int(x + yy), int(y + xx))
	def TeleLeft_func(self):
		try:
			val = int(self.telDis.GetText()) * 10
		except:
			val = 100
		chr.SelectInstance(getCharIndex())
		rotation = int(str(int(getCamRot())))
		x, y, z = player.GetMainCharacterPosition()
		self.Debug()
		xx = int(str(int(val * math.sin(rotation * 0.017453))))
		yy = int(str(int(val * math.cos(rotation * 0.017453))))
		x = int(str(int(x)))
		y = int(str(int(y)))
		try:
			chr.SetLoopMotion(chr.MOTION_WAIT)
		except:
			pass
		setPixelPos(int(x - yy), int(y - xx))
	def TeleRight_func(self):
		try:
			val = int(self.telDis.GetText()) * 10
		except:
			val = 100
		chr.SelectInstance(getCharIndex())
		rotation = int(str(int(getCamRot())))
		x, y, z = player.GetMainCharacterPosition()
		self.Debug()
		xx = int(str(int(val * math.sin(rotation * 0.017453))))
		yy = int(str(int(val * math.cos(rotation * 0.017453))))
		x = int(str(int(x)))
		y = int(str(int(y)))
		try:
			chr.SetLoopMotion(chr.MOTION_WAIT)
		except:
			pass
		setPixelPos(int(x + yy), int(y + xx))
	def TeleDown_func(self):
		try:
			val = int(self.telDis.GetText()) * 10
		except:
			val = 100
		chr.SelectInstance(getCharIndex())
		rotation = int(str(int(getCamRot())))
		x, y, z = player.GetMainCharacterPosition()
		self.Debug()
		xx = int(str(int(val * math.sin(rotation * 0.017453))))
		yy = int(str(int(val * math.cos(rotation * 0.017453))))
		x = int(str(int(x)))
		y = int(str(int(y)))
		try:
			chr.SetLoopMotion(chr.MOTION_WAIT)
		except:
			pass
		setPixelPos(int(x - xx), int(y + yy))
	def clearItemsFunc(self):
		global Items_VNUM,Items_Slots,UseItems_Slot
		UseItems_Slot = 0
		for x in range(999):
			self.gives.ClearSlot(x)
			self.gives.RefreshSlot()
		Items_VNUM = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
		Items_Slots = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
	def SetItemSlot(self, renderingSlotNumber, ItemIndex, ItemCount = 0):
		if 0 == ItemIndex or None == ItemIndex:
			wndMgr.ClearSlot(self.hWnd, renderingSlotNumber)
			return
		selectItem(ItemIndex)
		itemIcon = item.GetIconImage()
		selectItem(ItemIndex)
		(width, height) = item.GetItemSize()
		wndMgr.SetSlot(self.hWnd, renderingSlotNumber, ItemIndex, width, height, itemIcon)
		wndMgr.SetSlotCount(self.hWnd, renderingSlotNumber, ItemCount)
	def SelectEmptySlot(self, slot):
		global Items_VNUM,Items_Slots,UseItems_Slot,Items_VNUM
		if isAttached():
			attachedSlotType = GetAttachedType()
			attachedSlotPos = GetAttachedSlotNumber()
			attachedSlotVnum = GetAttachedItemIndex()
			selectItem(int(attachedSlotVnum))
			Items_VNUM[UseItems_Slot] = (attachedSlotVnum)
			Items_Slots[UseItems_Slot] = (slot)
			self.itemlist[slot] = attachedSlotPos
			UseItems_Slot += 1
			self.gives.SetItemSlot(slot, attachedSlotVnum)
			DeattachObject()
			self.gives.RefreshSlot()
	def OverInItem(self, slot):
		self.toolTip1.SetInventoryItem(self.itemlist[slot])
	def OverOutItem(self):
		self.toolTip1.HideToolTip()
	def OverOutItem1(self):
		if self.toolTip2:
			self.toolTip2.HideToolTip()
	def closeMapTel(self):
		self.newMap.Hide()
		self.closeRadarWindow()
	def CloseDopy(self):
		self.itemUseWindow.Hide()
	def CloseItemSell(self):
		self.itemsellWindow.Hide()
	def keepChAttachedItemUserFuncOff(self):
		self.keepChAttachedItemUserxFunc.XX1(9999999)
		self.keepChAttachedItemUserxFunc.XX2(self.keepChAttachedItemUserFuncOff)
	def keepChAttachedItemUserFuncOn(self):
		self.keepChAttachedItemUserxFunc.XX1(0.01)
		self.keepChAttachedItemUserxFunc.XX2(self.keepChAttachedItemUserFuncOn)
		try:
			if self.metin2_window.IsShow():
				if self.chChangerWindow.IsShow():
					pos = self.metin2_window.GetGlobalPosition()
					pos2 = self.chChangerWindow.GetGlobalPosition()
					self.itemUseWindow.SetPosition(pos[0]+self.metin2_window.GetWidth(),pos2[1] + self.chChangerWindow.GetHeight())
				else:
					pos = self.metin2_window.GetGlobalPosition()
					self.itemUseWindow.SetPosition(pos[0]+self.metin2_window.GetWidth(),pos[1])
			else:
				self.keepChAttachedItemUserFuncOff()
		except:
			self.keepChAttachedItemUserFuncOff()
	def useitem_func(self):
		if self.itemUseWindow.IsShow():
			self.itemUseWindow.Hide()
			self.keepChAttachedItemUserFuncOff()
		else:
			self.keepChAttachedItemUserFuncOn()
			self.itemUseWindow.Show()
	def keepChAttachedMapFuncOff(self):
		self.keepChAttachedMapxFunc.XX1(9999999)
		self.keepChAttachedMapxFunc.XX2(self.keepChAttachedMapFuncOff)
	def keepChAttachedMapFuncFuncOn(self):
		try:
			if self.metin2_window.IsShow():
				self.keepChAttachedMapxFunc.XX1(0.01)
				self.keepChAttachedMapxFunc.XX2(self.keepChAttachedMapFuncFuncOn)
				pos = self.metin2_window.GetGlobalPosition()
				self.newMap.SetPosition(pos[0] + (self.metin2_window.GetWidth() - self.metin2_window.GetWidth() - self.newMap.GetWidth()),pos[1])
			else:
				self.keepChAttachedMapFuncOff()
		except:
			self.keepChAttachedMapFuncOff()
	def teleport_func2(self, arg):
		pos = self.metin2_window.GetGlobalPosition()
		self.newMap.SetPosition(pos[0] + (self.metin2_window.GetWidth() - self.metin2_window.GetWidth() - self.newMap.GetWidth()),pos[1])
		if arg=='on':
			self.newMap.Show()
			self.loadTeleMap()
			self.keepChAttachedMapFuncFuncOn()
		elif arg=='off':
			self.newMap.Hide()
			self.keepChAttachedMapFuncOff()
	def setMega(self, arg):
		global megaConfirm
		if arg:
			megaConfirm = 1
		else:
			self.megaCb.OnToggleUp()
			megaConfirm = 0
		self.askMega.Close()
		self.askMega = None
	def cape_func(self):
		global capes_state,movement,pauseMobber,megaConfirm
		try:
			mobbert = int(self.mobberSec.GetText())
		except:
			mobbert = 5
		self.capes_state=1
		self.cape_funcx.XX1(mobbert)
		self.cape_funcx.XX2(self.cape_func)
		if not isConnect():
			return
		try:
			Mobber_ID = self.mobberId.GetText()
			self.btnCape.Hide()
			self.btnCapeStop.Show()
			curHP=player.GetStatus(player.HP)
			maxHP=player.GetStatus(player.MAX_HP)
			myHP = self.hpLower.GetText()
			if pauseMobber:
				return
			if 0 < (float(curHP) / float(maxHP) * 100) > int(myHP):
				for i in range(player.INVENTORY_PAGE_SIZE*10):
					Mobberitemx = player.GetItemIndex(i)
					if Mobberitemx == (int(Mobber_ID)):
						useItemFunc(i)
						break
				if self.megaCb.checked==1 and not megaConfirm:
					try:
						line2 = 0
						try:
							dialog = QuestionDialog2()
							line2 = 1
						except:
							if hasattr(uiCommon, 'QuestionDialog2'):
								dialog = uiCommon.QuestionDialog2()
								line2 = 1
							else:
								dialog = QuestionDialog()
						self.askMega = dialog
						if line2:
							self.askMega.SetText1(lang.RANGED_MOBBER_INFO1)
							self.askMega.SetText2(lang.RANGED_MOBBER_INFO2)
						else:
							self.askMega.SetText(lang.RANGED_MOBBER_INFO3)
						self.askMega.SetAcceptEvent(lambda: self.setMega(1))
						self.askMega.SetCancelEvent(lambda: self.setMega(0))
						self.askMega.Open()
						return
					except:
						self.setMega(0)
				if self.megaCb.checked==1:
					self.cape_funcx.XX1(float(0.2))
					myVid = getCharIndex()
					capesId = 0
					for i in range(player.INVENTORY_PAGE_SIZE*10):
						Mobberitemx = player.GetItemIndex(i)
						if Mobberitemx == (int(Mobber_ID)):
							capesId = i
							useItemFunc(i)
							break
					a=1
					while a:
						x, y, z = player.GetMainCharacterPosition()
						if movement == 0:
							chr.SelectInstance(myVid)
							setPixelPos(int(x) - 1200, int(y), int(z))
							onKeyDown(appKey('UP'))
							if foundx64PythonList:
								onKeyUp(player.DIR_UP)	
							else:
								onKeyUp(appKey('UP'))
							useItemFunc(capesId)
							useItemFunc(capesId)
							a = 0
							movement = movement + 1
							continue
						if movement == 1:
							chr.SelectInstance(myVid)
							setPixelPos(int(x) - 1200, int(y), int(z))
							onKeyDown(appKey('UP'))
							if foundx64PythonList:
								onKeyUp(player.DIR_UP)	
							else:
								onKeyUp(appKey('UP'))
							useItemFunc(capesId)
							useItemFunc(capesId)
							a = 0
							movement = movement + 1
							continue
						if movement == 2:
							chr.SelectInstance(myVid)
							setPixelPos(int(x) + 1200, int(y), int(z))
							onKeyDown(appKey('UP'))
							if foundx64PythonList:
								onKeyUp(player.DIR_UP)	
							else:
								onKeyUp(appKey('UP'))
							useItemFunc(capesId)
							useItemFunc(capesId)
							a = 0
							movement = movement + 1
							continue
						if movement == 3:
							chr.SelectInstance(myVid)
							setPixelPos(int(x) + 1200, int(y), int(z))
							onKeyDown(appKey('UP'))
							if foundx64PythonList:
								onKeyUp(player.DIR_UP)	
							else:
								onKeyUp(appKey('UP'))
							useItemFunc(capesId)
							useItemFunc(capesId)
							a = 0
							movement = movement + 1
							continue
						if movement == 4:
							chr.SelectInstance(myVid)
							setPixelPos(int(x), int(y) - 1200, int(z))
							onKeyDown(appKey('UP'))
							if foundx64PythonList:
								onKeyUp(player.DIR_UP)	
							else:
								onKeyUp(appKey('UP'))
							useItemFunc(capesId)
							useItemFunc(capesId)
							a = 0
							movement = movement + 1
							continue
						if movement == 5:
							chr.SelectInstance(myVid)
							setPixelPos(int(x), int(y) - 1200, int(z))
							onKeyDown(appKey('UP'))
							if foundx64PythonList:
								onKeyUp(player.DIR_UP)	
							else:
								onKeyUp(appKey('UP'))
							useItemFunc(capesId)
							useItemFunc(capesId)
							a = 0
							movement = movement + 1
							continue
						if movement == 6:
							chr.SelectInstance(myVid)
							setPixelPos(int(x), int(y) + 1200, int(z))
							onKeyDown(appKey('UP'))
							if foundx64PythonList:
								onKeyUp(player.DIR_UP)	
							else:
								onKeyUp(appKey('UP'))
							useItemFunc(capesId)
							useItemFunc(capesId)
							a = 0
							movement = movement + 1
							continue
						if movement == 7:
							chr.SelectInstance(myVid)
							setPixelPos(int(x), int(y) + 1200, int(z))
							onKeyDown(appKey('UP'))
							if foundx64PythonList:
								onKeyUp(player.DIR_UP)	
							else:
								onKeyUp(appKey('UP'))
							useItemFunc(capesId)
							useItemFunc(capesId)
							a = 0
							movement = movement + 1
							continue
						if movement == 8:
							chr.SelectInstance(myVid)
							setPixelPos(int(x) + 1200, int(y), int(z))
							onKeyDown(appKey('UP'))
							if foundx64PythonList:
								onKeyUp(player.DIR_UP)	
							else:
								onKeyUp(appKey('UP'))
							useItemFunc(capesId)
							useItemFunc(capesId)
							a = 0
							movement = movement + 1
							continue
						if movement == 9:
							chr.SelectInstance(myVid)
							setPixelPos(int(x) + 1200, int(y), int(z))
							onKeyDown(appKey('UP'))
							if foundx64PythonList:
								onKeyUp(player.DIR_UP)	
							else:
								onKeyUp(appKey('UP'))
							useItemFunc(capesId)
							useItemFunc(capesId)
							a = 0
							movement = movement + 1
							continue
						if movement == 10:
							chr.SelectInstance(myVid)
							setPixelPos(int(x) - 1200, int(y), int(z))
							onKeyDown(appKey('UP'))
							if foundx64PythonList:
								onKeyUp(player.DIR_UP)	
							else:
								onKeyUp(appKey('UP'))
							useItemFunc(capesId)
							useItemFunc(capesId)
							a = 0
							movement = movement + 1
							continue
						if movement == 11:
							chr.SelectInstance(myVid)
							setPixelPos(int(x) - 1200, int(y), int(z))
							onKeyDown(appKey('UP'))
							if foundx64PythonList:
								onKeyUp(player.DIR_UP)	
							else:
								onKeyUp(appKey('UP'))
							useItemFunc(capesId)
							useItemFunc(capesId)
							a = 0
							movement = movement + 1
							continue
						if movement == 12:
							chr.SelectInstance(myVid)
							setPixelPos(int(x), int(y) + 1200, int(z))
							onKeyDown(appKey('UP'))
							if foundx64PythonList:
								onKeyUp(player.DIR_UP)	
							else:
								onKeyUp(appKey('UP'))
							useItemFunc(capesId)
							useItemFunc(capesId)
							a = 0
							movement = movement + 1
							continue
						if movement == 13:
							chr.SelectInstance(myVid)
							setPixelPos(int(x), int(y) + 1200, int(z))
							onKeyDown(appKey('UP'))
							if foundx64PythonList:
								onKeyUp(player.DIR_UP)	
							else:
								onKeyUp(appKey('UP'))
							useItemFunc(capesId)
							useItemFunc(capesId)
							a = 0
							movement = movement + 1
							continue
						if movement == 14:
							chr.SelectInstance(myVid)
							setPixelPos(int(x), int(y) - 1200, int(z))
							onKeyDown(appKey('UP'))
							if foundx64PythonList:
								onKeyUp(player.DIR_UP)	
							else:
								onKeyUp(appKey('UP'))
							useItemFunc(capesId)
							useItemFunc(capesId)
							a = 0
							movement = movement + 1
							continue
						if movement == 15:
							chr.SelectInstance(myVid)
							setPixelPos(int(x), int(y) - 1200, int(z))
							onKeyDown(appKey('UP'))
							if foundx64PythonList:
								onKeyUp(player.DIR_UP)	
							else:
								onKeyUp(appKey('UP'))
							useItemFunc(capesId)
							useItemFunc(capesId)
							a = 0
							movement = 0
							self.cape_funcx.XX1(int(mobbert))
							continue
				if find_string(st_cur_server, "Destiny"):
					try:
						import constInfo
						constInfo.MMMATII = 0
					except:
						pass
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hMobber: " + lang.STR_ERR_MSG)
			self.cape_funcOff()
	def read_cape_id(self):
		if player.GetItemIndex(0):
			ItemValue = player.GetItemIndex(0)
			selectItem(ItemValue)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.STR_ITEM_READED_OK + " |cFFC0C0C0|H|h" + str(item.GetItemName()) + "|cffFFFF00|H|h " + lang.STR_ADD_BOSSID + " |cFFC0C0C0|H|h" + str(ItemValue))
			self.mobberId.SetText(str(ItemValue))
		else:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.STR_NOT_IN_FIRST_SLOT)
	def doNotAttackInfo(self):
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.NO_ATTACK_INFO)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.NO_ATTACK_INFO2)
	def disableCHNothing(self):
		global changeCHNothingState
		changeCHNothingState = 0
	def enableCHNothing(self):	
		global changeCHNothingState
		changeCHNothingState = 1
	def disableCHRoute(self):
		global changeCHRouteState
		changeCHRouteState = 0
	def enableCHRoute(self):	
		global changeCHRouteState
		changeCHRouteState = 1
	def disableRangeMobber(self):
		global rangedMobber
		rangedMobber = 0
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRanged mobber disabled.")			
	def enableRangeMobber(self):	
		global rangedMobber
		rangedMobber = 1	
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRanged mobber enabled.")
	def cape_funcOff(self):
		global capes_state,movement,megaConfirm
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCapes using disabled.")
		self.cape_funcx.XX1(9999999)
		self.cape_funcx.XX2(self.cape_funcOff)
		self.btnCape.Show()
		self.btnCapeStop.Hide()
		self.capes_state=0
		a = 0
		movement = 0
		megaConfirm = 0
	def useItem(self, itemID):
		slot = 0
		for i in range(player.INVENTORY_PAGE_SIZE * 10):
			if player.GetItemIndex(i) == itemID:
				slot = i
		if slot:
			useItemFunc(slot)
		
	def hotkeyTele_func(self):
		global hotkey_state
		self.enablehotKeyTeleportStop.Show()
		self.enablehotKeyTeleport.Hide()
		self.hotkeyTele_funcx.XX1(0.01)
		self.hotkeyTele_funcx.XX2(self.hotkeyTele_func)
		if not isConnect():
			self.hotkeyTele_funcx.XX1(3)
			return
		self.hotkey_state=1
		if isKeyPress('UP'):
			self.TeleUp_func()
		if isKeyPress('DOWN'):
			self.TeleDown_func()
		if isKeyPress('LEFT'):
			self.TeleLeft_func()
		if isKeyPress('RIGHT'):
			self.TeleRight_func()
	def hotkeyTele_funcend(self):
		global hotkey_state
		self.hotkeyTele_funcx.XX1(9999999)
		self.hotkeyTele_funcx.XX2(self.hotkeyTele_funcend)
		self.hotkey_state=0
		self.enablehotKeyTeleportStop.Hide()
		self.enablehotKeyTeleport.Show()
	def checkGoCh(self):
		global tempCurChannel, tempNextChannel,canChangeCH,farmEnable
		if not isConnect():
			return
		if foundx64PythonList:
			from pygame.net import GetServerInfo
			serverCH = GetServerInfo()
		else:
			serverCH = net.GetServerInfo()
		eventHandler.remove('changeChSequence')
		try:
			if farmEnable:
				self.farmingx2Func.XX1(10)
				self.farmingx2Func.XX2(self.farmingFunc2)
			channel_number = None
			found_digit = False
			for char in serverCH:
				if char.isdigit():
					found_digit = True
					if channel_number is None:
						channel_number = int(char)
					else:
						channel_number = channel_number * 10 + int(char)
				elif found_digit:
					break
			if channel_number is not None:
				current_channel = channel_number
				if tempNextChannel + 1 > len(channels):
					tempNextChannel = 1
				else:
					tempNextChannel += 1
				if tempNextChannel == 1:
					current_channel = 1
					tempCurChannel = current_channel
				else:
					current_channel = tempNextChannel - 1
					tempCurChannel = current_channel
				create_log("Changing current channel (" + str(tempCurChannel) + ") to channel: " + str(tempNextChannel))
				self.ChangeChannelById(tempNextChannel)
				canChangeCH = 0
		except:
			pass
	def quitAllFunc(self):
		dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'quit'
		non_detect = open_file(dirPl, "w")
		non_detect.write('1')
		non_detect.close()
	def notifyLog(self, arg):
		dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'detection'
		non_detect = open_file(dirPl, "w")
		non_detect.write(str(arg))
		non_detect.close()
		
		
	def isAdmin(self, i):
		global isGF
		try:
			name = chr.GetNameByVID(i)
			if not hasattr(chr, 'IsGameMaster') or find_string(st_cur_server, "SoW2") or find_string(st_cur_server, "Secret of World") or find_string(st_cur_server, "Sancy") or find_string(st_cur_server, "Zemia") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "velia") or find_string(st_cur_server, "landofheroes") or find_string(st_cur_server, "atheria") or isGF or find_string(st_cur_server, "lucerna") or find_string(st_cur_server, "veshia") or find_string(st_cur_server, "rhodium") or find_string(st_cur_server, "next2play"):
				if (chr.INSTANCE_TYPE_PLAYER == chr.GetInstanceType(i) and name[0] == "[") and chr.GetNameByVID(i) != getcharName():
					return True
			else:
	
				if chr.IsGameMaster(i) and chr.GetNameByVID(i) != getcharName():
					return True
		except:
			return False
	def hasTradedItems(self):
		for i in range(45):
			tradeItems = exchange.GetItemCountFromSelf(i)
			if tradeItems >= 1:
				return True
		return False
	def hasTradedYang(self):
		yang = exchange.GetElkFromSelf()
		if yang >= 1:
			return True
		return False
		
	def getPlayerInfo(self):
		global farmEnable, fishbotState, antiban_state, panicMode, pauseFishbot, pauseFarmbot, playerList, gmList
		global energyBotState, pauseBuffbot, BuffBotState, globalTimeRan, vidsListEnd1
		global radarEntities, bossIds, boss_list
		global globalFarmingKilled, globalFarmingStartTime
		global expSessionTotal, initialEXP
		global lastYang, initialYang
	
		try:
			self.getPlayerxInfo.XX1(0.5)
			self.getPlayerxInfo.XX2(self.getPlayerInfo)
	
			dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'charStatus_' + str(pid)
			if not isConnect():
				try:
					fr = open_file(dirPl, "r+")
					lines = fr.readlines()
					fr.close()
	
					updated_lines = []
					for line in lines:
						if line.startswith("Connected"):
							updated_lines.append("Connected: 0\n")
						elif line.startswith("Status"):
							updated_lines.append("Status: Offline\n")
						elif line.startswith("Server"):
							updated_lines.append("Server: " + st_cur_server + "\n")
						elif line.startswith("Race"):
							updated_lines.append("Race: -1\n")
						elif line.startswith("Name"):
							updated_lines.append("Name: \n")
						elif line.startswith("Level"):
							updated_lines.append("Level: \n")
						elif line.startswith("Yang"):
							updated_lines.append("Yang: 0\n")
						elif line.startswith("Mapname"):
							updated_lines.append("Mapname: None\n")
						elif line.startswith("HP"):
							updated_lines.append("HP: 0\n")
						elif line.startswith("MP"):
							updated_lines.append("MP: 0\n")
						elif line.startswith("EXP"):
							updated_lines.append("EXP: 0\n")
						elif line.startswith("Position"):
							updated_lines.append("Position: (0, 0)\n")
						elif line.startswith("Players_around"):
							updated_lines.append("Players_around: 0\n")
						elif line.startswith("GMs_around"):
							updated_lines.append("GMs_around: 0\n")
						else:
							updated_lines.append(line)
	
					fw = open_file(dirPl, "w")
					fw.writelines(updated_lines)
					fw.close()
	
				except:
					fw = open_file(dirPl, "w")
					fw.write("Server: " + st_cur_server + "\n")
					fw.write("Connected: 0\n")
					fw.write("Status: Offline\n")
					fw.write("Name: Unknown\n")
					fw.write("Race: -1\n")
					fw.write("Name:\n")
					fw.write("Level:\n")
					fw.write("Yang: 0\n")
					fw.write("Mapname: None\n")
					fw.write("HP: 0\n")
					fw.write("MP: 0\n")
					fw.write("EXP: 0\n")
					fw.write("Position: (0, 0)\n")
					fw.write("Players_around: 0\n")
					fw.write("GMs_around: 0\n")
					fw.close()
	
				self.getPlayerxInfo.XX1(5)
				return
	
			o = getCharIndex()
			charName = getcharName()
			xx, yy, _ = player.GetMainCharacterPosition()
			xx = xx / 100
			yy = yy / 100
			level = player.GetStatus(player.LEVEL)
			maxhp = player.GetStatus(player.MAX_HP)
			curHp = player.GetStatus(player.HP)
			totalHP = round((float(curHp) / float(maxhp)) * 100, 1)
	
			maxMP = player.GetStatus(player.MAX_SP)
			curMP = player.GetStatus(player.SP)
			totalMP = round((float(curMP) / float(maxMP)) * 100, 1)
	
			curEXP = int(player.GetStatus(player.EXP))
			nextEXP = int(player.GetStatus(player.NEXT_EXP))
			totalEXP = "%.2f" % ((float(curEXP) / float(nextEXP)) * 100)
	
			try:
				guildName = guild.GetGuildName()
				if not guildName:
					guildName = "No guild"
			except:
				guildName = "Unknown"
	
			# EXP session tracking (new logic)
			if initialEXP is None:
				initialEXP = curEXP
	
			exp_gained_this_session = curEXP - initialEXP
			if exp_gained_this_session < 0:
				exp_gained_this_session += nextEXP  # handle level-up rollover
	
			try:
				if globalFarmingStartTime > 0 and exp_gained_this_session > 0:
					current_time = app.GetGlobalTimeStamp()
					seconds_elapsed = current_time - globalFarmingStartTime
					if seconds_elapsed > 0:
						exp_per_hour = int((float(exp_gained_this_session) / seconds_elapsed) * 3600)
					else:
						exp_per_hour = 0
				else:
					exp_per_hour = 0
			except:
				exp_per_hour = 0
	
			mapName = background.GetCurrentMapName()
			chr.SelectInstance(o)
			Race = chr.GetRace(o)
			position = (int(xx), int(yy))
			yang = player.GetElk()
	
			if initialYang is None:
				initialYang = yang
	
			diff = yang - initialYang
			if diff >= 0:
				direction = "gained"
			else:
				direction = "lost"
	
			# Status
			if fishbotState and not pauseFishbot:
				statusText = "Fishing"
			elif fishbotState and pauseFishbot:
				statusText = "Paused: Fishing"
			elif BuffBotState and not pauseBuffbot:
				if buffbotTarget:
					try:
						charName = chr.GetNameByVID(buffbotTarget)
						if charName:
							statusText = "Buffing " + str(charName)
						else:
							statusText = "Using buffbot"
					except:
						statusText = "Using buffbot"
				else:
					statusText = "Using buffbot"
			elif BuffBotState and pauseBuffbot:
				statusText = "Paused: Buffbot"
			elif farmEnable and not pauseFarmbot:
				entity_status_parts = []
				if globalFarmingKilled["metins"] > 0:
					entity_status_parts.append("%d metins" % globalFarmingKilled["metins"])
				if globalFarmingKilled["mobs"] > 0:
					entity_status_parts.append("%d mobs" % globalFarmingKilled["mobs"])
				if globalFarmingKilled["bosses"] > 0:
					entity_status_parts.append("%d bosses" % globalFarmingKilled["bosses"])
				if globalFarmingKilled["ores"] > 0:
					entity_status_parts.append("%d ores" % globalFarmingKilled["ores"])
				if entity_status_parts:
					farming_runtime_text = ""
					try:
						current_time = app.GetGlobalTimeStamp()
					except:
						current_time = app.GetTime()
					seconds_passed = current_time - globalFarmingStartTime
					minutes_passed = int(seconds_passed / 60)
					hours_passed = int(minutes_passed / 60)
					minutes_only = minutes_passed % 60
					if hours_passed > 0:
						farming_runtime_text = " (%d hours %d minutes)" % (hours_passed, minutes_only)
					else:
						farming_runtime_text = " (%d minutes)" % (minutes_only)
					statusText = "Farming: " + ", ".join(entity_status_parts) + " killed" + farming_runtime_text
				else:
					statusText = "Farming"
			elif farmEnable and pauseFarmbot:
				statusText = "Paused: Farming"
			elif energyBotState and not pauseEnergy:
				statusText = "Doing energy"
			elif energyBotState and pauseEnergy:
				statusText = "Paused: Energy"
			else:
				statusText = "Idle"
	
			chNum = self.getChannel()
			time_to_level_minutes = "??"
			try:
				if globalFarmingStartTime > 0 and curEXP > 0 and nextEXP > 0:
					current_time = app.GetGlobalTimeStamp()
					seconds_elapsed = current_time - globalFarmingStartTime
					exp_progress = float(curEXP) / float(nextEXP)
					exp_remaining = 1.0 - exp_progress
					if exp_progress > 0 and seconds_elapsed > 0:
						exp_per_second = exp_progress / float(seconds_elapsed)
						if exp_per_second > 0:
							seconds_left = exp_remaining / exp_per_second
							minutes_left = int(seconds_left / 60)
							hours_left = int(minutes_left / 60)
							minutes_only = minutes_left % 60
							if hours_left > 0:
								time_to_level_minutes = "~ %d hours %d min" % (hours_left, minutes_only)
							else:
								time_to_level_minutes = "~ %d min" % minutes_left
			except:
				time_to_level_minutes = "??"
	
			toDisplay = ""
			if chNum:
				toDisplay = ", CH" + str(chNum)
			playTime = ""
			try:
				account = player.GetMainCharacterName()
				iddd = 0
				try:
					for accID in range(4):
						charname = net.GetAccountCharacterSlotDataString(accID, 1)
						if charname in account and charname != '':
							iddd = accID
							break
				except:
					pass
				
				
				playTimeRaw = net.GetAccountCharacterSlotDataInteger(iddd, net.ACCOUNT_CHARACTER_SLOT_PLAYTIME)
				
				days = playTimeRaw // (60 * 24)
				hours = (playTimeRaw % (60 * 24)) // 60
				minutes = playTimeRaw % 60
				
				timeParts = []
				
				if days > 0:
					timeParts.append("%dD" % days)
				
					if hours > 0:
						timeParts.append("%dH" % hours)
				
					if minutes > 0:
						timeParts.append("%dMin" % minutes)
				
					playTime = " (Playtime: " + " ".join(timeParts) + ")"
				
				else:
					if hours > 0:
						if hours == 1:
							hourText = "%d hour" % hours
						else:
							hourText = "%d hours" % hours
						timeParts.append(hourText)
				
					if minutes > 0 or hours == 0:
						if minutes == 1:
							minuteText = "%d minute" % minutes
						else:
							minuteText = "%d minutes" % minutes
						timeParts.append(minuteText)
				
					playTime = " (Playtime: " + ", ".join(timeParts) + ")"
			except:
				pass
			f = open_file(dirPl, "w")
			f.write('Timerun: ' + str(globalTimeRan) + "\n")
			f.write('Server: ' + str(st_cur_server) + toDisplay + "\n")
			f.write('Race: ' + str(Race) + "\n")
			f.write('Name: ' + str(charName) + " (" + str(formatNumber(o)) + ")" + "\n")
			f.write('Level: ' + str(level) + ' (Time to level up: ' + time_to_level_minutes + ")\n")
			f.write('HP: ' + str(totalHP) + "\n")
			f.write('MP: ' + str(totalMP) + "\n")
			f.write('EXP: ' + str(totalEXP) + "\n")
			f.write("Yang: %s (%s %s)\n" % (formatNumber(yang), direction, formatNumber(abs(diff))))
			f.write('Mapname: ' + str(mapName) + "\n")
			f.write('Guild: ' + str(guildName) + str(playTime) + "\n") #####################
			f.write("EXP_Session: %s\n" % formatNumber(exp_gained_this_session))
			if exp_per_hour > 1000:
				f.write("EXP_Per_Hour: %s\n" % formatNumber(exp_per_hour))
			else:
				f.write("EXP_Per_Hour: N/A\n")
			f.write('Position: ' + str(position) + "\n")
			f.write('Connected: ' + str(isConnect()) + "\n")
			f.write('Status: ' + str(statusText) + "\n")
			f.write('Antiban: ' + str(antiban_state) + "\n")
			f.write('Players_around: ' + str(len(playerList)) + "\n")
			f.write('GMs_around: ' + str(len(gmList)) + "\n")
			f.write('Panic: ' + str(panicMode) + "\n")
	
			if radarEntities:
				try:
					for entity_type in radarEntities:
						entities_dict = radarEntities[entity_type]
						unique_positions = entities_dict.values()
						if unique_positions:
							pos_str = ", ".join(["(%d, %d)" % (p[0], p[1]) for p in unique_positions])
							f.write("RadarType: %s, RadarPos: [%s]\n" % (entity_type, pos_str))
				except:
					pass
	
			f.close()
	
		except:
			pass
	def getPlayerInfoStop(self):
		self.getPlayerxInfo.XX1(9999999)
		self.getPlayerxInfo.XX2(self.getPlayerInfoStop)
		
		
	def funcAntiBanStart(self):
		global antiBanFunc
		self.antibanStart()
	def antibanStart(self):	
		global antiban_state, vidsListEnd1, vidsListEnd1,farmEnable
		global antiBantargetVID_Start, antiBantargetVID_End, antiBanrestartCounter, antiBanplayerDetected
		global antiBancanScan, antiBanrestartCountPD, canChangeCH, botStopped, antibanList
		global pauseFarmbot, pauseFishbot, pauseEnergy, pauseSkill, pausePick, pauseSpam, pauseItemUser
		global pauseAutoAttack, pauseMobber, pauseOneHit, pauseUsehorse, pauseReply, pauseAutoSell,isGF,canSearchPlayerVids,pauseMoblock
		global pauseBuffbot, pauseFollow, pauseRestart, setWalkingVar,canSetTarget,oldPython
		def update_pause_status(checkbox_dict, player_list, gm_list):
			global pauseFarmbot, pauseFishbot, pauseEnergy, pauseSkill, pausePick, pauseSpam, pauseItemUser
			global pauseAutoAttack, pauseMobber, pauseOneHit, pauseUsehorse, pauseReply, pauseAutoSell,pauseMoblock
			global pauseBuffbot, pauseFollow, pauseRestart, setWalkingVar
			pause_vars = {
				'pauseFarmbot': pauseFarmbot, 'pauseFishbot': pauseFishbot, 'pauseEnergy': pauseEnergy,
				'pauseSkill': pauseSkill, 'pausePick': pausePick, 'pauseSpam': pauseSpam,
				'pauseItemUser': pauseItemUser, 'pauseAutoAttack': pauseAutoAttack, 'pauseMobber': pauseMobber,
				'pauseOneHit': pauseOneHit, 'pauseUsehorse': pauseUsehorse, 'pauseReply': pauseReply,
				'pauseAutoSell': pauseAutoSell, 'pauseBuffbot': pauseBuffbot, 'pauseFollow': pauseFollow,
				'pauseRestart': pauseRestart, 'setWalkingVar': setWalkingVar, 'pauseMoblock': pauseMoblock
			}
			try:
				if gm_list:
					for key, checkbox in checkbox_dict['gm'].items():
						if checkbox.checked == 1:
							pause_vars[key] = 1
						else:
							pause_vars[key] = 0
				elif player_list:
					for key, checkbox in checkbox_dict['player'].items():
						if checkbox.checked == 1:
							pause_vars[key] = 1
						else:
							pause_vars[key] = 0
				else:
					for key in pause_vars.keys():
						pause_vars[key] = 0
				globals().update(pause_vars)
			except:
				pass
		a = 300
		self.startDetector.SetText('Stop antiban')
		self.hideShowAntibanBtnStop()
		
		del playerList[:]
		del gmList[:]
		del antibanList[:]
		self.startDetector.Show()
		self.antibanFunxc.XX1(0.2)
		self.antibanFunxc.XX2(self.antibanStart)
		if not isConnect():
			self.antibanFunxc.XX1(2)
			return
		if self.changeCHGM.checked == 1 or self.changeCHPl.checked == 1:
			if not channels:
				self.refreshChannels()
		dirPl = os.path.join(st_path, "Data", "Servers", str(st_cur_server), 'player_whitelist.txt')
		if not os.path.exists(dirPl):
			f = open_file(dirPl, "w+")
			f.write("")
			f.close()
		if os.stat(dirPl).st_size != 0:
			non_detect = open_file(dirPl, 'r+').read()
		else:
			non_detect = []
		antiban_state = 1
		if self.exitPM.checked == 1:
			quitGameIfGMPM = 1
		if self.beepPM.checked == 1:
			beepIfPM = 1
		if antiBanrestartCountPD >= 50:
			antiBanrestartCountPD = 0
			
			
		for i in vidsListEnd1:
			original_name = chr.GetNameByVID(i).strip()
			name = original_name.lower()
			if name != "none":
				if self.isAdmin(i):
					if name not in [n.lower() for n in antibanList]:
						antibanList.append(original_name)
						
					if name not in [n.lower() for n in gmList]:
						gmList.append(original_name)
					if self.notifyGM.checked == 1:
						seen = {}
						unique_players = []
						for x in gmList:
							lower_name = x.lower()
							if lower_name not in seen:
								seen[lower_name] = True
								unique_players.append(x)  # Deduplicate while preserving case
						gm_str = ", ".join(unique_players)
					if self.quitGM.checked == 1:
						if player.GetTargetVID() and farmEnable:
							canSetTarget = 0
							return
						create_log("Exiting client, GM detected: " + original_name)
						if self.quitAllGM.checked == 1:
							self.quitAllFunc()
							create_log("Stopped all metin2 clients, GM detected: " + original_name)
						universalTime(1)
					if self.logoutGM.checked == 1:
						if player.GetTargetVID() and farmEnable:
							canSetTarget = 0
							return
						create_log("Logged out because GM detected: " + original_name)
						self.KickMe()
						self.antibanFunxc.XX1(5)
					if self.beepGM.checked == 1:
						playBeep("gm")
						self.antibanFunxc.XX1(3)
					if self.changeCHGM.checked == 1:
						if player.GetTargetVID() and farmEnable:
							canSetTarget = 0
							return
						self.Debug()
						canChangeCH = 1
						self.checkGoCh()
						self.Debug()
						create_log("Changing CH, GM detected: " + original_name)
						self.antibanFunxc.XX1(10)
					if self.notifyWindowsGM.checked == 1:
						seen = {}
						unique_players = []
						for x in gmList:
							lower_name = x.lower()
							if lower_name not in seen:
								seen[lower_name] = True
								unique_players.append(x)
						players_str = ", ".join(unique_players)
						myName = str(getcharName())
						if len(gmList) == 1:
							msgx = str(myName) + " @ " + str(st_cur_server) + " - GM: " + str(players_str) + " was detected!"
						else:
							msgx = str(myName) + " @ " + str(st_cur_server) + " - (" + str(len(gmList)) + ") GMs: " + str(players_str) + " were detected!"
						self.notifyLog(msgx)
						self.antibanFunxc.XX1(5)
																						
				a = chr.GetInstanceType(i)
		
				if oldPython:
					isPlm = (
						a == playerType
						and name != "none"
						and name != getcharName().strip().lower()
						and not string_contains(non_detect.lower(), name)
					)
				else:
					isPlm = (
						a == playerType
						and name != "none"
						and name != getcharName().strip().lower()
						and name not in non_detect.lower()
					)
				
				if isPlm:
					if name not in [n.lower() for n in antibanList]:
						antibanList.append(original_name)
					if name not in [n.lower() for n in playerList]:
						playerList.append(original_name)
					seen = {}
					unique_players = []
					for x in playerList:
						lower_name = x.lower()
						if lower_name not in seen:
							seen[lower_name] = True
							unique_players.append(x)  # Deduplicate while preserving case
					players_str = ", ".join(unique_players)
					if self.notifyPl.checked == 1:
						self.antibanFunxc.XX1(1)
					if self.quitPl.checked == 1:
						if player.GetTargetVID() and farmEnable:
							canSetTarget = 0
							return
						create_log("Exiting client, player detected: " + original_name)
						universalTime(1)
					if self.logoutPl.checked == 1:
						if player.GetTargetVID() and farmEnable:
							canSetTarget = 0
							return
						create_log("Logged out because player detected: " + original_name)
						self.KickMe()
						self.antibanFunxc.XX1(5)
					if self.beepPl.checked == 1:
						playBeep("player")
						self.antibanFunxc.XX1(3)
					if self.changeCHPl.checked == 1:
						if player.GetTargetVID() and farmEnable:
							canSetTarget = 0
							return
						self.Debug()
						canChangeCH = 1
						self.checkGoCh()
						self.Debug()
						create_log("Changing CH, player detected: " + original_name)
						self.antibanFunxc.XX1(10)
					if self.notifyWindowsPl.checked == 1:
						seen = {}
						unique_players = []
						for x in playerList:
							lower_name = x.lower()
							if lower_name not in seen:
								seen[lower_name] = True
								unique_players.append(x)
						players_str = ", ".join(unique_players)
						myName = str(getcharName())
						if len(playerList) == 1:
							msgx = str(myName) + " @ " + str(st_cur_server) + " - Player: " + str(players_str) + " was detected!"
						else:
							msgx = str(myName) + " @ " + str(st_cur_server) + " - (" + str(len(playerList)) + ") Players: " + str(players_str) + " were detected!"
						self.notifyLog(msgx)
						self.antibanFunxc.XX1(5)
		try:
			if self.notifyGM.checked==1:
				if len(gmList) == 1:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDetector | GM: |cFFFF0000|H|h" + str(gm_str) + " |cffFFFF00|H|hwas detected!")
				else:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDetector | (" + str(len(gmList)) + ") GMs: |cFFFF0000|H|h" + str(gm_str) + " |cffFFFF00|H|hwere detected!")
		except:
			pass
		try:
			if self.notifyPl.checked==1:
				if len(playerList) == 1:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDetector | Player: |cFFFF0000|H|h" + str(players_str) + " |cffFFFF00|H|hwas detected!")
				else:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hDetector | (" + str(len(playerList)) + ") Players: |cFFFF0000|H|h" + str(players_str) + " |cffFFFF00|H|hwere detected!")
		except:
			pass
		checkbox_dict = {
			'player': {
				'pauseFarmbot': self.stopFarmbotCB1, 'pauseFishbot': self.stopFishbotCB1,
				'pauseEnergy': self.stopEnergyCB1, 'pauseSkill': self.stopSkillCB1,
				'pausePick': self.stopPickCB1, 'pauseSpam': self.stopSpamCB1,
				'pauseItemUser': self.stopItemUserCB1, 'pauseAutoAttack': self.stopAttackCB1,
				'pauseMobber': self.stopMobberCB1,'pauseMoblock': self.stopMoblockCB1, 'pauseOneHit': self.stopOneHitCB1,
				'pauseUsehorse': self.stopHorseCB1, 'pauseReply': self.stopReplyCB1,
				'pauseAutoSell': self.stopSellCB1, 'pauseBuffbot': self.stopBuff1,
				'pauseFollow': self.stopFollowTarget1, 'pauseRestart': self.stopRevive1, 'setWalkingVar': self.setWalking1
			},
			'gm': {
				'pauseFarmbot': self.stopFarmbotCB2, 'pauseFishbot': self.stopFishbotCB2,
				'pauseEnergy': self.stopEnergyCB2, 'pauseSkill': self.stopSkillCB2,
				'pausePick': self.stopPickCB2, 'pauseSpam': self.stopSpamCB2,
				'pauseItemUser': self.stopItemUserCB2, 'pauseAutoAttack': self.stopAttackCB2,
				'pauseMobber': self.stopMobberCB2,'pauseMoblock': self.stopMoblockCB2, 'pauseOneHit': self.stopOneHitCB2,
				'pauseUsehorse': self.stopHorseCB2, 'pauseReply': self.stopReplyCB2,
				'pauseAutoSell': self.stopSellCB2, 'pauseBuffbot': self.stopBuff2,
				'pauseFollow': self.stopFollowTarget2, 'pauseRestart': self.stopRevive2, 'setWalkingVar': self.setWalking2
			}
		}
		update_pause_status(checkbox_dict, playerList, gmList)
		if self.AutoAcceptPlayer.checked == 1:
			try:
				if exchange.isTrading() and exchange.GetAcceptFromTarget() and not self.hasTradedItems() and not self.hasTradedYang():
					net.SendExchangeAcceptPacket()
			except:
				pass
		if self.AutoAcceptCB2.checked == 1:
			try:
				if exchange.isTrading() and exchange.GetAcceptFromTarget() and not self.hasTradedItems() and not self.hasTradedYang():
					net.SendExchangeAcceptPacket()
			except:
				pass
				
	def antibanStop(self):
		global antiban_state,botStopped,updateCounter2,antibanList
		global pauseFarmbot, pauseFishbot, pauseEnergy, pauseSkill, pausePick, pauseSpam, pauseItemUser
		global pauseAutoAttack, pauseMobber, pauseOneHit, pauseUsehorse, pauseReply, pauseAutoSell,pauseMoblock
		global pauseBuffbot, pauseFollow, pauseRestart,setWalkingVar
		self.antibanFunxc.XX1(9999999)
		self.antibanFunxc.XX2(self.antibanStop)
		self.startDetector.SetText('Start antiban')
		antiban_state = 0
		updateCounter2 = 0
		self.hideShowAntibanBtn()
		botStopped = False
		antibanList = []
		pauseFarmbot = 0
		pauseFishbot = 0
		pauseEnergy = 0
		pauseSkill = 0
		pausePick = 0
		pauseSpam = 0
		pauseItemUser = 0
		pauseAutoAttack = 0
		pauseMobber = 0
		pauseMoblock = 0
		pauseOneHit = 0
		pauseUsehorse = 0
		pauseReply = 0
		pauseAutoSell = 0
		pauseBuffbot = 0
		pauseFollow = 0
		pauseRestart = 0
		setWalkingVar = 0
	def rotateQ_funcend(self):
		self.rotateQ_funcx.XX1(9999999)
		self.rotateQ_funcx.XX2(self.rotateQ_funcend)
		app.MovieRotateCamera(app.CAMERA_STOP)
	def rotateQ_func(self):
		if isConnect():
			self.rotateQ_funcx.XX1(0.1)
			self.rotateQ_funcx.XX2(self.rotateQ_func)
			app.MovieRotateCamera(app.CAMERA_TO_POSITIVE)
		else:
			self.rotateQ_funcx.XX1(15)
			self.rotateQ_funcx.XX2(self.rotateQ_func)
		self.rotateE_funcx.XX1(9999999)
		self.rotateE_funcx.XX2(self.rotateE_funcend)
		self.eCamera.SetUp()
	def useDews_funcend(self):
		global dews_state
		self.useDews_funcx.XX1(9999999)
		self.useDews_funcx.XX2(self.useDews_funcend)
		self.dews_state=0
		self.useDewsBtnStop.Hide()
		self.useDewsBtn.Show()
		eventHandler.remove("useItemFunc")
	def useDews_func(self):
		global dews_state,pauseItemUser
		try:
			delay = int(self.usedews_delay.GetText())
		except:
			delay = 60
		self.useDews_funcx.XX1(delay)
		self.useDews_funcx.XX2(self.useDews_func)
		if not isConnect():
			return
		self.useDewsBtnStop.Show()
		self.useDewsBtn.Hide()
		if pauseItemUser:
			return
		if self.usedews_delay.GetText() != "":
			self.use_dews()
			self.dews_state=1
	def rotateE_funcend(self):
		self.rotateE_funcx.XX1(9999999)
		self.rotateE_funcx.XX2(self.rotateE_funcend)
		app.MovieRotateCamera(app.CAMERA_STOP)
	def rotateE_func(self):
		if isConnect():
			self.rotateE_funcx.XX1(0.1)
			self.rotateE_funcx.XX2(self.rotateE_func)
			app.MovieRotateCamera(app.CAMERA_TO_NEGATIVE)
		else:
			self.rotateE_funcx.XX1(15)
			self.rotateE_funcx.XX2(self.rotateE_func)
		self.rotateQ_funcx.XX1(9999999)
		self.rotateQ_funcx.XX2(self.rotateQ_funcend)
		self.qCamera.SetUp()
	def keepRadarAttachedFuncOff(self):
		self.keepRadarAttachedxFunc.XX1(9999999)
		self.keepRadarAttachedxFunc.XX2(self.keepRadarAttachedFuncOff)
	def keepRadarAttachedFuncOn(self):
		self.keepRadarAttachedxFunc.XX1(0.01)
		self.keepRadarAttachedxFunc.XX2(self.keepRadarAttachedFuncOn)
		try:
			if self.newMap.IsShow():
				pos = self.newMap.GetGlobalPosition()
				self.radarSettingsWindow.SetPosition(pos[0],pos[1] - self.radarSettingsWindow.GetHeight())
			else:
				self.keepRadarAttachedFuncOff()
		except:
			self.keepRadarAttachedFuncOff()
	def showRadarWindow(self):
		if self.radarSettingsWindow.IsShow():
			self.radarSettingsWindow.Hide()
			self.keepRadarAttachedFuncOff()
		else:
			self.keepRadarAttachedFuncOn()
			self.radarSettingsWindow.Show()		
	def closeRadarWindow(self):
		self.radarSettingsWindow.Hide()
		self.keepRadarAttachedFuncOff()
	def keepItemsAttachedFuncOff(self):
		self.keepItemsAttachedxFunc.XX1(9999999)
		self.keepItemsAttachedxFunc.XX2(self.keepItemsAttachedFuncOff)
	def keepItemsAttachedFuncOn(self):
		self.keepItemsAttachedxFunc.XX1(0.01)
		self.keepItemsAttachedxFunc.XX2(self.keepItemsAttachedFuncOn)
		try:
			if self.metin2_window.IsShow():
				pos = self.metin2_window.GetGlobalPosition()
				self.sellItemsWindow.SetPosition(pos[0]+self.metin2_window.GetWidth(),pos[1])
			else:
				self.keepItemsAttachedFuncOff()
		except:
			self.keepItemsAttachedFuncOff()
	def closeItemsWindow(self):
		self.sellItemsWindow.Hide()
		self.keepItemsAttachedFuncOff()
	def keepChAttachedFuncOff(self):
		self.keepChAttachedxFunc.XX1(9999999)
		self.keepChAttachedxFunc.XX2(self.keepChAttachedFuncOff)
	def keepChAttachedFuncOn(self):
		self.keepChAttachedxFunc.XX1(0.01)
		self.keepChAttachedxFunc.XX2(self.keepChAttachedFuncOn)
		try:
			if self.metin2_window.IsShow():
				pos = self.metin2_window.GetGlobalPosition()
				self.chChangerWindow.SetPosition(pos[0]+self.metin2_window.GetWidth(),pos[1])
			else:
				self.keepChAttachedMapFuncOff()
		except:
			self.keepChAttachedMapFuncOff()
	def chChangerInfo_func(self):			
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCH Changer: " + lang.CH_CHANGER_INFO1)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCH Changer: " + lang.CH_CHANGER_INFO2)
	def closeChWindow(self):
		self.chChangerWindow.Hide()
		self.keepChAttachedFuncOff()
	def chChangerMenu(self, arg):
		if arg:
			if self.chChangerWindow.IsShow():
				self.chChangerWindow.Hide()
				self.keepChAttachedFuncOff()
			else:
				try:
					pos = self.metin2_window.GetGlobalPosition()
					self.chChangerWindow.SetPosition(pos[0]+self.metin2_window.GetWidth(),pos[1])
				except:
					pass
				self.keepChAttachedFuncOn()
				self.chChangerWindow.Show()
		else:
			if self.chChangerWindow.IsShow():
				self.chChangerWindow.Hide()
				self.keepChAttachedFuncOff()
			else:
				try:
					pos = self.metin2_window.GetGlobalPosition()
					self.chChangerWindow.SetPosition(pos[0]+self.metin2_window.GetWidth(),pos[1])
				except:
					pass
				self.keepChAttachedFuncOn()
				self.chChangerWindow.Show()
	def antifly_funcend(self):
		global one_hit_state
		self.antifly_funcx.XX1(9999999)
		self.antifly_funcx.XX2(self.antifly_funcend)
		self.one_hit_state=0
		self.oneHitBtnStop.Hide()
		self.oneHitBtn.Show()
	def isMoving(self, player, threshold=100):
		global previous_position
		current_position = player.GetMainCharacterPosition()
		if previous_position is None:
			previous_position = current_position
			return True
		dx = abs(current_position[0] - previous_position[0])
		dy = abs(current_position[1] - previous_position[1])
		dz = abs(current_position[2] - previous_position[2])
		previous_position = current_position
		if dx > threshold or dy > threshold or dz > threshold:
			return True
		else:
			return False
	def antifly_func(self):
		global one_hit_state, pauseOneHit
		self.one_hit_state = 1
		self.oneHitBtnStop.Show()
		self.oneHitBtn.Hide()
		try:
			my_vid = getCharIndex()
			chr.SelectInstance(my_vid)
			race = chr.GetRace(my_vid)
			if race > 50:
				delay = 0.80  # maybe poly
			else:
				RACE_DELAY = {
					0: 0.30,   # warrior M
					1: 0.20,   # assassin F
					2: 0.30,   # sura M
					3: 0.35,   # shaman F
					4: 0.28,   # warrior F
					5: 0.20,   # assassin M
					6: 0.30,   # sura F
					7: 0.35,   # shaman M
					8: 0.28,   # wolfman M
				}
	
			delay = RACE_DELAY.get(race, 0.30)
		except Exception:
			delay = 0.30
		self.antifly_funcx.XX1(delay)
		self.antifly_funcx.XX2(self.antifly_func)
		if not isConnect():
			self.antifly_funcx.XX1(4)
			return
			
		if pauseOneHit:
			return
		try:
			try:
				isMoving = self.isMoving(player)
			except Exception:
				isMoving = False
	
			if not isMoving:
				my_vid = getCharIndex()
				chr.SelectInstance(my_vid)
				chr.SetLoopMotion(chr.MOTION_WAIT)
		except Exception:
			self.antifly_funcend()
	def teleMetin_func(self):
		try:
		
			metinX = self.metinXLbl.GetText()
			metinY = self.metinYLbl.GetText()
			X = int(metinX)
			Y = int(metinY)
			self.TeleportToDest(int(X)*100, int(Y)*100)
			self.remMetinFunc()
		except:
			pass
	def walkMetin_func(self):
		try:
			
			metinX = self.metinXLbl.GetText()
			metinY = self.metinYLbl.GetText()
			X = int(metinX) * 100
			Y = int(metinY) * 100
			walkFunc(X,Y)
		except:
			pass
	def remBossFunc(self):
		self.bossNameLbl.SetText("")
	def remMetinFunc(self):
		self.metinNameLbl.SetText("")
	def teleBoss_func(self):
		try:
			
			bossX = self.bossXLbl.GetText()
			bossY = self.bossYLbl.GetText()
			X = int(bossX)
			Y = int(bossY)
			self.TeleportToDest(int(X)*100, int(Y)*100)
			self.remBossFunc()
		except:
			pass
	def walkBoss_func(self):
		try:
			o=getCharIndex()
			bossX = self.bossXLbl.GetText()
			bossY = self.bossYLbl.GetText()
			X = int(bossX) * 100
			Y = int(bossY) * 100
			walkFunc(X,Y)
		except:
			pass
	def mbDetect_funcend(self):
		global loadedBoss,boss_list
		self.mbDetect_funcx.XX1(9999999)
		self.mbDetect_funcx.XX2(self.mbDetect_func)
		loadedBoss = 0
	def mbDetect_func(self):
		global boss_list, metin_list,metinX,metinY,loadedBoss
		global vidsListEnd1, targetVID_Start, targetVID_End, restartCounter, isGF
		try:
			b = 0
			o=getCharIndex()
			namemetin=self.metinNameLbl.GetText()
			nameboss=self.bossNameLbl.GetText()
			self.mbDetect_funcx.XX1(0.1)
			self.mbDetect_funcx.XX2(self.mbDetect_func)
			if not isConnect():
				self.mbDetect_funcx.XX1(5)
				return
			if not loadedBoss:
				self.load_boss()
				loadedBoss = 1
			for i in vidsListEnd1:
				dystans = GetDis(i) 
				if dystans > 0:
					a = chr.GetInstanceType(i)
					if self.metinDetector.checked == 1:
						if a==metinType:
							chr.SelectInstance(i)
							x, y = getPos(i)
							metinX = x / 100
							metinY = y / 100
							self.metinNameLbl.SetText("|cffffc700|H|h" + str(chr.GetNameByVID(i)) + " - X: " + str(metinX) + " Y: " + str(metinY))
							self.metinXLbl.SetText(str(metinX))
							self.metinYLbl.SetText(str(metinY))
							if self.autoRotate.checked==1:
								try:
									self.setRot(i)
								except:
									pass
					if self.bossDetector.checked == 1:
						a = chr.GetInstanceType(i)
						if a == mobType:
							chr.SelectInstance(i)
							Race=chr.GetRace(i)
							try:
								bossListx = set(boss_list) | set(bossIds)
							except:
								bossListx = boss_list + bossIds
							for abc in bossListx:
								if Race==int(abc):
									x, y = getPos(i)
									metinX = x / 100
									metinY = y / 100
									self.bossNameLbl.SetText("|cffffc700|H|h" + str(chr.GetNameByVID(i)) + " - X: " + str(metinX) + " Y: " + str(metinY))
									self.bossXLbl.SetText(str(metinX))
									self.bossYLbl.SetText(str(metinY))
									if self.autoRotate.checked==1:
										try:
											self.setRot(i)
										except:
											pass
		except:	
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFailed starting Metin/Boss detector.")
			self.mbDetect_funcend()
	def virtual_funcend(self):
		self.virtual_funcx.XX1(9999999)
		self.virtual_funcx.XX2(self.virtual_funcend)
		try:
			chr.GetRace2=chr.GetRace
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.STR_NOT_CW)
			self.cw2FixBtn.SetUp()
	def virtual_func(self):
		if isConnect():
			self.virtual_funcx.XX1(30)
			self.virtual_funcx.XX2(self.virtual_func)
			net.SendQuestInputStringPacket('10')
		else:
			self.virtual_funcx.XX1(60)
			self.virtual_funcx.XX2(self.virtual_func)
	def sw_funcend(self):
		try:
			chr.GetRace2=chr.GetRace
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.STR_NOT_CW)
			self.cw2FixBtn.SetUp()
	def sw_func(self):
		try:
			chr.GetRace=chr.GetRace2
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.STR_NOT_CW)
			self.cw2FixBtn.SetUp()
	def calliope_funcend(self):
		self.calliope_funcx.XX1(9999999)
		self.calliope_funcx.XX2(self.calliope_funcend)
	def calliope_func(self):
		if isConnect():
			if find_string(st_cur_server, "calliope"):
				self.calliope_funcx.XX1(2)
				self.calliope_funcx.XX2(self.calliope_func)
				try:
					if constInfo.confirm_stone_check >= 1:
						constInfo.confirm_stone_check = 0
						SendChatPacket("/stone_check_answer 2")
						constInfo.confirm_stone_times = constInfo.confirm_stone_times + 1
						chr.SetCantAttack(0)
						player.SetBlockAttackState(False)
				except:
					pass
		else:
			self.calliope_funcx.XX1(15)
			self.calliope_funcx.XX2(self.calliope_func)
	def rotateTargetOn(self):
		try:
			self.rotateTargetBtn.SetText("Stop")
			self.rotatexTarget.XX1(0.1)
			self.rotatexTarget.XX2(self.rotateTargetOn)
			if not isConnect():
				self.rotatexTarget.XX1(3)
				return
			o=getCharIndex()
			vid = player.GetTargetVID()
			if vid != o:
				self.setRot(vid)
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRotate to target: An error occured!")
			self.rotateTargetBtn.SetText("Start")
			self.rotateTargetBtn.SetUp()
			self.rotateTargetOff()
	def rotateTargetOff(self):
		self.rotatexTarget.XX1(9999999)
		self.rotatexTarget.XX2(self.rotateTargetOff)
		self.rotateTargetBtn.SetText("Start")
		self.rotateTargetBtn.SetUp()
	def lockPlayersOn(self):
		global canUseVid, vidsListEnd1, targetVID_Start, targetVID_End, restartCounter, isGF
		try:
			self.lockPlayersx.XX1(0.1)
			self.lockPlayersx.XX2(self.lockPlayersOn)
			if not isConnect():
				self.lockPlayersx.XX1(3)
				return
			self.lockPlayersBtn.SetText("Stop")
			o=getCharIndex()
			x, y, z = player.GetMainCharacterPosition()
			for i in vidsListEnd1:
				dystans = GetDis(i) 
				if dystans > 0:
					a = chr.GetInstanceType(i)
					if a==playerType:
						chr.SelectInstance(i)
						setPixelPos(int(x), int(y), int(z))
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hTarget lock: An error occured!")
			self.lockPlayersBtn.SetText("Start")
			self.lockPlayersBtn.SetUp()
	def lockPlayersOff(self):
		self.lockPlayersx.XX1(9999999)
		self.lockPlayersx.XX2(self.lockPlayersOff)
		self.lockPlayersBtn.SetText("Start")
		self.lockPlayersBtn.SetUp()
	def lockTargetOn(self):
		global lockTarget, lockTargetVid
		i = player.GetTargetVID()
		try:
			self.lockTargetx.XX1(0.1)
			self.lockTargetx.XX2(self.lockTargetOn)
			if not isConnect():
				self.lockTargetx.XX1(3)
				return
			self.lockTargetBtn.SetText("Stop")
			x, y, z = player.GetMainCharacterPosition()
			if i != 0 or i != -1:
				lockTargetVid = i
				chr.SelectInstance(i)
				setPixelPos(int(x), int(y), int(z))
				lockTarget = 1
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hTarget lock: An error occured!")
			self.lockTargetBtn.SetText("Start")
			self.lockTargetBtn.SetUp()
			lockTarget = 0
	def lockTargetOff(self):
		global lockTarget
		self.lockTargetx.XX1(9999999)
		self.lockTargetx.XX2(self.lockTargetOff)
		self.lockTargetBtn.SetText("Start")
		self.lockTargetBtn.SetUp()
		lockTarget = 0
	def moblock_func(self):
		global moblock_state
		global canUseVid, vidsListEnd1, targetVID_Start, targetVID_End, restartCounter, isGF, pauseMoblock
		moblock_state = 1
		self.moblockStop.Show()
		self.moblock.Hide()
		self.moblock_funcczas.XX1(0.5)
		self.moblock_funcczas.XX2(self.moblock_func)
		if pauseMoblock:
			return
		if not isConnect():
			self.moblock_funcczas.XX1(3)
			self.moblock_funcczas.XX2(self.moblock_func)
			return
		try:
			x, y, z = player.GetMainCharacterPosition()
			if vidsListEnd1:
				num_mobs = len(vidsListEnd1)
				if num_mobs:
					angle_increment = 2 * math.pi / num_mobs
					for index in range(num_mobs):
						i = vidsListEnd1[index]
						DistanceToNext = GetDis(i) 
						if DistanceToNext <= 5000 and not self.isDead(i):
							angle = index * angle_increment
							mob_x = x + 200 * math.cos(angle)
							mob_y = y + 200 * math.sin(angle)
							chr.SelectInstance(i)
							b = chr.GetInstanceType(i)
							if b == mobType:
								setPixelPos(int(mob_x), int(mob_y))
		except:
			self.moblock_funcend()
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hMoblock: An error occured!")
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hMoblock: Failed to lock mobs!")
	def moblock_funcend(self):
		global moblock_state
		self.moblock_funcczas.XX1(100000000)
		self.moblock_funcczas.XX2(self.moblock_funcend)
		moblock_state=0
		self.moblockStop.Hide()
		self.moblock.Show()
	def useHorse_func(self):
		global setMountVnumFarm,pauseUsehorse
		self.useHorse_funcx.XX1(10)
		self.useHorse_funcx.XX2(self.useHorse_func)
		if not isConnect():
			return
		if pauseUsehorse:
			return
		if self.useMount.checked==1:
			if not player.IsMountingHorse():
				if setMountVnumFarm != 0:
					slot = 0
					if isConnect():
						for i in range(player.INVENTORY_PAGE_SIZE * 10):
							a = player.GetItemIndex(i)
							if a:
								if int(a) == int(setMountVnumFarm):
									slot = i
									break
						if slot:
							useItemFunc(slot)
	
						if not player.IsMountingHorse():
							mountHorseFunc(0)
		else:
			if not player.IsMountingHorse():
				if isConnect():
					
					if self.disableQuestHorse.checked == 1:
						self.InstallQuestWindowHook()
						
					if not find_string(st_cur_server, "luminus"):
						
						self.useItem(50051)
						
						self.useItem(50052)
						
						self.useItem(50053)
	
					if not player.IsMountingHorse():
						
						mountHorseFunc(0)
						
					# if self.disableQuestHorse.checked == 1:
						
						# self.UnHookQuestWindow(0)
						
				
	def useHorse_funcOff(self):
		self.useHorse_funcx.XX1(9999999)
		self.useHorse_funcx.XX2(self.useHorse_funcOff)
		if self.disableQuestHorse.checked == 1:
			self.UnHookQuestWindow(0)
	def getMyLoc(self):		
		global curPlayerX,curPlayerY
		mX, mY, _ = player.GetMainCharacterPosition()
		curPlayerX = mX
		curPlayerY = mY
	def FreezeToDest(self, aimx, aimy):
		step_distance = 20
		cur_position = player.GetMainCharacterPosition()
		curx = cur_position[0]
		cury = cur_position[1]
		total_distance = math.sqrt((aimx - curx)**2 + (aimy - cury)**2)
		steps = int(total_distance // step_distance)
		if steps > 0:
			step_x = (aimx - curx) / float(steps) 
			step_y = (aimy - cury) / float(steps)
		else:
			step_x = 0
			step_y = 0
		myVid = getCharIndex()
		for _ in range(steps):
			curx += step_x
			cury += step_y
			chr.SelectInstance(myVid)
			setPixelPos(int(curx), int(cury))
			# self.Debug()
		chr.SelectInstance(myVid)
		setPixelPos(int(aimx), int(aimy))
		# self.Debug() 
		global TeleportState
		TeleportState = 1
	def freeze_func(self):
		global curPlayerX,curPlayerY,panicMode
		self.freeze_funcx.XX1(0.01)
		self.freeze_funcx.XX2(self.freeze_func)
		if not isConnect():
			self.freeze_funcx.XX1(3)
			return
		if panicMode:
			return
		if curPlayerX == 0 or curPlayerY == 0 or curPlayerX == None or curPlayerY == None:
			mX, mY, _ = player.GetMainCharacterPosition()
			curPlayerX = mX
			curPlayerY = mY
		if curPlayerX != 0 or curPlayerY != 0 or curPlayerX != None or curPlayerY != None:
			self.btnfreeze.Hide()
			self.btnfreezeStop.Show()
			self.FreezeToDest(int(curPlayerX),int(curPlayerY))
	def freeze_funcOff(self):
		global curPlayerX,curPlayerY
		self.freeze_funcx.XX1(9999999)
		self.freeze_funcx.XX2(self.freeze_funcOff)
		self.btnfreeze.Show()
		self.btnfreezeStop.Hide()
		self.Debug()
		curPlayerX = 0
		curPlayerY = 0
############ PICKUP ############
	def SetPickSpeedGF(self):
		global pickSpeed
		pickUpSpeed = self.pickupSpeed.GetSliderPos()*10
		if pickUpSpeed == 0.00:
			pickUpSpeed = 0.01
		self.lblPickSpeed.SetText('%0.2f sec' % pickUpSpeed)
		aaa = '%0.2f' % pickUpSpeed
		pickSpeed = aaa
	def SetPickRange(self):
		global pickRange
		val = self.pickupRange.GetSliderPos()
		self.lblPickRange.SetText(str(int(val*10000)))
		val2 = str(int(val*10000))
		pickRange = val2
		eXLib.ItemGrndSelectRange(float(pickRange))
	def pickupFuncGF(self):
		global avoidPlayers,excludeItem,itemFirst,blockItems,pickRange,time_Settings_pickUpTimer,pickSpeed,hasToPickup,isFarmingOre
		if pickRange == None:
			pickRange = 2500
		x,y,z = player.GetMainCharacterPosition()
		vid,itemX,itemY = eXLib.GetCloseItemGround(x,y)
		if vid == 0:
			hasToPickup = 0
			return
		dst = dist(x,y,itemX,itemY)
		allowedRange = max(pickRange,290)
		if dst <= allowedRange:
			if dst >= 290 and not isFarmingOre:
				
				if self.walkToItem.checked:
					# if IsWeaponArch():
					hasToPickup = 1
					self.goingFunction("Walking", itemX, itemY, 0)
					eXLib.SendPickupItem(vid)
					# self.goingFunction("Walking", x, y, 0)
				else:
				
					self.TeleportStraightLine(x,y,itemX,itemY)
					eXLib.SendPickupItem(vid)
					self.TeleportStraightLine(itemX,itemY,x,y)
			else:
				eXLib.SendPickupItem(vid)	
	def pickupNormalStopGF(self):
		global pickupState
		self.pickupNormalxStart.XX1(9999999)
		self.pickupNormalxStart.XX2(self.pickupNormalStopGF)
		pickupState = 0
	def pickupNormalStartGF(self):
		global pickupState,pickSpeed,pausePick
		if pickSpeed == None:
			pickSpeed = 1
		self.pickupNormalxStart.XX1(float(pickSpeed))
		self.pickupNormalxStart.XX2(self.pickupNormalStartGF)
		if not isConnect():
			self.pickupNormalxStart.XX1(5)
			return
		if pausePick:
			return
		pickupState = 1
		self.pickupFuncGF()
	def excludeItemsFuncOff(self):
		global excludeItem
		excludeItem = 0
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.PICK_ALL_EXCEPT)
		eXLib.ItemGrndNotOnFilter()
	def excludeItemsFuncOn(self):
		global excludeItem
		excludeItem = 1
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.PICK_ONLY_FROM_LIST)
		eXLib.ItemGrndOnFilter()
		self.ignorePickList.OnToggleUp()
	def itemsFirstFuncOff(self):
		global itemFirst
		itemFirst = 0
		eXLib.ItemGrndNoItemFirst()
	def itemsFirstFuncOn(self):
		global itemFirst
		itemFirst = 1
		eXLib.ItemGrndItemFirst()
	def blockedItemsFuncOff(self):
		global blockItems
		blockItems = 0
		eXLib.ItemGrndInBlockedPath()
	def blockedItemsFuncOn(self):
		global blockItems
		blockItems = 1
		eXLib.ItemGrndNotInBlockedPath()
	def avoidPlayersFuncOff(self):
		global avoidPlayers
		avoidPlayers = 0
	def avoidPlayersFuncOn(self):
		global avoidPlayers
		avoidPlayers = 1
	def UpdatePickFilterList(self):	
		if isGF:
			try:
				ui.EditLine.OnIMEUpdate(self.PickSearchItemEditLine)
			except:
				pass
		else:
			try:
				EditLine.OnIMEUpdate(self.PickSearchItemEditLine)
			except:
				pass
		searchValue = self.PickSearchItemEditLine.GetText().lower()
		self.PickfileListBox.RemoveAllItems()
		for filterItem in sort_items(self.pickFilter):
			selectItem(filterItem)
			name = item.GetItemName().lower()
			if searchValue in name:
				self.PickfileListBox.AppendItem(Item(str(filterItem) + " " + item.GetItemName()))
	def UIAddPickFilterItem(self,item):
		self.addPickFilterItem(item)
		self.UpdatePickFilterList()
	def OpenPickItemDialog(self):
		pos = self.metin2_window.GetGlobalPosition()
		ItemListDialog(self.UIAddPickFilterItem,pos[0]+self.metin2_window.GetWidth(),pos[1])
		#ItemListDialog(self.AddFilterItem,pos[0],pos[1])
	def UIPickRemoveFilterItem(self):
		_item = self.PickfileListBox.GetSelectedItem()
		if _item == None:
			return
		item_name = _item.GetText()
		id = item_name.split(" ",1)
		self.delPickFilterItem(int(id[0]))
		self.UpdatePickFilterList()
	def delPickFilterItem(self,id):
		global PICKUP_LIST
		eXLib.ItemGrndDelFilter(id)
		self.pickFilter.remove(int(id))
		try:
			SaveListFile(PICKUP_LIST,self.pickFilter)
		except:
			pass
	def addPickFilterItem(self,id):
		global PICKUP_LIST
		eXLib.ItemGrndAddFilter(id)
		self.pickFilter.add(int(id))
		try:
			SaveListFile(PICKUP_LIST,self.pickFilter)
		except:
			pass
############ PICKUP ############
############ WAITHACK ##############
	def waithackStop(self):
		self.waithackxStart.XX1(9999999)
		self.waithackxStart.XX2(self.waithackStop)
	def waithackCheck(self):
		global pauseFishbot,canAttack
		delay = float(self.waithackSpeed.GetSliderPos())
		try:
			myHP = int(self.pauseWaithackValue.GetText())
		except:
			myHP = 30
		curHP=self.currentHP()
		self.waithackxStart.XX1(delay)
		self.waithackxStart.XX2(self.waithackCheck)
		if self.pauseWaithackIf.checked == 1:
			if curHP < myHP:
				return
		if pauseFishbot:
			eXLib.UnblockAttackPackets()
			return
		if self.waitForHPBox.checked==1:
			if canAttack == True:
				self.waithackStart()
		else:
			self.waithackStart()
	def setSafeDmg(self, arg):
		global doSafeDamage
		doSafeDamage = arg
	def TeleportAttack(self, lst, x, y):
		self.TeleportStraightLine(self.lastPos[0], self.lastPos[1], x, y)
		self.lastPos = (x, y)
		vid_hits = 0
		for vid in lst:
			mob_x, mob_y = getPos(vid)
			if dist(x, y, mob_x, mob_y) < 290:
				eXLib.SendAttackPacket(vid, 0)
				lst.remove(vid)
				vid_hits += 1
		return vid_hits
	def teleportAwayFromMob(self):
		global canWalkTele
		rnd = getRandom(300, 1000)
		if getRandom(0, 1) < 0.5:
			sign_x = -1
		else:
			sign_x = 1
		if getRandom(0, 1) < 0.5:
			sign_y = -1
		else:
			sign_y = 1
		rnd_x = rnd * sign_x
		rnd_y = rnd * sign_y
		(x, y, z) = player.GetMainCharacterPosition()
		finX = int(x + rnd_x)
		finY = int(y + rnd_y)
		if self.inside_circle(finX, finY, x, y, 1000):
			# msg("myX: " + str(x) + ", myY: " + str(y) + " to go X: " + str(finX) + " to go Y: " + str(finY))
			if not eXLib.IsPositionBlocked(int(finX), int(finY)):
				self.TeleportToPosition(finX, finY)
				# msg('goed')
	def waithackStart(self):
		global whRange, whMonsters,disableAttack,hasToPickup
		whRange = int(self.waithackRange.GetSliderPos() * 10000)
		whMonsters = int(self.waithackMonsters.GetSliderPos() * 100)
		main_vid = getCharIndex()
		if not self.isDead(main_vid) and not disableAttack and not hasToPickup:
			x, y = getPos(main_vid)
			self.lastPos = (x, y)
			lst = list()
			inst_list = eXLib.InstancesList.copy()
			inst_list.pop(main_vid, 0)
			for vid in inst_list:
				playerName = chr.GetNameByVID(vid)
				if not HasInstance(vid):
					continue
				if IsThisNPC(vid):
					continue
				if GetDis(vid) < whRange and not self.isDead(vid):
					if self.whMetins.checked == 1 and IsThisMetin(vid):
						lst.append(vid)
					if self.whMonsters.checked == 1 and IsThisMob(vid):
						lst.append(vid)
					if self.whPlayers.checked == 1 and IsThisPlayer(vid):
						lst.append(vid)
					if self.whBosses.checked == 1 and isBoss(vid):
						lst.append(vid)
			hit_counter = 0
			i = 0
			while len(lst) > 0 and hit_counter < whMonsters:
				vid = lst[0]
				mob_x, mob_y = getPos(vid)
				if self.waithackBlocked.checked == 1:
					if eXLib.IsPositionBlocked(mob_x, mob_y):
						lst.remove(vid)
						continue
				if self.waithackBlocked2.checked == 1:
					if eXLib.IsPathBlocked(x, y, mob_x, mob_y):
						lst.remove(vid)
						continue
				if self.whMetins.checked == 0 and IsThisMetin(vid):
					lst.remove(vid)
				if self.whMonsters.checked == 0 and IsThisMob(vid):
					lst.remove(vid)
				if self.whPlayers.checked == 0 and IsThisPlayer(vid):
					lst.remove(vid)
				if self.whBosses.checked == 0 and isBoss(vid):
					lst.remove(vid)
				hit_counter += self.TeleportAttack(lst, mob_x, mob_y)
				if self.safeDamage.checked == 1:
					self.teleportAwayFromMob()
				i += 1
			if dist(x, y, self.lastPos[0], self.lastPos[1]) >= 50:
				self.TeleportStraightLine(self.lastPos[0], self.lastPos[1], x, y)
	def waithackFunc(self,val):
		global waithackState,isGF,doSafeDamage
		if isGF:
			try:
				if(val):
					waithackState = 1
					eXLib.BlockAttackPackets()
					self.waithackCheck()
					if self.safeDamage.checked==1:
						doSafeDamage = 1
				else:
					waithackState = 0
					eXLib.UnblockAttackPackets()
					self.waithackStop()
			except:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hAn error occured and \x53\x54\x4d\x4f\x44 will not work correctly.")
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPlease restart client and only inject \x53\x54\x4d\x4f\x44 before logging in.")
	def setWaithackSpeed(self):
		global whSpeed
		val = float(self.waithackSpeed.GetSliderPos())
		self.waithackSpeedLbl2.SetText(str(int(val*1000)) + ' ms')
		val2 = val*1000
		whSpeed = val2
	def setWaithackRange(self):
		global whRange
		val = self.waithackRange.GetSliderPos()
		self.waithackRangeLbl2.SetText(str(int(val*10000)))
		val2 = str(int(val*10000))
		whRange = val2
	def setWaithackMonsters(self):
		global whMonsters
		val = float(self.waithackMonsters.GetSliderPos())
		self.waithackMonstersLbl2.SetText(str(int(val*100)))
		val2 = str(int(val*100))
		whMonsters = val2
############ WAITHACK ##############
	def attack_func(self):
		global attack_state,canWalkTele,disableAttack,panicMode
		self.btnAttack.Hide()
		self.btnAttackStop.Show()
		attack_state=1
		try:
			attackSetting = self.attackList.GetCurrentText()
		except:
			attackSetting = 'Normal'
		self.attack_funcx.XX1(0.1)
		self.attack_funcx.XX2(self.attack_func)
		if not isConnect():
			self.attack_funcx.XX1(3)
			return
		if disableAttack:
			Attack(False)
			return
		if panicMode:
			return
		Attack(True)
		if attackSetting == 'Rotation':
			self.attack_funcx.XX1(1)
			if not hasattr(chr, 'SetDirection'):
				try:
					chr.SetRotation(getRandom(0,360))
				except:
					pass
			else:
				try:
					chr.SetDirection(getRandom(0,7))
				except:
					pass
	def attack_funcOff(self):
		global attack_state
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hAuto attack disabled.")
		self.attack_funcx.XX1(9999999)
		self.attack_funcx.XX2(self.attack_funcOff)
		self.btnAttack.Show()
		self.btnAttackStop.Hide()
		Attack(False)
		attack_state=0
	def currentHP(self):
		try:
			maxhp = player.GetStatus(player.MAX_HP)
			curHp = player.GetStatus(player.HP)
			return float(curHp) / float(maxhp) * 100
		except:
			return float(100)
	def restartBtn_func(self):
		global restart_state, createLog, canAttack, justRevived, pauseRestart
		self.restartBtn.Hide()
		self.restartBtnStop.Show()
		self.restart_state = 1
		try:
			self.restartBtnx.XX1(1)
			self.restartBtnx.XX2(self.restartBtn_func)			
			
			if pauseRestart:
				return			
			if not isConnect():
				self.restartBtnx.XX1(3)
				return
			
			
			maxhp = player.GetStatus(player.MAX_HP)
			curHp = player.GetStatus(player.HP)
			try:
				myHP = int(self.waitForHP.GetText())
			except:
				myHP = 30
			if self.currentHP() <= 0:
				if createLog == 1:
					create_log("Player died, trying to restart here.")
					createLog = 0
				if find_string(st_cur_server, "Metin2BR") or find_string(st_cur_server, "tiks") or isGF or find_string(st_cur_server, "shinra"):
					import uiRestart
					RestartDialogX = uiRestart.RestartDialog()
					RestartDialogX.RestartHere()
					del RestartDialogX
				else:
					SendChatPacket("/restart_here")
				justRevived = True
				canAttack = False
			else:
				if justRevived:
					if self.waitForHPBox.checked == 1:
						if self.currentHP() >= myHP:
							canAttack = True
							justRevived = False
						else:
							canAttack = False
					else:
						canAttack = self.currentHP() >= myHP
				else:
					canAttack = True
				createLog = 1
		except:
			self.restartBtn_funcOff()
	def restartBtn_funcOff(self):
		global restart_state
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hAuto restart disabled.")
		self.restartBtnx.XX1(9999999)
		self.restartBtnx.XX2(self.restartBtn_funcOff)
		self.restartBtn.Show()
		self.restartBtnStop.Hide()
		self.restart_state=0
	def won_info(self):
		newMsg(lang.STR_WON_INFO, "down", 4, "box_blue", "text_white", 500, 200)
	def drop_item_info(self):
		newMsg(lang.STR_DROP_INFO, "down", 4, "box_blue", "text_white", 500, 200)
	def strongBodyInfo(self):
		newMsg(lang.STR_STRONG_BODY_INFO, "down", 4, "box_blue", "text_white", 500, 200)
	def hotKeyInfo(self):
		newMsg(lang.STR_HOTKEY_TELEPORT, "down", 4, "box_blue", "text_white", 500, 200)
	def skillInfo_Func(self):
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hRead SS info: The abilities are counted from 0, count the index for the skill you want to be upgraded.")
	def speedInfo_Func(self):
		newMsg(lang.STR_SPEEDHACK_HELP, "down", 4, "box_blue", "text_white", 500, 200)
	def waitInfoMsg(self):
		newMsg("How many seconds the bot should wait before going to the next target.", "down", 4, "box_blue", "text_white", 500, 200)
	def addItemInfo_Func(self):
		newMsg(lang.STR_PICK_INFO, "down", 4, "box_blue", "text_white", 500, 200)
	def skipAnimHelp_Func(self):
		newMsg("By default, the bot will try to summon horse, if no 'mount' is selected\nbut you can place a mount on the slot,\nthen the bot will auto use it when trying to pull rod.", "down", 4, "box_blue", "text_white", 500, 200)
	def refine_func(self):
		global isGF
		global Slot_refine
		global select_item_refineID,special_itemID
		if isGF:
			try:
				a = int(self.textUpTo.GetText())
			except:
				a = 1
			vlist = [20016, 20043, 20044, 20045, 20046]
			vnum = self.ScanBlacksmiths(vlist)
			dist = GetDis(vnum)
			if self.upList.GetCurrentText() == 'Blacksmith':
				if not vnum:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.NO_BLACKSMITH)
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.FIND_BLACKSMITH_OR_DIF)
					return
				if dist >= 2000:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.BLACKSMITH_AWAY)
					return
			for i in range(int(a)):
				if self.upList.GetCurrentText() == 'Blacksmith':
					net.SendGiveItemPacket(vnum, 1, select_item_refineID, 1)
					sendRefinePacket(select_item_refineID, -2)
				if self.upList.GetCurrentText() == 'Scroll of Blessing':
					for InventorySlot in range(player.INVENTORY_PAGE_SIZE*10):
						ItemValue = player.GetItemIndex(InventorySlot)
						if ItemValue == 25040:
							SendItemUseToItemPacket(InventorySlot, select_item_refineID)
							sendRefinePacket(select_item_refineID, 0)
							break
				if self.upList.GetCurrentText() == 'Magic Metal':
					for InventorySlot in range(player.INVENTORY_PAGE_SIZE*10):
						ItemValue = player.GetItemIndex(InventorySlot)
						if ItemValue == 25041:
							SendItemUseToItemPacket(InventorySlot, select_item_refineID)
							sendRefinePacket(select_item_refineID, 0)
							break
				if self.upList.GetCurrentText() == 'Special item':
					for InventorySlot in range(player.INVENTORY_PAGE_SIZE*10):
						ItemValue = player.GetItemIndex(InventorySlot)
						if ItemValue == int(special_itemID):
							SendItemUseToItemPacket(InventorySlot, select_item_refineID)
							sendRefinePacket(select_item_refineID, 0)
		else:
			try:
				a = int(self.textUpTo.GetText())
				for i in range(int(a)):
					if self.upList.GetCurrentText() == 'Blacksmith':
						if self.refineNewWindow.checked==1:
							sendRefinePacket(select_item_refineID, 0, 0, 0, 0, 100)
						else:
							sendRefinePacket(select_item_refineID, 0)
					if self.upList.GetCurrentText() == 'Guild Blacksmith':
						if self.refineNewWindow.checked==1:
							sendRefinePacket(select_item_refineID, 1, 0, 0, 0, 100)
						else:
							sendRefinePacket(select_item_refineID, 1)
					if self.upList.GetCurrentText() == 'Scroll of Blessing':
						for InventorySlot in range(player.INVENTORY_PAGE_SIZE*10):
							ItemValue = player.GetItemIndex(InventorySlot)
							if ItemValue == 25040:
								SendItemUseToItemPacket(InventorySlot, select_item_refineID)
								if self.refineNewWindow.checked==1:
									sendRefinePacket(select_item_refineID, 2, 0, 0, 0, 100)
								else:
									sendRefinePacket(select_item_refineID, 2)
								break
					if self.upList.GetCurrentText() == 'Magic Metal':
						for InventorySlot in range(player.INVENTORY_PAGE_SIZE*10):
							ItemValue = player.GetItemIndex(InventorySlot)
							if ItemValue == 25041:
								SendItemUseToItemPacket(InventorySlot, select_item_refineID)
								if self.refineNewWindow.checked==1:
									sendRefinePacket(select_item_refineID, 2, 0, 0, 0, 100)
								else:
									sendRefinePacket(select_item_refineID, 2)
								break
					if self.upList.GetCurrentText() == 'DT':
						if self.refineNewWindow.checked==1:
							sendRefinePacket(select_item_refineID, 4, 0, 0, 0, 100)
						else:
							sendRefinePacket(select_item_refineID, 4)
						break
					if self.upList.GetCurrentText() == 'Special item':
						for InventorySlot in range(player.INVENTORY_PAGE_SIZE*10):
							ItemValue = player.GetItemIndex(InventorySlot)
							if ItemValue == int(special_itemID):
								SendItemUseToItemPacket(InventorySlot, select_item_refineID)
								if self.refineNewWindow.checked==1:
									sendRefinePacket(select_item_refineID, 2, 0, 0, 0, 100)
								else:
									sendRefinePacket(select_item_refineID, 2)
								break
			except:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hItem refiner: " + lang.STR_ERR_OCCURED)
	def UpdateFileList(self):
		try:
			self.Gui[3].RemoveAllItems()
		except:
			pass
		for i in range(player.INVENTORY_PAGE_SIZE * 10):
			ItemIndex = player.GetItemIndex(i)
			if ItemIndex != 0:
				selectItem(ItemIndex)
				item.GetItemName(ItemIndex)
				ItemName = item.GetItemName()
				self.Gui[3].AppendItem(Item(str(i) + "	" + str(ItemIndex) + "	" + ItemName))
	def createGuild_func(self):
		try:
			nameguild = self.guildname.GetText()
			nameguildx = (str(nameguild))
			net.SendAnswerMakeGuildPacket(nameguildx)
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hGuild creator: " + lang.STR_ERR_OCCURED)
	def donate_func(self):
		global exp_state
		try:
			self.donate_funcx.XX1(1)
			self.donate_funcx.XX2(self.donate_func)
			if not isConnect():
				self.donate_funcx.XX1(3)
				return
			self.donateBtn.Hide()
			self.donateBtnStop.Show()
			self.exp_state=1
			guildName = guild.GetGuildName()
			curEXP = int(player.GetStatus(player.EXP))
			nextEXP = int(player.GetStatus(player.NEXT_EXP))
			curPoint = min(curEXP, nextEXP)
			curPoint = max(curPoint, 0)
			maxPoint = max(nextEXP, 0)
			percent = round((float(curPoint) / float(maxPoint)) * 100, 2)
			reqPercent = self.guildWhenPerc.GetText()
			level = player.GetStatus(player.LEVEL)
			reqLevel = self.guildFrom.GetText()
			if guildName != "":
				if float(level) >= float(reqLevel):
					if float(percent) >= float(reqPercent):
						net.SendGuildOfferPacket(curEXP)
						return
		except:
			pass
	def funcKeysOff(self):		
		self.funcxKeys.XX1(9999999)
		self.funcxKeys.XX2(self.funcKeysOff)
		eventHandler.remove("KeyFunc")
	def keyFunc(self, key):		
		player.RequestUseLocalQuickSlot(key)
		
		
	
	def setColorBtn(self, btn, color):
		try:
			btn.ButtonText.SetFontColor(*color)
		except:
			pass
	def funcKeys(self):
		global key1, key2, key3, key4, keyf1, keyf2, keyf3, keyf4
		self.funcxKeys.XX1(5)
		self.funcxKeys.XX2(self.funcKeys)
		if not isConnect():
			return
		if foundx64PythonList:
			try:
				if key1:
					eventHandler.add(0, lambda: self.keyFunc(0), 'KeyFunc')
				if key2:
					eventHandler.add(0.5, lambda: self.keyFunc(1), 'KeyFunc')	
				if key3:
					eventHandler.add(1, lambda: self.keyFunc(2), 'KeyFunc')
				if key4:
					eventHandler.add(1.5, lambda: self.keyFunc(3), 'KeyFunc')	
				if keyf1:
					eventHandler.add(2, lambda: self.keyFunc(4), 'KeyFunc')
				if keyf2:
					eventHandler.add(2.5, lambda: self.keyFunc(5), 'KeyFunc')
				if keyf3:
					eventHandler.add(3, lambda: self.keyFunc(6), 'KeyFunc')
				if keyf4:
					eventHandler.add(3.5, lambda: self.keyFunc(7), 'KeyFunc')
			except:
				self.funcKeysOff()
		else:
			try:
				if key1:
					player.RequestUseLocalQuickSlot(0)
				if key2:
					player.RequestUseLocalQuickSlot(1)		
				if key3:
					player.RequestUseLocalQuickSlot(2)
				if key4:
					player.RequestUseLocalQuickSlot(3)		
				if keyf1:
					player.RequestUseLocalQuickSlot(4)
				if keyf2:
					player.RequestUseLocalQuickSlot(5)		
				if keyf3:
					player.RequestUseLocalQuickSlot(6)
				if keyf4:
					player.RequestUseLocalQuickSlot(7)
			except:
				self.funcKeysOff()
	def funcKey1(self):
		global key1 
		
		
		if key1 == False:
			key1 = True
		elif key1 == True:
			key1 = False
			
		if key1:
			color = self.comp.RGB(73, 235, 52)
		else:
			color = self.comp.RGB(255, 255, 255)
		self.setColorBtn(self.btnPress1, color)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPress quick slot 1, set to: " + str(key1))
	def funcKey2(self):
		global key2 
		if key2 == False:
			key2 = True
		elif key2 == True:
			key2 = False
			
		if key2:
			color = self.comp.RGB(73, 235, 52)
		else:
			color = self.comp.RGB(255, 255, 255)
		self.setColorBtn(self.btnPress2, color)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPress quick slot 2, set to: " + str(key2))
	def funcKey3(self):
		global key3 
		if key3 == False:
			key3 = True
		elif key3 == True:
			key3 = False
			
		if key3:
			color = self.comp.RGB(73, 235, 52)
		else:
			color = self.comp.RGB(255, 255, 255)
		self.setColorBtn(self.btnPress3, color)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPress quick slot 3, set to: " + str(key3))
	def funcKey4(self):
		global key4 
		if key4 == False:
			key4 = True
		elif key4 == True:
			key4 = False
			
		if key4:
			color = self.comp.RGB(73, 235, 52)
		else:
			color = self.comp.RGB(255, 255, 255)
		self.setColorBtn(self.btnPress4, color)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPress quick slot 4, set to: " + str(key4))
	def funcKeyf1(self):
		global keyf1 
		if keyf1 == False:
			keyf1 = True
		elif keyf1 == True:
			keyf1 = False
			
		if keyf1:
			color = self.comp.RGB(73, 235, 52)
		else:
			color = self.comp.RGB(255, 255, 255)
		self.setColorBtn(self.btnPressF1, color)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPress quick slot F1, set to: " + str(keyf1))
	def funcKeyf2(self):
		global keyf2 
		if keyf2 == False:
			keyf2 = True
		elif keyf2 == True:
			keyf2 = False
		if keyf2:
			color = self.comp.RGB(73, 235, 52)
		else:
			color = self.comp.RGB(255, 255, 255)
		self.setColorBtn(self.btnPressF2, color)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPress quick slot F2, set to: " + str(keyf2))
	def funcKeyf3(self):
		global keyf3 
		if keyf3 == False:
			keyf3 = True
		elif keyf3 == True:
			keyf3 = False
			
		if keyf3:
			color = self.comp.RGB(73, 235, 52)
		else:
			color = self.comp.RGB(255, 255, 255)
		self.setColorBtn(self.btnPressF3, color)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPress quick slot F3, set to: " + str(keyf3))
	def funcKeyf4(self):
		global keyf4 
		if keyf4 == False:
			keyf4 = True
		elif keyf4 == True:
			keyf4 = False
			
		if keyf4:
			color = self.comp.RGB(73, 235, 52)
		else:
			color = self.comp.RGB(255, 255, 255)
		self.setColorBtn(self.btnPressF4, color)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPress quick slot F4, set to: " + str(keyf4))
	def donate_funcOff(self):
		global exp_state
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hExp donator disabled.")
		self.donate_funcx.XX1(9999999)
		self.donate_funcx.XX2(self.donate_funcOff)
		self.donateBtn.Show()
		self.donateBtnStop.Hide()
		self.exp_state=0
	def keepHotkeyOff(self):
		self.keepxHotkey.XX1(9999999)
		self.keepxHotkey.XX2(self.keepHotkeyOff)
	def keepHotkeyOn(self):
		try:
			if self.metin2_window.IsShow():
				self.keepxHotkey.XX1(0.01)
				self.keepxHotkey.XX2(self.keepHotkeyOn)
				pos = self.metin2_window.GetGlobalPosition()
				self.hotkeysWindow.SetPosition(pos[0] + (self.metin2_window.GetWidth() - self.metin2_window.GetWidth() - self.hotkeysWindow.GetWidth()),pos[1])
			else:
				self.keepHotkeyOff()
		except:
			self.keepHotkeyOff()
	def openHotkey(self):
		if self.hotkeysWindow.IsShow():
			self.hotkeysWindow.Hide()
			self.keepHotkeyOff()
		else:
			self.hotkeysWindow.Show()
			self.keepHotkeyOn()
	def openWiki(self):
		global isGF
		aaaa = '\x53\x54\x4d\x4f\x44'
		if isGF:
			os.startfile('https://wiki.' + aaaa + '.net/' + aaaa + '-officials')
		else:
			os.startfile('https://wiki.' + aaaa + '.net/' + aaaa + '-pservers/')
	def setPanic(self, arg):
		global panicMode,tempAntiBan
		if arg:
			panicMode = 0
			pauseFuncs(0)
			if tempAntiBan:
				self.funcAntiBanStart()
				tempAntiBan = 0
			self.panicBtn.Hide()
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hPANIC: Disabled!")
		self.askPanic.Close()
		self.askPanic = None
	def disablePanic(self):
		line2 = 0
		
		if find_string(st_cur_server, "aronix") or  find_string(st_cur_server, "metin2sg") or foundx64PythonList:
			dialog = uiCommon.QuestionDialog()
		else:
			try:
				dialog = QuestionDialog2()
				line2 = 1
			except:
				if hasattr(uiCommon, 'QuestionDialog2'):
					dialog = uiCommon.QuestionDialog2()
					line2 = 1
				else:
					dialog = QuestionDialog()
		self.askPanic = dialog
		if line2:
			self.askPanic.SetText1("Panic mode is enabled.")
			self.askPanic.SetText2("Would you like to disable it?")
		else:
			self.askPanic.SetText("Panic mode is enabled, Would you like to disable it?")
		self.askPanic.SetAcceptEvent(lambda: self.setPanic(1))
		self.askPanic.SetCancelEvent(lambda: self.setPanic(0))
		self.askPanic.Open()
		return
	def relogFunc(self):
		global OldRecv,game
		try:
			if not game:
				import game
			game.GameWindow.OpenQuestWindow = OldRecv
		except:
			pass
		try:
			chr.PushOnceMotion(chr.MOTION_INTRO_SELECTED, 0.1)
		except:
			pass
		if find_string(st_cur_server, "oficial"):
			net.SetAccountConnectorHandler(0)
		net.DirectEnter(0,0)
		tempRelogTime = 0
	def KickMe(self):
		global isGF
		if isGF:
			net.LogOutGame()
			net.SendPostAllGetItems()
			self.Debug()
			eventHandler.add(0.5, self.Debug, 'Debug')
		else:
			if find_string(st_cur_server, "oficial"):
				net.SetAccountConnectorHandler(0)
			net.DirectEnter(0)
			net.LogOutGame()
	def sortAutoOff(self):
		self.sortAutox.XX1(9999999)
		self.sortAutox.XX2(self.sortAutoOff)
	def sortAutoOn(self):
		self.sortAutox.XX1(5)
		self.sortAutox.XX2(self.sortAutoOn)
		if not isConnect():
			return
		self.sort_func()
	def useingameCH(self):
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hChecking this box \x53\x54\x4d\x6f\x64 will try to switch channels based on game's channel changer, if available.")
	def stackingAutoOff(self):
		self.stackingAutox.XX1(9999999)
		self.stackingAutox.XX2(self.stackingAutoOff)
	def stackingAutoOn(self):
		self.stackingAutox.XX1(5)
		self.stackingAutox.XX2(self.stackingAutoOn)
		if not isConnect():
			return
		self.stackingNow()
	def disableForce(self):		
		UnHookSetHPTargetBoard()
		self.onlyPickup.OnToggleUp()
	def showRouteWaitInfo(self):
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.TAB_FARM_WAITSTEPSINFO1)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.TAB_FARM_WAITSTEPSINFO2)
		msg("")
	def enableForce(self):
		HookSetHPTargetBoard()
	def stackingNow(self):
		items_arr = dict()
		try:
			max_stack = int(self.maxStackx.GetText())
		except:
			max_stack = 200
		self.toStackMoveActions = []
		for i in range(player.INVENTORY_PAGE_SIZE * 10):
			idx = player.GetItemIndex(i)
			if idx != 0:
				if idx not in items_arr:
					items_arr[idx] = [player.GetItemCount(i),i]
					continue
				count = player.GetItemCount(i)
				total_sum = count + items_arr[idx][0]
				if total_sum < max_stack:
					items_arr[idx][0] = total_sum
					self.toStackMoveActions.append((i,items_arr[idx][1],count))
				else:
					excess = total_sum - max_stack
					self.toStackMoveActions.append((i,items_arr[idx][1],count - excess))
					items_arr[idx][0] = excess
					items_arr[idx][1] = i
				args = self.toStackMoveActions.pop(0)
				MoveItem(args[0],args[1],args[2])
	def OnConnectButton(self, id):
		if id > len(channels):
			return
		if self.selected_channel is not None:
			try:
				channels[self.selected_channel]['btn'].ButtonText.SetFontColor(*self.comp.RGB(200, 200, 200))
			except:
				pass
		self.selected_channel = id
		first_ch = None
		for ch in channels:
			first_ch = ch
			break
		if first_ch == 0:
			id += 1
		try:
			channels[id]['btn'].ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
		except:
			pass
		self.refreshChannels()
		self.ChangeChannelById(id)
	def setChangingCH(self):		
		global isChangingCH
		isChangingCH = 0
	def ConnectToChannel(self):
		global farmEnable,isSelChar,isChangingCH,isGF
		if farmEnable == 1:
			self.farmingx2Func.XX1(10)
			self.farmingx2Func.XX2(self.farmingFunc2)
		ch = self.selectedChannel["id"]
		if isConnect():
			isChangingCH = 1
			if isGF:
				net.ConnectTCP(self.selectedChannel["ip"],self.selectedChannel["port"])
				try:
					eventHandler.add(4, self.relogMe)
				except:
					pass
			else:
				if self.useGameCH.checked == 1 and not find_string(st_cur_server, "calliope"):
					server_commands = {
						"/ch ": ["luminus"],
						"/fc ": ["rohan"],
						"/kanal ": ["m2khan"],
						"/move_channel ": ["atheria", "esteria","Solana", "Emerald", "Esenn", "Vidra", "Odessa", "ImperiaWorld", "Valoron", "Metin2GB", "sepherion", "lastworld", "aiver"],
						"/channel_switch ": ["Metin.World", "kronius"],
						"/change_channel ": ["Origins", "Honor", "Zenaris", "Atlas", "mylenium", "Metin2Severin", "LandOfHeroes", "SoW2", "Lucerna", "Veshia", "rhodium","Zemia", "Sancy", "Land Of Heroes", "avelo", "janes", "Xhelia", "bamboo", "Aerion", "OldSchool", "leonis", "thrones", "2set", "eden2"],
						"MoveChannelGame": ["ageofmagis", "Sirah", "Nethara", "Sineria","zaris","hunter","arezzo"],
						"ChangeChannel": ["WoM2"]
					}
					command_to_execute = None
					for command, servers in server_commands.items():
						for server in servers:
							if find_string(st_cur_server, server):
								command_to_execute = command
								break
						if command_to_execute:
							break
					if command_to_execute:
						if command_to_execute == "MoveChannelGame" and hasattr(net, 'MoveChannelGame'):
							net.MoveChannelGame(ch)
						elif command_to_execute == "ChangeChannel" and hasattr(net, 'ChangeChannel'):
							net.ChangeChannel(ch)
						else:
							SendChatPacket(str(command_to_execute) + " " + str(ch))
					else:
						SendChatPacket("/channel " + str(ch))
				else:
					if not (find_string(st_cur_server, "Mosha") or isGF or find_string(st_cur_server, "oficial")):
						net.Disconnect()
					if find_string(st_cur_server, "oficial"):
						net.HaiCuServeru(self.selectedChannel["ip"], self.selectedChannel["port"], '81.180.203.77', 11004)
					else:
						net.ConnectTCP(self.selectedChannel["ip"], self.selectedChannel["port"])
					eventHandler.add(4, self.relogMe, 'ConnectToGame')
			eventHandler.add(15, self.setChangingCH, 'setChangingCH')
	def ChangeChannelById(self, id):
		try:
			self.selectedChannel = channels[int(id)]
			self.currState = STATE_CHANGING_CHANNEL
			self.ConnectToChannel()
		except:
			pass
	def SetStateNone(self):
		self.selectedChannel = 0
		self.currState = STATE_NONE
	if isGF:
		def refreshChannels(self):
			global isGeneralTab, isFarmingTab
			if self.metin2_window.IsShow() and isGeneralTab:
				GetChannels()
				x = 19
				y = 50
				self.selected_channel = None
				first_ch = None
				for ch in channels:
					first_ch = ch
					break
				if first_ch is not None:
					channel_ids = list(channels)
					channel_ids.sort()
					for id in channel_ids:
						if first_ch == 0:
							channels[id]['btn'] = self.comp.Button(self.pnlChanger, 'CH ' + str(id+1), '', x, y,
																			getCallBackWithArg(self.OnConnectButton, int(id)),
																			small1,
																			small2,
																			small3)
						elif first_ch == 1:
							channels[id]['btn'] = self.comp.Button(self.pnlChanger, 'CH ' + str(id), '', x, y,
																			getCallBackWithArg(self.OnConnectButton, int(id)),
																			small1,
																			small2,
																			small3)
						try:
							serverCH = net.GetServerInfo()
							channel_number = None
							found_digit = False
							for char in serverCH:
								if char.isdigit():
									found_digit = True
									if channel_number is None:
										channel_number = int(char)
									else:
										channel_number = channel_number * 10 + int(char)
								elif found_digit:
									break
							if channel_number is not None:
								channels[id]['btn'].ButtonText.SetFontColor(*self.comp.RGB(200, 200, 200))
								channels[channel_number]['btn'].ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
						except:
							channels[id]['btn'].ButtonText.SetFontColor(*self.comp.RGB(200, 200, 200))
						if x >= 19:
							x = 19
							y += 22
	else:
		
		def refreshChannels(self):
			global newPython,isGeneralTab
			if self.metin2_window.IsShow() and isGeneralTab:
				GetChannels()
	
				if len(channels) > 10:
					x_start = 0
				else:
					x_start = 19
			
				y_start = 40
				x = x_start
				y = y_start
				column_limit = 10
				button_height = 18
				column_spacing = 40
				self.selected_channel = None
				first_ch = None
			
				for ch in channels:
					first_ch = ch
					break
			
				if first_ch is not None:
					if newPython:
						try:
							channel_ids = sorted(channels.keys())
						except:
							channel_ids = list(channels.keys())
							channel_ids.sort()
					else:
						channel_ids = channels.keys()
						channel_ids.sort() 
	
					index = 0
					for id in channel_ids:
						channels[id]['btn'] = self.comp.Button(
							self.pnlChanger, 'CH ' + str(id), '', x, y,
							getCallBackWithArg(self.OnConnectButton, int(id)),
							small1, small2, small3
						)
	
						index += 1
						if index % column_limit == 0:
							x += column_spacing  
							y = y_start 
						else:
							y += button_height  
			
						try:
							if find_string(st_cur_server, "SoW2") or find_string(st_cur_server, "Secret of World") or \
								find_string(st_cur_server, "Sancy") or find_string(st_cur_server, "Zemia") or \
								find_string(st_cur_server, "lucerna") or find_string(st_cur_server, "veshia") or find_string(st_cur_server, "rhodium") or \
								find_string(st_cur_server, "next2play"):
								from pygame.net import GetServerInfo
								serverCH = GetServerInfo()
							else:
								serverCH = net.GetServerInfo()
	
							channel_number = None
							found_digit = False
			
							for char in serverCH:
								if char.isdigit():
									found_digit = True
									if channel_number is None:
										channel_number = int(char)
									else:
										channel_number = channel_number * 10 + int(char)
								elif found_digit:
									break
			
							try:
								if channel_number is not None:
									channels[id]['btn'].ButtonText.SetFontColor(*self.comp.RGB(200, 200, 200))
									channels[channel_number]['btn'].ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
							except:
								pass
						except:
							try:
								channels[id]['btn'].ButtonText.SetFontColor(*self.comp.RGB(200, 200, 200))
							except:
								pass
	
	def zoomfog_func(self):
		try:
			self.zoomfogBtn.Hide()
			self.zoomfogBtnStop.Show()
			self.zoomfog_funcx.XX1(5)
			self.zoomfog_funcx.XX2(self.zoomfog_func)
			if not isConnect():
				return
			try:
				app.SetCameraMaxDistance(100000)
			except:
				pass
			try:
				app.SetMinFog(100000)
			except:
				pass
			self.zoom_state=1
		except:
			self.zoomfog_funcOff()
	def zoomfog_funcOff(self):
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hZoom & no fog disabled.")
		self.zoomfog_funcx.XX1(9999999)
		self.zoomfog_funcx.XX2(self.zoomfog_funcOff)
		self.zoomfogBtn.Show()
		self.zoomfogBtnStop.Hide()
		try:
			app.SetCameraMaxDistance(3000)
			app.SetMinFog(100)
		except:
			pass
		self.zoom_state=0
	def use_item_relog_func(self):
		global Item_User_Relog_ID
		for i in range(player.INVENTORY_PAGE_SIZE*10):
			item_index = player.GetItemIndex(i)
			if item_index == (int(Item_User_Relog_ID)):
				useItemFunc(i)	
				break
	if isGF:
		def relogMe(self):
			global tempRelogTime
			account = player.GetMainCharacterName()
			try:
				chr.PushOnceMotion(chr.MOTION_INTRO_SELECTED, 0.1)
			except:
				pass
			net.DirectEnter(0,0)
			tempRelogTime = 0
	else:	
		def relogMe(self):
			global tempRelogTime
			account = player.GetMainCharacterName()
			iddd = 0
			try:
				for accID in range(4):
					charname = net.GetAccountCharacterSlotDataString(accID, 1)
					if charname in account and charname != '':
						iddd = accID
						break
			except:
				pass
			chr.SelectInstance(iddd)
			if find_string(st_cur_server, "oficial"):
				net.SetAccountConnectorHandler(iddd)
			net.DirectEnter(iddd)
			tempRelogTime = 0
	def testFunc(self):
		try:
			self.QuestionDialog = PopupDialog()
		except:
			self.QuestionDialog = uiCommon.PopupDialog()
		self.QuestionDialog.SetText("Are you sure you want to close this client?")
		self.QuestionDialog.Open()
	def if_remove_item_btn_func1(self):		
		if find_string(st_cur_server, "aronix") or  find_string(st_cur_server, "metin2sg") or foundx64PythonList:
			self.QuestionDialog = uiCommon.QuestionDialog()
		else:
			self.QuestionDialog = QuestionDialog()
		self.QuestionDialog.SetText(lang.STR_REM_PICK)
		self.QuestionDialog.SetAcceptEvent(__mem_func__(self.remove_pick_list))
		self.QuestionDialog.SetCancelEvent(__mem_func__(self.endClientStop))
		self.QuestionDialog.Open()
	def import_community(self, module_name):
		file = open_file(st_path + '/Data/Python/Community/%s' % (module_name), 'r+')
		module_code = file.read()
		module_globals = {}
		file.close()
		exec(module_code, module_globals)
		return module_globals
	def load_com_script(self):
		try:
			script = self.scripts_list.DropList.GetSelectedItem().textBox.GetText()
			self.import_community(str(script))
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hScript |cff00FF00|H|h'" + script + "'|cffFFFF00|H|h was loaded succesfully")
		except Exception:
			try:
				exc_type, exc_value, exc_traceback = sys.exc_info()
				err = exc_type.__name__
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFailed to load: |cff00FF00|H|h'%s' !" %(script))
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hError Title: %s" % (str(err)))
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hError Details: %s" % (str(exc_value)))
			except:
				pass
	def emtpyFunc(self):			
		pass
	def closeClientFunc(self):
		if find_string(st_cur_server, "aronix") or find_string(st_cur_server, "metin2sg") or foundx64PythonList:
			self.QuestionDialog = uiCommon.QuestionDialog()
		else:
			self.QuestionDialog = QuestionDialog()
		self.QuestionDialog.SetText(lang.STR_CLOSE)
		self.QuestionDialog.SetAcceptEvent(__mem_func__(self.endClient))
		self.QuestionDialog.SetCancelEvent(__mem_func__(self.endClientStop))
		self.QuestionDialog.Open()
	def clearTextFunc(self):
		self.spamtexteditline.SetText("")
		self.endClientStop()
	def remove_pick_list(self):
		global pickupFilterwhitelist,ITEM_FILTER_LIST,iVID,pickupFilterwhitelist
		try:
			self.if_list_list_white.RemoveAllItems()
		except:
			pass
		self.ITEM_FILTER_LIST=[]
		pickupFilterwhitelist=[]
		self.ITEM_FILTER_LIST=[]
		self.ITEM_FILTER_WHITELIST=[]
		self.endClientStop()
	def endClient(self):
		try:
			universalTime(0)
		except:
			pass
	def endClientStop(self):
		self.QuestionDialog.Close()
		self.QuestionDialog = None
	def mBtn_func(self):
		global streamer
		self.metin2_window.Hide()
		if not streamer:
			self.showButton.Show()
		try:
			self.CloseDopy()
		except:
			pass
		try:
			self.closeChWindow()
		except:
			pass		
		try:
			self.saveSettings()
		except:
			pass
		self.bossEditorWindow.Hide()
		self.playersOnlineWindow.Hide()
		self.visible = 0
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h\x53\x54\x4d\x6f\x64 " + lang.HIDDEN_WIN1)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.HIDDEN_WIN2)
	def xBtn_func(self):
		self.metin2_window.Hide()
		try:
			self.CloseDopy()
		except:
			pass
		self.visible = 0
	def ClearSpamFunc(self):
		if find_string(st_cur_server, "aronix") or  find_string(st_cur_server, "metin2sg") or foundx64PythonList:
			self.QuestionDialog = uiCommon.QuestionDialog()
		else:
			self.QuestionDialog = QuestionDialog()
		self.QuestionDialog.SetText(lang.STR_REM_SPAM)
		self.QuestionDialog.SetAcceptEvent(__mem_func__(self.clearTextFunc))
		self.QuestionDialog.SetCancelEvent(__mem_func__(self.endClientStop))
		self.QuestionDialog.Open()
######################################## Farm FUNCS #########################################
	def DivideToFloat(self,x, y):
		try:
			return x * (y**-1)
		except:
			return 0
	def GetTmpTeleport(self,DestX, DestY):
		global DivideToFloat
		(PlayerX, PlayerY, PlayerZ) = player.GetMainCharacterPosition()
		DifX = DestX - PlayerX
		DifY = DestY - PlayerY
		Vektor = self.DivideToFloat(2000, math.sqrt(DifX**2 + DifY**2))
		TempX = PlayerX + Vektor*DifX
		TempY = PlayerY + Vektor*DifY
		Count = self.DivideToFloat((DestX - PlayerX), (Vektor*DifX))
		return (TempX, TempY, Count)
	def Debug(self):
		onKeyDown(appKey('UP'))
		if foundx64PythonList:
			onKeyUp(player.DIR_UP)	
		else:
			onKeyUp(appKey('UP'))
	def TeleportToDest(self, aimx, aimy):
		step_distance = 20
		cur_position = player.GetMainCharacterPosition()
		curx = cur_position[0]
		cury = cur_position[1]
		total_distance = math.sqrt((aimx - curx)**2 + (aimy - cury)**2)
		steps = int(total_distance // step_distance)
		if steps > 0:
			step_x = (aimx - curx) / float(steps) 
			step_y = (aimy - cury) / float(steps)
		else:
			step_x = 0
			step_y = 0
		myVid = getCharIndex()
		for _ in range(steps):
			curx += step_x
			cury += step_y
			chr.SelectInstance(myVid)
			setPixelPos(int(curx), int(cury))
			self.Debug()
		chr.SelectInstance(myVid)
		setPixelPos(int(aimx), int(aimy))
		self.Debug() 
		global TeleportState
		TeleportState = 1
	def disable_rem_settings(self):
		self.QuestionDialog.Close()
		self.QuestionDialog = None
	def remove_settings(self):
		global CONFIG,ITEMS_TO_SELL,CONFIG_FISH,CONFIG_ITEMS,CONFIG_PRICE
		setting = ''
		settingx = self.settingsList.GetSelectedItem()
		if not settingx:
			setting = str(getcharName())
		else:
			setting = settingx.GetText()
		try:
			CONFIG_PRICE = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_priceconfig.st_set'
			os.remove(CONFIG_PRICE)
		except:
			pass			
		try:
			CONFIG_ITEMS = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_config_item_user.st_set'
			os.remove(CONFIG_ITEMS)
		except:
			pass			
		try:
			CONFIG_FISH = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_fishing.st_set'
			os.remove(CONFIG_FISH)
		except:
			pass			
		try:
			ITEMS_TO_SELL = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_sell_items.st_set'
			os.remove(ITEMS_TO_SELL)
		except:
			pass				
		try:
			CONFIG = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_config.st_set'
			os.remove(CONFIG)
		except:
			pass	
		self.disable_rem_settings()
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.STR_REM_SETTINGS)
		self.addAllSettings()
	def reset_settings_func(self):
		setting = ''
		settingx = self.settingsList.GetSelectedItem()
		if not settingx:
			setting = str(getcharName())
		else:
			setting = settingx.GetText()
		if find_string(st_cur_server, "aronix") or  find_string(st_cur_server, "metin2sg") or foundx64PythonList:
			self.QuestionDialog = uiCommon.QuestionDialog()
		else:
			self.QuestionDialog = QuestionDialog()
		self.QuestionDialog.SetText("Are you sure you want to delete '" + str(setting) + "' setting?")
		self.QuestionDialog.SetAcceptEvent(__mem_func__(self.remove_settings))
		self.QuestionDialog.SetCancelEvent(__mem_func__(self.disable_rem_settings))
		self.QuestionDialog.Open()
	def call_function(self, config_key, function, *args):
		try:
			config_value = str(ReadConfig(config_key))
			if string_contains("True", config_value) or string_contains("1", config_value):
				function(*args)
		except:
			pass
	def set_text(self, text_field, config_key):
		try:
			text_field.SetText(ReadConfig(config_key))
		except:
			pass
	def check_config_value(self, config_key):
		try:
			config_value = str(ReadConfig(config_key))
			return string_contains("True", config_value) or string_contains("1", config_value)
		except:
			return False
	def clear_duplicates(self):
		for controls in self.npc_duplicate_controls:
			for control in controls:
				control.Hide() 
		self.npc_duplicate_controls = []
		for controls in self.quest_duplicate_controls:
			for control in controls:
				control.Hide()
		self.quest_duplicate_controls = []
	def create_duplicates(self):
		for i in range(self.npc_duplicate_count):
			y_offset = (i + 1) * 25
			new_lblDungeonVnum = self.comp.TextLine(self.pnlDungeon, lang.NPC_VNUM, 9, 35 + y_offset, self.comp.RGB(255, 255, 255))
			new_txtDungeonVnum, new_dungeonVnum = self.comp.EditLine(self.pnlDungeon, '0', 80, 35 + y_offset, 40, 15, 20)
			new_dungeonVnum.SetNumberMode()
			new_getVnumBtn = self.comp.Button(self.pnlDungeon, lang.GET_VNUM, '', 130, 33 + y_offset, lambda ed=new_dungeonVnum: self.getDungeonVnum(ed), middle1, middle2, middle3)
			self.npc_duplicate_controls.append((new_lblDungeonVnum, new_txtDungeonVnum, new_dungeonVnum, new_getVnumBtn))
		for i in range(self.quest_duplicate_count):
			y_offset = (i + 1) * 25
			new_clickQuest = CheckBox(lang.CLICK_QUEST)
			new_clickQuest.SetParent(self.pnlDungeon)
			new_clickQuest.SetPosition(400, 35 + y_offset)
			new_clickQuest.Show()
			new_txtDungeonQuestIndex, new_DungeonQuestIndex = self.comp.EditLine(self.pnlDungeon, '0', 535, 37 + y_offset, 25, 15, 3)
			new_DungeonQuestIndex.SetNumberMode()
			self.quest_duplicate_controls.append((new_clickQuest, new_txtDungeonQuestIndex, new_DungeonQuestIndex))
	def loadsettingsFunc(self):
		global Items_Slots, Items_VNUM,autologin_state
		global CONFIG,ITEMS_TO_SELL,CONFIG_FISH,CONFIG_ITEMS,CONFIG_PRICE
		global zoom_state
		global gm_state
		global player_state
		global exp_state
		global dews_state
		global restart_state
		global state_fantom
		global red_state
		global red_e_state
		global blue_state
		global blue_e_state
		global day_state
		global night_state
		global oneh_state
		global twoh_state
		global speed_state
		global vit_state
		global int_state
		global str_state
		global dex_state
		global p1_state
		global p2_state
		global p3_state
		global p4_state
		global p5_state
		global p6_state
		global farm1_state
		global farm2_state
		global mining_state
		global pick1_state
		global pick2_state
		global lvl_state
		global attack_state
		global moblock_state
		global item_user_state
		global hotkey_state
		global one_hit_state
		global capes_state
		global sk1_state
		global sk2_state
		global sk3_state
		global sk4_state
		global sk5_state
		global sk6_state
		global str_body_state
		global xFishbot_KillFishes
		global xFishbot_OpenClams
		global xFishbot_SellFish
		global xFishbot_SellHair
		global xFishbot_SwitchArmor
		global xFishbot_SellMinnow
		global xFishbot_SellCrap
		global xFishbot_UpgradeRod
		global xFishbot_Cancel_Animation
		global xFishbot_DisableQuests
		global xFishbot_FishernumVnum
		global xFishbot_DefaultShopIndex
		global xFishbot_BuyBait
		global xFishbot_BuyBaitShopIndex
		global xFishbot_BuyBaitQ
		global xFishbot_Bait_Minnow
		global xFishbot_Bait_Other
		global xFishbot_Bait_Worm
		global xFishbot_Bait_Paste
		global setMountVnumFarm
		global pickSpeed,farmEnable,sellItemsFunction,rangedMobber
		global changeCHRouteState
		global changeCHNothingState,fish_state,skillsList,skillsBuffList
		global key1, key2, key3, key4, keyf1, keyf2, keyf3, keyf4,dungeonState,dragItemId,dragItem
		global dragItem2, dragItemId2,megaConfirm,isGF
		global dragItem3, dragItemId3,AUTO_ACCEPT_FRIEND
		global buff1SkillUsage,buff2SkillUsage,buff3SkillUsage,followTargetStatus,BuffBotState,defaultRot,maxThreshhold,rangeX,rangeY,streamer,sortDelay
		try:
			import os
		except:
			pass
		try:
			if os.path.exists(CONFIG_ITEMS):
				cfg = open_file(CONFIG_ITEMS, 'r+').read().split()
				y = 1
				z = 0
				for k in range(0,28):
					self.gives.ClearSlot(k)
					self.gives.RefreshSlot()
				for x in range(0,28):
					Items_VNUM[x] = cfg[y]
					Items_Slots[x] = cfg[z]
					self.gives.SetItemSlot(int(cfg[z]), int(cfg[y]))
					y = y + 2
					z = z + 2
					if y >= 56:
						break
		except:
			pass
		try:
			pickSpeed = ReadConfig("Pickup_Speed")
			plm = float(pickSpeed) / 10
			if pickSpeed <= 0.01:
				pickSpeed = 0.1
				plm = 0.1
			self.lblPickSpeed.SetText(str(pickSpeed) + str("0 s"))
			self.pickupSpeed.SetSliderPos(plm)
		except:
			pass	
		try:
			pickSpeed = ReadConfig("Pickup_Speed")
			plm = round(float(pickSpeed) / 10,2)
			self.lblPickSpeed.SetText('%0.2f sec' % pickSpeed)
			self.pickupSpeed.SetSliderPos(plm)
		except:
			pass
		if isGF:
			try:
				if string_contains(ReadConfig("Normal_Pickup"), "True") or string_contains(ReadConfig("Normal_Pickup"), "1"):
					self.normalPickup.OnToggleDown()
				else:
					self.normalPickup.OnToggleUp()
			except:
				pass
		try:
			self.pickupRange.SetSliderPos(float(ReadConfig("Pickup_Range")))
			rangePick = float(self.pickupRange.GetSliderPos())
			self.lblPickRange.SetText(str(int(rangePick*10000)))
			pickRange = str(int(rangePick*10000))
		except:
			pass	
		try:
			self.waithackRange.SetSliderPos(float(ReadConfig("Waithack_Range")))
			rangeWH = float(self.waithackRange.GetSliderPos())
			self.waithackRangeLbl2.SetText(str(int(rangeWH*10000)))
			whRange = str(int(rangeWH*10000))
		except:
			pass
		try:
			self.waithackSpeed.SetSliderPos(float(ReadConfig("Waithack_Speed")))
			speed = float(self.waithackSpeed.GetSliderPos())
			self.waithackSpeedLbl2.SetText(str(int(speed*1000)) + ' ms')
		except:
			pass
		try:
			self.waithackMonsters.SetSliderPos(float(ReadConfig("Waithack_Monsters")))
			maxMonster = int(self.waithackMonsters.GetSliderPos()*100)
			self.waithackMonstersLbl2.SetText(str(maxMonster))
		except:
			pass
		try:
			if string_contains(ReadConfig("Pickup_RandomSpeed"), "True") or string_contains(ReadConfig("Pickup_RandomSpeed"), "1"):
				self.randomizePickup.OnToggleDown()
			else:
				self.randomizePickup.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("WallHack"), "True") or string_contains(ReadConfig("WallHack"), "1"):
				self.WallhackOn()
			else:
				self.WallhackOff()
		except:
			pass
		try:
			if string_contains(ReadConfig("FeedPet"), "True") or string_contains(ReadConfig("FeedPet"), "1"):
				self.feedPet.OnToggleDown()
			else:
				self.feedPet.OnToggleUp()
		except:
			pass
			
		try:
			if string_contains(ReadConfig("RadarMetin"), "True") or string_contains(ReadConfig("RadarMetin"), "1"):
				self.showMetins.OnToggleDown()
			else:
				self.showMetins.OnToggleUp()
		except:
			pass	
		try:
			if string_contains(ReadConfig("Pickup_WalkToItem"), "True") or string_contains(ReadConfig("Pickup_WalkToItem"), "1"):
				self.walkToItem.OnToggleDown()
			else:
				self.walkToItem.OnToggleUp()
		except:
			pass	
			
		try:
			if string_contains(ReadConfig("ApproachTarget"), "True") or string_contains(ReadConfig("ApproachTarget"), "1"):
				self.approachTarget.OnToggleDown()
			else:
				self.approachTarget.OnToggleUp()
		except:
			pass
			
			
			
			
		try:
			if string_contains(ReadConfig("ManualVidRange"), "True") or string_contains(ReadConfig("ManualVidRange"), "1"):
				self.vidRangeLbl1.OnToggleDown()
				
				if not isGF:
					self.decreaseVidRangeBtn.Hide()
					self.VidRangeTxt.Hide()
					self.VidRangeVal.Hide()
					self.increaseVidRangeBtn.Hide()
					self.applyVidRangeBtn.Hide()
				
			else:
				self.vidRangeLbl1.OnToggleUp()
		except:
			pass
			
		try:
			if string_contains(ReadConfig("RadarBoss"), "True") or string_contains(ReadConfig("RadarBoss"), "1"):
				self.showBoss.OnToggleDown()
			else:
				self.showBoss.OnToggleUp()
		except:
			pass
			
		try:
			if string_contains(ReadConfig("RadarPortals"), "True") or string_contains(ReadConfig("RadarPortals"), "1"):
				self.showPortals.OnToggleDown()
			else:
				self.showPortals.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("RadarMobs"), "True") or string_contains(ReadConfig("RadarMobs"), "1"):
				self.showMobs.OnToggleDown()
			else:
				self.showMobs.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("RadarOre"), "True") or string_contains(ReadConfig("RadarOre"), "1"):
				self.showOre.OnToggleDown()
			else:
				self.showOre.OnToggleUp()
		except:
			pass					
		try:
			if string_contains(ReadConfig("RadarPlayer"), "True") or string_contains(ReadConfig("RadarPlayer"), "1"):
				self.showPlayer.OnToggleDown()
			else:
				self.showPlayer.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("RadarGM"), "True") or string_contains(ReadConfig("RadarGM"), "1"):
				self.showGM.OnToggleDown()
			else:
				self.showGM.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("RadarNPC"), "True") or string_contains(ReadConfig("RadarNPC"), "1"):
				self.showNPC.OnToggleDown()
			else:
				self.showNPC.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Autologin_UseCredentials"), "True") or string_contains(ReadConfig("Autologin_UseCredentials"), "1"):
				self.useCredentials.OnToggleDown()
			else:
				self.useCredentials.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("RadarRoute"), "True") or string_contains(ReadConfig("RadarRoute"), "1"):
				self.drawRoute.OnToggleDown()
			else:
				self.drawRoute.OnToggleUp()
		except:
			pass
			
		try:
			if string_contains(ReadConfig("RadarFarmRange"), "True") or string_contains(ReadConfig("RadarFarmRange"), "1"):
				self.drawFarmRange.OnToggleDown()
			else:
				self.drawFarmRange.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("RadarInitialFarmRange"), "True") or string_contains(ReadConfig("RadarInitialFarmRange"), "1"):
				self.drawInitialFarmRange.OnToggleDown()
			else:
				self.drawInitialFarmRange.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Waithack_AttackMetin"), "True") or string_contains(ReadConfig("Waithack_AttackMetin"), "1"):
				self.whMetins.OnToggleDown()
			else:
				self.whMetins.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Waithack_AttackMob"), "True") or string_contains(ReadConfig("Waithack_AttackMob"), "1"):
				self.whMonsters.OnToggleDown()
			else:
				self.whMonsters.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Waithack_AttackBoss"), "True") or string_contains(ReadConfig("Waithack_AttackBoss"), "1"):
				self.whBosses.OnToggleDown()
			else:
				self.whBosses.OnToggleUp()
		except:
			pass	
		try:
			if string_contains(ReadConfig("SkipTargetNotReach"), "True") or string_contains(ReadConfig("SkipTargetNotReach"), "1"):
				self.skipTarget.OnToggleDown()
			else:
				self.skipTarget.OnToggleUp()
		except:
			pass
		try:
			self.targetTimeoutValue.SetText(ReadConfig("SkipTargetNotReachSeconds"))
		except:
			pass			
			
			
		try:
			if string_contains(ReadConfig("Waithack_WaitIfHP"), "True") or string_contains(ReadConfig("Waithack_WaitIfHP"), "1"):
				self.pauseWaithackIf.OnToggleDown()
			else:
				self.pauseWaithackIf.OnToggleUp()
		except:
			pass
		try:
			self.jigsawChestCount.SetText(ReadConfig("JigsawChestCount"))
		except:
			pass
			
			
		try:
			if string_contains(ReadConfig("JigsawOpenMultiple"), "True") or string_contains(ReadConfig("JigsawOpenMultiple"), "1"):
				self.openJigsawChest.OnToggleDown()
			else:
				self.openJigsawChest.OnToggleUp()
		except:
			pass
		try:
			self.QuitGMPMTimes.SetText(ReadConfig("Detector_GMQuitPMTimes"))
		except:
			pass			
		try:
			self.dungeonNumber.SetText(ReadConfig("DungeonNumberVal"))
		except:
			pass			
		try:
			self.pauseWaithackValue.SetText(ReadConfig("Waithack_WaitHPValue"))
		except:
			pass
		try:
			self.pauseWaithackValue.SetText(ReadConfig("Waithack_WaitHPValue"))
		except:
			pass
		try:
			if string_contains(ReadConfig("Waithack_AttackPlayer"), "True") or string_contains(ReadConfig("Waithack_AttackPlayer"), "1"):
				self.whPlayers.OnToggleDown()
			else:
				self.whPlayers.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Waithack_Wall"), "True") or string_contains(ReadConfig("Waithack_Wall"), "1"):
				self.waithackBlocked.OnToggleDown()
			else:
				self.waithackBlocked.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Waithack_Blocked"), "True") or string_contains(ReadConfig("Waithack_Blocked"), "1"):
				self.waithackBlocked2.OnToggleDown()
			else:
				self.waithackBlocked2.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Energy_BuyAvailable"), "True") or string_contains(ReadConfig("Energy_BuyAvailable"), "1"):
				self.buyAvailable.OnToggleDown()
			else:
				self.buyAvailable.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_CheckForOnlineUsers"), "True") or string_contains(ReadConfig("Antiban_CheckForOnlineUsers"), "1"):
				self.stopBotIfPlayerOnline.OnToggleDown()
			else:
				self.stopBotIfPlayerOnline.OnToggleUp()
				
			
		except:
			pass
			
		try:
			self.refreshOnlinePlayersList()
		except:
			pass
		try:
			if string_contains(ReadConfig("RandomizeMiningTime"), "True") or string_contains(ReadConfig("RandomizeMiningTime"), "1"):
				self.randomizeMiningTime.OnToggleDown()
			else:
				self.randomizeMiningTime.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Send_WinNotify_OnPM"), "True") or string_contains(ReadConfig("Send_WinNotify_OnPM"), "1"):
				self.notifyPM.OnToggleDown()
			else:
				self.notifyPM.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Energy_BuyFromShop"), "True") or string_contains(ReadConfig("Energy_BuyFromShop"), "1"):
				self.buyFromShop.OnToggleDown()
			else:
				self.buyFromShop.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("PickupEnabled"), "True") or string_contains(ReadConfig("PickupEnabled"), "1"):
				self.normalPickup.OnToggleDown()
			else:
				self.normalPickup.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Energy_UseRoute"), "True") or string_contains(ReadConfig("Energy_UseRoute"), "1"):
				self.energyRoute.OnToggleDown()
			else:
				self.energyRoute.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Energy_UseRoute"), "True") or string_contains(ReadConfig("Energy_UseRoute"), "1"):
				self.energyRoute.OnToggleDown()
			else:
				self.energyRoute.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("ExcludeItems"), "True") or string_contains(ReadConfig("ExcludeItems"), "1"):
				self.excludeItems.OnToggleDown()
			else:
				self.excludeItems.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("ItemsFirst"), "True") or string_contains(ReadConfig("ItemsFirst"), "1"):
				self.itemsFirst.OnToggleDown()
			else:
				self.itemsFirst.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("BlockItems"), "True") or string_contains(ReadConfig("BlockItems"), "1"):
				self.blockedItems.OnToggleDown()
			else:
				self.blockedItems.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Pickup_IgnoreList"), "True") or string_contains(ReadConfig("Pickup_IgnoreList"), "1"):
				self.ignorePickList.OnToggleDown()
			else:
				self.ignorePickList.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Energy_AutoCreate"), "True") or string_contains(ReadConfig("Energy_AutoCreate"), "1"):
				self.crystal.OnToggleDown()
			else:
				self.crystal.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Energy_StopYang"), "True") or string_contains(ReadConfig("Energy_StopYang"), "1"):
				self.stopYang.OnToggleDown()
			else:
				self.stopYang.OnToggleUp()
		except:
			pass
		try:
			self.fragval.SetText(ReadConfig("Energy_AmmountCrystals"))
		except:
			pass 
		try:
			self.yangval.SetText(ReadConfig("Energy_YangValue"))
		except:
			pass 
		try:
			self.sortDelayTxt.SetText(ReadConfig("DefaultSortDelay"))
			sortDelay = ReadConfig("DefaultSortDelay")
		except:
			pass			
		try:
			self.textRed.SetText(ReadConfig("Red_pots"))
		except:
			pass
		try:
			self.textBlue.SetText(ReadConfig("Blue_pots"))
		except:
			pass
		try:
			self.SpeedValue.SetText(ReadConfig("Speed_hack"))
		except:
			pass
		try:
			self.StringEditline.SetText(ReadConfig("Confirm_string"))
		except:
			pass
		try:
			self.useItemDelay.SetText(ReadConfig("Item_Use_delay"))
		except:
			pass 
		try:
			self.mobberSec.SetText(ReadConfig("Use_capes_delay"))
		except:
			pass 
		try:
			self.mobberId.SetText(ReadConfig("Capes_ID"))
		except:
			pass
		try:
			self.shopIndex.SetText(ReadConfig("Energy_Shop_Index")) 
		except:
			pass
		try:
			self.relogBotDelay.SetText(ReadConfig("RelogBotDelay"))
		except:
			pass
		try:
			self.delay_textbox.SetText(ReadConfig("Fishbot_delay"))
		except:
			pass
		try:
			megaConfirm = ReadConfig("MegaMobberConfirmation")
		except:
			pass
		try:
			self.clear_duplicates()
		except:
			pass
		try:
			self.quest_duplicate_count = int(ReadConfig("QuestDuplicateCount"))
		except:
			self.quest_duplicate_count = 0
		try:
			self.npc_duplicate_count = int(ReadConfig("NpcDuplicateCount"))
		except:
			self.npc_duplicate_count = 0
		self.create_duplicates()
		try:
			self.dungeonVnum.SetText(ReadConfig("DungeonVNUM"))
		except:
			pass
		try:
			for i in range(1, self.npc_duplicate_count + 1):
				self.npc_duplicate_controls[i - 1][2].SetText(ReadConfig("DungeonVNUM_" + str(i)))
		except:
			pass
		try:
			self.DungeonQuestIndex.SetText(ReadConfig("DungeonQuestIndex"))
		except:
			pass
		for i in range(1, self.quest_duplicate_count + 1):
			try:
				self.quest_duplicate_controls[i - 1][2].SetText(ReadConfig("DungeonQuestIndex_" + str(i)))
			except:
				pass
		try:
			if string_contains(ReadConfig("DungeonClickQuest"), "True") or string_contains(ReadConfig("DungeonClickQuest"), "1"):
				self.clickQuest.OnToggleDown()
			else:
				self.clickQuest.OnToggleUp()
		except:
			pass
		for i in range(1, self.quest_duplicate_count + 1):
			try:
				if string_contains(ReadConfig("DungeonClickQuest_" + str(i)), "True") or string_contains(ReadConfig("DungeonClickQuest_" + str(i)), "1"):
					self.quest_duplicate_controls[i - 1][0].OnToggleDown()
				else:
					self.quest_duplicate_controls[i - 1][0].OnToggleUp()
			except:
				pass
		try:
			vidrange = ReadConfig("VidRANGE")
			if vidrange != None:
				self.VidRangeVal.SetText(ReadConfig("VidRANGE"))
			self.applyVidRangeFunc()
		except:
			pass
		try:
			self.buffBotDelayTxt.SetText(ReadConfig("BuffBotDelay"))
		except:
			pass			
		try:
			self.spamtexteditline.SetText(ReadConfig("Spam_text"))
		except:
			pass
		try:
			self.spamdelayeditline.SetText(ReadConfig("Spam_delay"))
		except:
			pass
		try:
			self.energyDelay.SetText(ReadConfig("Energy_Delay")) 
		except:
			pass 
		try:
			self.split_item_to_value.SetText(ReadConfig("Split_into"))
		except:
			pass 
		try:
			self.slotBuyBot.SetText(ReadConfig("Buy_sell_slot"))
		except:
			pass
		try:
			self.delayBuyBot.SetText(ReadConfig("Buy_sell_delay"))
		except:
			pass
		try:
			self.slotUseBot.SetText(ReadConfig("Buy_use_slot"))
		except:
			pass 
		try:
			self.delayUseBot.SetText(ReadConfig("Buy_use_delay"))
		except:
			pass
		try:
			self.npctoBuyLocX.SetText(ReadConfig("NPC_X_Coord"))
		except:
			pass 
		try:
			self.npctoBuyLocY.SetText(ReadConfig("NPC_Y_Coord"))
		except:
			pass
		try:
			self.alchemistLocX.SetText(ReadConfig("Alchemist_X_Coord"))
		except:
			pass
		try:
			self.alchemistLocY.SetText(ReadConfig("Alchemist_Y_Coord"))
		except:
			pass 
		try:
			self.buyFromShopValue.SetText(ReadConfig("Items_to_buy"))
		except:
			pass
		try:
			self.npcVnum.SetText(ReadConfig("NPC_Vnum"))
		except:
			pass
		key1 = self.check_config_value("Use_quickSlot_1")
		key2 = self.check_config_value("Use_quickSlot_2")
		key3 = self.check_config_value("Use_quickSlot_3")
		key4 = self.check_config_value("Use_quickSlot_4")
		keyf1 = self.check_config_value("Use_quickSlot_F1")
		keyf2 = self.check_config_value("Use_quickSlot_F2")
		keyf3 = self.check_config_value("Use_quickSlot_F3")
		keyf4 = self.check_config_value("Use_quickSlot_F4")
		quick_slots = {
			"Use_quickSlot_1": "btnPress1",
			"Use_quickSlot_2": "btnPress2",
			"Use_quickSlot_3": "btnPress3",
			"Use_quickSlot_4": "btnPress4",
			"Use_quickSlot_F1": "btnPressF1",
			"Use_quickSlot_F2": "btnPressF2",
			"Use_quickSlot_F3": "btnPressF3",
			"Use_quickSlot_F4": "btnPressF4",
		}
		
		for key, btn_attr in quick_slots.items():
			key_value = self.check_config_value(key)
			
			if key_value:
				color = self.comp.RGB(73, 235, 52)
			else:
				color = self.comp.RGB(255, 255, 255)
			
			self.setColorBtn(getattr(self, btn_attr), color)
		
			
		# if key1:
			# color1 = self.comp.RGB(73, 235, 52)
		# else:
			# color1 = self.comp.RGB(255, 255, 255)
	
		# if key2:
			# color2 = self.comp.RGB(73, 235, 52)
		# else:
			# color2 = self.comp.RGB(255, 255, 255)
			
		# if key3:
			# color3 = self.comp.RGB(73, 235, 52)
		# else:
			# color3 = self.comp.RGB(255, 255, 255)
	
		# if key4:
			# color4 = self.comp.RGB(73, 235, 52)
		# else:
			# color4 = self.comp.RGB(255, 255, 255)			
			
		# if keyf1:
			# colorf1 = self.comp.RGB(73, 235, 52)
		# else:
			# colorf1 = self.comp.RGB(255, 255, 255)
	
		# if keyf2:
			# colorf2 = self.comp.RGB(73, 235, 52)
		# else:
			# colorf2 = self.comp.RGB(255, 255, 255)			
		# if keyf3:
			# colorf3 = self.comp.RGB(73, 235, 52)
		# else:
			# colorf3 = self.comp.RGB(255, 255, 255)
	
		# if keyf4:
			# colorf4 = self.comp.RGB(73, 235, 52)
		# else:
			# colorf4 = self.comp.RGB(255, 255, 255)
	
	
		# self.setColorBtn(self.btnPress1, color1)
		# self.setColorBtn(self.btnPress2, color2)
		# self.setColorBtn(self.btnPress3, color3)
		# self.setColorBtn(self.btnPress4, color4)
		# self.setColorBtn(self.btnPressF1, colorf1)
		# self.setColorBtn(self.btnPressF2, colorf2)
		# self.setColorBtn(self.btnPressF3, colorf3)
		# self.setColorBtn(self.btnPressF4, colorf4)
		try:
			defaultRot = ReadConfig("Fishbot_CharacterRotation")
		except:
			pass			
		try:
			self.followTargetName.SetText(ReadConfig("TargetNameToFollow"))
		except:
			pass
		try:
			self.stopquitLevel.SetText(ReadConfig("StopQuitBotAtLevel"))
		except:
			pass
		try:
			self.usedews_delay.SetText(ReadConfig("Use_dews_delay"))
		except:
			pass
		try:
			self.fbot_delay.SetText(ReadConfig("Bot_delay"))
		except:
			pass 
		try:
			self.buyFromSlot.SetText(ReadConfig("Buy_from_slot"))
		except:
			pass 		
		try:
			self.skipMetinDelay.SetText(ReadConfig("SkipMetinAfter"))
		except:
			pass 
		try:
			self.useHpLower.SetText(ReadConfig("UseItem_HpLow_When"))
		except:
			pass 
		try:
			self.waitMinutesDelay.SetText(ReadConfig("WaitBefore_Minutes"))
		except:
			pass 
		try:
			self.quitBotDelay.SetText(ReadConfig("QuitBot_Minutes"))
		except:
			pass 
		try:
			self.stopBotDelay.SetText(ReadConfig("StopBot_Minutes"))
		except:
			pass 
		try:
			self.changeCHIn.SetText(ReadConfig("ChangeCH_InSeconds")) 
		except:
			pass 			
		try:
			self.SellItemsDelay.SetText(ReadConfig("SDItems_Delay")) 
		except:
			pass
		try:
			self.stopquitLogout.SetText(ReadConfig("QuitBot_IfLoggedOutTime")) 
		except:
			pass 
		try:
			if string_contains(ReadConfig("AutoreplyTimes"), "True") or string_contains(ReadConfig("AutoreplyTimes"), "1"):
				self.replyTimesBox.OnToggleDown()
			else:
				self.replyTimesBox.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Antiban_StopFarmbotPlayer"), "True") or string_contains(ReadConfig("Antiban_StopFarmbotPlayer"), "1"):
				self.stopFarmbotCB1.OnToggleDown()
			else:
				self.stopFarmbotCB1.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_StopFishPlayer"), "True") or string_contains(ReadConfig("Antiban_StopFishPlayer"), "1"):
				self.stopFishbotCB1.OnToggleDown()
			else:
				self.stopFishbotCB1.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Antiban_StopEnergyPlayer"), "True") or string_contains(ReadConfig("Antiban_StopEnergyPlayer"), "1"):
				self.stopEnergyCB1.OnToggleDown()
			else:
				self.stopEnergyCB1.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Antiban_StopSkillPlayer"), "True") or string_contains(ReadConfig("Antiban_StopSkillPlayer"), "1"):
				self.stopSkillCB1.OnToggleDown()
			else:
				self.stopSkillCB1.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Antiban_StopPickPickPlayer"), "True") or string_contains(ReadConfig("Antiban_StopPickPickPlayer"), "1"):
				self.stopPickCB1.OnToggleDown()
			else:
				self.stopPickCB1.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Antiban_StopSpamPlayer"), "True") or string_contains(ReadConfig("Antiban_StopSpamPlayer"), "1"):
				self.stopSpamCB1.OnToggleDown()
			else:
				self.stopSpamCB1.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Antiban_StopItemPlayer"), "True") or string_contains(ReadConfig("Antiban_StopItemPlayer"), "1"):
				self.stopItemUserCB1.OnToggleDown()
			else:
				self.stopItemUserCB1.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_StopAttackPlayer"), "True") or string_contains(ReadConfig("Antiban_StopAttackPlayer"), "1"):
				self.stopAttackCB1.OnToggleDown()
			else:
				self.stopAttackCB1.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_StopMoblockPlayer"), "True") or string_contains(ReadConfig("Antiban_StopMoblockPlayer"), "1"):
				self.stopMoblockCB1.OnToggleDown()
			else:
				self.stopMoblockCB1.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Antiban_StopMobberPlayer"), "True") or string_contains(ReadConfig("Antiban_StopMobberPlayer"), "1"):
				self.stopMobberCB1.OnToggleDown()
			else:
				self.stopMobberCB1.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_StopOneHitPlayer"), "True") or string_contains(ReadConfig("Antiban_StopOneHitPlayer"), "1"):
				self.stopOneHitCB1.OnToggleDown()
			else:
				self.stopOneHitCB1.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_StopUseHorsePlayer"), "True") or string_contains(ReadConfig("Antiban_StopUseHorsePlayer"), "1"):
				self.stopHorseCB1.OnToggleDown()
			else:
				self.stopHorseCB1.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_StopAutoReplyPlayer"), "True") or string_contains(ReadConfig("Antiban_StopAutoReplyPlayer"), "1"):
				self.stopReplyCB1.OnToggleDown()
			else:
				self.stopReplyCB1.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_StopSellBotPlayer"), "True") or string_contains(ReadConfig("Antiban_StopSellBotPlayer"), "1"):
				self.stopSellCB1.OnToggleDown()
			else:
				self.stopSellCB1.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_StopBuffBotPlayer"), "True") or string_contains(ReadConfig("Antiban_StopBuffBotPlayer"), "1"):
				self.stopBuff1.OnToggleDown()
			else:
				self.stopBuff1.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_StopFollowTargetPlayer"), "True") or string_contains(ReadConfig("Antiban_StopFollowTargetPlayer"), "1"):
				self.stopFollowTarget1.OnToggleDown()
			else:
				self.stopFollowTarget1.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_StopAutoRestartPlayer"), "True") or string_contains(ReadConfig("Antiban_StopAutoRestartPlayer"), "1"):
				self.stopRevive1.OnToggleDown()
			else:
				self.stopRevive1.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_StopBuffBotGM"), "True") or string_contains(ReadConfig("Antiban_StopBuffBotGM"), "1"):
				self.stopBuff2.OnToggleDown()
			else:
				self.stopBuff2.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_StopFollowTargetGM"), "True") or string_contains(ReadConfig("Antiban_StopFollowTargetGM"), "1"):
				self.stopFollowTarget2.OnToggleDown()
			else:
				self.stopFollowTarget2.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_SetWalkingPlayer"), "True") or string_contains(ReadConfig("Antiban_SetWalkingPlayer"), "1"):
				self.setWalking1.OnToggleDown()
			else:
				self.setWalking1.OnToggleUp()
		except:
			pass				
		try:
			if string_contains(ReadConfig("Antiban_SetWalkingGM"), "True") or string_contains(ReadConfig("Antiban_SetWalkingGM"), "1"):
				self.setWalking2.OnToggleDown()
			else:
				self.setWalking2.OnToggleUp()
		except:
			pass				
		try:
			if string_contains(ReadConfig("Antiban_StopAutoRestartGM"), "True") or string_contains(ReadConfig("Antiban_StopAutoRestartGM"), "1"):
				self.stopRevive2.OnToggleDown()
			else:
				self.stopRevive2.OnToggleUp()
		except:
			pass
			
		try:
			if string_contains(ReadConfig("Antiban_AcceptFriendRequest"), "True") or string_contains(ReadConfig("Antiban_AcceptFriendRequest"), "1"):
				self.playerAutoAcceptFriend.OnToggleDown()
				AUTO_ACCEPT_FRIEND = 1
			else:
				self.playerAutoAcceptFriend.OnToggleUp()
				AUTO_ACCEPT_FRIEND = 0
		except:
			pass			
		try:
			if string_contains(ReadConfig("Antiban_AutoAcceptPlayer"), "True") or string_contains(ReadConfig("Antiban_AutoAcceptPlayer"), "1"):
				self.AutoAcceptPlayer.OnToggleDown()
			else:
				self.AutoAcceptPlayer.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Antiban_StopFarmbotGM"), "True") or string_contains(ReadConfig("Antiban_StopFarmbotGM"), "1"):
				self.stopFarmbotCB2.OnToggleDown()
			else:
				self.stopFarmbotCB2.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Antiban_StopFishGM"), "True") or string_contains(ReadConfig("Antiban_StopFishGM"), "1"):
				self.stopFishbotCB2.OnToggleDown()
			else:
				self.stopFishbotCB2.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Antiban_StopEnergyGM"), "True") or string_contains(ReadConfig("Antiban_StopEnergyGM"), "1"):
				self.stopEnergyCB2.OnToggleDown()
			else:
				self.stopEnergyCB2.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Antiban_StopSkillGM"), "True") or string_contains(ReadConfig("Antiban_StopSkillGM"), "1"):
				self.stopSkillCB2.OnToggleDown()
			else:
				self.stopSkillCB2.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Antiban_StopPickPickGM"), "True") or string_contains(ReadConfig("Antiban_StopPickPickGM"), "1"):
				self.stopPickCB2.OnToggleDown()
			else:
				self.stopPickCB2.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Antiban_StopSpamGM"), "True") or string_contains(ReadConfig("Antiban_StopSpamGM"), "1"):
				self.stopSpamCB2.OnToggleDown()
			else:
				self.stopSpamCB2.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Antiban_StopItemGM"), "True") or string_contains(ReadConfig("Antiban_StopItemGM"), "1"):
				self.stopItemUserCB2.OnToggleDown()
			else:
				self.stopItemUserCB2.OnToggleUp()
		except:
			pass		
		try:
			if string_contains(ReadConfig("Antiban_StopAttackGM"), "True") or string_contains(ReadConfig("Antiban_StopAttackGM"), "1"):
				self.stopAttackCB2.OnToggleDown()
			else:
				self.stopAttackCB2.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_StopMoblockGM"), "True") or string_contains(ReadConfig("Antiban_StopMoblockGM"), "1"):
				self.stopMoblockCB2.OnToggleDown()
			else:
				self.stopMoblockCB2.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Antiban_StopMobberGM"), "True") or string_contains(ReadConfig("Antiban_StopMobberGM"), "1"):
				self.stopMobberCB2.OnToggleDown()
			else:
				self.stopMobberCB2.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_StopOneHitGM"), "True") or string_contains(ReadConfig("Antiban_StopOneHitGM"), "1"):
				self.stopOneHitCB2.OnToggleDown()
			else:
				self.stopOneHitCB2.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_StopUseHorseGM"), "True") or string_contains(ReadConfig("Antiban_StopUseHorseGM"), "1"):
				self.stopHorseCB2.OnToggleDown()
			else:
				self.stopHorseCB2.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_StopAutoReplyGM"), "True") or string_contains(ReadConfig("Antiban_StopAutoReplyGM"), "1"):
				self.stopReplyCB2.OnToggleDown()
			else:
				self.stopReplyCB2.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_StopSellBotGM"), "True") or string_contains(ReadConfig("Antiban_StopSellBotGM"), "1"):
				self.stopSellCB2.OnToggleDown()
			else:
				self.stopSellCB2.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Antiban_AutoAcceptGM"), "True") or string_contains(ReadConfig("Antiban_AutoAcceptGM"), "1"):
				self.AutoAcceptCB2.OnToggleDown()
			else:
				self.AutoAcceptCB2.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("QuitIfLoggedOut"), "True") or string_contains(ReadConfig("QuitIfLoggedOut"), "1"):
				self.quitIfLogout.OnToggleDown()
			else:
				self.quitIfLogout.OnToggleUp()
		except:
			pass
		try:
			self.skillbotDelay.SetText(ReadConfig("SkillbotDelay")) 
		except:
			pass 
		try:
			if string_contains(ReadConfig("AutoHide"), "True") or string_contains(ReadConfig("AutoHide"), "1"):
				self.autoHide.OnToggleDown()
			else:
				self.autoHide.OnToggleUp()
		except:
			pass			
		try:
			self.pauseFishFor.SetText(ReadConfig("Fishbot_PauseFor"))
		except:
			pass
		try:
			self.pauseFishEach.SetText(ReadConfig("Fishbot_PauseEach"))
		except:
			pass
		try:
			if string_contains(ReadConfig("Fishbot_PauseEachMinute"), "True") or string_contains(ReadConfig("Fishbot_PauseEachMinute"), "1"):
				self.pauseFishing.OnToggleDown()
			else:
				self.pauseFishing.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("RandomizeFishDelay"), "True") or string_contains(ReadConfig("RandomizeFishDelay"), "1"):
				self.randomizeFish.OnToggleDown()
			else:
				self.randomizeFish.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("DoNotAttack"), "True") or string_contains(ReadConfig("DoNotAttack"), "1"):
				self.doNotAttack.OnToggleDown()
			else:
				self.doNotAttack.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("StopPickupIfPlayer"), "True") or string_contains(ReadConfig("StopPickupIfPlayer"), "1"):
				self.playerStopPickup.OnToggleDown()
			else:
				self.playerStopPickup.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("InitRouteClosest"), "True") or string_contains(ReadConfig("InitRouteClosest"), "1"):
				self.initRouteClosest.OnToggleDown()
			else:
				self.initRouteClosest.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("RelogBotXMinutes"), "True") or string_contains(ReadConfig("RelogBotXMinutes"), "1"):
				self.relogBotCb.OnToggleDown()
			else:
				self.relogBotCb.OnToggleUp()
		except:
			pass				
		try:
			if string_contains(ReadConfig("RestartFarmbotIfNothing"), "True") or string_contains(ReadConfig("RestartFarmbotIfNothing"), "1"):
				self.restartNothing.OnToggleDown()
			else:
				self.restartNothing.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Energy_BuyAvailable"), "True") or string_contains(ReadConfig("Energy_BuyAvailable"), "1"):
				self.buyAvailable.OnToggleDown()
			else:
				self.buyAvailable.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("RelogIfNothingToattack"), "True") or string_contains(ReadConfig("RelogIfNothingToattack"), "1"):
				self.relogNothing.OnToggleDown()
			else:
				self.relogNothing.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Sell_Items_Box"), "True") or string_contains(ReadConfig("Sell_Items_Box"), "1"):
				self.sellThem.OnToggleDown()
			else:
				self.sellThem.OnToggleUp()
		except:
			pass
			
		try:
			self.sellBonusCount.SetText(ReadConfig("Sell_Items_Function_BonusCount"))
		except:
			pass
		try:
			if string_contains(ReadConfig("Sell_Items_Check_BonusCount"), "True") or string_contains(ReadConfig("Sell_Items_Check_BonusCount"), "1"):
				self.checkBonusCount.OnToggleDown()
			else:
				self.checkBonusCount.OnToggleUp()
		except:
			pass	
			
		try:
			if string_contains(ReadConfig("Destroy_Items_Box"), "True") or string_contains(ReadConfig("Destroy_Items_Box"), "1"):
				self.destroyThem.OnToggleDown()
			else:
				self.destroyThem.OnToggleUp()
		except:
			pass	
			
		try:
			if hasattr(net, 'SendItemExtractEnergyPacket'):
				if string_contains(ReadConfig("ItemSeller_Shards"), "True") or string_contains(ReadConfig("ItemSeller_Shards"), "1"):
					self.extractShards.OnToggleDown()
				else:
					self.extractShards.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Use_Hotkeys"), "True") or string_contains(ReadConfig("Use_Hotkeys"), "1"):
				self.hotKeyCB.OnToggleDown()
				self.HotkeyRelog()
			else:
				self.hotKeyCB.OnToggleUp()
				self.HotkeyRelogStop()
		except:
			pass
		try:
			if string_contains(ReadConfig("SkipSkillAnimations"), "True") or string_contains(ReadConfig("SkipSkillAnimations"), "1"):
				self.useInstant.OnToggleDown()
			else:
				self.useInstant.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("ChangeCH_Route"), "True") or string_contains(ReadConfig("ChangeCH_Route"), "1"):
				self.changeCHRoute.OnToggleDown()
			else:
				self.changeCHRoute.OnToggleUp()
		except:
			pass
		try:
			skillsBuffList = []
			skillsBuffList = ReadBuffSkillConfig("BuffSkillsOrder")
			if skillsBuffList:
				idx = 4
				for skillBtn in [self.BuffskillBtn1, self.BuffskillBtn3, self.BuffskillBtn2]:
					if idx in skillsBuffList:
						skillBtn.Down()
					else:
						skillBtn.SetUp()
					idx += 1
		except:
			pass
		try:
			skillsList = []
			skillsList = ReadSkillConfig("SkillsOrder")
			if skillsList:
				idx = 1
				for skillBtn in [self.skillBtn1, self.skillBtn2, self.skillBtn3, self.skillBtn4, self.skillBtn5, self.skillBtn6]:
					if idx in skillsList:
						skillBtn.Down()
					else:
						skillBtn.SetUp()
					idx += 1
		except:
			pass
		try:
			if string_contains(ReadConfig("BuffBotState"), "True") or string_contains(ReadConfig("BuffBotState"), "1"):
				self.BuffBotUsage('on')
				self.startBuffbot.Down()
			else:
				self.BuffBotUsage('off')
				self.startBuffbot.SetUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("FollowTargetStatus"), "True") or string_contains(ReadConfig("FollowTargetStatus"), "1"):
				self.followTargetBtn.Hide()
				self.followTargetBtnStop.Show()
				self.followTarget_func()
			else:
				self.followTargetBtn.Show()
				self.followTargetBtnStop.Hide()
				self.followTarget_funcOff()
		except:
			pass
		try:
			if string_contains(ReadConfig("SkillbotState"), "True") or string_contains(ReadConfig("SkillbotState"), "1"):
				self.startSkillbot.Down()
				self.skillUsage('on')
			else:
				self.startSkillbot.SetUp()
				self.skillUsage('off')
		except:
			pass
		try:
			if string_contains(ReadConfig("PauseAttack"), "True") or string_contains(ReadConfig("PauseAttack"), "1"):
				self.pauseAttack.OnToggleDown()
			else:
				self.pauseAttack.OnToggleUp()
		except:
			pass		
		try:
			if string_contains(ReadConfig("ChangeCH_Nothing"), "True") or string_contains(ReadConfig("ChangeCH_Nothing"), "1"):
				self.changeCHNothing.OnToggleDown()
			else:
				self.changeCHNothing.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("RangedMobber"), "True") or string_contains(ReadConfig("RangedMobber"), "1"):
				self.megaCb.OnToggleDown()
			else:
				self.megaCb.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Skip_MetinIfAttackedFor"), "True") or string_contains(ReadConfig("Skip_MetinIfAttackedFor"), "1"):
				self.skipMetin.OnToggleDown()
			else:
				self.skipMetin.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("QuitBot_After"), "True") or string_contains(ReadConfig("QuitBot_After"), "1"):
				self.quitBotCb.OnToggleDown()
			else:
				self.quitBotCb.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("StopBot_After"), "True") or string_contains(ReadConfig("StopBot_After"), "1"):
				self.stopBotCb.OnToggleDown()
			else:
				self.stopBotCb.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("WaitBeforeLoggingIn"), "True") or string_contains(ReadConfig("WaitBeforeLoggingIn"), "1"):
				self.waitMinCb.OnToggleDown()
			else:
				self.waitMinCb.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("UseItemHpLow"), "True") or string_contains(ReadConfig("UseItemHpLow"), "1"):
				self.useItemHpLow.OnToggleDown()
			else:
				self.useItemHpLow.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("GoTo_Next_Target_Quick"), "True") or string_contains(ReadConfig("GoTo_Next_Target_Quick"), "1"):
				self.force.OnToggleDown()
			else:
				self.force.OnToggleUp()
		except:
			pass
			
		try:
			if string_contains(ReadConfig("Only_Pickup_After"), "True") or string_contains(ReadConfig("Only_Pickup_After"), "1"):
				self.onlyPickup.OnToggleDown()
			else:
				self.onlyPickup.OnToggleUp()
		except:
			pass
			
		try:
			if string_contains(ReadConfig("Autologin"), "True") or string_contains(ReadConfig("Autologin"), "1"):
				self.relogBtn_func()
			else:
				self.relogBtn_funcOff()
		except:
			pass
		try:
			if string_contains(ReadConfig("Zoom"), "True") or string_contains(ReadConfig("Zoom"), "1"):
				self.zoomfog_func()
			else:
				self.zoomfog_funcOff()
		except:
			pass 
		try:
			self.exp_state=ReadConfig("EXP_Donator")
			if string_contains(ReadConfig("EXP_Donator"), "True") or string_contains(ReadConfig("EXP_Donator"), "1"):
				self.donate_func()
			else:
				self.donate_funcOff()
		except:
			pass 
		try:
			self.guildWhenPerc.SetText(ReadConfig("Donate_EXP_When_Percent"))
		except:
			pass 				
		try:
			self.guildFrom.SetText(ReadConfig("DonateEXP_After_Level"))
		except:
			pass 	
		try:
			self.dews_state=ReadConfig("Use_Dews")
			if string_contains(ReadConfig("Use_Dews"), "True") or string_contains(ReadConfig("Use_Dews"), "1"):
				self.useDews_func() 
			else:
				self.useDews_funcend()   
		except:
			pass
		try:
			self.restart_state=ReadConfig("Restart_Here")
			if string_contains(ReadConfig("Restart_Here"), "True") or string_contains(ReadConfig("Restart_Here"), "1"):
				self.restartBtn_func()
			else:
				self.restartBtn_funcOff()
		except:
			pass
		try:
			self.state_fantom=ReadConfig("ChrRevive")
			if string_contains(ReadConfig("ChrRevive"), "True") or string_contains(ReadConfig("ChrRevive"), "1"):
				self.metinx_func()
			else:
				self.metinx_funcOff()
		except:
			pass
		try:
			self.red_state=ReadConfig("Use_red_pots")
			if string_contains(ReadConfig("Use_red_pots"), "True") or string_contains(ReadConfig("Use_red_pots"), "1"):
				self.red_func()
			else:
				self.red_funcOff()
		except:
			pass
		try:
			self.red_e_state=ReadConfig("Use_red_elixirs")
			if string_contains(ReadConfig("Use_red_elixirs"), "True") or string_contains(ReadConfig("Use_red_elixirs"), "1"):
				self.redElixir_func()
			else:
				self.redElixir_funcOff()
		except:
			pass
		try:
			self.blue_state=ReadConfig("Use_blue_pots")
			if string_contains(ReadConfig("Use_blue_pots"), "True") or string_contains(ReadConfig("Use_blue_pots"), "1"):
				self.blue_func()
			else:
				self.blue_funcOff()
		except:
			pass 
		try:
			self.blue_e_state=ReadConfig("Use_blue_elixirs")
			if string_contains(ReadConfig("Use_blue_elixirs"), "True") or string_contains(ReadConfig("Use_blue_elixirs"), "1"):
				self.blueElixir_func()
			else:
				self.blueElixir_funcOff()
		except:
			pass
		try:
			self.day_state=ReadConfig("Day")
			if string_contains(ReadConfig("Day"), "True") or string_contains(ReadConfig("Day"), "1"):
				self.day_func()
			else:
				self.day_funcx.XX1(9999999)
				self.day_funcx.XX2(self.day_func)
		except:
			pass
		try:
			self.night_state=ReadConfig("Night")
			if string_contains(ReadConfig("Night"), "True") or string_contains(ReadConfig("Night"), "1"):
				self.night_func()
			else:
				self.night_funcx.XX1(9999999)
				self.night_funcx.XX2(self.night_func)
		except:
			pass 
		try:
			self.oneh_state=ReadConfig("One_hand")
			if string_contains(ReadConfig("One_hand"), "True") or string_contains(ReadConfig("One_hand"), "1"):
				self.onehand_func()
				self.btnoneHand.Down()
			else:
				self.onehand_funcend()
				self.btnoneHand.SetUp()
		except:
			pass 
		try:
			self.twoh_state=ReadConfig("Two_hands")
			if string_contains(ReadConfig("Two_hands"), "True") or string_contains(ReadConfig("Two_hands"), "1"):
				self.twohand_func()
				self.btntwoHand.Down()
			else:
				self.twohand_funcend()
				self.btntwoHand.SetUp()
		except:
			pass
		try:
			self.speed_state=ReadConfig("Speedhack")
			if string_contains(ReadConfig("Speedhack"), "True") or string_contains(ReadConfig("Speedhack"), "1"):
				self.speedFunc1()
			else:
				self.speedFunc1Stop()
		except:
			pass
		try:
			self.vit_state=ReadConfig("Upgrade_VIT")
			if string_contains(ReadConfig("Upgrade_VIT"), "True") or string_contains(ReadConfig("Upgrade_VIT"), "1"):
				self.vit_funcx()
				self.btnVit.Down()
			else:
				self.vit_funcxstop()
				self.btnVit.SetUp()
		except:
			pass 
		try:
			self.int_state=ReadConfig("Upgrade_INT")
			if string_contains(ReadConfig("Upgrade_INT"), "True") or string_contains(ReadConfig("Upgrade_INT"), "1"):
				self.int_funcx()
				self.btnInt.Down()
			else:
				self.int_funcxstop()
				self.btnInt.SetUp()
		except:
			pass
		try:
			self.str_state=ReadConfig("Upgrade_STR")
			if string_contains(ReadConfig("Upgrade_STR"), "True") or string_contains(ReadConfig("Upgrade_STR"), "1"):
				self.str_funcx()
				self.btnStr.Down()
			else:
				self.str_funcxstop()
				self.btnStr.SetUp()
		except:
			pass 
		try:
			self.dex_state=ReadConfig("Upgrade_DEX")
			if string_contains(ReadConfig("Upgrade_DEX"), "True") or string_contains(ReadConfig("Upgrade_DEX"), "1"):
				self.dex_funcx()
				self.btnDex.Down()
			else:
				self.dex_funcxstop()
				self.btnDex.SetUp()
		except:
			pass
		try:
			self.p1_state=ReadConfig("Upgrade_Skill_1")
			if string_contains(ReadConfig("Upgrade_Skill_1"), "True") or string_contains(ReadConfig("Upgrade_Skill_1"), "1"):
				self.skillplus1_funcx()
				self.btnSkill1.Down()
			else:
				self.skillplus1_funcxstop()
				self.btnSkill1.SetUp()
		except:
			pass
		try:
			self.p2_state=ReadConfig("Upgrade_Skill_2")
			if string_contains(ReadConfig("Upgrade_Skill_2"), "True") or string_contains(ReadConfig("Upgrade_Skill_2"), "1"):
				self.skillplus2_funcx()
				self.btnSkill2.Down()
			else:
				self.skillplus2_funcxstop()
				self.btnSkill2.SetUp()
		except:
			pass
		try:
			self.p3_state=ReadConfig("Upgrade_Skill_3")
			if string_contains(ReadConfig("Upgrade_Skill_3"), "True") or string_contains(ReadConfig("Upgrade_Skill_3"), "1"):
				self.skillplus3_funcx()
				self.btnSkill3.Down()
			else:
				self.skillplus3_funcxstop()
				self.btnSkill3.SetUp()
		except:
			pass
		try:
			self.p4_state=ReadConfig("Upgrade_Skill_4")
			if string_contains(ReadConfig("Upgrade_Skill_4"), "True") or string_contains(ReadConfig("Upgrade_Skill_4"), "1"):
				self.skillplus4_funcx()
				self.btnSkill4.Down()
			else:
				self.skillplus4_funcxstop()
				self.btnSkill4.SetUp()
		except:
			pass 
		try:
			self.p5_state=ReadConfig("Upgrade_Skill_5")
			if string_contains(ReadConfig("Upgrade_Skill_5"), "True") or string_contains(ReadConfig("Upgrade_Skill_5"), "1"):
				self.skillplus5_funcx()
				self.btnSkill5.Down()
			else:
				self.skillplus5_funcxstop()
				self.btnSkill5.SetUp()
		except:
			pass
		try:
			self.p6_state=ReadConfig("Upgrade_Skill_6")
			if string_contains(ReadConfig("Upgrade_Skill_6"), "True") or string_contains(ReadConfig("Upgrade_Skill_6"), "1"):
				self.skillplus6_funcx()
				self.btnSkill6.Down()
			else:
				self.skillplus6_funcxstop()
				self.btnSkill6.SetUp()
		except:
			pass
		try:
			if str(ReadConfig("HowToFollowTarget")) == str("None"):
				self.followMethod.SetCurrentItem(str(goToMetinWay[0]))
			else:
				self.followMethod.SetCurrentItem(str(ReadConfig("HowToFollowTarget")))
		except:
			self.followMethod.SetCurrentItem(str(goToMetinWay[0]))
		try:
			if str(ReadConfig("Attack_Func_Mode")) == str("None"):
				self.attackList.SetCurrentItem(str("Normal"))
			else:
				self.attackList.SetCurrentItem(str(ReadConfig("Attack_Func_Mode")))
		except:
			self.attackList.SetCurrentItem(str("Normal"))
		try:
			if str(ReadConfig("SpammingType")) == str("None"):
				self.spamType.SetCurrentItem(str("Chat"))
			else:
				self.spamType.SetCurrentItem(str(ReadConfig("SpammingType")))
		except:
			self.spamType.SetCurrentItem(str("Chat"))
		try:
			if str(ReadConfig("SpammingColor")) == str("None"):
				self.spamColor.SetCurrentItem(str("Normal"))
			else:
				self.spamColor.SetCurrentItem(str(ReadConfig("SpammingColor")))
		except:
			self.spamColor.SetCurrentItem(str("Normal"))
		try:
			if str(ReadConfig("Priority")) == str("None"):
				self.listPriority.SetCurrentItem(str("Metins first"))
			else:
				self.listPriority.SetCurrentItem(str(ReadConfig("Priority")))
		except:
			self.listPriority.SetCurrentItem(str("Metins first"))
		try:
			if str(ReadConfig("gotoFisher_Moving_Method")) == str("None"):
				self.gotoFisher.SetCurrentItem(goToMetinWay[0])
			else:
				self.gotoFisher.SetCurrentItem(str(ReadConfig("gotoFisher_Moving_Method")))
		except:
			if not isGF:
				self.gotoFisher.SetCurrentItem(goToMetinWay[0])
		try:
			if str(ReadConfig("Moving_Method")) == str("None"):
				self.farmGoingMethod.SetCurrentItem(goToMetinWay[0])
			else:
				self.farmGoingMethod.SetCurrentItem(str(ReadConfig("Moving_Method")))
		except:
			self.farmGoingMethod.SetCurrentItem(goToMetinWay[0])
		try:
			if str(ReadConfig("Energy_GoingMethod")) == str("None"):
				self.gotoEnergy.SetCurrentItem(goToMetinWay[0])
			else:
				self.gotoEnergy.SetCurrentItem(str(ReadConfig("Energy_GoingMethod")))
		except:
			self.gotoEnergy.SetCurrentItem(goToMetinWay[0])
		try:
			if str(ReadConfig("What_To_Mine")) == str("None"):
				self.NewminingList.SetCurrentItem(str("Everything"))
			else:
				self.NewminingList.SetCurrentItem(str(ReadConfig("What_To_Mine")))
		except:
			self.NewminingList.SetCurrentItem(str("Everything"))
		try:
			if str(ReadConfig("MapHowToGo")) == str("None"):
				self.mapTeleWalk.SetCurrentItem(goToMetinWay[0])
			else:
				self.mapTeleWalk.SetCurrentItem(str(ReadConfig("MapHowToGo")))
		except:
			self.mapTeleWalk.SetCurrentItem(goToMetinWay[0])
		try:
			if string_contains(ReadConfig("Use_Game_CH_Changer"), "True") or string_contains(ReadConfig("Use_Game_CH_Changer"), "1"):
				self.useGameCH.OnToggleDown()  
			else:
				self.useGameCH.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Detector_BeepPM"), "True") or string_contains(ReadConfig("Detector_BeepPM"), "1"):
				self.beepPM.OnToggleDown() 
			else:
				self.beepPM.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Detector_GMQuitPM"), "True") or string_contains(ReadConfig("Detector_GMQuitPM"), "1"):
				self.exitPM.OnToggleDown() 
			else:
				self.exitPM.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Detector_GMChangeCH"), "True") or string_contains(ReadConfig("Detector_GMChangeCH"), "1"):
				self.changeCHGM.OnToggleDown() 
			else:
				self.changeCHGM.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Detector_GMBeep"), "True") or string_contains(ReadConfig("Detector_GMBeep"), "1"):
				self.beepGM.OnToggleDown() 
			else:
				self.beepGM.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Detector_GM_All_Quit"), "True") or string_contains(ReadConfig("Detector_GM_All_Quit"), "1"):
				self.quitAllGM.OnToggleDown()  
			else:
				self.quitAllGM.OnToggleUp()
		except:
			pass		
		try:
			if string_contains(ReadConfig("Detector_GMQuit"), "True") or string_contains(ReadConfig("Detector_GMQuit"), "1"):
				self.quitGM.OnToggleDown()  
			else:
				self.quitGM.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Detector_GMLogout"), "True") or string_contains(ReadConfig("Detector_GMLogout"), "1"):
				self.logoutGM.OnToggleDown()  
			else:
				self.logoutGM.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Detector_GMChat"), "True") or string_contains(ReadConfig("Detector_GMChat"), "1"):
				self.notifyGM.OnToggleDown()  
			else:
				self.notifyGM.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Detector_Player_WindowsNotify"), "True") or string_contains(ReadConfig("Detector_Player_WindowsNotify"), "1"):
				self.notifyWindowsPl.OnToggleDown()  
			else:
				self.notifyWindowsPl.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Detector_GM_WindowsNotify"), "True") or string_contains(ReadConfig("Detector_GM_WindowsNotify"), "1"):
				self.notifyWindowsGM.OnToggleDown()  
			else:
				self.notifyWindowsGM.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Detector_PlayerChangeCH"), "True") or string_contains(ReadConfig("Detector_PlayerChangeCH"), "1"):
				self.changeCHPl.OnToggleDown()  
			else:
				self.changeCHPl.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Detector_PlayerBeep"), "True") or string_contains(ReadConfig("Detector_PlayerBeep"), "1"):
				self.beepPl.OnToggleDown()  
			else:
				self.beepPl.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Detector_PlayerLogout"), "True") or string_contains(ReadConfig("Detector_PlayerLogout"), "1"):
				self.logoutPl.OnToggleDown()  
			else:
				self.logoutPl.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Detector_PlayerQuit"), "True") or string_contains(ReadConfig("Detector_PlayerQuit"), "1"):
				self.quitPl.OnToggleDown()  
			else:
				self.quitPl.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Detector_PlayerChat"), "True") or string_contains(ReadConfig("Detector_PlayerChat"), "1"):
				self.notifyPl.OnToggleDown()  
			else:
				self.notifyPl.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Use_Item_After_Relog"), "True") or string_contains(ReadConfig("Use_Item_After_Relog"), "1"):
				self.useItemRelogBtn.OnToggleDown()  
			else:
				self.useItemRelogBtn.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Normal_Pickup"), "True") or string_contains(ReadConfig("Normal_Pickup"), "1"):
				self.normalPickup.OnToggleDown()   
			else:
				self.normalPickup.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Filter_Pickup"), "True") or string_contains(ReadConfig("Filter_Pickup"), "1"):
				self.filterPickup.OnToggleDown()  
			else:
				self.filterPickup.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("PickAllItems_val"), "True") or string_contains(ReadConfig("PickAllItems_val"), "1"):
				self.pickItemsAtOnce.OnToggleDown()  
			else:
				self.pickItemsAtOnce.OnToggleUp()
		except:
			pass
		try:			
			if string_contains(ReadConfig("Farm_Metins"), "True") or string_contains(ReadConfig("Farm_Metins"), "1"):
				self.farmMetinsCB.OnToggleDown() 
			else:
				self.farmMetinsCB.OnToggleUp()
		except:
			pass
		try:			
			if string_contains(ReadConfig("Farm_Bosses"), "True") or string_contains(ReadConfig("Farm_Bosses"), "1"):
				self.farmBossCB.OnToggleDown()  
			else:
				self.farmBossCB.OnToggleUp()
		except:
			pass 
		try:			
			if string_contains(ReadConfig("Farm_Monsters"), "True") or string_contains(ReadConfig("Farm_Monsters"), "1"):
				self.farmMobCB.OnToggleDown()  
			else:
				self.farmMobCB.OnToggleUp()
		except:
			pass
		try:			
			if string_contains(ReadConfig("Farm_Ore"), "True") or string_contains(ReadConfig("Farm_Ore"), "1"):
				self.farmOreCB.OnToggleDown()  
			else:
				self.farmOreCB.OnToggleUp()
		except:
			pass
		try:
			self.TimeMiningOreVal.SetText(ReadConfig("Farm_Ore_Time"))
		except:
			pass
		try:		
			if string_contains(ReadConfig("Farm_In_Range"), "True") or string_contains(ReadConfig("Farm_In_Range"), "1"):
				self.farmInRangeCB.OnToggleDown()  
			else:
				self.farmInRangeCB.OnToggleUp()
		except:
			pass 
		try:
			if string_contains(ReadConfig("Farm_By_Route"), "True") or string_contains(ReadConfig("Farm_By_Route"), "1"):
				self.farmbyRouteCB.OnToggleDown()  
			else:
				self.farmbyRouteCB.OnToggleUp()
		except:
			pass
		try:		
			if string_contains(ReadConfig("Auto_Increase_Range"), "True") or string_contains(ReadConfig("Auto_Increase_Range"), "1"):
				self.fixedRange.OnToggleDown()
				try:
					rangeX = float(ReadConfig("Farm_RangeX"))
					rangeY = float(ReadConfig("Farm_RangeY"))
				except:
					pass
			else:
				self.fixedRange.OnToggleUp()
		except:
			pass
		try:		
			if string_contains(ReadConfig("Farm_GoInitialPos"), "True") or string_contains(ReadConfig("Farm_GoInitialPos"), "1"):
				self.goToInitial.OnToggleDown()  
			else:
				self.goToInitial.OnToggleUp()
		except:
			pass
		try:			
			if string_contains(ReadConfig("Farm_Unstuck"), "True") or string_contains(ReadConfig("Farm_Unstuck"), "1"):
				self.unstuckCB.OnToggleDown()  
			else:
				self.unstuckCB.OnToggleUp()
		except:
			pass
		try:			
			if string_contains(ReadConfig("Farm_Run_Route_Backwards"), "True") or string_contains(ReadConfig("Farm_Run_Route_Backwards"), "1"):
				self.runRouteBackwards.OnToggleDown()  
			else:
				self.runRouteBackwards.OnToggleUp()
		except:
			pass
		try:			
			if string_contains(ReadConfig("Farm_Stop_If_Player"), "True") or string_contains(ReadConfig("Farm_Stop_If_Player"), "1"):
				self.playerDetector.OnToggleDown()  
			else:
				self.playerDetector.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("DoNotKs"), "True") or string_contains(ReadConfig("DoNotKs"), "1"):
				self.dontKs.OnToggleDown()  
			else:
				self.dontKs.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Use_HorseDisableQuest"), "True") or string_contains(ReadConfig("Use_HorseDisableQuest"), "1"):
				self.disableQuestHorse.OnToggleDown()
			else:
				self.disableQuestHorse.OnToggleUp()
		except:
			pass
		try:			
			if string_contains(ReadConfig("Use_Horse_Ride"), "True") or string_contains(ReadConfig("Use_Horse_"), "1"):
				self.useHorseCB.OnToggleDown()  
			else:
				self.useHorseCB.OnToggleUp()
		except:
			pass
		try:			
			if string_contains(ReadConfig("Use_Mount_"), "True") or string_contains(ReadConfig("Use_Mount_"), "1"):
				self.useMount.OnToggleDown()  
			else:
				self.useMount.OnToggleUp()
		except:
			pass 
		try:			
			if string_contains(ReadConfig("TP_Away_When_HP"), "True") or string_contains(ReadConfig("TP_Away_When_HP"), "1"):
				self.tpAway.OnToggleDown()  
			else:
				self.tpAway.OnToggleUp()
		except:
			pass 
		try:			
			if string_contains(ReadConfig("Relog_Away_When_HP"), "True") or string_contains(ReadConfig("Relog_Away_When_HP"), "1"):
				self.relogTp.OnToggleDown()  
			else:
				self.relogTp.OnToggleUp()
		except:
			pass 
		try:			
			if string_contains(ReadConfig("TP_Hybrid_Away_When_HP"), "True") or string_contains(ReadConfig("TP_Hybrid_Away_When_HP"), "1"):
				self.hybridTP.OnToggleDown()  
			else:
				self.hybridTP.OnToggleUp()
		except:
			pass 
		try:			
			if string_contains(ReadConfig("WaitForHP"), "True") or string_contains(ReadConfig("WaitForHP"), "1"):
				self.waitForHPBox.OnToggleDown()  
			else:
				self.waitForHPBox.OnToggleUp()
		except:
			pass 
		try:
			self.waitForHP.SetText(ReadConfig("WaitForHPValue"))
		except:
			pass 
		try:		
			if string_contains(ReadConfig("Classic_Farming_Start_Button"), "True") or string_contains(ReadConfig("Classic_Farming_Start_Button"), "1"):
				self.classicStartCB.OnToggleDown()  
				self.classicBtnEnable()
			else:
				self.classicStartCB.OnToggleUp()
				self.classicBtnDisable()
		except:
			pass
		try:		
			if string_contains(ReadConfig("Fishbot_OpenClams"), "True") or string_contains(ReadConfig("Fishbot_OpenClams"), "1"):
				self.openclamhBtn.OnToggleDown()  
			else:
				self.openclamhBtn.OnToggleUp()
		except:
			pass 
		try:
			if string_contains(ReadConfig("GoToFisherman"), "True") or string_contains(ReadConfig("GoToFisherman"), "1"):
				self.goToFisherman.OnToggleDown() 
			else:
				self.goToFisherman.OnToggleUp()
		except:
			pass 
		try:
			if string_contains(ReadConfig("Fishbot_SwitchArmor"), "True") or string_contains(ReadConfig("Fishbot_SwitchArmor"), "1"):
				self.switchArmor.OnToggleDown()  
			else:
				self.switchArmor.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Fishbot_Stop_If_Player"), "True") or string_contains(ReadConfig("Fishbot_Stop_If_Player"), "1"):
				self.playerDetectorFish.OnToggleDown()  
			else:
				self.playerDetectorFish.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Fishbot_SellMinnow"), "True") or string_contains(ReadConfig("Fishbot_SellMinnow"), "1"):
				self.sellminnowCb.OnToggleDown()  
			else:
				self.sellminnowCb.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Fishbot_UpgradeRod"), "True") or string_contains(ReadConfig("Fishbot_UpgradeRod"), "1"):
				self.upgradeRod.OnToggleDown() 
			else:
				self.upgradeRod.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Fishbot_Cancel_Animation"), "True") or string_contains(ReadConfig("Fishbot_Cancel_Animation"), "1"):
				self.skipAnim.OnToggleDown()  
			else:
				self.skipAnim.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Fishbot_DisableQuests"), "True") or string_contains(ReadConfig("Fishbot_DisableQuests"), "1"):
				self.fix_quest.OnToggleDown()  
			else:
				self.fix_quest.OnToggleUp()
		except:
			pass
		try:
			self.fisherVnum.SetText(ReadConfig("Fishbot_FishernumVnum"))
		except:
			pass 
		try:
			self.fishshopIndex.SetText(ReadConfig("Fishbot_DefaultShopIndex"))
		except:
			pass
		try:
			if string_contains(ReadConfig("Fishbot_BuyBait"), "True") or string_contains(ReadConfig("Fishbot_BuyBait"), "1"):
				self.buyBaitBtn.OnToggleDown()  
			else:
				self.buyBaitBtn.OnToggleUp()
		except:
			pass
		try:
			self.buyBaitIndex.SetText(ReadConfig("Fishbot_xBuyBaitShopIndex"))
		except:
			pass
		try:
			if string_contains(ReadConfig("Fishbot_BuyxBaitQ"), "True") or string_contains(ReadConfig("Fishbot_BuyxBaitQ"), "1"):
				self.buyBaitQBtn.OnToggleDown()  
			else:
				self.buyBaitQBtn.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Auto_Sort"), "True") or string_contains(ReadConfig("Auto_Sort"), "1"):
				self.autoSortCB.OnToggleDown()  
			else:
				self.autoSortCB.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Auto_Stack"), "True") or string_contains(ReadConfig("Auto_Stack"), "1"):
				self.autoStackCB.OnToggleDown() 
			else:
				self.autoStackCB.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Fishbot_Bait_Minnow"), "True") or string_contains(ReadConfig("Fishbot_Bait_Minnow"), "1"):
				self.minnowCb.OnToggleDown()  
			else:
				self.minnowCb.OnToggleUp()
		except:
			pass 
		try:
			if string_contains(ReadConfig("Fishbot_Bait_Other"), "True") or string_contains(ReadConfig("Fishbot_Bait_Other"), "1"):
				self.alternativeBtn.OnToggleDown()  
			else:
				self.alternativeBtn.OnToggleUp()
		except:
			pass 
		try:
			if string_contains(ReadConfig("Fishbot_Bait_Worm"), "True") or string_contains(ReadConfig("Fishbot_Bait_Worm"), "1"):
				self.wormCb.OnToggleDown()  
			else:
				self.wormCb.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Fishbot_Bait_Paste"), "True") or string_contains(ReadConfig("Fishbot_Bait_Paste"), "1"):
				self.pasteCb.OnToggleDown()  
			else:
				self.pasteCb.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Fix_Pulling_Rod"), "True") or string_contains(ReadConfig("Fix_Pulling_Rod"), "1"):
				self.fix_fishbot.OnToggleDown()  
			else:
				self.fix_fishbot.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Reply_with_question_mark_if_unknown"), "True") or string_contains(ReadConfig("Reply_with_question_mark_if_unknown"), "1"):
				self.replyWithQuestion.OnToggleDown() 
			else:
				self.replyWithQuestion.OnToggleUp()
		except:
			pass 
		try:
			if string_contains(ReadConfig("Reply_with_previous_msg_if_unknown"), "True") or string_contains(ReadConfig("Reply_with_previous_msg_if_unknown"), "1"):
				self.repeatMsg.OnToggleDown() 
			else:
				self.repeatMsg.OnToggleUp()
		except:
			pass 
		try:
			if string_contains(ReadConfig("Enable_reply_bot"), "True") or string_contains(ReadConfig("Enable_reply_bot"), "1"):
				self.enableReplyBot.OnToggleDown()  
			else:
				self.enableReplyBot.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("WaitCheck"), "True") or string_contains(ReadConfig("WaitCheck"), "1"):
				self.waitAfter.OnToggleDown()  
			else:
				self.waitAfter.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("WaitCheckRoute"), "True") or string_contains(ReadConfig("WaitCheckRoute"), "1"):
				self.waitRouteAfter.OnToggleDown()  
			else:
				self.waitRouteAfter.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Use_Horse_Skill_Unstuck"), "True") or string_contains(ReadConfig("Use_Horse_Skill_Unstuck"), "1"):
				self.useHorseSkill.OnToggleDown()  
			else:
				self.useHorseSkill.OnToggleUp()
		except:
			pass
		try:
			self.wait.SetText(ReadConfig("Seconds_Wait"))
		except:
			pass
		try:
			self.hpLower.SetText(ReadConfig("TP_When_Hp_Lower"))
		except:
			pass 
		try:
			self.telDis.SetText(ReadConfig("Teleport_Distance"))
		except:
			pass
		try:
			self.newFarmRangeVal.SetText(ReadConfig("Farming_Range"))
		except:
			pass
		# NEW SETTINGS
		try:
			attack_state=ReadConfig("Attack_Function")
			if string_contains(ReadConfig("Attack_Function"), "True") or string_contains(ReadConfig("Attack_Function"), "1"):
				self.attack_func() 
			else:
				self.attack_funcOff()
		except:
			pass
		try:
			if string_contains(ReadConfig("Moblock"), "True") or string_contains(ReadConfig("Moblock"), "1"):
				self.moblock_func()  
			else:
				self.moblock_funcend()
		except:
			pass
			
		try:
			self.LoadItems(CONFIG_ITEMS)
		except:
			pass
		try:
			item_user_state=ReadConfig("Item_user")
			if string_contains(ReadConfig("Item_user"), "True") or string_contains(ReadConfig("Item_user"), "1"):
				self.itemuse_func()  
			else:
				self.itemuse_funcStop()
		except:
			pass 
		try:
			self.hotkey_state=ReadConfig("Hotkey_Teleport")
			if string_contains(ReadConfig("Hotkey_Teleport"), "True") or string_contains(ReadConfig("Hotkey_Teleport"), "1"):
				self.hotkeyTele_func()  
			else:
				self.hotkeyTele_funcend()
		except:
			pass
		try:
			self.one_hit_state=ReadConfig("One_Hit")
			if string_contains(ReadConfig("One_Hit"), "True") or string_contains(ReadConfig("One_Hit"), "1"):
				self.antifly_func()  
			else:
				self.antifly_funcend()
		except:
			pass 
		try:
			self.capes_state=ReadConfig("Pull_Mobs")
			if string_contains(ReadConfig("Pull_Mobs"), "True") or string_contains(ReadConfig("Pull_Mobs"), "1"):
				self.cape_func()  
			else:
				self.cape_funcOff()
		except:
			pass
		try:
			if string_contains(ReadConfig("Use_horse_state"), "True") or string_contains(ReadConfig("Use_horse_state"), "1"):
				self.useHorseCB.OnToggleDown()  
			else:
				self.useHorseCB.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Strong_body"), "True") or string_contains(ReadConfig("Strong_body"), "1"):
				self.strongBody_funcOn()
				self.corpRezistenBtn.Down()
			else:
				self.strongBody_funcOff()
				self.corpRezistenBtn.SetUp()
		except:
			pass
		try:
			if os.path.exists(st_path + "/Data/rascal2/pm_reply.cfg"):
				self.loadReplyList()
				self.replyDelay.SetText(ReadConfig("Reply_Delay"))
				self.applyDelayFunc()
		except:
			pass
		try:
			self.loadItemHpLow()
		except:
			pass
		try:
			self.loadFarmingMount()
		except:
			pass
		try:
			self.loadItemRelog()
		except:
			pass
		try:
			self.loadFishAnimMount()
		except:
			pass
		try:
			self.loadItemForAlchemist()
		except:
			pass
		try:
			last_used_route = str(ReadConfig("Last_Used_Route"))
			selected_index = -1
			index = 0 
			self.routeListbox.DropList.RemoveAllItems()
			for routeName in os.listdir(st_path + "/Data/Routes"):
				if not routeName.startswith("empty_route"):
					self.routeListbox.AppendItem(str(routeName))
					if str(routeName) == last_used_route:
						selected_index = index
					index += 1
			if selected_index != -1:
				self.routeListbox.DropList.SelectIndex(selected_index)
				selected_item = self.routeListbox.DropList.GetSelectedItem()
				self.routeListbox.SetTitle(selected_item)
		except:
			pass
		try:
			last_energy_used_route = str(ReadConfig("Last_Energy_Used_Route"))
			selected_index = -1
			index = 0 
			self.energyRouteListbox.DropList.RemoveAllItems()
			for routeName in os.listdir(st_path + "/Data/Routes"):
				if not routeName.startswith("empty_route"):
					self.energyRouteListbox.AppendItem(str(routeName))
					if str(routeName) == last_energy_used_route:
						selected_index = index
					index += 1
			if selected_index != -1:
				self.energyRouteListbox.DropList.SelectIndex(selected_index)
				selected_item = self.energyRouteListbox.DropList.GetSelectedItem()
				self.energyRouteListbox.SetTitle(selected_item)
		except:
			pass
		try:
			if string_contains(ReadConfig("FarmBotState"), "True") or string_contains(ReadConfig("FarmBotState"), "1"):
				farmEnable = 1
				if farmEnable == 1:
					if self.classicStartCB.checked == 1:
						self.startFarmingBtn2.Down()
					else:
						self.startFarmingBtn.SetOn()
					self.onOffFarmbot(True)
			else:
				farmEnable = 0
				self.onOffFarmbot(False, False)
				if self.classicStartCB.checked == 1:
					self.startFarmingBtn2.SetUp()
				else:
					self.startFarmingBtn.SetOff()
		except:
			pass
		try:
			eventHandler.add(2, self.loadSellItemsFunc)
		except:
			pass
			
		try:
			if string_contains(ReadConfig("Sell_Items_Filter"), "True") or string_contains(ReadConfig("Sell_Items_Filter"), "1"):
				self.onlyItemsWithout.OnToggleDown()
	
				if switchEnabled:
					bonusFilterUI = BonusFilterDialog()
					bonusFilterUI.LoadSettings()
					bonusFilterUI.CreateBonusInputs()
					bonusFilterUI.Hide()
			else:
				self.onlyItemsWithout.SetUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Sell_Items_Function"), "True") or string_contains(ReadConfig("Sell_Items_Function"), "1"):
				self.SellItemsFunction('on')
				self.startStopSellItems.Down()
			else:
				self.SellItemsFunction('off')
				self.startStopSellItems.SetUp()
		except:
			pass
		try:
			self.updateWhitelist()
		except:
			pass
		try:
			self.loadItemOtherBait()
		except:
			pass
		try:
			if string_contains(ReadConfig("Fishbot_Cur_State"), "True") or string_contains(ReadConfig("Fishbot_Cur_State"), "1"):
				self.StartFishBot()
			else:
				self.StopFishBot()
		except:
			pass
		try:
			if string_contains(ReadConfig("Bio_UseElixir"), "True") or string_contains(ReadConfig("Bio_UseElixir"), "1"):
				self.useElixir.OnToggleDown()  
			else:
				self.useElixir.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("Bio_ResetTime"), "True") or string_contains(ReadConfig("Bio_ResetTime"), "1"):
				self.resetTime.OnToggleDown()  
			else:
				self.resetTime.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("Bio_NewBio"), "True") or string_contains(ReadConfig("Bio_NewBio"), "1"):
				self.newBio.OnToggleDown()  
			else:
				self.newBio.OnToggleUp()
		except:
			pass
		try:
			self.bioDelay.SetText(ReadConfig("Bio_Delay"))
		except:
			pass			
		try:
			self.bioTxt.SetText(ReadConfig("Bio_Command"))
		except:
			pass
		try:
			self.loadItemElixirBio()
		except:
			pass
		try:
			self.loadItemResetBio()
		except:
			pass
		try:
			self.dungeonVnum.SetText(ReadConfig("DungeonVNUM"))
		except:
			pass			
		try:
			self.dungeonDelay.SetText(ReadConfig("DungeonDELAY"))
		except:
			pass
		try:
			self.DungeonQuestIndex.SetText(ReadConfig("DungeonQuestIndex"))
		except:
			pass
		try:
			if string_contains(ReadConfig("DungeonDragItem"), "True") or string_contains(ReadConfig("DungeonDragItem"), "1"):
				self.lblDragItem.OnToggleDown()
			else:
				self.lblDragItem.OnToggleUp()
		except:
			pass
		try:
			self.DragNpcVNUM.SetText(ReadConfig("DungeonDragItemVNUM"))
		except:
			pass
		try:
			if string_contains(ReadConfig("DungeonDrag2Item"), "True") or string_contains(ReadConfig("DungeonDrag2Item"), "1"):
				self.lblDragItem2.OnToggleDown()
			else:
				self.lblDragItem2.OnToggleUp()
		except:
			pass
		try:
			self.DragNpcVNUM2.SetText(ReadConfig("DungeonDrag2ItemVNUM"))
		except:
			pass
			
		try:
			if string_contains(ReadConfig("DungeonDrag3Item"), "True") or string_contains(ReadConfig("DungeonDrag3Item"), "1"):
				self.lblDragItem3.OnToggleDown()
			else:
				self.lblDragItem3.OnToggleUp()
		except:
			pass
		try:
			self.DragNpcVNUM3.SetText(ReadConfig("DungeonDrag3ItemVNUM"))
		except:
			pass
			
		try:
			if str(ReadConfig("GoToNPC_Method")) == str("None"):
				self.goToNpcDungeon.SetCurrentItem(goToNpcWay[0])
			else:
				self.goToNpcDungeon.SetCurrentItem(str(ReadConfig("GoToNPC_Method")))
		except:
			self.goToNpcDungeon.SetCurrentItem(goToNpcWay[0])
		try:
			self.loadDragItem()
		except:
			pass
			
		try:
			self.loadDragItem2()
		except:
			pass			
		try:
			self.loadDragItem3()
		except:
			pass
		if string_contains(ReadConfig("DungeonState"), "True") or string_contains(ReadConfig("DungeonState"), "1"):
			self.dungeonStartBtn.Down()
			self.dungeonStart()
		else:
			self.dungeonStartBtn.SetUp()
			self.dungeonStop()
		try:
			if string_contains(ReadConfig("Auto_RefreshInventory"), "True") or string_contains(ReadConfig("Auto_RefreshInventory"), "1"):
				self.autoRefreshInventory.OnToggleDown()  
			else:
				self.autoRefreshInventory.OnToggleUp()
		except:
			pass			
		try:
			if string_contains(ReadConfig("DungeonClickQuest"), "True") or string_contains(ReadConfig("DungeonClickQuest"), "1"):
				self.clickQuest.OnToggleDown()  
			else:
				self.clickQuest.OnToggleUp()
		except:
			pass
		try:
			if string_contains(ReadConfig("BiologistBotStatus"), "True") or string_contains(ReadConfig("BiologistBotStatus"), "1"):
				self.startBio()
			else:
				self.stopBio()
		except:
			pass
		try:
			if not self.startDetector.IsDown():
				self.hideShowAntibanBtn()
			else:
				self.hideShowAntibanBtnStop()
		except:
			pass
		try:
			if self.useItemRelogBtn.checked == 1:
				self.use_item_relog_func()
		except:
			pass
		try:
			if string_contains(ReadConfig("AntiBanState"), "True") or string_contains(ReadConfig("AntiBanState"), "1"):
				self.startDetector.Down()
				self.funcAntiBanStart()
			else:
				self.startDetector.SetUp()
				self.antibanStop()
		except:
			pass
		try:
			if string_contains(ReadConfig("SpambotState"), "True") or string_contains(ReadConfig("SpambotState"), "1"):
				self.selectstartspam()
			else:
				self.selectstopspam()
		except:
			pass
		try:
			if string_contains(ReadConfig("Waithack_State"), "True") or string_contains(ReadConfig("Waithack_State"), "1"):
				self.waithackFunc(1)
				self.enableButton.Down()
			else:
				self.waithackFunc(0)
				self.enableButton.SetUp()
		except:
			pass
		if isGF:
			eventHandler.add(1, self.loadPickupList)
		try:
			self.loadFishSetting()
		except:
			pass
		try:
			self.loadHotkeys(1)
		except:
			pass
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.STR_LOAD_SETTINGS_OK)
		try:
			if self.autoHide.checked==1:
				self.mBtn_func()
		except:
			pass
	def loadPickupList(self):
		try:
			global PICKUP_LIST
			for i in LoadListFile(PICKUP_LIST):
				self.pickFilter.add(int(i))
				eXLib.ItemGrndAddFilter(int(i))
			self.UpdatePickFilterList()
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFailed loading pickup filter list.")
			pass
	def loadNonePickList(self):
		self.excludeItems.OnToggleUp()
		for _item in self.PickfileListBox.itemList:
			if _item is None:
				continue
			item_name = _item.GetText()
			item_id = item_name.split(" ", 1)[0]
			eXLib.ItemGrndDelFilter(int(item_id))
	def loadDragItem(self):
		global dragItemId,dragItem
		dragItemId = ReadConfig("DungeonDragItemID")
		if int(dragItemId) <= 1:
			self.itemToDragIcon.LoadImage(slot_base)
		else:
			selectItem(int(dragItemId))
			itemToDragIcon = item.GetIconImageFileName()
			self.itemToDragIcon.LoadImage(str(itemToDragIcon))
			for i in range(200):
				if player.GetItemIndex(i) == int(dragItemId):
					dragItem = i
	def loadDragItem2(self):
		global dragItem2, dragItemId2
		dragItemId2 = ReadConfig("DungeonDrag2ItemID")
		if int(dragItemId2) <= 1:
			self.itemToDragIcon2.LoadImage(slot_base)
		else:
			selectItem(int(dragItemId2))
			itemToDragIcon2 = item.GetIconImageFileName()
			self.itemToDragIcon2.LoadImage(str(itemToDragIcon2))
			for i in range(200):
				if player.GetItemIndex(i) == int(dragItemId2):
					dragItem2 = i
	def loadDragItem3(self):
		global dragItem3, dragItemId3
		dragItemId3 = ReadConfig("DungeonDrag3ItemID")
		if int(dragItemId3) <= 1:
			self.itemToDragIcon3.LoadImage(slot_base)
		else:
			selectItem(int(dragItemId3))
			itemToDragIcon3 = item.GetIconImageFileName()
			self.itemToDragIcon3.LoadImage(str(itemToDragIcon3))
			for i in range(200):
				if player.GetItemIndex(i) == int(dragItemId3):
					dragItem3 = i
	def showAntiBanBtn(self):
		if self.pnlAntiBan.IsShow():
			self.startDetector.Show()
	def hideShowAntibanBtn(self):
		self.hideShowxAntibanBtn.XX1(0.7)
		self.hideShowxAntibanBtn.XX2(self.hideShowAntibanBtn)
		self.startDetector.Hide()
		eventHandler.add(0.1, self.showAntiBanBtn, 'showAntiBanBtn')
	def hideShowAntibanBtnStop(self):
		self.hideShowxAntibanBtn.XX1(9999999)
		self.hideShowxAntibanBtn.XX2(self.hideShowAntibanBtnStop)
		eventHandler.remove("showAntiBanBtn")
	def loadSellItemsFunc(self):
		try:
			global oldPython
			if oldPython:
				sell_items = []
			else:
				sell_items = set()
			for i in LoadListFile(ITEMS_TO_SELL):
				item = int(i)
				if oldPython:
					if item not in sell_items:
						sell_items.append(item)
				else:
					sell_items.add(item)
			self.sellItems = sell_items
			self.UpdateSellFilterList()
		except:
			pass
	def loadItemElixirBio(self):
		global elixirItem
		elixirItemID = ReadConfig("Bio_ElixirItemID")	
		elixirItemIcon = item.GetIconImageFileName()
		if int(elixirItemID) <= 1:
			self.elixirItemIcon.LoadImage(slot_base)
		else:
			selectItem(int(elixirItemID))
			elixirItemIcon = item.GetIconImageFileName()
			self.switchIcon.LoadImage(str(elixirItemIcon))
			elixirItem = elixirItemID
	def loadItemResetBio(self):
		global bioItemReset
		bioItemID = ReadConfig("Bio_ResetItemID")	
		bioItemIcon = item.GetIconImageFileName()
		if int(bioItemID) <= 1:
			self.bioItemIcon.LoadImage(slot_base)
		else:
			selectItem(int(bioItemID))
			bioItemIcon = item.GetIconImageFileName()
			self.resetIcon.LoadImage(str(bioItemIcon))
			bioItemReset = bioItemID
	def loadItemOtherBait(self):
		global Bait_Alternative_ID
		OtherBaitLowIcon_ = ReadConfig("Fishbot_Bait_OtherID")	
		bait_Reader_Item_Icon = item.GetIconImageFileName()
		if int(OtherBaitLowIcon_) <= 1:
			self.bait_Reader_Item_Icon.LoadImage(slot_base)
		else:
			selectItem(int(OtherBaitLowIcon_))
			bait_Reader_Item_Icon = item.GetIconImageFileName()
			self.bait_Reader_Item_Icon.LoadImage(str(bait_Reader_Item_Icon))
			Bait_Alternative_ID = OtherBaitLowIcon_
	def loadItemHpLow(self):
		global useItemHpLowID
		useItemHpLowIcon_ = ReadConfig("UseItemHp_Low_ItemID")	
		UseHpLowIcon = item.GetIconImageFileName()
		if int(useItemHpLowIcon_) <= 1:
			self.UseHpLowIcon.LoadImage(slot_base)
		else:
			selectItem(int(useItemHpLowIcon_))
			UseHpLowIcon = item.GetIconImageFileName()
			self.UseHpLowIcon.LoadImage(str(UseHpLowIcon))
			useItemHpLowID = useItemHpLowIcon_
		# msg(useItemHpLowID)
	def loadFarmingMount(self):
		global setMountVnumFarm
		setMountVnumFarm_ = ReadConfig("Use_Mount_VNUM")
		# msg(setMountVnumFarm_)
		selectItem(int(setMountVnumFarm_))
		iconMountFarm = item.GetIconImageFileName()
		if int(setMountVnumFarm_) <= 1:
			self.iconMountFarm.LoadImage(slot_base)
		else:
			selectItem(int(setMountVnumFarm_))
			iconMountFarm = item.GetIconImageFileName()
			self.iconMountFarm.LoadImage(str(iconMountFarm))
			setMountVnumFarm = setMountVnumFarm_
	def loadItemRelog(self):
		global Item_User_Relog_ID
		itemUserRelog_Item_Icon_ = ReadConfig("Use_Item_Relog")	
		itemUserRelog_Item_Icon = item.GetIconImageFileName()
		if int(itemUserRelog_Item_Icon_) <= 1:
			self.itemUserRelog_Item_Icon.LoadImage(slot_base)
		else:
			selectItem(int(itemUserRelog_Item_Icon_))
			itemUserRelog_Item_Icon = item.GetIconImageFileName()
			self.itemUserRelog_Item_Icon.LoadImage(str(itemUserRelog_Item_Icon))
			Item_User_Relog_ID = itemUserRelog_Item_Icon_
	def loadFishAnimMount(self):
		global setMountVnum
		iconMount_ = ReadConfig("Fishing_Cancel_Animation_Mount")	
		iconMount = item.GetIconImageFileName()
		if int(iconMount_) <= 1:
			self.iconMount.LoadImage(slot_base)
		else:
			selectItem(int(iconMount_))
			iconMount = item.GetIconImageFileName()
			self.iconMount.LoadImage(str(iconMount))
			setMountVnum = iconMount_
	def loadItemForAlchemist(self):
		global select_item_toGiveID
		itemToGiveIcon_ = ReadConfig("Item_To_Give_To_Alchemist")	
		itemToGiveIcon = item.GetIconImageFileName()
		if int(itemToGiveIcon_) <= 1:
			self.itemToGiveIcon.LoadImage(slot_base)
		else:
			selectItem(int(itemToGiveIcon_))
			itemToGiveIcon = item.GetIconImageFileName()
			self.itemToGiveIcon.LoadImage(str(itemToGiveIcon))
			select_item_toGiveID = itemToGiveIcon_
	def loadFishSetting(self):
		for fish_id in self.catches.keys():
			# msg("fish_id: " + str(fish_id))
			for fishButtonName in self.catches[fish_id].keys():
				# msg("FishBot_" + str(fish_id) + "_" + fishButtonName)
				self.catches[fish_id][fishButtonName].SetValue(boolean(ReadConfigFish("FishBot_" + str(fish_id) + "_" + fishButtonName)))
				# msg('daaaa')
	def saveFishSetting(self):
		global CONFIG_FISH
		try:
			# self.loadFishSetting()
			if os.path.exists(CONFIG_FISH):
				os.remove(CONFIG_FISH)
			for fish_id in self.catches.keys():
				for fishButtonName in self.catches[fish_id].keys():
					name = "FishBot_" + str(fish_id) + "_" + fishButtonName
					value = self.catches[fish_id][fishButtonName].isOn
					all = name + "=" + str(value) + "\n"
					f = open_file(CONFIG_FISH, 'a')
					lines = [all]
					f.writelines(lines)
					f.close()
		except:
			pass
	def savesettingsFunc(self, abc):
		global Items_Slots, Items_VNUM,setMountVnumFarm,Item_User_Relog_ID
		global CONFIG,ITEMS_TO_SELL,CONFIG_FISH,CONFIG_ITEMS,CONFIG_PRICE
		global autologin_state
		global zoom_state
		global gm_state
		global player_state
		global exp_state
		global dews_state
		global restart_state
		global state_fantom
		global red_state
		global red_e_state
		global blue_state
		global blue_e_state
		global day_state
		global night_state
		global oneh_state
		global twoh_state
		global speed_state
		global vit_state
		global int_state
		global str_state
		global dex_state
		global p1_state
		global p2_state
		global p3_state
		global p4_state
		global p5_state
		global p6_state
		global farm1_state
		global farm2_state
		global mining_state
		global pick1_state
		global pick2_state
		global lvl_state
		global attack_state
		global moblock_state
		global item_user_state
		global hotkey_state
		global one_hit_state
		global capes_state
		global sk1_state
		global sk2_state
		global sk3_state
		global sk4_state
		global sk5_state
		global sk6_state
		global str_body_state
		global pickSpeed,farmEnable
		global antiban_state,useItemHpLowID,sellItemsFunction,rangedMobber
		global changeCHRouteState
		global changeCHNothingState,fish_state,Bait_Alternative_ID,bioBotStatus
		global elixirItem, bioItemReset,Item_User_Status
		global skillsList,SkillbotState,skillsBuffList,defaultRot,dragItemId,dragItem,dragItemId2,dragItem2,megaConfirm,spamState,isGF,waithackState,dragItemId3,dragItem3
		global key1, key2, key3, key4, keyf1, keyf2, keyf3, keyf4, dungeonState,buff1SkillUsage,buff2SkillUsage,buff3SkillUsage,followTargetStatus,BuffBotState,rangeX,rangeY,wallhack
		try:
			os.mkdir(CONFIG_FOLDER)
		except:
			pass
		try:
			try:
				SaveListFile(ITEMS_TO_SELL,self.sellItems)
			except:
				pass
			selectedRoute = self.routeListbox.DropList.GetSelectedItem()
			if selectedRoute:
				last_used_route = str(selectedRoute.textBox.GetText())
			else:
				last_used_route = ""
			selectedEnergyRoute = self.energyRouteListbox.DropList.GetSelectedItem()
			
			if selectedEnergyRoute:
				last_energy_used_route = str(selectedEnergyRoute.textBox.GetText())
			else:
				last_energy_used_route = ""
			hasExtract = None
			if hasattr(net, 'SendItemExtractEnergyPacket'):
				hasExtract = self.extractShards.checked
			else:
				hasExtract = None
			hasPet = None
			if hasattr(net, 'SendPetFeedPacket'):
				hasPet = self.feedPet.checked
			else:
				hasPet = None
			shopIndex = self.shopIndex.GetText()
			buyFromShop = self.buyFromShop.checked
			gotoEnergy = self.gotoEnergy.GetCurrentText()
			stopYang = self.stopYang.checked
			onlyItemsWithout = self.onlyItemsWithout.checked
			yangval = self.yangval.GetText()
			crystal = self.crystal.checked
			fragval = self.fragval.GetText()
			defaultDelayVal = self.sortDelayTxt.GetText()
			
			sellBonusCount = self.sellBonusCount.GetText()
			checkBonusCount = self.checkBonusCount.checked
			
	
			
			
			if isGF:
				fbot_delay = None
				buyFromSlot = None
				delayBuyBot = None
				slotBuyBot = None
				delayUseBot = None
				skipAnim = None
				slotUseBot = None
				filterPickup = None
				minnowCb = None
				alternativeBtn = None
				pasteCb = None
				wormCb = None
				buyBaitBtn = None
				buyBaitQBtn = None
				skipAnim = None
				fishshopIndex = None
				fix_quest = None
				fisherVnum = None
				openclamhBtn = None
				pauseFishEach = None		
				pauseFishing = None
				pauseFishFor = None
				sellminnowCb = None
				playerDetectorFish = None
				switchArmor = None
				upgradeRod = None
				delay_textbox = None
				buyBaitIndex = None
				fix_fishbot = None
				goToFisherman = None
				randomizeFish = None
				split_item_to_value = None
				gotoFisher = None
				randPickSpeed = None
				useCredentials = None
				ignorePickupList = self.ignorePickList.checked
				excludeItems = self.excludeItems.checked
				itemsFirst = self.itemsFirst.checked
				blockedItems = self.blockedItems.checked
				pickupRange = self.pickupRange.GetSliderPos()
				waithackRange = self.waithackRange.GetSliderPos()
				waithackSpeed = self.waithackSpeed.GetSliderPos()
				waithackMonsters = self.waithackMonsters.GetSliderPos()
				waithackBlocked = self.waithackBlocked.checked
				waithackBlocked2 = self.waithackBlocked2.checked
				whMetins = self.whMetins.checked
				whMonsters = self.whMonsters.checked
				whBosses = self.whBosses.checked
				whPlayers = self.whPlayers.checked
				pauseWaithackIf = self.pauseWaithackIf.checked
				walkToItem = self.walkToItem.checked
				pauseWaithackValue = self.pauseWaithackValue.GetText()
			else:
				fbot_delay = self.fbot_delay.GetText()
				buyFromSlot = self.buyFromSlot.GetText()
				delayBuyBot = self.delayBuyBot.GetText()
				slotBuyBot = self.slotBuyBot.GetText()
				delayUseBot = self.delayUseBot.GetText()
				skipAnim = self.skipAnim.checked
				useCredentials = self.useCredentials.checked
				randPickSpeed = self.randomizePickup.checked
				slotUseBot = self.slotUseBot.GetText()
				filterPickup = self.filterPickup.checked
				minnowCb = self.minnowCb.checked
				alternativeBtn = self.alternativeBtn.checked
				pasteCb = self.pasteCb.checked
				wormCb = self.wormCb.checked
				buyBaitBtn = self.buyBaitBtn.checked
				buyBaitQBtn = self.buyBaitQBtn.checked
				skipAnim = self.skipAnim.checked
				fishshopIndex = self.fishshopIndex.GetText()
				fix_quest = self.fix_quest.checked
				fisherVnum = self.fisherVnum.GetText()		
				openclamhBtn = self.openclamhBtn.checked
				pauseFishEach = self.pauseFishEach.GetText()			
				pauseFishing = self.pauseFishing.checked
				pauseFishFor = self.pauseFishFor.GetText()
				sellminnowCb = self.sellminnowCb.checked
				playerDetectorFish = self.playerDetectorFish.checked
				switchArmor = self.switchArmor.checked
				upgradeRod = self.upgradeRod.checked
				delay_textbox = self.delay_textbox.GetText()
				buyBaitIndex = self.buyBaitIndex.GetText()
				fix_fishbot = self.fix_fishbot.checked
				goToFisherman = self.goToFisherman.checked
				randomizeFish = self.randomizeFish.checked
				split_item_to_value = self.split_item_to_value.GetText()
				gotoFisher = self.gotoFisher.GetCurrentText()
				excludeItems = None
				itemsFirst = None
				blockedItems = None
				pickupRange = None
				waithackRange = None
				waithackSpeed = None
				waithackMonsters = None
				waithackBlocked = None
				waithackBlocked2 = None
				whMetins = None
				whMonsters = None
				whBosses = None
				whPlayers = None
				pauseWaithackIf = None
				pauseWaithackValue = None
				ignorePickupList = None
				
				walkToItem = None
			open_file(CONFIG, 'w').write('%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n' % (
			"Alchemist_X_Coord=%s" % str(self.alchemistLocX.GetText()),
			"Alchemist_Y_Coord=%s" % str(self.alchemistLocY.GetText()),
			"AntiBanState=%s" % str(antiban_state),
			"Antiban_AutoAcceptGM=%s" % str(self.AutoAcceptCB2.checked),
			"Antiban_AutoAcceptPlayer=%s" % str(self.AutoAcceptPlayer.checked),
			"Antiban_AcceptFriendRequest=%s" % str(self.playerAutoAcceptFriend.checked),
			"Antiban_CheckForOnlineUsers=%s" % str(self.stopBotIfPlayerOnline.checked),
			"Antiban_SetWalkingGM=%s" % str(self.setWalking2.checked),
			"Antiban_SetWalkingPlayer=%s" % str(self.setWalking1.checked),
			"Antiban_StopAttackGM=%s" % str(self.stopAttackCB2.checked),
			"Antiban_StopAttackPlayer=%s" % str(self.stopAttackCB1.checked),
			"Antiban_StopAutoReplyGM=%s" % str(self.stopReplyCB2.checked),
			"Antiban_StopAutoReplyPlayer=%s" % str(self.stopReplyCB1.checked),
			"Antiban_StopAutoRestartGM=%s" % str(self.stopRevive2.checked),
			"Antiban_StopAutoRestartPlayer=%s" % str(self.stopRevive1.checked),
			"Antiban_StopBuffBotGM=%s" % str(self.stopBuff2.checked),
			"Antiban_StopBuffBotPlayer=%s" % str(self.stopBuff1.checked),
			"Antiban_StopEnergyGM=%s" % str(self.stopEnergyCB2.checked),
			"Antiban_StopEnergyPlayer=%s" % str(self.stopEnergyCB1.checked),
			"Antiban_StopFarmbotGM=%s" % str(self.stopFarmbotCB2.checked),
			"Antiban_StopFarmbotPlayer=%s" % str(self.stopFarmbotCB1.checked),
			"Antiban_StopFishGM=%s" % str(self.stopFishbotCB2.checked),
			"Antiban_StopFishPlayer=%s" % str(self.stopFishbotCB1.checked),
			"Antiban_StopFollowTargetGM=%s" % str(self.stopFollowTarget2.checked),
			"Antiban_StopFollowTargetPlayer=%s" % str(self.stopFollowTarget1.checked),
			"Antiban_StopItemGM=%s" % str(self.stopItemUserCB2.checked),
			"Antiban_StopItemPlayer=%s" % str(self.stopItemUserCB1.checked),
			"Antiban_StopMobberGM=%s" % str(self.stopMobberCB2.checked),
			"Antiban_StopMoblockGM=%s" % str(self.stopMoblockCB2.checked),
			"Antiban_StopMobberPlayer=%s" % str(self.stopMobberCB1.checked),
			"Antiban_StopMoblockPlayer=%s" % str(self.stopMoblockCB1.checked),
			"Antiban_StopOneHitGM=%s" % str(self.stopOneHitCB2.checked),
			"Antiban_StopOneHitPlayer=%s" % str(self.stopOneHitCB1.checked),
			"Antiban_StopPickPickGM=%s" % str(self.stopPickCB2.checked),
			"Antiban_StopPickPickPlayer=%s" % str(self.stopPickCB1.checked),
			"Antiban_StopSellBotGM=%s" % str(self.stopSellCB2.checked),
			"Antiban_StopSellBotPlayer=%s" % str(self.stopSellCB1.checked),
			"Antiban_StopSkillGM=%s" % str(self.stopSkillCB2.checked),
			"Antiban_StopSkillPlayer=%s" % str(self.stopSkillCB1.checked),
			"Antiban_StopSpamGM=%s" % str(self.stopSpamCB2.checked),
			"Antiban_StopSpamPlayer=%s" % str(self.stopSpamCB1.checked),
			"Antiban_StopUseHorseGM=%s" % str(self.stopHorseCB2.checked),
			"Antiban_StopUseHorsePlayer=%s" % str(self.stopHorseCB1.checked),
			"Attack_Func_Mode=%s" % str(self.attackList.GetCurrentText()),
			"Attack_Function=%s" % str(attack_state),
			"ApproachTarget=%s" % str(self.approachTarget.checked),
			"AutoHide=%s" % str(self.autoHide.checked),
			"Auto_Increase_Range=%s" % str(self.fixedRange.checked),
			"Auto_RefreshInventory=%s" % str(self.autoRefreshInventory.checked),
			"Auto_Sort=%s" % str(self.autoSortCB.checked),
			"Auto_Stack=%s" % str(self.autoStackCB.checked),
			"Autologin=%s" % str(self.autologin_state),
			"Autologin_UseCredentials=%s" % str(useCredentials),
			"AutoreplyTimes=%s" % str(self.replyTimesBox.checked),
			"Bio_Command=%s" % str(self.bioTxt.GetText()),
			"Bio_Delay=%s" % str(self.bioDelay.GetText()),
			"Bio_ElixirItemID=%s" % str(elixirItem),
			"Bio_NewBio=%s" % str(self.newBio.checked),
			"Bio_ResetItemID=%s" % str(bioItemReset),
			"Bio_ResetTime=%s" % str(self.resetTime.checked),
			"Bio_UseElixir=%s" % str(self.useElixir.checked),
			"BiologistBotStatus=%s" % str(bioBotStatus),
			"BlockItems=%s" % str(blockedItems),
			"Blue_pots=%s" % str(self.textBlue.GetText()),
			"Bot_delay=%s" % str(fbot_delay),
			"BuffBotDelay=%s" % str(self.buffBotDelayTxt.GetText()),
			"BuffBotState=%s" % str(BuffBotState),
			"BuffSkillsOrder=%s" % str(skillsBuffList),
			"Buy_from_slot=%s" % str(buyFromSlot),
			"Buy_sell_delay=%s" % str(delayBuyBot),
			"Buy_sell_slot=%s" % str(slotBuyBot),
			"Buy_use_delay=%s" % str(delayUseBot),
			"Buy_use_slot=%s" % str(slotUseBot),
			"Cancel_Fishing_Animation=%s" % str(skipAnim),
			"Capes_ID=%s" % str(self.mobberId.GetText()),
			"ChangeCH_InSeconds=%s" % str(self.changeCHIn.GetText()),
			"ChangeCH_Nothing=%s" % str(changeCHNothingState),
			"ChangeCH_Route=%s" % str(changeCHRouteState),
			"ChrRevive=%s" % str(self.state_fantom),
			"Classic_Farming_Start_Button=%s" % str(self.classicStartCB.checked),
			"Confirm_string=%s" % str(self.StringEditline.GetText()),
			"Day=%s" % str(self.day_state),
			"DefaultSortDelay=%s" % str(defaultDelayVal),
			"Destroy_Items_Box=%s" % str(self.destroyThem.checked),
			"Detector_BeepPM=%s" % str(self.beepPM.checked),
			"Detector_GMBeep=%s" % str(self.beepGM.checked),
			"Detector_GMChangeCH=%s" % str(self.changeCHGM.checked),
			"Detector_GMChat=%s" % str(self.notifyGM.checked),
			"Detector_GMLogout=%s" % str(self.logoutGM.checked),
			"Detector_GMQuit=%s" % str(self.quitGM.checked),
			"Detector_GMQuitPM=%s" % str(self.exitPM.checked),
			"Detector_GMQuitPMTimes=%s" % str(self.QuitGMPMTimes.GetText()),
			"Detector_GM_All_Quit=%s" % str(self.quitAllGM.checked),
			"Detector_GM_WindowsNotify=%s" % str(self.notifyWindowsGM.checked),
			"Detector_PlayerBeep=%s" % str(self.beepPl.checked),
			"Detector_PlayerChangeCH=%s" % str(self.changeCHPl.checked),
			"Detector_PlayerChat=%s" % str(self.notifyPl.checked),
			"Detector_PlayerLogout=%s" % str(self.logoutPl.checked),
			"Detector_PlayerQuit=%s" % str(self.quitPl.checked),
			"Detector_Player_WindowsNotify=%s" % str(self.notifyWindowsPl.checked),
			"DoNotAttack=%s" % str(self.doNotAttack.checked),
			"DoNotKs=%s" % str(self.dontKs.checked),
			"DonateEXP_After_Level=%s" % str(self.guildFrom.GetText()),
			"Donate_EXP_When_Percent=%s" % str(self.guildWhenPerc.GetText()),
			"DungeonClickQuest=%s" % str(self.clickQuest.checked),
			"DungeonDELAY=%s" % str(self.dungeonDelay.GetText()),
			"DungeonDrag3Item=%s" % str(self.lblDragItem3.checked),
			"DungeonDrag3ItemID=%s" % str(dragItemId3),
			"DungeonDrag3ItemVNUM=%s" % str(self.DragNpcVNUM3.GetText()),
			"DungeonDrag2Item=%s" % str(self.lblDragItem2.checked),
			"DungeonDrag2ItemID=%s" % str(dragItemId2),
			"DungeonDrag2ItemVNUM=%s" % str(self.DragNpcVNUM2.GetText()),
			"DungeonDragItem=%s" % str(self.lblDragItem.checked),
			"DungeonDragItemID=%s" % str(dragItemId),
			"DungeonDragItemVNUM=%s" % str(self.DragNpcVNUM.GetText()),
			"DungeonNumberVal=%s" % str(self.dungeonNumber.GetText()),
			"DungeonQuestIndex=%s" % str(self.DungeonQuestIndex.GetText()),
			"DungeonState=%s" % str(dungeonState),
			"DungeonVNUM=%s" % str(self.dungeonVnum.GetText()),
			"EXP_Donator=%s" % str(self.exp_state),
			"Enable_reply_bot=%s" % str(self.enableReplyBot.checked),	
			"Energy_AmmountCrystals=%s" % str(fragval),
			"Energy_AutoCreate=%s" % str(crystal),
			"Energy_BuyAvailable=%s" % str(self.buyAvailable.checked),
			"Energy_BuyFromShop=%s" % str(buyFromShop),
			"Energy_Delay=%s" % str(self.energyDelay.GetText()),
			"Energy_GoingMethod=%s" % str(gotoEnergy),
			"Energy_Shop_Index=%s" % str(self.shopIndex.GetText()),
			"Energy_Shop_Index=%s" % str(shopIndex),
			"Energy_StopYang=%s" % str(stopYang),
			"Energy_YangValue=%s" % str(yangval),
			"Energy_UseRoute=%s" % str(self.energyRoute.checked),
			"ExcludeItems=%s" % str(excludeItems),
			"FarmBotState=%s" % str(farmEnable),
			"Farm_Bosses=%s" % str(self.farmBossCB.checked),
			"Farm_By_Route=%s" % str(self.farmbyRouteCB.checked),
			"Farm_GoInitialPos=%s" % str(self.goToInitial.checked),
			"Farm_In_Range=%s" % str(self.farmInRangeCB.checked),
			"Farm_Metins=%s" % str(self.farmMetinsCB.checked),
			"Farm_Monsters=%s" % str(self.farmMobCB.checked),
			"Farm_Ore=%s" % str(self.farmOreCB.checked),
			"Farm_Ore_Time=%s" % str(self.TimeMiningOreVal.GetText()),
			"Farm_RangeX=%s" % str(rangeX),
			"Farm_RangeY=%s" % str(rangeY),
			"Farm_Run_Route_Backwards=%s" % str(self.runRouteBackwards.checked),
			"Farm_Stop_If_Player=%s" % str(self.playerDetector.checked),
			"Farm_Unstuck=%s" % str(self.unstuckCB.checked),
			"Farming_Range=%s" % str(self.newFarmRangeVal.GetText()),
			"FeedPet=%s" % str(hasPet),
			"Filter_Pickup=%s" % str(filterPickup),
			"Fishbot_Bait_Minnow=%s" % str(minnowCb),
			"Fishbot_Bait_Other=%s" % str(alternativeBtn),
			"Fishbot_Bait_OtherID=%s" % str(Bait_Alternative_ID),
			"Fishbot_Bait_Paste=%s" % str(pasteCb),
			"Fishbot_Bait_Worm=%s" % str(wormCb),
			"Fishbot_BuyBait=%s" % str(buyBaitBtn),
			"Fishbot_BuyxBaitQ=%s" % str(buyBaitQBtn),
			"Fishbot_Cancel_Animation=%s" % str(skipAnim),
			"Fishbot_CharacterRotation=%s" % str(defaultRot),
			"Fishbot_Cur_State=%s" % str(fish_state),
			"Fishbot_DefaultShopIndex=%s" % str(fishshopIndex),
			"Fishbot_DisableQuests=%s" % str(fix_quest),
			"Fishbot_FishernumVnum=%s" % str(fisherVnum),
			"Fishbot_OpenClams=%s" % str(openclamhBtn),
			"Fishbot_PauseEach=%s" % str(pauseFishEach),
			"Fishbot_PauseEachMinute=%s" % str(pauseFishing),
			"Fishbot_PauseFor=%s" % str(pauseFishFor),
			"Fishbot_SellMinnow=%s" % str(sellminnowCb),
			"Fishbot_Stop_If_Player=%s" % str(playerDetectorFish),
			"Fishbot_SwitchArmor=%s" % str(switchArmor),
			"Fishbot_UpgradeRod=%s" % str(upgradeRod),
			"Fishbot_delay=%s" % str(delay_textbox),
			"Fishbot_xBuyBaitShopIndex=%s" % str(buyBaitIndex),
			"Fishing_Cancel_Animation_Mount=%s" % str(setMountVnum),
			"Fix_Pulling_Rod=%s" % str(fix_fishbot),
			"FollowTargetStatus=%s" % str(followTargetStatus),
			"GM_Detector=%s" % str(self.gm_state),
			"GoToFisherman=%s" % str(goToFisherman),
			"GoToNPC_Method=%s" % str(self.goToNpcDungeon.GetCurrentText()),
			"GoTo_Next_Target_Quick=%s" % str(self.force.checked),
			"Hotkey_Teleport=%s" % str(self.hotkey_state),
			"HowToFollowTarget=%s" % str(self.followMethod.GetCurrentText()),
			"InitRouteClosest=%s" % str(self.initRouteClosest.checked),
			"ItemSeller_Shards=%s" % str(hasExtract),
			"Item_To_Give_To_Alchemist=%s" % str(select_item_toGiveID),
			"Item_user=%s" % str(item_user_state),
			"ItemsFirst=%s" % str(itemsFirst),
			"Items_to_buy=%s" % str(self.buyFromShopValue.GetText()),
			"JigsawOpenMultiple=%s" % str(self.openJigsawChest.checked),
			"JigsawChestCount=%s" % str(self.jigsawChestCount.GetText()),
			"Last_Used_Route=%s" % str(last_used_route),
			"Last_Energy_Used_Route=%s" % str(last_energy_used_route),
			"ManualVidRange=%s" % str(self.vidRangeLbl1.checked),
			"MapHowToGo=%s" % str(self.mapTeleWalk.GetCurrentText()),
			"MegaMobberConfirmation=%s" % str(megaConfirm),
			"Moblock=%s" % str(moblock_state),
			"Moving_Method=%s" % str(self.farmGoingMethod.GetCurrentText()),
			"NPC_Vnum=%s" % str(self.npcVnum.GetText()),
			"NPC_X_Coord=%s" % str(self.npctoBuyLocX.GetText()),
			"NPC_Y_Coord=%s" % str(self.npctoBuyLocY.GetText()),
			"Night=%s" % str(self.night_state),
			"Normal_Pickup=%s" % str(self.normalPickup.checked),
			"NpcDuplicateCount=%s" % str(self.npc_duplicate_count),
			"One_Hit=%s" % str(self.one_hit_state),
			"One_hand=%s" % str(self.oneh_state),
			"Only_Pickup_After=%s" % str(self.onlyPickup.checked),
			"PauseAttack=%s" % str(self.pauseAttack.checked),
			"PickAllItems_val=%s" % str(self.pickItemsAtOnce.checked),
			"Pickup_IgnoreList=%s" % str(ignorePickupList),
			"Pickup_Range=%s" % str(pickupRange),
			"Pickup_RandomSpeed=%s" % str(randPickSpeed),
			"Pickup_Speed=%s" % str(pickSpeed),
			"Pickup_WalkToItem=%s" % str(walkToItem),
			"Player_Detector=%s" % str(self.player_state),
			"Send_WinNotify_OnPM=%s" % str(self.notifyPM.checked),
			"Priority=%s" % str(self.listPriority.GetCurrentText()),
			"Pull_Mobs=%s" % str(self.capes_state),
			"QuestDuplicateCount=%s" % str(self.quest_duplicate_count),
			"QuitBotAtLevel=%s" % str(self.quitBotLevel.checked),
			"QuitBot_After=%s" % str(self.quitBotCb.checked),
			"QuitBot_IfLoggedOutTime=%s" % str(self.stopquitLogout.GetText()),
			"QuitBot_Minutes=%s" % str(self.quitBotDelay.GetText()),
			"QuitIfLoggedOut=%s" % str(self.quitIfLogout.checked),
			"RadarMetin=%s" % str(self.showMetins.checked),
			"RadarBoss=%s" % str(self.showBoss.checked),
			"RadarOre=%s" % str(self.showOre.checked),
			"RadarPlayer=%s" % str(self.showPlayer.checked),
			"RadarGM=%s" % str(self.showGM.checked),
			"RadarNPC=%s" % str(self.showNPC.checked),
			"RadarRoute=%s" % str(self.drawRoute.checked),
			"RadarPortals=%s" % str(self.showPortals.checked),
			"RadarMobs=%s" % str(self.showMobs.checked),
			"RadarFarmRange=%s" % str(self.drawFarmRange.checked),
			"RadarInitialFarmRange=%s" % str(self.drawInitialFarmRange.checked),
			"RandomizeFishDelay=%s" % str(randomizeFish),
			"RandomizeMiningTime=%s" % str(self.randomizeMiningTime.checked),
			"RangedMobber=%s" % str(rangedMobber),
			"Red_pots=%s" % str(self.textRed.GetText()),
	
			"RelogBotDelay=%s" % str(self.relogBotDelay.GetText()),
			"RelogBotXMinutes=%s" % str(self.relogBotCb.checked),
			"RelogIfNothingToattack=%s" % str(self.relogNothing.checked),
			"Relog_Away_When_HP=%s" % str(self.relogTp.checked),
			"Reply_Delay=%s" % str(self.replyDelay.GetText()),
			"Reply_with_previous_msg_if_unknown=%s" % str(self.repeatMsg.checked),
			"Reply_with_question_mark_if_unknown=%s" % str(self.replyWithQuestion.checked),
			"RestartFarmbotIfNothing=%s" % str(self.restartNothing.checked),
			"Restart_Here=%s" % str(self.restart_state),
			"SDItems_Delay=%s" % str(self.SellItemsDelay.GetText()),
			"Seconds_Wait=%s" % str(self.wait.GetText()),
			"Sell_Items_Box=%s" % str(self.sellThem.checked),
			"Sell_Items_Filter=%s" % str(onlyItemsWithout),
			"Sell_Items_Function=%s" % str(sellItemsFunction),
	
			"Sell_Items_Function_BonusCount=%s" % str(sellBonusCount),
			"Sell_Items_Check_BonusCount=%s" % str(checkBonusCount),
			
			"SkillbotDelay=%s" % str(self.skillbotDelay.GetText()),
			"SkillbotState=%s" % str(skillBotState),
			"SkillsOrder=%s" % str(skillsList),
	
			"SkipTargetNotReach=%s" % str(self.skipTarget.checked),
			"SkipTargetNotReachSeconds=%s" % str(self.targetTimeoutValue.GetText()),
			
			
			
			"SkipMetinAfter=%s" % str(self.skipMetinDelay.GetText()),
			"SkipSkillAnimations=%s" % str(self.useInstant.checked),
			"Skip_MetinIfAttackedFor=%s" % str(self.skipMetin.checked),
			"Spam_delay=%s" % str(self.spamdelayeditline.GetText()),
			"Spam_text=%s" % str(self.spamtexteditline.GetText()),
			"SpambotState=%s" % str(spamState),
			"SpammingColor=%s" % str(self.spamColor.GetCurrentText()),
			"SpammingType=%s" % str(self.spamType.GetCurrentText()),
			"Speed_hack=%s" % str(self.SpeedValue.GetText()),
			"Speedhack=%s" % str(self.speed_state),
			"Split_into=%s" % str(split_item_to_value),
			"StopBotAtLevel=%s" % str(self.stopBotLevel.checked),
			"StopBot_After=%s" % str(self.stopBotCb.checked),
			"StopBot_Minutes=%s" % str(self.stopBotDelay.GetText()),
			"StopPickupIfPlayer=%s" % str(self.playerStopPickup.checked),
			"StopQuitBotAtLevel=%s" % str(self.stopquitLevel.GetText()),
			"StreamerMode=%s" % str(self.streamerMode.checked),
			"Strong_body=%s" % str(str_body_state),
			"TP_Away_When_HP=%s" % str(self.tpAway.checked),
			"TP_Hybrid_Away_When_HP=%s" % str(self.hybridTP.checked),
			"TP_When_Hp_Lower=%s" % str(self.hpLower.GetText()),
			"TargetNameToFollow=%s" % str(self.followTargetName.GetText()),
			"Teleport_Distance=%s" % str(self.telDis.GetText()),
			"Two_hands=%s" % str(self.twoh_state),
			"Upgrade_DEX=%s" % str(self.dex_state),
			"Upgrade_INT=%s" % str(self.int_state),
			"Upgrade_STR=%s" % str(self.str_state),
			"Upgrade_Skill_1=%s" % str(self.p1_state),
			"Upgrade_Skill_2=%s" % str(self.p2_state),
			"Upgrade_Skill_3=%s" % str(self.p3_state),
			"Upgrade_Skill_4=%s" % str(self.p4_state),
			"Upgrade_Skill_5=%s" % str(self.p5_state),
			"Upgrade_Skill_6=%s" % str(self.p6_state),
			"Upgrade_VIT=%s" % str(self.vit_state),
			"UseItemHpLow=%s" % str(self.useItemHpLow.checked),
			"UseItemHp_Low_ItemID=%s" % str(useItemHpLowID),
			"UseItem_HpLow_When=%s" % str(self.useHpLower.GetText()),
			"Use_Dews=%s" % str(self.dews_state),
			"Use_Game_CH_Changer=%s" % str(self.useGameCH.checked),
			"Use_HorseDisableQuest=%s" % str(self.disableQuestHorse.checked),
			"Use_Horse_Ride=%s" % str(self.useHorseCB.checked),
			"Use_Horse_Ride=%s" % str(self.useHorseCB.checked),
			"Use_Horse_Skill_Unstuck=%s" % str(self.useHorseSkill.checked),
			"Use_Hotkeys=%s" % str(self.hotKeyCB.checked),
			"Use_Item_After_Relog=%s" % str(self.useItemRelogBtn.checked),
			"Use_Item_Relog=%s" % str(Item_User_Relog_ID),
			"Use_Mount_=%s" % str(self.useMount.checked),
			"Use_Mount_VNUM=%s" % str(setMountVnumFarm),
			"Use_blue_elixirs=%s" % str(self.blue_e_state),
			"Use_blue_pots=%s" % str(self.blue_state),
			"Use_capes_delay=%s" % str(self.mobberSec.GetText()),
			"Use_dews_delay=%s" % str(self.usedews_delay.GetText()),
			"Use_horse_state=%s" % str(self.useHorseCB.checked),
			"Use_quickSlot_1=%s" % str(key1),
			"Use_quickSlot_2=%s" % str(key2),
			"Use_quickSlot_3=%s" % str(key3),
			"Use_quickSlot_4=%s" % str(key4),
			"Use_quickSlot_F1=%s" % str(keyf1),
			"Use_quickSlot_F2=%s" % str(keyf2),
			"Use_quickSlot_F3=%s" % str(keyf3),
			"Use_quickSlot_F4=%s" % str(keyf4),
			"Use_red_elixirs=%s" % str(self.red_e_state),
			"Use_red_pots=%s" % str(self.red_state),
			"VidRANGE=%s" % str(self.VidRangeVal.GetText()),			
			"WaitBeforeLoggingIn=%s" % str(self.waitMinCb.checked),
			"WaitBefore_Minutes=%s" % str(self.waitMinutesDelay.GetText()),
			"WaitCheck=%s" % str(self.waitAfter.checked),
			"WaitCheckRoute=%s" % str(self.waitRouteAfter.checked),
			"WaitForHP=%s" % str(self.waitForHPBox.checked),
			"WaitForHPValue=%s" % str(self.waitForHP.GetText()),
			"Waithack_AttackBoss=%s" % str(whBosses),
			"Waithack_AttackMetin=%s" % str(whMetins),
			"Waithack_AttackMob=%s" % str(whMonsters),
			"Waithack_AttackPlayer=%s" % str(whPlayers),
			"Waithack_Blocked=%s" % str(waithackBlocked2),
			"Waithack_Monsters=%s" % str(waithackMonsters),
			"Waithack_Range=%s" % str(waithackRange),
			"Waithack_Speed=%s" % str(waithackSpeed),
			"Waithack_State=%s" % str(waithackState),
			"Waithack_WaitHPValue=%s" % str(pauseWaithackValue),
			"Waithack_WaitIfHP=%s" % str(pauseWaithackIf),
			"Waithack_Wall=%s" % str(waithackBlocked),
			"WallHack=%s" % str(wallhack),
			"What_To_Mine=%s" % str(self.NewminingList.GetCurrentText()),
			"Zoom=%s" % str(self.zoom_state),
			"gotoFisher_Moving_Method=%s" % str(gotoFisher),
			))
			
			
			try:
				npc_vnums = [self.dungeonVnum.GetText()] + [dup[2].GetText() for dup in self.npc_duplicate_controls]
				quest_indexes = [self.DungeonQuestIndex.GetText()] + [dup[2].GetText() for dup in self.quest_duplicate_controls]
				quest_click_states = [self.clickQuest.checked] + [dup[0].checked for dup in self.quest_duplicate_controls]
				self.modify_setting(CONFIG, "DungeonVNUM", npc_vnums[0])
				i = 1
				for vnum in npc_vnums[1:]:
					self.modify_setting(CONFIG, "DungeonVNUM_" + str(i), vnum)
					i += 1
				self.modify_setting(CONFIG, "DungeonQuestIndex", quest_indexes[0])
				i = 1
				for index in quest_indexes[1:]:
					self.modify_setting(CONFIG, "DungeonQuestIndex_" + str(i), index)
					i += 1
				self.modify_setting(CONFIG, "DungeonClickQuest", str(quest_click_states[0]))
				i = 1
				for state in quest_click_states[1:]:
					self.modify_setting(CONFIG, "DungeonClickQuest_" + str(i), str(state))
					i += 1
			except:
				pass
				
			
			try:
				self.SaveItems(CONFIG_ITEMS)
			except:
				pass
			try:
				self.saveHotkeys(1)
			except:
				pass
			if abc:
				try:
					self.saveFishSetting()
				except:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hAn error occured while trying to save drop/kill fish settings.")
			if abc:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.STR_SV_SETTINGS_OK)
		except:
			if abc:			
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hAn error occured while trying to save settings.")
	def saveSettings(self):
		global CONFIG,ITEMS_TO_SELL,CONFIG_FISH,CONFIG_ITEMS,CONFIG_PRICE
		setting = ''
		settingx = self.settingsList.GetSelectedItem()
		if not settingx:
			setting = str(getcharName())
		else:
			setting = settingx.GetText()
		if setting == '':
			CONFIG = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_config.st_set'
			ITEMS_TO_SELL = st_path + '/Data/rascal2/sell_items.st_set'
			CONFIG_FISH = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_fishing.st_set'
			CONFIG_ITEMS = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_config_item_user.st_set'
			CONFIG_PRICE = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_priceconfig.st_set'
		else:
			CONFIG = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_config.st_set'
			ITEMS_TO_SELL = st_path + '/Data/rascal2/sell_items.st_set'
			CONFIG_FISH = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_fishing.st_set'
			CONFIG_ITEMS = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_config_item_user.st_set'
			CONFIG_PRICE = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_priceconfig.st_set'
		self.savesettingsFunc(True)
		self.addAllSettings()
	def set_default_hotkeys(self):
		global hotkeyList, hotkeyListDefault
		hotkeyList.clear()
		hotkeyList.update(hotkeyListDefault)
		self.update_gui_dropdowns()
	def loadDefaultSettings(self):
		global CONFIG,ITEMS_TO_SELL,CONFIG_FISH,CONFIG_ITEMS,CONFIG_PRICE
		try:
			if os.path.exists(st_path + "/Data/Servers/" + str(st_cur_server) + '/defaultSettings_config.st_set'):
				CONFIG = st_path + "/Data/Servers/" + str(st_cur_server) + '/defaultSettings_config.st_set'
				ITEMS_TO_SELL = st_path + '/Data/rascal2/sell_items.st_set'
				CONFIG_FISH = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + 'defaultSettings_fishing.st_set'
				CONFIG_ITEMS = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + 'defaultSettings_config_item_user.st_set'
				CONFIG_PRICE = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + 'defaultSettings_priceconfig.st_set'
				if os.path.exists(CONFIG):
					self.loadsettingsFunc()
			setting = ''
			settingx = self.settingsList.GetSelectedItem()
			if not settingx:
				setting = str(getcharName())
			else:
				setting = settingx.GetText()
			if setting == '':
				CONFIG = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_config.st_set'
				ITEMS_TO_SELL = st_path + '/Data/rascal2/sell_items.st_set'
				CONFIG_FISH = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_fishing.st_set'
				CONFIG_ITEMS = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_config_item_user.st_set'
				CONFIG_PRICE = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_priceconfig.st_set'
			else:
				CONFIG = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_config.st_set'
				ITEMS_TO_SELL = st_path + '/Data/rascal2/sell_items.st_set'
				CONFIG_FISH = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_fishing.st_set'
				CONFIG_ITEMS = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_config_item_user.st_set'
				CONFIG_PRICE = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_priceconfig.st_set'
			self.set_default_hotkeys()
		except:
			pass
	def loadSettings(self):
		global CONFIG,ITEMS_TO_SELL,CONFIG_FISH,CONFIG_ITEMS,CONFIG_PRICE
		setting = ''
		settingx = self.settingsList.GetSelectedItem()
		if not settingx:
			setting = str(getcharName())
		else:
			setting = settingx.GetText()
		if setting == '':
			CONFIG = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_config.st_set'
			ITEMS_TO_SELL = st_path + '/Data/rascal2/sell_items.st_set'
			CONFIG_FISH = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_fishing.st_set'
			CONFIG_ITEMS = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_config_item_user.st_set'
			CONFIG_PRICE = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(getcharName()) + '_priceconfig.st_set'
		else:
			CONFIG = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_config.st_set'
			ITEMS_TO_SELL = st_path + '/Data/rascal2/sell_items.st_set'
			CONFIG_FISH = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_fishing.st_set'
			CONFIG_ITEMS = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_config_item_user.st_set'
			CONFIG_PRICE = st_path + "/Data/Servers/" + str(st_cur_server) + '/' + str(setting) + '_priceconfig.st_set'
		if os.path.exists(CONFIG):
			try:
				self.loadsettingsFunc()
			except:
				pass
################################################################################################
	def OnKeyDown(self, key):
		try:
			self.onPressKeyDict[key]()
		except KeyError:
			pass
		except:
			raise
		return True
	def OpenWindow(self):
		pass  # Men almyor
	def Close(self):
		self.metin2_window.Hide()
		visible=0
				
				
############
try:
	original_OnMessengerAddFriendQuestion = game.GameWindow.OnMessengerAddFriendQuestion
	
	def patched_OnMessengerAddFriendQuestion(self, name):
		try:
			if AUTO_ACCEPT_FRIEND:
				rnd = getRandom(0,5)
				eventHandler.add(rnd, lambda: SendChatPacket("/messenger_auth y " + name))
				
				
				return True
		except:
			pass
		return original_OnMessengerAddFriendQuestion(self, name)
	game.GameWindow.OnMessengerAddFriendQuestion = patched_OnMessengerAddFriendQuestion
except:
	pass
	
	
############
BACKGROUND_COLOR = grp.GenerateColor(0.0, 0.0, 0.0, 1.0)
DARK_COLOR = grp.GenerateColor(0.4, 0.4, 0.4, 1.0)
WHITE_COLOR = grp.GenerateColor(1.0, 1.0, 1.0, 0.3)
HALF_WHITE_COLOR = grp.GenerateColor(1.0, 1.0, 1.0, 0.2)
if elixirItems: universalTime(1)
BRIGHT_COLOR = grp.GenerateColor(0.7, 0.7, 0.7, 1.0)
SELECT_COLOR = grp.GenerateColor(0.0, 0.0, 0.5, 0.3)
if find_string(st_cur_server, "merlis"):
	class ScriptWindow(ui.Window):
		def __init__(self, layer = "TOP_MOST"):
			ui.Window.__init__(self, layer)
			self.Children = []
			self.ElementDictionary = {}
		def __del__(self):
			try:
				ui.Window.__del__(self)
			except:
				pass
		def ClearDictionary(self):
			self.Children = []
			self.ElementDictionary = {}
		def InsertChild(self, name, child):
			self.ElementDictionary[name] = child
		def IsChild(self, name):
			global newPython
			if newPython:
				return name in self.ElementDictionary
			else:
				return self.ElementDictionary.has_key(name)
		def GetChild(self, name):
			return self.ElementDictionary[name]
		def GetChild2(self, name):
			return self.ElementDictionary.get(name, None)
else:
	class ScriptWindow(Window):
		def __init__(self, layer = "TOP_MOST"):
			Window.__init__(self, layer)
			self.Children = []
			self.ElementDictionary = {}
		def __del__(self):
			try:
				Window.__del__(self)
			except:
				pass
		def ClearDictionary(self):
			self.Children = []
			self.ElementDictionary = {}
		def InsertChild(self, name, child):
			self.ElementDictionary[name] = child
		def IsChild(self, name):
			global newPython
			if newPython:
				return name in self.ElementDictionary
			else:
				return self.ElementDictionary.has_key(name)
		def GetChild(self, name):
			return self.ElementDictionary[name]
		def GetChild2(self, name):
			return self.ElementDictionary.get(name, None)
class ListBoxEx(Window):
	class Item(Window):
		def __init__(self):
			Window.__init__(self)
		def __del__(self):
			try:
				Window.__del__(self)
			except:
				pass
		def SetParent(self, parent):
			Window.SetParent(self, parent)
			self.parent=proxy(parent)
		def OnMouseLeftButtonDown(self):
			self.parent.SelectItem(self)
		def OnRender(self):
			if self.parent.GetSelectedItem()==self:
				self.OnSelectedRender()
		def OnSelectedRender(self):
			x, y = self.GetGlobalPosition()
			grp.SetColor(grp.GenerateColor(0.0, 0.0, 0.7, 0.7))
			grp.RenderBar(x, y, self.GetWidth(), self.GetHeight())
	def __init__(self):
		Window.__init__(self)
		self.viewItemCount=10
		self.basePos=0
		self.itemHeight=16
		self.itemStep=20
		self.selItem=0
		self.itemList=[]
		self.onSelectItemEvent = lambda *arg: None
		self.itemWidth=100
		self.scrollBar=None
		self.__UpdateSize()
	def __del__(self):
		try:
			Window.__del__(self)
		except:
			pass
	def __UpdateSize(self):
		height=self.itemStep*self.__GetViewItemCount()
		self.SetSize(self.itemWidth, height)
	def IsEmpty(self):
		if len(self.itemList)==0:
			return 1
		return 0
	def SetItemStep(self, itemStep):
		self.itemStep=itemStep
		self.__UpdateSize()
	def SetItemSize(self, itemWidth, itemHeight):
		self.itemWidth=itemWidth
		self.itemHeight=itemHeight
		self.__UpdateSize()
	def SetViewItemCount(self, viewItemCount):
		self.viewItemCount=viewItemCount
	def SetSelectEvent(self, event):
		self.onSelectItemEvent = event
	def SetBasePos(self, basePos):
		for oldItem in self.itemList[self.basePos:self.basePos+self.viewItemCount]:
			oldItem.Hide()
		self.basePos=basePos
		pos=basePos
		for newItem in self.itemList[self.basePos:self.basePos+self.viewItemCount]:
			(x, y)=self.GetItemViewCoord(pos, newItem.GetWidth())
			newItem.SetPosition(x, y)
			newItem.Show()
			pos+=1
	def GetItemIndex(self, argItem):
		return self.itemList.index(argItem)
	def GetSelectedItem(self):
		return self.selItem
	def SelectIndex(self, index):
		if index >= len(self.itemList) or index < 0:
			self.selItem = None
			return
		try:
			self.selItem=self.itemList[index]
		except:
			pass
	def SelectItem(self, selItem):
		self.selItem=selItem
		self.onSelectItemEvent(selItem)
	def RemoveAllItems(self):
		self.selItem=None
		self.itemList=[]
		if self.scrollBar:
			self.scrollBar.SetPos(0)
	def RemoveItem(self, delItem):
		if delItem==self.selItem:
			self.selItem=None
		self.itemList.remove(delItem)
	def AppendItem(self, newItem):
		newItem.SetParent(self)
		newItem.SetSize(self.itemWidth, self.itemHeight)
		pos=len(self.itemList)
		if self.__IsInViewRange(pos):
			(x, y)=self.GetItemViewCoord(pos, newItem.GetWidth())
			newItem.SetPosition(x, y)
			newItem.Show()
		else:
			newItem.Hide()
		self.itemList.append(newItem)
	def SetScrollBar(self, scrollBar):
		scrollBar.SetScrollEvent(__mem_func__(self.__OnScroll))
		self.scrollBar=scrollBar
	def __OnScroll(self):
		self.SetBasePos(int(self.scrollBar.GetPos()*self.__GetScrollLen()))
	def __GetScrollLen(self):
		scrollLen=self.__GetItemCount()-self.__GetViewItemCount()
		if scrollLen<0:
			return 0
		return scrollLen
	def __GetViewItemCount(self):
		return self.viewItemCount
	def __GetItemCount(self):
		return len(self.itemList)
	def GetItemViewCoord(self, pos, itemWidth):
		return (0, (pos-self.basePos)*self.itemStep)
	def __IsInViewRange(self, pos):
		if pos<self.basePos:
			return 0
		if pos>=self.basePos+self.viewItemCount:
			return 0
		return 1
	def OnMouseWheel(self, length):
		if not self.scrollBar:
			return False
		currentPos = self.scrollBar.GetPos()
		step = self.scrollBar.GetScrollStep() or 0.1
		if length > 0:
			newPos = currentPos - step
		elif length < 0:
			newPos = currentPos + step
		else:
			return False
		newPos = max(0.0, min(1.0, newPos))
		self.scrollBar.SetPos(newPos)
		self.scrollBar.eventScroll()
	
		return True
	def OnRunMouseWheel(self, length):
		if not self.scrollBar:
			return False
		currentPos = self.scrollBar.GetPos()
		step = self.scrollBar.GetScrollStep() or 0.1
		if length > 0:
			newPos = currentPos - step
		elif length < 0:
			newPos = currentPos + step
		else:
			return False
		newPos = max(0.0, min(1.0, newPos))
		self.scrollBar.SetPos(newPos)
		self.scrollBar.eventScroll()
	
		return True
	def OnScrollWheel(self, length):
		if not self.scrollBar:
			return False
		currentPos = self.scrollBar.GetPos()
		step = self.scrollBar.GetScrollStep() or 0.1
		if length > 0:
			newPos = currentPos - step
		elif length < 0:
			newPos = currentPos + step
		else:
			return False
		newPos = max(0.0, min(1.0, newPos))
		self.scrollBar.SetPos(newPos)
		self.scrollBar.eventScroll()
	
		return True
if find_string(st_cur_server, "legendofmetin"):
	class BonusListItem(ListBoxEx.Item):
		def __init__(self, bonus_name, default_value, parent):
			ListBoxEx.Item.__init__(self)
			self.SetSize(340, 25)
			self.comp = Component()
	
			self.textLine1 = TextLine()
			self.textLine1.SetParent(self)
			self.textLine1.SetText(lang.MIN_BONUS_VALUE)
			self.textLine1.SetPosition(1, 5)
			self.textLine1.Show()
	
			orange = "|cFFFF8040|H|h"
			self.textLine = TextLine()
			self.textLine.SetParent(self)
			self.textLine.SetText(lang.MIN_BONUS_VALUE_FOR_BNS + " " + str(orange) + str(bonus_name))
			self.textLine.SetPosition(120, 5)
			self.textLine.Show()
		
			self.slotBar, self.editLine = self.comp.EditLine(self, str(default_value), 80, 5, 35, 15, 4)
else:
	class BonusListItem(ui.ListBoxEx.Item):
		def __init__(self, bonus_name, default_value, parent):
			ui.ListBoxEx.Item.__init__(self)
			self.SetSize(340, 25)
			self.comp = Component()
	
			self.textLine1 = ui.TextLine()
			self.textLine1.SetParent(self)
			self.textLine1.SetText(lang.MIN_BONUS_VALUE)
			self.textLine1.SetPosition(1, 5)
			self.textLine1.Show()
	
			orange = "|cFFFF8040|H|h"
			self.textLine = ui.TextLine()
			self.textLine.SetParent(self)
			self.textLine.SetText(lang.MIN_BONUS_VALUE_FOR_BNS + " " + str(orange) + str(bonus_name))
			self.textLine.SetPosition(120, 5)
			self.textLine.Show()
		
			self.slotBar, self.editLine = self.comp.EditLine(self, str(default_value), 80, 5, 35, 15, 4)
class BonusFilterDialog(ScriptWindow):
	def __init__(self):
		ScriptWindow.__init__(self)
		self.comp = Component()
		self.bonus_entries = {}
		self.LoadWindow()
		
	def LoadWindow(self):
		if find_string(st_cur_server, "alune") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "next2play"):
			self.board = ui.BoardWithTitleBar()
		else:
			self.board = BoardWithTitleBar()
		self.board.SetSize(380, 480)
		self.board.SetCenterPosition()
		self.board.SetTitleName("Bonus Filter Settings")
		self.board.AddFlag(movplable)
		# self.board.Show()
		self.settingsItems, self.bonusList, self.settingsScrollbar = self.comp.ListBoxEx2(self.board, 15, 35, 340, 380)
		self.bonusList.SetViewItemCount(19)
		self.CreateBonusInputs()
		self.saveButton = self.comp.Button(
			self.board, "Save", "Save the bonus settings", 
			120, 450, self.SaveSettings, 
			middle1,
			middle2,
			middle3
		)
		self.loadButton = self.comp.Button(
			self.board, "Load", "Load the bonus settings", 
			200, 450, self.LoadSettings, 
			middle1,
			middle2,
			middle3
		)
		
		self.sellFilterInfo = self.comp.Button(self.board, 'Help', '', 10, 9, self.sellFilterInfoFunc, xmall1, xmall2, xmall3)
		
	def sellFilterInfoFunc(self):
		newMsg('\x53\x54\x4d\x6f\x64 ' + lang.NO_TAKE_ACTION, "down", 10, "box_blue", "text_white", 500, 200)
	def CreateBonusInputs(self):
		if not BonusIDListe:
			return
		if isinstance(self.bonusList, tuple):
			listBox = self.bonusList[1]
		else:
			listBox = self.bonusList
	
		listBox.RemoveAllItems()
		self.bonus_entries = {}
	
		listBox.SetSize(340, 380)
		listBox.SetScrollBar(self.settingsScrollbar)
		self.settingsScrollbar.SetPos(0.0)
	
		appended_items = 0
		first_edit_line = None
		for bonus_id, bonus_data in BonusIDListe.items():
			if bonus_id in excludeBonusList:
				continue
			cleaned_bonus_name = "".join([char for char in bonus_data if not char.isdigit() and char not in ["+", "%", "-", ":"]]).strip()
			default_value = oldytBonus.get(bonus_id, 0)
		
			listItem = BonusListItem(cleaned_bonus_name, default_value, self)
			listBox.AppendItem(listItem)
		
			self.bonus_entries[bonus_id] = listItem.editLine
		self.settingsScrollbar.Show()
		listBox.Show()
	
		if first_edit_line:
			first_edit_line.SetFocus()
	
	def SaveSettings(self):
		saved_bonuses = []
		for bonus_id, editLine in self.bonus_entries.items():
			try:
				value = int(editLine.GetText())
				
				saved_bonuses.append(str(bonus_id) + "|" + str(value))
			except:
				pass
		if saved_bonuses:
			f = open_file(st_path + '/Data/rascal2/sell_items_bonus_filter.st_set', "w")
			f.write("\n".join(saved_bonuses))
			f.close()
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hSell items filter list saved successfully!")
		self.LoadSettings()
	def LoadSettings(self):
		if not oldytBonus:
			return
		try:
			f = open_file(st_path + '/Data/rascal2/sell_items_bonus_filter.st_set', "r+")
			saved_data = f.readlines()
			f.close()
	
			if not saved_data:
				return
	
			for line in saved_data:
				line = line.strip()
				if "|" in line:
					split_data = line.split("|")
					bonus_id = int(split_data[0])
					value = int(split_data[1])
	
					oldytBonus[bonus_id] = value
	
					if bonus_id in self.bonus_entries:
						self.bonus_entries[bonus_id].SetText(str(value))
	
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hSell items filter list loaded successfully!")
	
		except IOError:
			pass
		for bonus_id in BonusIDListe:
			if bonus_id not in oldytBonus:
				oldytBonus[bonus_id] = 0
	
				if bonus_id in self.bonus_entries:
					self.bonus_entries[bonus_id].SetText("0")
	
	def Open(self):
		self.LoadSettings()
		self.CreateBonusInputs()
		self.board.Show()
	
	def Close(self):
		
		self.board.Hide()
class ImageBox(Window):
	def __init__(self, layer='UI'):
		Window.__init__(self, layer)
		self.eventDict = {}
		self.ToolTipText = None
	def __del__(self):
		try:
			Window.__del__(self)
		except:
			pass
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.RegisterImageBox(self, layer)
	def LoadImage(self, imageName):
		self.name = imageName
		wndMgr.LoadImage(self.hWnd, imageName)
	def SetAlpha(self, alpha):
		wndMgr.SetDiffuseColor(self.hWnd, 1.0, 1.0, 1.0, alpha)
	def SetImgColor(self, r, g, b, a):
		wndMgr.SetDiffuseColor(self.hWnd, 153, 153, 102, a)
	def GetWidth(self):
		return wndMgr.GetWidth(self.hWnd)
	def GetHeight(self):
		return wndMgr.GetHeight(self.hWnd)
	def SetText(self, text):
		textLine = Textline()
		textLine.SetParent(self)
		textLine.SetPosition(0, 0)
		textLine.SetText(text)
		textLine.Show()
		textLine.SetPackedFontColor(0x7eFFFFFF)
	def OnMouseOverIn(self):
		try:
			self.eventDict['MOUSE_OVER_IN']()
		except KeyError:
			pass
		if self.ToolTipText:
			self.ToolTipText.Show()
	def OnMouseOverOut(self):
		try:
			self.eventDict['MOUSE_OVER_OUT']()
		except KeyError:
			pass
		if self.ToolTipText:
			self.ToolTipText.Hide()
	def SAFE_SetStringEvent(self, event, func, isa=False):
		if not isa:
			self.eventDict[event] = __mem_func__(func)
		else:
			self.eventDict[event] = func
	def SetFormToolTipText(self, type, text, x, y):
		if not self.ToolTipText:
			toolTip = createToolTipWindowDict[type]()
			toolTip.SetParent(self)
			toolTip.SetSize(0, 0)
			toolTip.SetHorizontalAlignCenter()
			try:
				toolTip.SetOutline()
			except:
				pass
			toolTip.Hide()
			toolTip.SetPosition(x + float(self.GetWidth()) / 2, y)
			self.ToolTipText = toolTip
		self.ToolTipText.SetText(text)
	def SetToolTipWindow(self, toolTip):
		self.ToolTipText = toolTip
		self.ToolTipText.SetParentProxy(self)
	def SetToolTipText(self, text, x=0, y=-19):
		self.SetFormToolTipText('TEXT', text, x, y)
		self.ToolTipText.SetPackedFontColor(0x7eFFFF00)
def universalTime(arg):
	if arg:
		quitPid = st_path + "/Data/Servers/" + str(st_cur_server) + "/quit_" + str(pid)
		quitx = open_file(quitPid, 'w')
		quitx.write("1")
		quitx.close()
class SlotWindow(Window):
	if find_string(st_cur_server, "nextworld"):
		but1 = "d:/worktree/ui/_ui_nextworld2/public/slot_cover_button_03.slc"
		but2 = "d:/worktree/ui/_ui_nextworld2/public/slot_cover_button_03.slc"
		but3 = "d:/worktree/ui/_ui_nextworld2/public/slot_cover_button_03.slc"
		but4 = "d:/worktree/ui/_ui_nextworld2/public/slot_cover_button_03.slc"
	else:
		but1="d:/ymir work/ui/public/slot_cover_button_01.sub"
		but2="d:/ymir work/ui/public/slot_cover_button_02.sub"
		but3="d:/ymir work/ui/public/slot_cover_button_03.sub"
		but4="d:/ymir work/ui/public/slot_cover_button_04.sub"
	def __init__(self):
		Window.__init__(self)
		self.StartIndex = 0
		self.eventSelectEmptySlot = None
		self.eventSelectItemSlot = None
		self.eventUnselectEmptySlot = None
		self.eventUnselectItemSlot = None
		self.eventUseSlot = None
		self.eventOverInItem = None
		self.eventOverOutItem = None
		self.eventPressedSlotButton = None
	def __del__(self):
		try:
			Window.__del__(self)
		except:
			pass
		self.eventSelectEmptySlot = None
		self.eventSelectItemSlot = None
		self.eventUnselectEmptySlot = None
		self.eventUnselectItemSlot = None
		self.eventUseSlot = None
		self.eventOverInItem = None
		self.eventOverOutItem = None
		self.eventPressedSlotButton = None
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.RegisterSlotWindow(self, layer)
	def SetSlotStyle(self, style):
		wndMgr.SetSlotStyle(self.hWnd, style)
	def HasSlot(self, slotIndex):
		return wndMgr.HasSlot(self.hWnd, slotIndex)
	def SetSlotBaseImage(self, imageFileName, r, g, b, a):
		wndMgr.SetSlotBaseImage(self.hWnd, imageFileName, r, g, b, a)
	def SetCoverButton(self,\
						slotIndex,\
						upName=but1,\
						overName=but2,\
						downName=but3,\
						disableName=but4,\
						LeftButtonEnable = False,\
						RightButtonEnable = True):
		wndMgr.SetCoverButton(self.hWnd, slotIndex, upName, overName, downName, disableName, LeftButtonEnable, RightButtonEnable)
	def EnableCoverButton(self, slotIndex):
		wndMgr.EnableCoverButton(self.hWnd, slotIndex)
	def DisableCoverButton(self, slotIndex):
		wndMgr.DisableCoverButton(self.hWnd, slotIndex)
	def SetAlwaysRenderCoverButton(self, slotIndex, bAlwaysRender = True):
		wndMgr.SetAlwaysRenderCoverButton(self.hWnd, slotIndex, bAlwaysRender)
	def AppendSlotButton(self, upName, overName, downName):
		wndMgr.AppendSlotButton(self.hWnd, upName, overName, downName)
	def ShowSlotButton(self, slotNumber):
		wndMgr.ShowSlotButton(self.hWnd, slotNumber)
	def HideAllSlotButton(self):
		wndMgr.HideAllSlotButton(self.hWnd)
	def AppendRequirementSignImage(self, filename):
		wndMgr.AppendRequirementSignImage(self.hWnd, filename)
	def ShowRequirementSign(self, slotNumber):
		wndMgr.ShowRequirementSign(self.hWnd, slotNumber)
	def HideRequirementSign(self, slotNumber):
		wndMgr.HideRequirementSign(self.hWnd, slotNumber)
	def ActivateSlot(self, slotNumber):
		wndMgr.ActivateSlot(self.hWnd, slotNumber)
	def DeactivateSlot(self, slotNumber):
		wndMgr.DeactivateSlot(self.hWnd, slotNumber)
	def ShowSlotBaseImage(self, slotNumber):
		wndMgr.ShowSlotBaseImage(self.hWnd, slotNumber)
	def HideSlotBaseImage(self, slotNumber):
		wndMgr.HideSlotBaseImage(self.hWnd, slotNumber)
	def SAFE_SetButtonEvent(self, button, state, event):
		if "LEFT"==button:
			if "EMPTY"==state:
				self.eventSelectEmptySlot=__mem_func__(event)
			elif "EXIST"==state:
				self.eventSelectItemSlot=__mem_func__(event)
			elif "ALWAYS"==state:
				self.eventSelectEmptySlot=__mem_func__(event)
				self.eventSelectItemSlot=__mem_func__(event)
		elif "RIGHT"==button:
			if "EMPTY"==state:
				self.eventUnselectEmptySlot=__mem_func__(event)
			elif "EXIST"==state:
				self.eventUnselectItemSlot=__mem_func__(event)
			elif "ALWAYS"==state:
				self.eventUnselectEmptySlot=__mem_func__(event)
				self.eventUnselectItemSlot=__mem_func__(event)
	def SetSelectEmptySlotEvent(self, empty):
		self.eventSelectEmptySlot = empty
	def SetSelectItemSlotEvent(self, item):
		self.eventSelectItemSlot = item
	def SetUnselectEmptySlotEvent(self, empty):
		self.eventUnselectEmptySlot = empty
	def SetUnselectItemSlotEvent(self, item):
		self.eventUnselectItemSlot = item
	def SetUseSlotEvent(self, use):
		self.eventUseSlot = use
	def SetOverInItemEvent(self, event):
		self.eventOverInItem = event
	def SetOverOutItemEvent(self, event):
		self.eventOverOutItem = event
	def SetPressedSlotButtonEvent(self, event):
		self.eventPressedSlotButton = event
	def GetSlotCount(self):
		return wndMgr.GetSlotCount(self.hWnd)
	def SetUseMode(self, flag):
		wndMgr.SetUseMode(self.hWnd, flag)
	def SetUsableItem(self, flag): 
		wndMgr.SetUsableItem(self.hWnd, flag)
	## Slot
	def SetSlotCoolTime(self, slotIndex, coolTime, elapsedTime = 0.0):
		wndMgr.SetSlotCoolTime(self.hWnd, slotIndex, coolTime, elapsedTime)
	def DisableSlot(self, slotIndex):
		wndMgr.DisableSlot(self.hWnd, slotIndex)
	def EnableSlot(self, slotIndex):
		wndMgr.EnableSlot(self.hWnd, slotIndex)
	def LockSlot(self, slotIndex):
		wndMgr.LockSlot(self.hWnd, slotIndex)
	def UnlockSlot(self, slotIndex):
		wndMgr.UnlockSlot(self.hWnd, slotIndex)
	def RefreshSlot(self):
		wndMgr.RefreshSlot(self.hWnd)
	def ClearSlot(self, slotNumber):
		wndMgr.ClearSlot(self.hWnd, slotNumber)
	def ClearAllSlot(self):
		wndMgr.ClearAllSlot(self.hWnd)
	def AppendSlot(self, index, x, y, width, height):
		wndMgr.AppendSlot(self.hWnd, index, x, y, width, height)
	def SetSlot(self, slotIndex, itemIndex, width, height, icon, diffuseColor = (1.0, 1.0, 1.0, 1.0)):
		wndMgr.SetSlot(self.hWnd, slotIndex, itemIndex, width, height, icon, diffuseColor)
	def SetSlotCount(self, slotNumber, count):
		wndMgr.SetSlotCount(self.hWnd, slotNumber, count)
	def SetSlotCountNew(self, slotNumber, grade, count):
		wndMgr.SetSlotCountNew(self.hWnd, slotNumber, grade, count)
	def SetItemSlot(self, renderingSlotNumber, ItemIndex, ItemCount = 0, diffuseColor = (1.0, 1.0, 1.0, 1.0)):
		if 0 == ItemIndex or None == ItemIndex:
			wndMgr.ClearSlot(self.hWnd, renderingSlotNumber)
			return
		selectItem(ItemIndex)
		itemIcon = item.GetIconImage()
		selectItem(ItemIndex)
		(width, height) = item.GetItemSize()
		wndMgr.SetSlot(self.hWnd, renderingSlotNumber, ItemIndex, width, height, itemIcon, diffuseColor)
		wndMgr.SetSlotCount(self.hWnd, renderingSlotNumber, ItemCount)
	def SetSkillSlot(self, renderingSlotNumber, skillIndex, skillLevel):
		skillIcon = skill.GetIconImage(skillIndex)
		if 0 == skillIcon:
			wndMgr.ClearSlot(self.hWnd, renderingSlotNumber)
			return
		wndMgr.SetSlot(self.hWnd, renderingSlotNumber, skillIndex, 1, 1, skillIcon)
		wndMgr.SetSlotCount(self.hWnd, renderingSlotNumber, skillLevel)
	def SetSkillSlotNew(self, renderingSlotNumber, skillIndex, skillGrade, skillLevel):
		skillIcon = skill.GetIconImageNew(skillIndex, skillGrade)
		if 0 == skillIcon:
			wndMgr.ClearSlot(self.hWnd, renderingSlotNumber)
			return
		wndMgr.SetSlot(self.hWnd, renderingSlotNumber, skillIndex, 1, 1, skillIcon)
	def SetEmotionSlot(self, renderingSlotNumber, emotionIndex):
		icon = player.GetEmotionIconImage(emotionIndex)
		if 0 == icon:
			wndMgr.ClearSlot(self.hWnd, renderingSlotNumber)
			return
		wndMgr.SetSlot(self.hWnd, renderingSlotNumber, emotionIndex, 1, 1, icon)
	## Event
	def OnSelectEmptySlot(self, slotNumber):
		if self.eventSelectEmptySlot:
			self.eventSelectEmptySlot(slotNumber)
	def OnSelectItemSlot(self, slotNumber):
		if self.eventSelectItemSlot:
			self.eventSelectItemSlot(slotNumber)
	def OnUnselectEmptySlot(self, slotNumber):
		if self.eventUnselectEmptySlot:
			self.eventUnselectEmptySlot(slotNumber)
	def OnUnselectItemSlot(self, slotNumber):
		if self.eventUnselectItemSlot:
			self.eventUnselectItemSlot(slotNumber)
	def OnUseSlot(self, slotNumber):
		if self.eventUseSlot:
			self.eventUseSlot(slotNumber)
	def OnOverInItem(self, slotNumber):
		if self.eventOverInItem:
			self.eventOverInItem(slotNumber)
	def OnOverOutItem(self):
		if self.eventOverOutItem:
			self.eventOverOutItem()
	def OnPressedSlotButton(self, slotNumber):
		if self.eventPressedSlotButton:
			self.eventPressedSlotButton(slotNumber)
	def GetStartIndex(self):
		return 0
class GridSlotWindow(SlotWindow):
	def __init__(self):
		SlotWindow.__init__(self)
		self.startIndex = 0
	def __del__(self):
		SlotWindow.__del__(self)
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.RegisterGridSlotWindow(self, layer)
	def ArrangeSlot(self, StartIndex, xCount, yCount, xSize, ySize, xBlank, yBlank):
		self.startIndex = StartIndex
		wndMgr.ArrangeSlot(self.hWnd, StartIndex, xCount, yCount, xSize, ySize, xBlank, yBlank)
		self.startIndex = StartIndex
	def GetStartIndex(self):
		return self.startIndex
class TitleBar(Window):
	BLOCK_WIDTH = 32
	BLOCK_HEIGHT = 23
	def __init__(self):
		Window.__init__(self)
		self.AddFlag("attach")
	def __del__(self):
		try:
			Window.__del__(self)
		except:
			pass
	def MakeTitleBar(self, width, color):
		if find_string(st_cur_server, "Mt2Mester") or find_string(st_cur_server, "eclipse") or find_string(st_cur_server, "aleris") or find_string(st_cur_server, "aladam") or find_string(st_cur_server, "baria") or find_string(st_cur_server, "LandOfHeroes") or find_string(st_cur_server, "caroline") or find_string(st_cur_server, "odyssey") or find_string(st_cur_server, "rpp") or find_string(st_cur_server, "mt2.hu") or find_string(st_cur_server, "magictime") or find_string(st_cur_server, "pegasus"):
			btnLoc = "d:/ymir work/ui/pattern/"
		else:
			if os.path.exists('rascal2/'):
				btnLoc = 'rascal2/img/buttons/'
			else:
				try:
					copy_folder(st_path + "/Data/rascal2/img/buttons", "rascal2/img/buttons")
					btnLoc = 'rascal2/img/buttons/'
				except Exception:
					try:
						exc_type, exc_value, exc_traceback = sys.exc_info()
						err = exc_type.__name__
						if str('RuntimeError') in err:
							btnLoc = "d:/ymir work/ui/pattern/"
					except:
						pass
		width = max(64, width)
		imgLeft = ImageBox()
		imgCenter = ExpandedImageBox()
		imgRight = ImageBox()
		imgLeft.AddFlag("not_pick")
		imgCenter.AddFlag("not_pick")
		imgRight.AddFlag("not_pick")
		imgLeft.SetParent(self)
		imgCenter.SetParent(self)
		imgRight.SetParent(self)
		try:
			imgLeft.LoadImage(btnLoc + "titlebar_left.tga")
			imgCenter.LoadImage(btnLoc + "titlebar_center.tga")
			imgRight.LoadImage(btnLoc + "titlebar_right.tga")
		except Exception:
			try:
				exc_type, exc_value, exc_traceback = sys.exc_info()
				err = exc_type.__name__
				if str('RuntimeError') in err:
					btnLoc = "d:/ymir work/ui/pattern/"
					imgLeft.LoadImage(btnLoc + "titlebar_left.tga")
					imgCenter.LoadImage(btnLoc + "titlebar_center.tga")
					imgRight.LoadImage(btnLoc + "titlebar_right.tga")
			except:
				pass
		imgLeft.Show()
		imgCenter.Show()
		imgRight.Show()
		btnClose = Button()
		btnClose.SetParent(self)
		btnClose.SetUpVisual(close1)
		btnClose.SetOverVisual(close2)
		btnClose.SetDownVisual(close3)
		btnClose.SetToolTipText('', 0, -23)
		btnClose.Show()
		# btnMinimize = Button()
		# btnMinimize.SetParent(self)
		# btnMinimize.SetUpVisual(btnLoc + "minimize_button_01.sub")
		# btnMinimize.SetOverVisual(btnLoc + "minimize_button_02.sub")
		# btnMinimize.SetDownVisual(btnLoc + "minimize_button_03.sub")
		# btnMinimize.SetToolTipText('', -15, -23)
		# btnMinimize.Show()
		self.imgLeft = imgLeft
		self.imgCenter = imgCenter
		self.imgRight = imgRight
		self.btnClose = btnClose
		# self.btnMinimize = btnMinimize
		self.SetWidth(width)
	def SetWidth(self, width):
		self.imgCenter.SetRenderingRect(0.0, 0.0, float((width - self.BLOCK_WIDTH*2) - self.BLOCK_WIDTH) / self.BLOCK_WIDTH, 0.0)
		self.imgCenter.SetPosition(self.BLOCK_WIDTH, 0)
		self.imgRight.SetPosition(width - self.BLOCK_WIDTH, 0)
		self.btnClose.SetPosition(width - self.btnClose.GetWidth() - 3, 3)
		# self.btnMinimize.SetPosition(width - self.btnMinimize.GetWidth() - 20, 3)
		self.SetSize(width, self.BLOCK_HEIGHT)
	def SetCloseEvent(self, event):
		self.btnClose.SetEvent(event)
	# def SetMinimizeEvent(self, event):
		# self.btnMinimize.SetEvent(event)

class ExpandedImageBox(ImageBox):
	def __init__(self, layer = "TOP_MOST"):
		ImageBox.__init__(self, layer)
	def __del__(self):
		ImageBox.__del__(self)
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.RegisterExpandedImageBox(self, layer)
	def SetScale(self, xScale, yScale):
		wndMgr.SetScale(self.hWnd, xScale, yScale)
	def SetOrigin(self, x, y):
		wndMgr.SetOrigin(self.hWnd, x, y)
	def SetRotation(self, rotation):
		wndMgr.SetRotation(self.hWnd, rotation)
	def SetRenderingMode(self, mode):
		wndMgr.SetRenderingMode(self.hWnd, mode)
	def SetRenderingRect(self, left, top, right, bottom):
		wndMgr.SetRenderingRect(self.hWnd, left, top, right, bottom)
	def SetPercentage(self, curValue, maxValue):
		if maxValue:
			self.SetRenderingRect(0.0, 0.0, -1.0 + float(curValue) / float(maxValue), 0.0)
		else:
			self.SetRenderingRect(0.0, 0.0, 0.0, 0.0)
	def GetWidth(self):
		return wndMgr.GetWindowWidth(self.hWnd)
	def GetHeight(self):
		return wndMgr.GetWindowHeight(self.hWnd)
class Board(Window):
	CORNER_WIDTH = 32
	CORNER_HEIGHT = 32
	LINE_WIDTH = 128
	LINE_HEIGHT = 128
	LT = 0
	LB = 1
	RT = 2
	RB = 3
	L = 0
	R = 1
	T = 2
	B = 3
	def __init__(self, layer = "TOP_MOST"):
		Window.__init__(self, layer)
		if find_string(st_cur_server, "Mt2Mester") or find_string(st_cur_server, "eclipse") or find_string(st_cur_server, "aleris") or find_string(st_cur_server, "aladam") or find_string(st_cur_server, "baria") or find_string(st_cur_server, "baria") or find_string(st_cur_server, "LandOfHeroes") or find_string(st_cur_server, "caroline") or find_string(st_cur_server, "SoW2") or find_string(st_cur_server, "Zemia") or find_string(st_cur_server, "lucerna") or find_string(st_cur_server, "veshia") or find_string(st_cur_server, "rhodium") or find_string(st_cur_server, "lucerna") or find_string(st_cur_server, "Origins") or find_string(st_cur_server, "Sancy") or find_string(st_cur_server, "odyssey")  or find_string(st_cur_server, "rpp") or find_string(st_cur_server, "mt2.hu") or find_string(st_cur_server, "magictime") or find_string(st_cur_server, "pegasus"):
			btnLoc = "d:/ymir work/ui/pattern/"
		else:
			if os.path.exists('rascal2/'):
				btnLoc = 'rascal2/img/buttons/'
			else:
				try:
					copy_folder(st_path + "/Data/rascal2/img/buttons", "rascal2/img/buttons")
					btnLoc = 'rascal2/img/buttons/'
				except Exception:
					try:
						exc_type, exc_value, exc_traceback = sys.exc_info()
						err = exc_type.__name__
						if str('RuntimeError') in err:
							btnLoc = "d:/ymir work/ui/pattern/"
					except:
						pass
		self.MakeBoard(btnLoc + "board_corner_", btnLoc + "board_line_")
		self.MakeBase()
	def MakeBoard(self, cornerPath, linePath):
		CornerFileNames = [ cornerPath+dir+".tga" for dir in ("lefttop", "leftbottom", "righttop", "rightbottom", ) ]
		LineFileNames = [ linePath+dir+".tga" for dir in ("left", "right", "top", "bottom", ) ]
		self.Corners = []
		for fileName in CornerFileNames:
			Corner = ExpandedImageBox()
			Corner.AddFlag("not_pick")
			Corner.LoadImage(fileName)
			Corner.SetParent(self)
			Corner.SetPosition(0, 0)
			Corner.Show()
			self.Corners.append(Corner)
		self.Lines = []
		for fileName in LineFileNames:
			Line = ExpandedImageBox()
			Line.AddFlag("not_pick")
			Line.LoadImage(fileName)
			Line.SetParent(self)
			Line.SetPosition(0, 0)
			Line.Show()
			self.Lines.append(Line)
		self.Lines[self.L].SetPosition(0, self.CORNER_HEIGHT)
		self.Lines[self.T].SetPosition(self.CORNER_WIDTH, 0)
	def MakeBase(self):
		self.Base = ExpandedImageBox()
		self.Base.AddFlag("not_pick")
		if find_string(st_cur_server, "Mt2Mester") or find_string(st_cur_server, "eclipse") or find_string(st_cur_server, "aleris") or find_string(st_cur_server, "aladam") or find_string(st_cur_server, "baria") or find_string(st_cur_server, "LandOfHeroes") or find_string(st_cur_server, "caroline") or find_string(st_cur_server, "Origins") or find_string(st_cur_server, "odyssey")  or find_string(st_cur_server, "rpp") or find_string(st_cur_server, "mt2.hu") or find_string(st_cur_server, "magictime") or find_string(st_cur_server, "pegasus"):
			btnLoc = "d:/ymir work/ui/pattern/"
		else:
			if os.path.exists('rascal2/'):
				btnLoc = 'rascal2/img/buttons/'
			else:
				try:
					copy_folder(st_path + "/Data/rascal2/img/buttons", "rascal2/img/buttons")
					btnLoc = 'rascal2/img/buttons/'
				except Exception:
					try:
						exc_type, exc_value, exc_traceback = sys.exc_info()
						err = exc_type.__name__
						if str('RuntimeError') in err:
							btnLoc = "d:/ymir work/ui/pattern/"
					except:
						pass
		self.Base.LoadImage(btnLoc + "board_base.tga")
		self.Base.SetParent(self)
		self.Base.SetPosition(self.CORNER_WIDTH, self.CORNER_HEIGHT)
		self.Base.Show()
	def __del__(self):
		try:
			Window.__del__(self)
		except:
			pass
	def SetSize(self, width, height):
		width = max(self.CORNER_WIDTH*2, width)
		height = max(self.CORNER_HEIGHT*2, height)
		Window.SetSize(self, width, height)
		self.Corners[self.LB].SetPosition(0, height - self.CORNER_HEIGHT)
		self.Corners[self.RT].SetPosition(width - self.CORNER_WIDTH, 0)
		self.Corners[self.RB].SetPosition(width - self.CORNER_WIDTH, height - self.CORNER_HEIGHT)
		self.Lines[self.R].SetPosition(width - self.CORNER_WIDTH, self.CORNER_HEIGHT)
		self.Lines[self.B].SetPosition(self.CORNER_HEIGHT, height - self.CORNER_HEIGHT)
		verticalShowingPercentage = float((height - self.CORNER_HEIGHT*2) - self.LINE_HEIGHT) / self.LINE_HEIGHT
		horizontalShowingPercentage = float((width - self.CORNER_WIDTH*2) - self.LINE_WIDTH) / self.LINE_WIDTH
		self.Lines[self.L].SetRenderingRect(0, 0, 0, verticalShowingPercentage)
		self.Lines[self.R].SetRenderingRect(0, 0, 0, verticalShowingPercentage)
		self.Lines[self.T].SetRenderingRect(0, 0, horizontalShowingPercentage, 0)
		self.Lines[self.B].SetRenderingRect(0, 0, horizontalShowingPercentage, 0)
		if self.Base:
			self.Base.SetRenderingRect(0, 0, horizontalShowingPercentage, verticalShowingPercentage)
if find_string(st_cur_server, "SoW2") or find_string(st_cur_server, "mt2classichu") or find_string(st_cur_server, "Invision") or find_string(st_cur_server, "everin") or find_string(st_cur_server, "landofheroes") or find_string(st_cur_server, "nextworld"):
	class BoardWithTitleBar(ui.Board):
		def __init__(self):
			ui.Board.__init__(self)
			titleBar = ui.TitleBar()
			titleBar.SetParent(self)
			titleBar.MakeTitleBar(0, "red")
			titleBar.SetPosition(8, 7)
			titleBar.Show()
			titleName = ui.TextLine()
			titleName.SetParent(titleBar)
			titleName.SetPosition(0, 4)
			titleName.SetWindowHorizontalAlignCenter()
			titleName.SetHorizontalAlignCenter()
			titleName.Show()
			self.titleBar = titleBar
			self.titleName = titleName
			self.SetCloseEvent(self.Hide)
		def __del__(self):
			ui.Board.__del__(self)
			self.titleBar = None
			self.titleName = None
		def SetSize(self, width, height):
			self.titleBar.SetWidth(width - 15)
			ui.Board.SetSize(self, width, height)
			self.titleName.UpdateRect()
		def SetTitleColor(self, color):
			self.titleName.SetPackedFontColor(color)
		def SetTitleName(self, name):
			self.titleName.SetText(name)
		def SetCloseEvent(self, event):
			self.titleBar.SetCloseEvent(event)
else:
	class BoardWithTitleBar(Board):
		global isGF
		def __init__(self):
			Board.__init__(self)
			titleBar = TitleBar()
			titleBar.SetParent(self)
			titleBar.MakeTitleBar(0, "red")
			titleBar.SetPosition(8, 7)
			titleBar.Show()
			if isGF:
				titleName = ui.TextLine()
			else:
				titleName = Textline()
			titleName.SetParent(titleBar)
			titleName.SetPosition(0, 4)
			titleName.SetWindowHorizontalAlignCenter()
			titleName.SetHorizontalAlignCenter()
			titleName.Show()
			self.titleBar = titleBar
			self.titleName = titleName
			self.SetCloseEvent(self.Hide)
		def __del__(self):
			Board.__del__(self)
			self.titleBar = None
			self.titleName = None
		def SetSize(self, width, height):
			self.titleBar.SetWidth(width - 15)
			Board.SetSize(self, width, height)
			self.titleName.UpdateRect()
		def SetTitleColor(self, color):
			self.titleName.SetPackedFontColor(color)
		def SetTitleName(self, name):
			self.titleName.SetText(name)
		def SetCloseEvent(self, event):
			self.titleBar.SetCloseEvent(event)
class Box(Window):
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.RegisterBox(self, layer)
	def SetColor(self, color):
		wndMgr.SetColor(self.hWnd, color)
class Bar(Window):
	def RegisterWindow(self, layer = "TOP_MOST"):
		self.hWnd = wndMgr.RegisterBar(self, layer)
	def SetColor(self, color):
		wndMgr.SetColor(self.hWnd, color)
class TextBar(Window):
	def __init__(self, width, height):
		Window.__init__(self)
		self.handle = grp.CreateTextBar(width, height)
	def __del__(self):
		try:
			Window.__del__(self)
			grp.DestroyTextBar(self.handle)
		except:
			pass
	def ClearBar(self):
		grp.ClearTextBar(self.handle)
	def SetClipRect(self, x1, y1, x2, y2):
		grp.SetTextBarClipRect(self.handle, x1, y1, x2, y2)
	def TextOut(self, x, y, text):
		grp.TextBarTextOut(self.handle, x, y, text)
	def OnRender(self):
		x, y = self.GetGlobalPosition()
		grp.RenderTextBar(self.handle, x, y)
	def SetTextColor(self, r, g, b):
		grp.TextBarSetTextColor(self.handle, r, g, b)
	def GetTextExtent(self, text):
		return grp.TextBarGetTextExtent(self.handle, text)

if hasattr(grp, 'CreateBigTextBar'):
	class BigTextBar(TextBar):
		def __init__(self, width, height, fontSize):
			Window.__init__(self)
			self.handle = grp.CreateBigTextBar(width, height, fontSize)
else:
	class BigTextBar(Window):
		def __init__(self, width, height, fontSize):
			Window.__init__(self)
			self.width = width
			self.height = height
			self.fontSize = fontSize
			self.textLines = []
			self.SetSize(width, height)
	
		def AddText(self, text, x, y, color):
			textLine = ui.TextLine()
			textLine.SetParent(self)
			textLine.SetPosition(x, y)
			textLine.SetText(text)
			textLine.SetPackedFontColor(self.__ConvertToPackedColor(color))
			textLine.Show()
	
			self.textLines.append(textLine)
	
		def ClearBar(self):
			for textLine in self.textLines:
				textLine.Hide()
				textLine = None
			self.textLines = []
	
		def __ConvertToPackedColor(self, color):
			r, g, b = color
			return (r << 16) | (g << 8) | b
		
BOX_COLOR_DICT = {
	"box_green": (0.0, 1.0, 0.0, 0.5),
	"box_red": (1.0, 0.0, 0.0, 0.5),
	"box_blue": (0.0, 0.0, 1.0, 0.5),
	"box_white": (1.0, 1.0, 1.0, 1.0),
	"box_black": (0.0, 0.0, 0.0, 1.0),
	"box_yellow": (1.0, 1.0, 0.0, 0.5),
	"box_cyan": (0.0, 1.0, 1.0, 0.5),
	"box_magenta": (1.0, 0.0, 1.0, 0.5),
	"box_orange": (1.0, 0.5, 0.0, 0.5),
	"box_purple": (0.5, 0.0, 0.5, 0.5),
	"box_pink": (1.0, 0.75, 0.8, 0.5),
	"box_gray": (0.5, 0.5, 0.5, 0.5),
	"box_light_blue": (0.5, 0.5, 1.0, 0.5),
	"box_dark_green": (0.0, 0.5, 0.0, 0.5),
	"box_brown": (0.65, 0.16, 0.16, 0.5)
}
TEXT_COLOR_DICT = {
	"text_white": (255, 255, 255, 255),
	"text_black": (10, 10, 10, 255),
	"text_red": (255, 0, 0, 255),
	"text_green": (0, 255, 0, 255),
	"text_blue": (0, 0, 255, 255),
	"text_yellow": (255, 255, 0, 255),
	"text_cyan": (0, 255, 255, 255),
	"text_magenta": (255, 0, 255, 255),
	"text_orange": (255, 165, 0, 255),
	"text_purple": (128, 0, 128, 255),
	"text_pink": (255, 192, 203, 255),
	"text_gray": (128, 128, 128, 255),
	"text_light_blue": (173, 216, 230, 255),
	"text_dark_green": (0, 100, 0, 255),
	"text_brown": (165, 42, 42, 255)
}
class BigBoard2(Bar):
	SCROLL_WAIT_TIME = 5.0  # Time to wait before scrolling to the next tip.
	FONT_WIDTH = 18  # Width of each character in the font.
	FONT_HEIGHT = 18  # Height of each character in the font.
	LINE_WIDTH = 500  # Maximum width for a line of text.
	LINE_HEIGHT = FONT_HEIGHT + 5  # Height of a line of text, including padding.
	
	def __init__(self):
		Bar.__init__(self)
	
		self.AddFlag("not_pick")  # Prevent picking/clicking on the board.
		self.tipList = []  # List to store tips to display.
	
		self.SetPosition(0, 150)  # Set initial position of the board.
		self.SetSize(512, 55)  # Set size of the board.
		self.SetColor(grp.GenerateColor(0.0, 1.0, 0.0, 0.5))  # Default transparent green background.
		self.SetWindowHorizontalAlignCenter()  # Center the board horizontally.
	
		self.__CreateTextBar()  # Create the text bar for displaying text.
	
	def __CreateTextBar(self):
		self.textBar = BigTextBar(self.LINE_WIDTH, 300, self.FONT_HEIGHT)  # Create the text bar.
		self.textBar.SetParent(self)  # Set the board as the parent of the text bar.
		self.textBar.SetPosition(0, 0)  # Position the text bar at the top-left of the box.
		self.textBar.SetTextColor(242, 231, 193)  # Default text color.
		self.textBar.Show()  # Show the text bar.
	
	def __SplitTextIntoLines(self, text):
		words = text.split(" ")
		lines = []
		current_line = ""
	
		for word in words:
			# test_line = current_line + ("" if not current_line else " ") + word
			
			if current_line:
				test_line = current_line + " " + word
			else:
				test_line = current_line + word
			
			text_width, _ = self.textBar.GetTextExtent(test_line)
	
			if text_width <= self.LINE_WIDTH:
				current_line = test_line
			else:
				lines.append(current_line.strip())
				current_line = word
	
		if current_line:
			lines.append(current_line.strip())
	
		return lines
	
	def __CleanOldTip(self):
		curTime = app.GetTime()  # Get the current time.
		leaveList = []  # List to store valid tips.
		for madeTime, text, position, duration, boxColor, textColor in self.tipList:
			if curTime - madeTime <= duration:  # Check if the tip's duration has expired.
				leaveList.append((madeTime, text, position, duration, boxColor, textColor))
	
		self.tipList = leaveList  # Update the tip list.
	
		if not leaveList:  # If no tips remain, clear the text bar and hide the board.
			self.textBar.ClearBar()
			self.Hide()
			return
	
		self.__RefreshBoard()  # Refresh the board to show remaining tips.
	
	def __RefreshBoard(self):
		self.textBar.ClearBar()  # Clear the text bar.
	
		for checkTime, text, position, duration, boxColor, textColor in self.tipList:
			# Split the text into lines, considering both newlines and wrapping
			raw_lines = text.split("\n")
			wrapped_lines = []
	
			for raw_line in raw_lines:
				wrapped_lines.extend(self.__SplitTextIntoLines(raw_line))
	
			total_height = len(wrapped_lines) * self.LINE_HEIGHT
	
			# Adjust box height to fit all lines
			self.SetSize(self.GetWidth(), total_height + 10)
	
			# Set the box background color
			self.SetColor(grp.GenerateColor(*boxColor))
	
			# Set the text color
			self.textBar.SetTextColor(*textColor[:3])  # Use only R, G, B values.
	
			# Calculate starting y-coordinate for centering text
			start_y = 5  # Add a small padding at the top
	
			for i, line in enumerate(wrapped_lines):
				(text_width, text_height) = self.textBar.GetTextExtent(line)
	
				# Calculate position for each line
				# x = position[0] if position[0] != -1 else (self.GetWidth() - text_width) // 2
				
				if position[0] != -1:
					x = position[0]
				else:
					x = (self.GetWidth() - text_width) // 2
				
				
				y = start_y + i * self.LINE_HEIGHT
	
				# Ensure the text is fully visible
				self.textBar.TextOut(x, y, line)
	def SetTip(self, text, position=None, duration=10.0, boxColor=(0.0, 1.0, 0.0, 0.5), textColor=(242, 231, 193, 255), width=512, height=55):
		if position is None:
			position = (-1, -1)
		curTime = app.GetTime()
		self.tipList.append((curTime, text, position, duration, boxColor, textColor))
		self.SetSize(width, height)
		self.__RefreshBoard()
		if not self.IsShow():
			self.Show()
	def OnUpdate(self):
		if not self.tipList: 
			self.Hide()
			return
	
		self.__CleanOldTip() 
	
	def SetTop(self):
		self.SetPosition(0, 50) 
		return (-1, -1) 
	
	def SetBottom(self):
		bottom_reserved_space = 250  
		self.SetPosition(0, wndMgr.GetScreenHeight() - self.GetHeight() - bottom_reserved_space)
		return (-1, -1)
	
	def SetCenter(self):
		self.SetPosition(0, (wndMgr.GetScreenHeight() - self.GetHeight()) / 2)
		return (-1, -1)
try:
	bigBoardMessage = BigBoard2()
	POSITION_DICT = {
		"up": bigBoardMessage.SetTop,
		"top": bigBoardMessage.SetTop,
		"down": bigBoardMessage.SetBottom,
		"center": bigBoardMessage.SetCenter
	}
	def newMsg(text, position, duration, boxColor, textColor, width=512, height=55):
		# newMsg("Hello!\ntest\ntest2\ntest4\ntest7\ntest\ntest2\ntest4\ntest7", "up", 4, "box_red", "text_white", 500, 200)
		
		global streamer
		if streamer == 0:
		
			try:
				pos_func = POSITION_DICT[position]()
				box_color_value = BOX_COLOR_DICT[boxColor]
				text_color_value = TEXT_COLOR_DICT[textColor]
				bigBoardMessage.SetTip(text, pos_func, duration, box_color_value, text_color_value, width, height)
			except:
				msg(text)
				
	def newMsgSimple(msg):
		newMsg(str(msg), "up", 4, "box_blue", "text_white", 500, 200)
				
except:
	def newMsg(text, position, duration, boxColor, textColor, width=512, height=55):
		msg(text)
		
class Line(Window):
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.RegisterLine(self, layer)
	def SetColor(self, color):
		wndMgr.SetColor(self.hWnd, color)
class Slotbar(Window):
	def __init__(self):
		Window.__init__(self)
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.RegisterBar3D(self, layer)
class Bar3D(Window):
	def __init__(self):
		Window.__init__(self)
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.RegisterBar3D(self, layer)
	def SetColor(self, left, right, center):
		wndMgr.SetColor(self.hWnd, left, right, center)
class ThinBoard(Window):
	CORNER_WIDTH = 16
	CORNER_HEIGHT = 16
	LINE_WIDTH = 16
	LINE_HEIGHT = 16
	BOARD_COLOR = grp.GenerateColor(0.0, 0.0, 0.0, 0.51)
	LT = 0
	LB = 1
	RT = 2
	RB = 3
	L = 0
	R = 1
	T = 2
	B = 3
	def __init__(self, layer = "TOP_MOST"):
		Window.__init__(self, layer)
		if find_string(st_cur_server, "Mt2Mester") or find_string(st_cur_server, "eclipse") or find_string(st_cur_server, "aleris") or find_string(st_cur_server, "aladam") or find_string(st_cur_server, "baria") or find_string(st_cur_server, "LandOfHeroes") or find_string(st_cur_server, "caroline") or find_string(st_cur_server, "Origins") or find_string(st_cur_server, "odyssey")  or find_string(st_cur_server, "rpp") or find_string(st_cur_server, "mt2.hu") or find_string(st_cur_server, "magictime") or find_string(st_cur_server, "atheria") or find_string(st_cur_server, "pegasus"):
			btnLoc = "d:/ymir work/ui/pattern/"
		else:
			if os.path.exists('rascal2/'):
				btnLoc = 'rascal2/img/buttons/'
			else:
				try:
					copy_folder(st_path + "/Data/rascal2/img/buttons", "rascal2/img/buttons")
					btnLoc = 'rascal2/img/buttons/'
				except Exception:
					try:
						exc_type, exc_value, exc_traceback = sys.exc_info()
						err = exc_type.__name__
						if str('RuntimeError') in err:
							btnLoc = "d:/ymir work/ui/pattern/"
					except:
						pass
		self.MakeBoard(btnLoc + "thinboard_corner_", btnLoc + "thinboard_line_")
	def MakeBoard(self, cornerPath, linePath):
		CornerFileNames = [ cornerPath+dir+".tga" for dir in ("lefttop", "leftbottom", "righttop", "rightbottom", ) ]
		LineFileNames = [ linePath+dir+".tga" for dir in ("left", "right", "top", "bottom", ) ]
		self.Corners = []
		for fileName in CornerFileNames:
			Corner = ExpandedImageBox()
			Corner.AddFlag("not_pick")
			Corner.LoadImage(fileName)
			Corner.SetParent(self)
			Corner.SetPosition(0, 0)
			Corner.Show()
			self.Corners.append(Corner)
		self.Lines = []
		for fileName in LineFileNames:
			Line = ExpandedImageBox()
			Line.AddFlag("not_pick")
			Line.LoadImage(fileName)
			Line.SetParent(self)
			Line.SetPosition(0, 0)
			Line.Show()
			self.Lines.append(Line)
		Base = Bar()
		Base.SetParent(self)
		Base.AddFlag("attach")
		Base.AddFlag("not_pick")
		Base.SetPosition(self.CORNER_WIDTH, self.CORNER_HEIGHT)
		Base.SetColor(self.BOARD_COLOR)
		Base.Show()
		self.Base = Base
		self.Lines[self.L].SetPosition(0, self.CORNER_HEIGHT)
		self.Lines[self.T].SetPosition(self.CORNER_WIDTH, 0)
	def __del__(self):
		try:
			Window.__del__(self)
		except:
			pass
	def SetSize(self, width, height):
		width = max(self.CORNER_WIDTH*2, width)
		height = max(self.CORNER_HEIGHT*2, height)
		Window.SetSize(self, width, height)
		self.Corners[self.LB].SetPosition(0, height - self.CORNER_HEIGHT)
		self.Corners[self.RT].SetPosition(width - self.CORNER_WIDTH, 0)
		self.Corners[self.RB].SetPosition(width - self.CORNER_WIDTH, height - self.CORNER_HEIGHT)
		self.Lines[self.R].SetPosition(width - self.CORNER_WIDTH, self.CORNER_HEIGHT)
		self.Lines[self.B].SetPosition(self.CORNER_HEIGHT, height - self.CORNER_HEIGHT)
		verticalShowingPercentage = float((height - self.CORNER_HEIGHT*2) - self.LINE_HEIGHT) / self.LINE_HEIGHT
		horizontalShowingPercentage = float((width - self.CORNER_WIDTH*2) - self.LINE_WIDTH) / self.LINE_WIDTH
		self.Lines[self.L].SetRenderingRect(0, 0, 0, verticalShowingPercentage)
		self.Lines[self.R].SetRenderingRect(0, 0, 0, verticalShowingPercentage)
		self.Lines[self.T].SetRenderingRect(0, 0, horizontalShowingPercentage, 0)
		self.Lines[self.B].SetRenderingRect(0, 0, horizontalShowingPercentage, 0)
		self.Base.SetSize(width - self.CORNER_WIDTH*2, height - self.CORNER_HEIGHT*2)
	def ShowInternal(self):
		self.Base.Show()
		for wnd in self.Lines:
			wnd.Show()
		for wnd in self.Corners:
			wnd.Show()
	def HideInternal(self):
		self.Base.Hide()
		for wnd in self.Lines:
			wnd.Hide()
		for wnd in self.Corners:
			wnd.Hide()
class Textline(Window):
	def __init__(self):
		Window.__init__(self)
		self.max = 0
		self.SetFontName('Tahoma:12')
	def __del__(self):
		try:
			Window.__del__(self)
		except:
			pass
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.RegisterTextLine(self, layer)
	def SetMax(self, max):
		wndMgr.SetMax(self.hWnd, max)
	def SetLimitWidth(self, width):
		wndMgr.SetLimitWidth(self.hWnd, width)
	def SetMultiLine(self):
		wndMgr.SetMultiLine(self.hWnd, True)
	def SetHorizontalAlignArabic(self):
		wndMgr.SetHorizontalAlign(self.hWnd, wndMgr.TEXT_HORIZONTAL_ALIGN_ARABIC)
	def SetHorizontalAlignLeft(self):
		wndMgr.SetHorizontalAlign(self.hWnd, wndMgr.TEXT_HORIZONTAL_ALIGN_LEFT)
	def SetHorizontalAlignRight(self):
		wndMgr.SetHorizontalAlign(self.hWnd, wndMgr.TEXT_HORIZONTAL_ALIGN_RIGHT)
	def SetHorizontalAlignCenter(self):
		wndMgr.SetHorizontalAlign(self.hWnd, wndMgr.TEXT_HORIZONTAL_ALIGN_CENTER)
	def SetVerticalAlignTop(self):
		wndMgr.SetVerticalAlign(self.hWnd, wndMgr.TEXT_VERTICAL_ALIGN_TOP)
	def SetVerticalAlignBottom(self):
		wndMgr.SetVerticalAlign(self.hWnd, wndMgr.TEXT_VERTICAL_ALIGN_BOTTOM)
	def SetVerticalAlignCenter(self):
		wndMgr.SetVerticalAlign(self.hWnd, wndMgr.TEXT_VERTICAL_ALIGN_CENTER)
	def SetSecret(self, Value=True):
		wndMgr.SetSecret(self.hWnd, Value)
	def SetOutline(self, Value=True):
		wndMgr.SetOutline(self.hWnd, Value)
	def SetFeather(self, value=True):
		wndMgr.SetFeather(self.hWnd, value)
	def SetFontName(self, fontName):
		wndMgr.SetFontName(self.hWnd, fontName)
	def SetDefaultFontName(self):
		wndMgr.SetFontName(self.hWnd, 'Tahoma:12')
	def SetFontColor(self, red, green, blue):
		wndMgr.SetFontColor(self.hWnd, red, green, blue)
	def SetPackedFontColor(self, color):
		wndMgr.SetFontColor(self.hWnd, color)
	def SetText(self, text):
		wndMgr.SetText(self.hWnd, text)
	def GetText(self):
		return wndMgr.GetText(self.hWnd)
	def GetTextSize(self):
		if hasattr(wndMgr, 'GetTextSize'):
			return wndMgr.GetTextSize(self.hWnd)
class EmptyCandidateWindow(Window):
	def __init__(self):
		Window.__init__(self)
	def __del__(self):
		Window.__init__(self)
	def Load(self):
		pass
	def SetCandidatePosition(self, x, y, textCount):
		pass
	def Clear(self):
		pass
	def Append(self, text):
		pass
	def Refresh(self):
		pass
	def Select(self):
		pass
class MarkBox(Window):
	def __init__(self, layer = "TOP_MOST"):
		Window.__init__(self, layer)
	def __del__(self):
		try:
			Window.__del__(self)
		except:
			pass
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.RegisterMarkBox(self, layer)
	def Load(self):
		wndMgr.MarkBox_Load(self.hWnd)
	def SetScale(self, scale):
		wndMgr.MarkBox_SetScale(self.hWnd, scale)
	def SetIndex(self, guildID):
		MarkID = guild.GuildIDToMarkID(guildID)
		wndMgr.MarkBox_SetImageFilename(self.hWnd, guild.GetMarkImageFilenameByMarkID(MarkID))
		wndMgr.MarkBox_SetIndex(self.hWnd, guild.GetMarkIndexByMarkID(MarkID))
	def SetAlpha(self, alpha):
		wndMgr.MarkBox_SetDiffuseColor(self.hWnd, 1.0, 1.0, 1.0, alpha)
class Circle(Window):
	def __init__(self, parent=None, radius=50, layer='UI', color=(255, 255, 255)):
		super().__init__(layer)
		self.radius = radius
		self.color = color
		self.SetSize(self.radius * 2, self.radius * 2)
		self.SetParent(parent)
		self.SetColor(self.color)
		self.SetPosition(0, 0)
	def SetRadius(self, radius):
		self.radius = radius
		self.SetSize(self.radius * 2, self.radius * 2)
		self.UpdateRect()
	def SetColor(self, color):
		self.color = color
		wndMgr.SetDiffuseColor(self.hWnd, *self.color)
	def SetPosition(self, x, y):
		# Center the circle at (x, y)
		super().SetPosition(x - self.radius, y - self.radius)
	def Draw(self):
		wndMgr.SetWindowSize(self.hWnd, self.radius * 2, self.radius * 2)
		wndMgr.SetWindowPosition(self.hWnd, self.GetWindowGlobalPosition())
		wndMgr.SetDiffuseColor(self.hWnd, *self.color)
		wndMgr.Show(self.hWnd)
class Button(Window):
	def __init__(self, layer = "TOP_MOST"):
		Window.__init__(self, layer)
		self.eventFunc = None
		self.eventArgs = None
		self.ButtonText = None
		self.ToolTipText = None
	def __del__(self):
		try:
			Window.__del__(self)
		except:
			pass
		self.eventFunc = None
		self.eventArgs = None
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.RegisterButton(self, layer)
	def SetUpVisual(self, filename):
		wndMgr.SetUpVisual(self.hWnd, filename)
	def SetOverVisual(self, filename):
		wndMgr.SetOverVisual(self.hWnd, filename)
	def SetDownVisual(self, filename):
		wndMgr.SetDownVisual(self.hWnd, filename)
	def SetDisableVisual(self, filename):
		wndMgr.SetDisableVisual(self.hWnd, filename)
	def GetUpVisualFileName(self):
		return wndMgr.GetUpVisualFileName(self.hWnd)
	def GetOverVisualFileName(self):
		return wndMgr.GetOverVisualFileName(self.hWnd)
	def GetDownVisualFileName(self):
		return wndMgr.GetDownVisualFileName(self.hWnd)
	def Flash(self):
		wndMgr.Flash(self.hWnd)
	def Enable(self):
		wndMgr.Enable(self.hWnd)
	def Disable(self):
		wndMgr.Disable(self.hWnd)
	def Down(self):
		wndMgr.Down(self.hWnd)
	def SetUp(self):
		wndMgr.SetUp(self.hWnd)
	def SAFE_SetEvent(self, func, *args):
		self.eventFunc = __mem_func__(func)
		self.eventArgs = args
	def SetEvent(self, func, *args):
		self.eventFunc = func
		self.eventArgs = args
	def SetTextColor(self, color):
		if not self.ButtonText:
			return
		self.ButtonText.SetPackedFontColor(color)
	def SetText(self, text, height = 4):
		if not self.ButtonText:
			if isGF:
				textLine = ui.TextLine()
			else:
				textLine = Textline()
			textLine.SetParent(self)
			textLine.SetPosition(self.GetWidth()/2, self.GetHeight()/2)
			textLine.SetVerticalAlignCenter()
			textLine.SetHorizontalAlignCenter()
			textLine.Show()
			self.ButtonText = textLine
		self.ButtonText.SetText(text)
	def SetFormToolTipText(self, type, text, x, y):
		if not self.ToolTipText:		
			toolTip=createToolTipWindowDict[type]()
			toolTip.SetParent(self)
			toolTip.SetSize(0, 0)
			toolTip.SetHorizontalAlignCenter()
			toolTip.SetOutline()
			toolTip.Hide()
			toolTip.SetPosition(x + self.GetWidth()/2, y)
			self.ToolTipText=toolTip
		self.ToolTipText.SetText(text)
	def SetToolTipWindow(self, toolTip):		
		self.ToolTipText=toolTip		
		self.ToolTipText.SetParentProxy(self)
	def SetToolTipText(self, text, x=0, y = -19):
		self.SetFormToolTipText("TEXT", text, x, y)
	def CallEvent(self):
		try:
			snd.PlaySound("sound/ui/click.wav")
		except:
			pass
		if self.eventFunc:
			self.eventFunc(*self.eventArgs)
	def ShowToolTip(self):
		if self.ToolTipText:
			self.ToolTipText.Show()
	def HideToolTip(self):
		if self.ToolTipText:
			self.ToolTipText.Hide()
	def IsDown(self):
		return wndMgr.IsDown(self.hWnd)
class RadioButton(Button):
	def __init__(self):
		Button.__init__(self)
	def __del__(self):
		Button.__del__(self)
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.RegisterRadioButton(self, layer)

createToolTipWindowDict = {}
def RegisterCandidateWindowClass(codePage, candidateWindowClass):
	EditLine.candidateWindowClassDict[codePage]=candidateWindowClass
def RegisterToolTipWindow(type, createToolTipWindow):
	createToolTipWindowDict[type]=createToolTipWindow
class TextLine(Window):
	def __init__(self, font=None):
		Window.__init__(self)
		self.max = 0
		self.SetFontName('Tahoma:12')
	def __del__(self):
		try:
			Window.__del__(self)
		except:
			pass
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.RegisterTextLine(self, layer)
	def SetMax(self, max):
		wndMgr.SetMax(self.hWnd, max)
	def SetLimitWidth(self, width):
		wndMgr.SetLimitWidth(self.hWnd, width)
	def SetMultiLine(self):
		wndMgr.SetMultiLine(self.hWnd, True)
	def SetHorizontalAlignArabic(self):
		wndMgr.SetHorizontalAlign(self.hWnd, wndMgr.TEXT_HORIZONTAL_ALIGN_ARABIC)
	def SetHorizontalAlignLeft(self):
		wndMgr.SetHorizontalAlign(self.hWnd, wndMgr.TEXT_HORIZONTAL_ALIGN_LEFT)
	def SetHorizontalAlignRight(self):
		wndMgr.SetHorizontalAlign(self.hWnd, wndMgr.TEXT_HORIZONTAL_ALIGN_RIGHT)
	def SetHorizontalAlignCenter(self):
		wndMgr.SetHorizontalAlign(self.hWnd, wndMgr.TEXT_HORIZONTAL_ALIGN_CENTER)
	def SetVerticalAlignTop(self):
		wndMgr.SetVerticalAlign(self.hWnd, wndMgr.TEXT_VERTICAL_ALIGN_TOP)
	def SetVerticalAlignBottom(self):
		wndMgr.SetVerticalAlign(self.hWnd, wndMgr.TEXT_VERTICAL_ALIGN_BOTTOM)
	def SetVerticalAlignCenter(self):
		wndMgr.SetVerticalAlign(self.hWnd, wndMgr.TEXT_VERTICAL_ALIGN_CENTER)
	def SetSecret(self, Value=True):
		wndMgr.SetSecret(self.hWnd, Value)
	try:
		def SetOutline(self, Value=True):
			if find_string(st_cur_server, "Nw2Online") or find_string(st_cur_server, "nextworld"):
				pass
			else:
				wndMgr.SetOutline(self.hWnd, Value)
	except:
		pass
	def SetFeather(self, value=True):
		wndMgr.SetFeather(self.hWnd, value)
	def SetFontName(self, fontName):
		wndMgr.SetFontName(self.hWnd, fontName)
	def SetDefaultFontName(self):
		wndMgr.SetFontName(self.hWnd, 'Tahoma:12')
	def SetFontColor(self, red, green, blue):
		wndMgr.SetFontColor(self.hWnd, red, green, blue)
	def SetPackedFontColor(self, color):
		wndMgr.SetFontColor(self.hWnd, color)
	def SetText(self, text):
		wndMgr.SetText(self.hWnd, text)
	def GetText(self):
		return wndMgr.GetText(self.hWnd)
	def GetTextSize(self):
		return wndMgr.GetTextSize(self.hWnd)
RegisterToolTipWindow('TEXT', TextLine)
class ReadingWnd(Bar):
	def __init__(self):
		Bar.__init__(self,"TOP_MOST")
		self.__BuildText()
		self.SetSize(80, 19)
		self.Show()
	def __del__(self):
		Bar.__del__(self)
	def __BuildText(self):
		self.text = Textline()
		self.text.SetParent(self)
		self.text.SetPosition(4, 3)
		self.text.Show()
	def SetText(self, text):
		self.text.SetText(text)
	def SetReadingPosition(self, x, y):
		xPos = x + 2
		yPos = y  - self.GetHeight() - 2
		self.SetPosition(xPos, yPos)
	def SetTextColor(self, color):
		self.text.SetPackedFontColor(color)
class EditLine(TextLine):
	candidateWindowClassDict = {}
	def __init__(self):
		TextLine.__init__(self)
		self.eventReturn = Window.NoneMethod
		self.eventEscape = Window.NoneMethod
		self.eventTab = None
		self.numberMode = False
		self.eventUpdate = None
		self.useIME = True
		self.bCodePage = False
		self.candidateWindowClass = None
		self.candidateWindow = None
		try:
			self.SetCodePage(app.GetDefaultCodePage())
		except:
			pass
		self.readingWnd = ReadingWnd()
		self.readingWnd.Hide()
	def __del__(self):
		TextLine.__del__(self)
		self.eventReturn = Window.NoneMethod
		self.eventEscape = Window.NoneMethod
		self.eventTab = None
	def SetCodePage(self, codePage):
		candidateWindowClass=EditLine.candidateWindowClassDict.get(codePage, EmptyCandidateWindow)
		self.__SetCandidateClass(candidateWindowClass)
	def __SetCandidateClass(self, candidateWindowClass):
		if self.candidateWindowClass==candidateWindowClass:
			return
		self.candidateWindowClass = candidateWindowClass
		self.candidateWindow = self.candidateWindowClass()
		self.candidateWindow.Load()
		self.candidateWindow.Hide()
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.RegisterTextLine(self, layer)
	def SAFE_SetReturnEvent(self, event):
		self.eventReturn = __mem_func__(event)		
	def SetReturnEvent(self, event):
		self.eventReturn = event
	def SetEscapeEvent(self, event):
		self.eventEscape = event
	def SetTabEvent(self, event):
		self.eventTab = event
	def SetMax(self, max):
		self.max = max
		wndMgr.SetMax(self.hWnd, self.max)
		try:
			ime.SetMax(self.max)
		except:
			pass
		self.SetUserMax(self.max)
	def SetUserMax(self, max):
		self.userMax = max
		try:
			ime.SetUserMax(self.userMax)
		except:
			pass
	def SetNumberMode(self):
		self.numberMode = True
	def SetIMEFlag(self, flag):
		self.useIME = flag
	def SetText(self, text):
		wndMgr.SetText(self.hWnd, text)
		if self.IsFocus():
			try:
				ime.SetText(text)
			except:
				pass
	def Enable(self):
		wndMgr.ShowCursor(self.hWnd)
	def Disable(self):
		wndMgr.HideCursor(self.hWnd)
	def SetEndPosition(self):
		try:
			ime.MoveEnd()
		except:
			pass
	def OnSetFocus(self):
		try:
			Text = self.GetText()
			ime.SetText(Text)
			try:
				ime.SetMax(self.max)
				ime.SetUserMax(self.userMax)
			except:
				pass
			ime.SetCursorPosition(-1)
			if self.numberMode:
				ime.SetNumberMode()
			else:
				ime.SetStringMode()
			ime.EnableCaptureInput()
			if self.useIME:
				ime.EnableIME()
			else:
				ime.DisableIME()
			wndMgr.ShowCursor(self.hWnd, True)
		except:
			pass
	def OnKillFocus(self):
		self.SetText(ime.GetText(self.bCodePage))
		self.OnIMECloseCandidateList()
		self.OnIMECloseReadingWnd()
		ime.DisableIME()
		ime.DisableCaptureInput()
		wndMgr.HideCursor(self.hWnd)
	def OnIMEChangeCodePage(self):
		self.SetCodePage(ime.GetCodePage())
	def OnIMEOpenCandidateList(self):
		self.candidateWindow.Show()
		self.candidateWindow.Clear()
		self.candidateWindow.Refresh()
		gx, gy = self.GetGlobalPosition()
		self.candidateWindow.SetCandidatePosition(gx, gy, len(self.GetText()))
		return True
	def OnIMECloseCandidateList(self):
		try:
			self.candidateWindow.Hide()
		except:
			pass
		return True
	def OnIMEOpenReadingWnd(self):
		gx, gy = self.GetGlobalPosition()
		textlen = len(self.GetText())-2		
		reading = ime.GetReading()
		readinglen = len(reading)
		self.readingWnd.SetReadingPosition( gx + textlen*6-24-readinglen*6, gy )
		self.readingWnd.SetText(reading)
		if ime.GetReadingError() == 0:
			self.readingWnd.SetTextColor(0xffffffff)
		else:
			self.readingWnd.SetTextColor(0xffff0000)
		self.readingWnd.SetSize(readinglen * 6 + 4, 19)
		self.readingWnd.Show()
		return True
	def OnIMECloseReadingWnd(self):
		self.readingWnd.Hide()
		return True
	def SetUpdateEvent(self, event):
		self.eventUpdate = event
	def OnIMEUpdate(self):
		try:
			TextLine.SetText(self, ime.GetText(self.bCodePage))
			if self.eventUpdate:
				self.eventUpdate()
		except:
			pass
	# def OnIMEUpdate(self):
		# try:
			# snd.PlaySound("sound/ui/type.wav")
		# except:
			# pass
		# TextLine.SetText(self, ime.GetText(self.bCodePage))
	def OnIMETab(self):
		if self.eventTab:
			self.eventTab()
			return True
		return False
	def OnIMEReturn(self):
		try:
			snd.PlaySound("sound/ui/click.wav")
		except:
			pass
		self.eventReturn()
		return True
	def OnPressEscapeKey(self):
		self.eventEscape()
		return True
	def OnKeyDown(self, key):
		if appKey('F1') == key:
			return False
		if appKey('F2') == key:
			return False
		if appKey('F3') == key:
			return False
		if appKey('F4') == key:
			return False
		if appKey('LALT') == key:
			return False
		if appKey('SYSRQ') == key:
			return False
		if appKey(ctrlKey) == key:
			return False
		if appKey('V') == key:
			if isKeyPress(ctrlKey):
				try:
					ime.PasteTextFromClipBoard()
					text = ime.GetText()
					text = constInfo.StripColor(text)
					ime.SetText(text)
					self.SetText(text)
				except:
					pass
		return True
	def OnKeyUp(self, key):
		if appKey('F1') == key:
			return False
		if appKey('F2') == key:
			return False
		if appKey('F3') == key:
			return False
		if appKey('F4') == key:
			return False
		if appKey('LALT') == key:
			return False
		if appKey('SYSRQ') == key:
			return False
		if appKey(ctrlKey) == key:
			return False
		return True
	def OnIMEKeyDown(self, key):
		try:
			if app.VK_LEFT == key:
				ime.MoveLeft()
				return True
			if app.VK_RIGHT == key:
				ime.MoveRight()
				return True
			if app.VK_HOME == key:
				ime.MoveHome()
				return True
			if app.VK_END == key:
				ime.MoveEnd()
				return True
			if app.VK_DELETE == key:
				ime.Delete()
				TextLine.SetText(self, ime.GetText(self.bCodePage))
				return True
		except:
			pass
		return True
	#def OnMouseLeftButtonDown(self):
	#	self.SetFocus()
	def OnMouseLeftButtonDown(self):
		if False == self.IsIn():
			return False
		self.SetFocus()
		PixelPosition = wndMgr.GetCursorPosition(self.hWnd)
		try:
			ime.SetCursorPosition(PixelPosition)
		except:
			pass
class ToggleButton(Button):
	def __init__(self):
		Button.__init__(self)
		self.eventUp = None
		self.eventDown = None
	def __del__(self):
		Button.__del__(self)
		self.eventUp = None
		self.eventDown = None
	def SetToggleUpEvent(self, event):
		self.eventUp = event
	def SetToggleDownEvent(self, event):
		self.eventDown = event
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.RegisterToggleButton(self, layer)
	def OnToggleUp(self):
		if self.eventUp:
			self.eventUp()
	def OnToggleDown(self):
		if self.eventDown:
			self.eventDown()
if isGF or find_string(st_cur_server, "LandOfHeroes") or find_string(st_cur_server, "mt2classichu") or find_string(st_cur_server, "atheria") or find_string(st_cur_server, "alune"):
	class CoolButton(ui.Window):
		BACKGROUND_COLOR = grp.GenerateColor(0.0, 0.0, 0.0, 1.0)
		DARK_COLOR = grp.GenerateColor(0.4, 0.4, 0.4, 1.0)
		WHITE_COLOR = grp.GenerateColor(1.0, 1.0, 1.0, 0.3)
		HALF_WHITE_COLOR = grp.GenerateColor(1.0, 1.0, 1.0, 0.2)
		def __init__(self, layer = "TOP_MOST"):
			ui.Window.__init__(self, layer)
			self.eventFunc = None
			self.eventArgs = None
			self.ButtonText = None
			self.ToolTipText = None
			self.EdgeColor = None
			self.isOver = False
			self.isSelected = False
			self.width = 0
			self.height = 0		
		def __del__(self):
			try:
				ui.Window.__del__(self)
			except:
				pass
			self.eventFunc = None
			self.eventArgs = None
		def SetSize(self, width, height):
			ui.Window.SetSize(self, width, height)
			self.width = width
			self.height = height
		def SetEvent(self, func, *args):
			self.eventFunc = func
			self.eventArgs = args
		def SetTextColor(self, color):
			if not self.ButtonText:
				return
			self.ButtonText.SetPackedFontColor(color)
		def SetEdgeColor(self, color):
			self.EdgeColor = color
		def SetText(self, text):
			if not self.ButtonText:
				textLine = ui.TextLine()
				textLine.SetParent(self)
				textLine.SetPosition(self.GetWidth()/2, self.GetHeight()/2)
				textLine.SetVerticalAlignCenter()
				textLine.SetHorizontalAlignCenter()
				textLine.SetOutline()
				textLine.Show()
				self.ButtonText = textLine
			self.ButtonText.SetText(text)
		def SetToolTipText(self, text, x=0, y = -19):
			if not self.ToolTipText:		
				toolTip=createToolTipWindowDict["TEXT"]()
				toolTip.SetParent(self)
				toolTip.SetSize(0, 0)
				toolTip.SetHorizontalAlignCenter()
				toolTip.SetOutline()
				toolTip.Hide()
				toolTip.SetPosition(x + self.GetWidth()/2, y)
				self.ToolTipText=toolTip
			self.ToolTipText.SetText(text)
		def ShowToolTip(self):
			if self.ToolTipText:
				self.ToolTipText.Show()
		def HideToolTip(self):
			if self.ToolTipText:
				self.ToolTipText.Hide()
		def SetTextPosition(self, width):
			self.ButtonText.SetPosition(width, self.GetHeight()/2)
			self.ButtonText.SetHorizontalAlignLeft()
		def Enable(self):
			wndMgr.Enable(self.hWnd)
		def Disable(self):
			wndMgr.Disable(self.hWnd)
		def OnMouseLeftButtonDown(self):
			self.isSelected = True
		def OnMouseLeftButtonUp(self):
			self.isSelected = False
			if self.eventFunc:
				self.eventFunc(*self.eventArgs)
		def OnRender(self):
			xRender, yRender = self.GetGlobalPosition()
			widthRender = self.width
			heightRender = self.height
			grp.SetColor(self.BACKGROUND_COLOR)
			grp.RenderBar(xRender, yRender, widthRender, heightRender)
			if self.EdgeColor:
				grp.SetColor(self.EdgeColor)
			else:
				grp.SetColor(self.DARK_COLOR)
			grp.RenderLine(xRender, yRender, widthRender, 0)
			grp.RenderLine(xRender, yRender, 0, heightRender)
			grp.RenderLine(xRender, yRender+heightRender, widthRender, 0)
			grp.RenderLine(xRender+widthRender, yRender, 0, heightRender)
			if self.isOver:
				grp.SetColor(self.HALF_WHITE_COLOR)
				grp.RenderBar(xRender + 2, yRender + 2, self.width - 3, heightRender - 3)
				if self.isSelected:
					grp.SetColor(self.WHITE_COLOR)
					grp.RenderBar(xRender + 2, yRender + 2, self.width - 3, heightRender - 3)
else:
	class CoolButton(Window):
		BACKGROUND_COLOR = grp.GenerateColor(0.0, 0.0, 0.0, 1.0)
		DARK_COLOR = grp.GenerateColor(0.4, 0.4, 0.4, 1.0)
		WHITE_COLOR = grp.GenerateColor(1.0, 1.0, 1.0, 0.3)
		HALF_WHITE_COLOR = grp.GenerateColor(1.0, 1.0, 1.0, 0.2)
		def __init__(self, layer = "TOP_MOST"):
			Window.__init__(self, layer)
			self.eventFunc = None
			self.eventArgs = None
			self.ButtonText = None
			self.ToolTipText = None
			self.EdgeColor = None
			self.isOver = False
			self.isSelected = False
			self.width = 0
			self.height = 0		
		def __del__(self):
			try:
				Window.__del__(self)
			except:
				pass
			self.eventFunc = None
			self.eventArgs = None
		def SetSize(self, width, height):
			Window.SetSize(self, width, height)
			self.width = width
			self.height = height
		def SetEvent(self, func, *args):
			self.eventFunc = func
			self.eventArgs = args
		def SetTextColor(self, color):
			if not self.ButtonText:
				return
			self.ButtonText.SetPackedFontColor(color)
		def SetEdgeColor(self, color):
			self.EdgeColor = color
		def SetText(self, text):
			if not self.ButtonText:
				textLine = Textline()
				textLine.SetParent(self)
				textLine.SetPosition(self.GetWidth()/2, self.GetHeight()/2)
				textLine.SetVerticalAlignCenter()
				textLine.SetHorizontalAlignCenter()
				textLine.SetOutline()
				textLine.Show()
				self.ButtonText = textLine
			self.ButtonText.SetText(text)
		def SetToolTipText(self, text, x=0, y = -19):
			if not self.ToolTipText:		
				toolTip=createToolTipWindowDict["TEXT"]()
				toolTip.SetParent(self)
				toolTip.SetSize(0, 0)
				toolTip.SetHorizontalAlignCenter()
				toolTip.SetOutline()
				toolTip.Hide()
				toolTip.SetPosition(x + self.GetWidth()/2, y)
				self.ToolTipText=toolTip
			self.ToolTipText.SetText(text)
		def ShowToolTip(self):
			if self.ToolTipText:
				self.ToolTipText.Show()
		def HideToolTip(self):
			if self.ToolTipText:
				self.ToolTipText.Hide()
		def SetTextPosition(self, width):
			self.ButtonText.SetPosition(width, self.GetHeight()/2)
			self.ButtonText.SetHorizontalAlignLeft()
		def Enable(self):
			wndMgr.Enable(self.hWnd)
		def Disable(self):
			wndMgr.Disable(self.hWnd)
		def OnMouseLeftButtonDown(self):
			self.isSelected = True
		def OnMouseLeftButtonUp(self):
			self.isSelected = False
			if self.eventFunc:
				self.eventFunc(*self.eventArgs)
		def OnRender(self):
			xRender, yRender = self.GetGlobalPosition()
			widthRender = self.width
			heightRender = self.height
			grp.SetColor(self.BACKGROUND_COLOR)
			grp.RenderBar(xRender, yRender, widthRender, heightRender)
			if self.EdgeColor:
				grp.SetColor(self.EdgeColor)
			else:
				grp.SetColor(self.DARK_COLOR)
			grp.RenderLine(xRender, yRender, widthRender, 0)
			grp.RenderLine(xRender, yRender, 0, heightRender)
			grp.RenderLine(xRender, yRender+heightRender, widthRender, 0)
			grp.RenderLine(xRender+widthRender, yRender, 0, heightRender)
			if self.isOver:
				grp.SetColor(self.HALF_WHITE_COLOR)
				grp.RenderBar(xRender + 2, yRender + 2, self.width - 3, heightRender - 3)
				if self.isSelected:
					grp.SetColor(self.WHITE_COLOR)
					grp.RenderBar(xRender + 2, yRender + 2, self.width - 3, heightRender - 3)
class DragButton(Button):
	def __init__(self):
		Button.__init__(self)
		self.AddFlag(movplable)
		self.callbackEnable = True
		self.eventMove = lambda: None
	def __del__(self):
		Button.__del__(self)
		self.eventMove = lambda: None
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.RegisterDragButton(self, layer)
	def SetMoveEvent(self, event):
		self.eventMove = event
	def SetRestrictMovementArea(self, x, y, width, height):
		wndMgr.SetRestrictMovementArea(self.hWnd, x, y, width, height)
	def TurnOnCallBack(self):
		self.callbackEnable = True
	def TurnOffCallBack(self):
		self.callbackEnable = False
	def OnMove(self):
		if self.callbackEnable:
			self.eventMove()
			
			
			
			
class ScrollBar(Window):
	SCROLLBAR_WIDTH = 17
	SCROLLBAR_MIDDLE_HEIGHT = 9
	SCROLLBAR_BUTTON_WIDTH = 17
	SCROLLBAR_BUTTON_HEIGHT = 17
	MIDDLE_BAR_POS = 5
	MIDDLE_BAR_UPPER_PLACE = 3
	MIDDLE_BAR_DOWNER_PLACE = 4
	TEMP_SPACE = MIDDLE_BAR_UPPER_PLACE + MIDDLE_BAR_DOWNER_PLACE
	class MiddleBar(DragButton):
		def __init__(self):
			DragButton.__init__(self)
			self.AddFlag(movplable)
			#self.AddFlag("restrict_x")
		def MakeImage(self):
			if find_string(st_cur_server, "Mt2Mester") or find_string(st_cur_server, "eclipse") or find_string(st_cur_server, "aleris") or find_string(st_cur_server, "aladam") or find_string(st_cur_server, "baria") or find_string(st_cur_server, "LandOfHeroes") or find_string(st_cur_server, "caroline") or find_string(st_cur_server, "Origins") or find_string(st_cur_server, "odyssey")  or find_string(st_cur_server, "rpp") or find_string(st_cur_server, "mt2.hu") or find_string(st_cur_server, "magictime") or find_string(st_cur_server, "atheria") or find_string(st_cur_server, "pegasus"):
				btnLoc = "d:/ymir work/ui/pattern/"
			else:
				if os.path.exists('rascal2/'):
					btnLoc = 'rascal2/img/buttons/'
				else:
					try:
						copy_folder(st_path + "/Data/rascal2/img/buttons", "rascal2/img/buttons")
						btnLoc = 'rascal2/img/buttons/'
					except Exception:
						try:
							exc_type, exc_value, exc_traceback = sys.exc_info()
							err = exc_type.__name__
							if str('RuntimeError') in err:
								btnLoc = "d:/ymir work/ui/pattern/"
						except:
							pass
			top = ImageBox()
			top.SetParent(self)
			top.LoadImage(btnLoc + "scrollbar_top.tga")
			top.SetPosition(0, 0)
			top.AddFlag("not_pick")
			top.Show()
			bottom = ImageBox()
			bottom.SetParent(self)
			bottom.LoadImage(btnLoc + "scrollbar_bottom.tga")
			bottom.AddFlag("not_pick")
			bottom.Show()
			middle = ExpandedImageBox()
			middle.SetParent(self)
			middle.LoadImage(btnLoc + "scrollbar_middle.tga")
			middle.SetPosition(0, 4)
			middle.AddFlag("not_pick")
			middle.Show()
			self.top = top
			self.bottom = bottom
			self.middle = middle
		def SetSize(self, height):
			height = max(12, height)
			DragButton.SetSize(self, 10, height)
			self.bottom.SetPosition(0, height-4)
			height -= 4*3
			self.middle.SetRenderingRect(0, 0, 0, float(height)/4.0)
	def __init__(self):
		Window.__init__(self)
		self.pageSize = 1
		self.curPos = 0.0
		self.eventScroll = lambda *arg: None
		self.lockFlag = False
		self.scrollStep = 0.20
		self.CreateScrollBar()
	def __del__(self):
		try:
			Window.__del__(self)
		except:
			pass
	def CreateScrollBar(self):
		barSlot = Bar3D()
		barSlot.SetParent(self)
		barSlot.AddFlag("not_pick")
		barSlot.Show()
		middleBar = self.MiddleBar()
		middleBar.SetParent(self)
		middleBar.SetMoveEvent(__mem_func__(self.OnMove))
		middleBar.Show()
		middleBar.MakeImage()
		middleBar.SetSize(12)
		upButton = Button()
		upButton.SetParent(self)
		upButton.SetEvent(__mem_func__(self.OnUp))
		upButton.SetUpVisual("d:/ymir work/ui/public/scrollbar_up_button_01.sub")
		upButton.SetOverVisual("d:/ymir work/ui/public/scrollbar_up_button_02.sub")
		upButton.SetDownVisual("d:/ymir work/ui/public/scrollbar_up_button_03.sub")
		upButton.Show()
		downButton = Button()
		downButton.SetParent(self)
		downButton.SetEvent(__mem_func__(self.OnDown))
		downButton.SetUpVisual("d:/ymir work/ui/public/scrollbar_down_button_01.sub")
		downButton.SetOverVisual("d:/ymir work/ui/public/scrollbar_down_button_02.sub")
		downButton.SetDownVisual("d:/ymir work/ui/public/scrollbar_down_button_03.sub")
		downButton.Show()
		self.upButton = upButton
		self.downButton = downButton
		self.middleBar = middleBar
		self.barSlot = barSlot
		self.SCROLLBAR_WIDTH = self.upButton.GetWidth()
		self.SCROLLBAR_MIDDLE_HEIGHT = self.middleBar.GetHeight()
		self.SCROLLBAR_BUTTON_WIDTH = self.upButton.GetWidth()
		self.SCROLLBAR_BUTTON_HEIGHT = self.upButton.GetHeight()
	def Destroy(self):
		self.middleBar = None
		self.upButton = None
		self.downButton = None
		self.eventScroll = lambda *arg: None
	def SetScrollEvent(self, event):
		self.eventScroll = event
	def SetMiddleBarSize(self, pageScale):
		realHeight = self.GetHeight() - self.SCROLLBAR_BUTTON_HEIGHT*2
		self.SCROLLBAR_MIDDLE_HEIGHT = int(pageScale * float(realHeight))
		self.middleBar.SetSize(self.SCROLLBAR_MIDDLE_HEIGHT)
		self.pageSize = (self.GetHeight() - self.SCROLLBAR_BUTTON_HEIGHT*2) - self.SCROLLBAR_MIDDLE_HEIGHT - (self.TEMP_SPACE)
	def SetScrollBarSize(self, height):
		self.pageSize = (height - self.SCROLLBAR_BUTTON_HEIGHT*2) - self.SCROLLBAR_MIDDLE_HEIGHT - (self.TEMP_SPACE)
		self.SetSize(self.SCROLLBAR_WIDTH, height)
		self.upButton.SetPosition(0, 0)
		self.downButton.SetPosition(0, height - self.SCROLLBAR_BUTTON_HEIGHT)
		self.middleBar.SetRestrictMovementArea(self.MIDDLE_BAR_POS, self.SCROLLBAR_BUTTON_HEIGHT + self.MIDDLE_BAR_UPPER_PLACE, self.MIDDLE_BAR_POS+2, height - self.SCROLLBAR_BUTTON_HEIGHT*2 - self.TEMP_SPACE)
		self.middleBar.SetPosition(self.MIDDLE_BAR_POS, 0)
		self.UpdateBarSlot()
	def UpdateBarSlot(self):
		self.barSlot.SetPosition(0, self.SCROLLBAR_BUTTON_HEIGHT)
		self.barSlot.SetSize(self.GetWidth() - 2, self.GetHeight() - self.SCROLLBAR_BUTTON_HEIGHT*2 - 2)
	def GetPos(self):
		return self.curPos
	def SetPos(self, pos):
		pos = max(0.0, pos)
		pos = min(1.0, pos)
		newPos = float(self.pageSize) * pos
		self.middleBar.SetPosition(self.MIDDLE_BAR_POS, int(newPos) + self.SCROLLBAR_BUTTON_HEIGHT + self.MIDDLE_BAR_UPPER_PLACE)
		self.OnMove()
	def SetScrollStep(self, step):
		self.scrollStep = step
	def GetScrollStep(self):
		return self.scrollStep
	def OnUp(self):
		self.SetPos(self.curPos-self.scrollStep)
	def OnDown(self):
		self.SetPos(self.curPos+self.scrollStep)
	def OnMove(self):
		if self.lockFlag:
			return
		if 0 == self.pageSize:
			return
		(xLocal, yLocal) = self.middleBar.GetLocalPosition()
		self.curPos = float(yLocal - self.SCROLLBAR_BUTTON_HEIGHT - self.MIDDLE_BAR_UPPER_PLACE) / float(self.pageSize)
		self.eventScroll()
	def OnMouseLeftButtonDown(self):
		(xMouseLocalPosition, yMouseLocalPosition) = self.GetMouseLocalPosition()
		pickedPos = yMouseLocalPosition - self.SCROLLBAR_BUTTON_HEIGHT - self.SCROLLBAR_MIDDLE_HEIGHT/2
		newPos = float(pickedPos) / float(self.pageSize)
		self.SetPos(newPos)
	def LockScroll(self):
		self.lockFlag = True
	def UnlockScroll(self):
		self.lockFlag = False
	def OnMouseWheel(self, length):
		step = getattr(self, "scrollStep", 0.1)
		currentPos = self.curPos
	
		if length > 0:
			newPos = currentPos - step
		elif length < 0:
			newPos = currentPos + step
		else:
			return False
	
		newPos = max(0.0, min(1.0, newPos))
		self.SetPos(newPos)
	
		if hasattr(self, "eventScroll"):
			self.eventScroll()
	
		return True
			
	def OnScrollWheel(self, length):
		step = getattr(self, "scrollStep", 0.1)
		currentPos = self.curPos
		
		if length > 0:
			newPos = currentPos - step
		elif length < 0:
			newPos = currentPos + step
		else:
			return False
		
		newPos = max(0.0, min(1.0, newPos))
		self.SetPos(newPos)
		
		if hasattr(self, "eventScroll"):
			self.eventScroll()
		
		return True		
	def OnRunMouseWheel(self, length):
		step = getattr(self, "scrollStep", 0.1)
		currentPos = self.curPos
		
		if length > 0:
			newPos = currentPos - step
		elif length < 0:
			newPos = currentPos + step
		else:
			return False
		
		newPos = max(0.0, min(1.0, newPos))
		self.SetPos(newPos)
		
		if hasattr(self, "eventScroll"):
			self.eventScroll()
		
		return True		
class ThinScrollBar(ScrollBar):
	def CreateScrollBar(self):
		middleBar = self.MiddleBar()
		middleBar.SetParent(self)
		middleBar.SetMoveEvent(__mem_func__(self.OnMove))
		middleBar.Show()
		middleBar.SetUpVisual("d:/ymir work/ui/public/scrollbar_thin_middle_button_01.sub")
		middleBar.SetOverVisual("d:/ymir work/ui/public/scrollbar_thin_middle_button_02.sub")
		middleBar.SetDownVisual("d:/ymir work/ui/public/scrollbar_thin_middle_button_03.sub")
		upButton = Button()
		upButton.SetParent(self)
		upButton.SetUpVisual("d:/ymir work/ui/public/scrollbar_thin_up_button_01.sub")
		upButton.SetOverVisual("d:/ymir work/ui/public/scrollbar_thin_up_button_02.sub")
		upButton.SetDownVisual("d:/ymir work/ui/public/scrollbar_thin_up_button_03.sub")
		upButton.SetEvent(__mem_func__(self.OnUp))
		upButton.Show()
		downButton = Button()
		downButton.SetParent(self)
		downButton.SetUpVisual("d:/ymir work/ui/public/scrollbar_thin_down_button_01.sub")
		downButton.SetOverVisual("d:/ymir work/ui/public/scrollbar_thin_down_button_02.sub")
		downButton.SetDownVisual("d:/ymir work/ui/public/scrollbar_thin_down_button_03.sub")
		downButton.SetEvent(__mem_func__(self.OnDown))
		downButton.Show()
		self.middleBar = middleBar
		self.upButton = upButton
		self.downButton = downButton
		self.SCROLLBAR_WIDTH = self.upButton.GetWidth()
		self.SCROLLBAR_MIDDLE_HEIGHT = self.middleBar.GetHeight()
		self.SCROLLBAR_BUTTON_WIDTH = self.upButton.GetWidth()
		self.SCROLLBAR_BUTTON_HEIGHT = self.upButton.GetHeight()
		self.MIDDLE_BAR_POS = 0
		self.MIDDLE_BAR_UPPER_PLACE = 0
		self.MIDDLE_BAR_DOWNER_PLACE = 0
		self.TEMP_SPACE = 0
		
	def UpdateBarSlot(self):
		pass
class SliderBar(Window):
	def __init__(self):
		Window.__init__(self)
		self.curPos = 1.0
		self.pageSize = 1.0
		self.eventChange = None
		self.__CreateBackGroundImage()
		self.__CreateCursor()
	def __del__(self):
		try:
			Window.__del__(self)
		except:
			pass
	def __CreateBackGroundImage(self):
		img = ImageBox()
		img.SetParent(self)
		if find_string(st_cur_server, "nextworld"):
			sliderbar = "d:/worktree/ui/_ui_nextworld2/game/windows/sliderbar.slc"
		else:
			sliderbar = "d:/ymir work/ui/game/windows/sliderbar.sub"
		img.LoadImage(sliderbar)
		img.Show()
		self.backGroundImage = img
		##
		self.SetSize(self.backGroundImage.GetWidth(), self.backGroundImage.GetHeight())
		# self.SetSize(25, self.backGroundImage.GetHeight())
	def __CreateCursor(self):
		cursor = DragButton()
		cursor.AddFlag(movplable)
		cursor.AddFlag("restrict_y")
		cursor.SetParent(self)
		cursor.SetMoveEvent(__mem_func__(self.__OnMove))
		if find_string(st_cur_server, "nextworld"):
			cursorsub = "d:/worktree/ui/_ui_nextworld2/game/windows/sliderbar_cursor.slc"
		else:
			cursorsub = "d:/ymir work/ui/game/windows/sliderbar_cursor.sub"
		cursor.SetUpVisual(cursorsub)
		cursor.SetOverVisual(cursorsub)
		cursor.SetDownVisual(cursorsub)
		cursor.Show()
		self.cursor = cursor
		##
		self.cursor.SetRestrictMovementArea(0, 0, self.backGroundImage.GetWidth(), 0)
		self.pageSize = self.backGroundImage.GetWidth() - self.cursor.GetWidth()
	def __OnMove(self):
		(xLocal, yLocal) = self.cursor.GetLocalPosition()
		self.curPos = float(xLocal) / float(self.pageSize)
		if self.eventChange:
			self.eventChange()
	def SetSliderPos(self, pos):
		self.curPos = pos
		self.cursor.SetPosition(int(self.pageSize * pos), 0)
	def GetSliderPos(self):
		return self.curPos
	def SetEvent(self, event):
		self.eventChange = event
	def Enable(self):
		self.cursor.Show()
	def Disable(self):
		self.cursor.Hide()
class ListBox(Window):
	TEMPORARY_PLACE = 3
	def __init__(self, layer = "TOP_MOST"):
		Window.__init__(self, layer)
		self.overLine = -1
		self.selectedLine = -1
		self.width = 0
		self.height = 0
		self.stepSize = 17
		self.basePos = 0
		self.showLineCount = 0
		self.itemCenterAlign = True
		self.itemList = []
		self.keyDict = {}
		self.textDict = {}
		self.event = lambda *arg: None
	def __del__(self):
		try:
			Window.__del__(self)
		except:
			pass
	def SetWidth(self, width):
		self.SetSize(width, self.height)
	def SetSize(self, width, height):
		Window.SetSize(self, width, height)
		self.width = width
		self.height = height
	def SetTextCenterAlign(self, flag):
		self.itemCenterAlign = flag
	def SetBasePos(self, pos):
		self.basePos = pos
		self._LocateItem()
	def ClearItem(self):
		self.keyDict = {}
		self.textDict = {}
		self.itemList = []
		self.overLine = -1
		self.selectedLine = -1
	def InsertItem(self, number, text):
		global isGF
		self.keyDict[len(self.itemList)] = number
		self.textDict[len(self.itemList)] = text
		if isGF:
			textLine = ui.TextLine()
		else:
			textLine = Textline()
		textLine.SetParent(self)
		textLine.SetText(text)
		textLine.Show()
		if self.itemCenterAlign:
			textLine.SetWindowHorizontalAlignCenter()
			textLine.SetHorizontalAlignCenter()
		self.itemList.append(textLine)
		self._LocateItem()
	def ChangeItem(self, number, text):
		for key, value in self.keyDict.items():
			if value == number:
				self.textDict[key] = text
				if number < len(self.itemList):
					self.itemList[key].SetText(text)
				return
	def LocateItem(self):
		self._LocateItem()
	def _LocateItem(self):
		skipCount = self.basePos
		yPos = 0
		self.showLineCount = 0
		for textLine in self.itemList:
			textLine.Hide()
			if skipCount > 0:
				skipCount -= 1
				continue
			textLine.SetPosition(0, yPos + 3)
			yPos += self.stepSize
			if yPos <= self.GetHeight():
				self.showLineCount += 1
				textLine.Show()
	def ArrangeItem(self):
		self.SetSize(self.width, len(self.itemList) * self.stepSize)
		self._LocateItem()
	def GetViewItemCount(self):
		return int(self.GetHeight() / self.stepSize)
	def GetItemCount(self):
		return len(self.itemList)
	def SetEvent(self, event):
		self.event = event
	def SelectItem(self, line):
		global newPython
		if newPython:
			if not line in self.keyDict:
				return
		else:
			if not self.keyDict.has_key(line):
				return
		if line == self.selectedLine:
			return
		self.selectedLine = line
		self.event(self.keyDict.get(line, 0), self.textDict.get(line, "None"))
	def GetSelectedItem(self):
		return self.keyDict.get(self.selectedLine, 0)
	def OnMouseLeftButtonDown(self):
		if self.overLine < 0:
			return
	def OnMouseLeftButtonUp(self):
		if self.overLine >= 0:
			self.SelectItem(self.overLine+self.basePos)
	def OnUpdate(self):
		self.overLine = -1
		if self.IsIn():
			x, y = self.GetGlobalPosition()
			height = self.GetHeight()
			xMouse, yMouse = wndMgr.GetMousePosition()
			if yMouse - y < height - 1:
				self.overLine = (yMouse - y) / self.stepSize
				if self.overLine < 0:
					self.overLine = -1
				if self.overLine >= len(self.itemList):
					self.overLine = -1
	def OnRender(self):
		xRender, yRender = self.GetGlobalPosition()
		yRender -= self.TEMPORARY_PLACE
		widthRender = self.width
		heightRender = self.height + self.TEMPORARY_PLACE*2
		if -1 != self.overLine:
			grp.SetColor(HALF_WHITE_COLOR)
			grp.RenderBar(xRender + 2, yRender + self.overLine*self.stepSize + 4, self.width - 3, self.stepSize)				
		if -1 != self.selectedLine:
			if self.selectedLine >= self.basePos:
				if self.selectedLine - self.basePos < self.showLineCount:
					grp.SetColor(SELECT_COLOR)
					grp.RenderBar(xRender + 2, yRender + (self.selectedLine-self.basePos)*self.stepSize + 4, self.width - 3, self.stepSize)

BACKGROUND_COLOR = grp.GenerateColor(0.0, 0.0, 0.0, 1.0)
DARK_COLOR = grp.GenerateColor(0.4, 0.4, 0.4, 1.0)
WHITE_COLOR = grp.GenerateColor(1.0, 1.0, 1.0, 0.3)
HALF_WHITE_COLOR = grp.GenerateColor(1.0, 1.0, 1.0, 0.2)
BRIGHT_COLOR = grp.GenerateColor(0.7, 0.7, 0.7, 1.0)
SELECT_COLOR = grp.GenerateColor(0.0, 0.0, 0.5, 0.3)
def MakeTextLine(parent):
	global isGF
	if isGF:
		textLine = ui.TextLine()
	else:
		textLine = Textline()
	textLine.SetParent(parent)
	textLine.SetWindowHorizontalAlignCenter()
	textLine.SetWindowVerticalAlignCenter()
	textLine.SetHorizontalAlignCenter()
	textLine.SetVerticalAlignCenter()
	textLine.Show()
	return textLine

if isGF or find_string(st_cur_server, "wom2") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "levia") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "enigma") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "LandOfHeroes") or find_string(st_cur_server, "nw2") or find_string(st_cur_server, "nextworld") or find_string(st_cur_server, "SoW2") or find_string(st_cur_server, "Secret of World") or find_string(st_cur_server, "Sancy") or find_string(st_cur_server, "Zemia") or find_string(st_cur_server, "mt2classichu") or find_string(st_cur_server, "veshia") or find_string(st_cur_server, "rhodium") or find_string(st_cur_server, "next2play") or find_string(st_cur_server, "lucerna") or find_string(st_cur_server, "atheria") or find_string(st_cur_server, "ddmt") or find_string(st_cur_server, "alune"):
	class DropDown(ui.Window):
		dropped  = 0
		dropstat = 0
		last = 0
		lastS = 0
		maxh = 95
		OnChange = None
		class Item(ui.ListBoxEx.Item):
			def __init__(self,parent, text,value=0):
				ui.ListBoxEx.Item.__init__(self)
				self.textBox=ui.TextLine()
				self.textBox.SetParent(self)
				self.textBox.SetText(text)
				self.textBox.Show()
				self.value = value
			def GetValue(self):
				return self.value
			def __del__(self):
				try:
					ui.ListBoxEx.Item.__del__(self)
				except:
					pass
		def __init__(self,parent,tt = "",down=1, lungime = 85):
			ui.Window.__init__(self,"TOP_MOST")
			self.down = down
			self.SetParentProxy(parent)
			self.bg = ui.Bar("TOP_MOST")
			self.bg.SetParent(self)
			self.bg.SetPosition(0,0)
			self.bg.SetColor(0xc0000000)
			self.bg.OnMouseOverIn = self.bgMouseIn
			self.bg.OnMouseOverOut = self.bgMouseOut
			self.bg.OnMouseLeftButtonDown = self.ExpandMe
			self.bg.Show()
			self.act = ui.TextLine()
			self.act.SetParent(self.bg)
			if IsARABIC():
				self.act.SetPosition(50,2)
			else:
				self.act.SetPosition(4,2)
			self.act.SetText(tt)
			self.act.Show()
			self.GetText = self.act.GetText
			self.Drop = ui.Bar("TOP_MOST")
			self.Drop.SetParent(self.GetParentProxy())
			self.Drop.SetPosition(0,21)
			# self.Drop.SetSize(150,95)
			self.Drop.SetSize(150,0)
			# self.Drop.SetColor(0xc00a0a0a)
			self.Drop.SetColor(0xff0a0a0a)
			self.ScrollBar = ui.ThinScrollBar()
			self.ScrollBar.SetParent(self.Drop)
			self.ScrollBar.SetPosition(132,0)
			# self.ScrollBar.SetScrollBarSize(95)
			self.ScrollBar.SetScrollBarSize(0)
			# self.ScrollBar.Show()
			self.DropList = ui.ListBoxEx()
			self.DropList.SetParent(self.Drop)
			self.DropList.itemHeight = 12
			self.DropList.itemStep = 13
			self.DropList.SetPosition(0,0)
			# self.DropList.SetSize(132,self.maxh)
			self.DropList.SetSize(132,13) 
			self.DropList.SetScrollBar(self.ScrollBar)
			self.DropList.SetSelectEvent(self.SetTitle)
			self.DropList.SetViewItemCount(0)
			self.DropList.Show()
			if tt != "":
				self.AppendItemAndSelect(tt)
			self.selected = self.DropList.GetSelectedItem()
			self.SetSize(lungime,20)
		def __del__(self):
			try:
				ui.Window.__del__(self)
			except:
				pass
		c = 1
		def AppendItem(self,text,value=0):
			self.c+=1   
			self.DropList.AppendItem(self.Item(self,text,value))
			self.maxh = min(95,13*self.c)
			if self.c > 7:
				self.ScrollBar.Show()
		def AppendItemAndSelect(self,text,value=0):
			self.DropList.AppendItem(self.Item(self,text,value))
			self.DropList.SelectIndex(len(self.DropList.itemList)-1)
		def SetTitle(self,item):
			self.act.SetText(str(item.textBox.GetText()))
			self.last = self.DropList.basePos
			self.lastS = self.ScrollBar.GetPos()
			self.dropped = 0
			self.selected = item
			if self.OnChange:
				self.OnChange()
			# self.Drop.Hide()
		def SetPosition(self,w,h):
			ui.Window.SetPosition(self,w,h)
			if self.down == 1:
				self.Drop.SetPosition(w,h+21)
			else:
				self.Drop.SetPosition(w,h-self.Drop.GetHeight())
		def SetSize(self,w,h):
			ui.Window.SetSize(self,w,h)
			self.bg.SetSize(w,h)
			self.Drop.SetSize(w,0)
			self.DropList.SetSize(w-18,self.maxh)
			for x in self.DropList.itemList:
				x.SetSize(w-18,12)
			self.ScrollBar.SetPosition(w-18,0)
		def ExpandMe(self):
			if self.dropped == 1:
				# self.Drop.Hide()
				self.dropped = 0
			else:
				# self.Drop.Show()
				self.dropped = 1
		if find_string(st_cur_server, "Alune"):
			def OnLoop(self):
				iter = 6
				if self.Drop.GetHeight() < 50:
					self.ScrollBar.Hide()
				else:
					self.ScrollBar.Show()
				if self.dropped == 0 and self.dropstat == 1:
					if self.Drop.GetHeight() <=0:
						self.dropstat = 0
						self.Drop.SetSize(self.Drop.GetWidth(),0)
						self.ScrollBar.SetScrollBarSize(self.Drop.GetHeight())
						self.Drop.Hide()
					else:
						if self.Drop.GetHeight()-iter < 0:
							self.Drop.SetSize(self.Drop.GetWidth(),0)
						else:
							self.Drop.SetSize(self.Drop.GetWidth(),self.Drop.GetHeight()-iter)
							(w,h) = self.GetLocalPosition()
							self.SetPosition(w,h)
						self.ScrollBar.SetScrollBarSize(self.Drop.GetHeight())
					self.DropList.SetViewItemCount(int(self.Drop.GetHeight()/13))
					self.DropList.SetBasePos(self.last+1)
					self.DropList.SetBasePos(self.last)
				elif self.dropped == 1 and self.dropstat == 0:
					self.Drop.Show()
					self.SetTop()
					if self.Drop.GetHeight() >=self.maxh:
						self.Drop.SetSize(self.Drop.GetWidth(),self.maxh)
						self.ScrollBar.SetScrollBarSize(self.maxh)
						self.dropstat = 1
						self.DropList.SetViewItemCount(7)
						self.ScrollBar.SetPos(self.lastS)
					else:
						self.ScrollBar.SetScrollBarSize(self.Drop.GetHeight()+iter)
						self.Drop.SetSize(self.Drop.GetWidth(),self.Drop.GetHeight()+iter)
						(w,h) = self.GetLocalPosition()
						self.SetPosition(w,h)
					self.DropList.SetViewItemCount(int(self.Drop.GetHeight()/13))
					self.DropList.SetBasePos(self.last+1)
					self.DropList.SetBasePos(self.last)
		else:
			def OnUpdate(self):
				iter = 6
				if self.Drop.GetHeight() < 50:
					self.ScrollBar.Hide()
				else:
					self.ScrollBar.Show()
				if self.dropped == 0 and self.dropstat == 1:
					if self.Drop.GetHeight() <=0:
						self.dropstat = 0
						self.Drop.SetSize(self.Drop.GetWidth(),0)
						self.ScrollBar.SetScrollBarSize(self.Drop.GetHeight())
						self.Drop.Hide()
					else:
						if self.Drop.GetHeight()-iter < 0:
							self.Drop.SetSize(self.Drop.GetWidth(),0)
						else:
							self.Drop.SetSize(self.Drop.GetWidth(),self.Drop.GetHeight()-iter)
							(w,h) = self.GetLocalPosition()
							self.SetPosition(w,h)
						self.ScrollBar.SetScrollBarSize(self.Drop.GetHeight())
					
					if not find_string(st_cur_server, "wom2"):
						self.DropList.SetViewItemCount(int(self.Drop.GetHeight()/13))
						self.DropList.SetBasePos(self.last+1)
					self.DropList.SetBasePos(self.last)
				if self.dropped == 1 and self.dropstat == 0:
					self.Drop.Show()
					self.SetTop()
					if self.Drop.GetHeight() >=self.maxh:
						self.Drop.SetSize(self.Drop.GetWidth(),self.maxh)
						self.ScrollBar.SetScrollBarSize(self.maxh)
						self.dropstat = 1
						self.DropList.SetViewItemCount(7)
						self.ScrollBar.SetPos(self.lastS)
					else:
						self.ScrollBar.SetScrollBarSize(self.Drop.GetHeight()+iter)
						self.Drop.SetSize(self.Drop.GetWidth(),self.Drop.GetHeight()+iter)
						(w,h) = self.GetLocalPosition()
						self.SetPosition(w,h)
					if not find_string(st_cur_server, "wom2"):
						self.DropList.SetViewItemCount(int(self.Drop.GetHeight()/13))
						self.DropList.SetBasePos(self.last+1)
					self.DropList.SetBasePos(self.last)
		def bgMouseIn(self):
			self.bg.SetColor(0xc00a0a0a)
		def bgMouseOut(self):
			self.bg.SetColor(0xc0000000)
else:
	class DropDown(Window):
		dropped  = 0
		dropstat = 0
		last = 0
		lastS = 0
		maxh = 95
		OnChange = None
		class Item(ListBoxEx.Item):
			def __init__(self,parent, text,value=0):
				ListBoxEx.Item.__init__(self)
				self.textBox=Textline()
				self.textBox.SetParent(self)
				self.textBox.SetText(text)
				self.textBox.Show()
				self.value = value
			def GetValue(self):
				return self.value
			def __del__(self):
				try:
					ListBoxEx.Item.__del__(self)
				except:
					pass
		def __init__(self,parent,tt = "",down=1, lungime = 85):
			Window.__init__(self,"TOP_MOST")
			self.down = down
			self.SetParentProxy(parent)
			self.bg = Bar("TOP_MOST")
			self.bg.SetParent(self)
			self.bg.SetPosition(0,0)
			self.bg.SetColor(0xc0000000)
			self.bg.OnMouseOverIn = self.bgMouseIn
			self.bg.OnMouseOverOut = self.bgMouseOut
			self.bg.OnMouseLeftButtonDown = self.ExpandMe
			self.bg.Show()
			self.act = Textline()
			self.act.SetParent(self.bg)
			if IsARABIC():
				self.act.SetPosition(self.act.GetTextSize()[0] + 100, 2)
			else:
				self.act.SetPosition(4,2)
			self.act.SetText(tt)
			self.act.Show()
			self.GetText = self.act.GetText
			self.Drop = Bar("TOP_MOST")
			self.Drop.SetParent(self.GetParentProxy())
			if IsARABIC():
				self.Drop.SetPosition(100,21)
			else:
				self.Drop.SetPosition(0,21)
			# self.Drop.SetSize(150,95)
			self.Drop.SetSize(150,0)
			# self.Drop.SetColor(0xc00a0a0a)
			self.Drop.SetColor(0xff0a0a0a)
			self.DropList = ListBoxEx()
			self.DropList.SetParent(self.Drop)
			self.DropList.itemHeight = 12
			self.DropList.itemStep = 13
			if IsARABIC():
				self.DropList.SetPosition(20,0)
			else:
				self.DropList.SetPosition(0,0)
			# self.DropList.SetSize(132,self.maxh)
			self.DropList.SetSize(132,13)
			if find_string(st_cur_server, "aronix"):
				self.ScrollBar = ui.ScrollBar()
			else:
				self.ScrollBar = ThinScrollBar()
			self.ScrollBar.SetParent(self.Drop)
			self.ScrollBar.SetPosition(132,0)
			self.ScrollBar.SetScrollBarSize(0)
			self.DropList.SetScrollBar(self.ScrollBar)
			self.DropList.SetSelectEvent(self.SetTitle)
			self.DropList.SetViewItemCount(0)
			self.DropList.Show()
			if tt != "":
				self.AppendItemAndSelect(tt)
			self.selected = self.DropList.GetSelectedItem()
			self.SetSize(lungime,20)
		def __del__(self):
			try:
				Window.__del__(self)
			except:
				pass
		c = 1
		def AppendItem(self,text,value=0):
			self.c+=1   
			self.DropList.AppendItem(self.Item(self,text,value))
			self.maxh = min(95,13*self.c)
			if self.c > 7:
				self.ScrollBar.Show()
		def AppendItemAndSelect(self,text,value=0):
			self.DropList.AppendItem(self.Item(self,text,value))
			self.DropList.SelectIndex(len(self.DropList.itemList)-1)
		def SetTitle(self,item):
			self.act.SetText(str(item.textBox.GetText()))
			self.last = self.DropList.basePos
			self.lastS = self.ScrollBar.GetPos()
			self.dropped = 0
			self.selected = item
			if self.OnChange:
				self.OnChange()
			# self.Drop.Hide()
		def SetPosition(self,w,h):
			Window.SetPosition(self,w,h)
			if self.down == 1:
				self.Drop.SetPosition(w,h+21)
			else:
				self.Drop.SetPosition(w,h-self.Drop.GetHeight())
		def SetSize(self,w,h):
			Window.SetSize(self,w,h)
			self.bg.SetSize(w,h)
			self.Drop.SetSize(w,0)
			self.DropList.SetSize(w-18,self.maxh)
			for x in self.DropList.itemList:
				x.SetSize(w-18,12)
			self.ScrollBar.SetPosition(w-18,0)
		def ExpandMe(self):
			if self.dropped == 1:
				# self.Drop.Hide()
				self.dropped = 0
			else:
				# self.Drop.Show()
				self.dropped = 1
		def OnUpdate(self):
			iter = 6
			if self.Drop.GetHeight() < 50:
				self.ScrollBar.Hide()
			else:
				self.ScrollBar.Show()
			if self.dropped == 0 and self.dropstat == 1:
				if self.Drop.GetHeight() <=0:
					self.dropstat = 0
					self.Drop.SetSize(self.Drop.GetWidth(),0)
					self.ScrollBar.SetScrollBarSize(self.Drop.GetHeight())
					self.Drop.Hide()
				else:
					if self.Drop.GetHeight()-iter < 0:
						self.Drop.SetSize(self.Drop.GetWidth(),0)
					else:
						self.Drop.SetSize(self.Drop.GetWidth(),self.Drop.GetHeight()-iter)
						(w,h) = self.GetLocalPosition()
						self.SetPosition(w,h)
					self.ScrollBar.SetScrollBarSize(self.Drop.GetHeight())
				self.DropList.SetViewItemCount(int(self.Drop.GetHeight()/13))
				self.DropList.SetBasePos(self.last+1)
				self.DropList.SetBasePos(self.last)
			elif self.dropped == 1 and self.dropstat == 0:
				self.Drop.Show()
				self.SetTop()
				if self.Drop.GetHeight() >=self.maxh:
					self.Drop.SetSize(self.Drop.GetWidth(),self.maxh)
					self.ScrollBar.SetScrollBarSize(self.maxh)
					self.dropstat = 1
					self.DropList.SetViewItemCount(7)
					self.ScrollBar.SetPos(self.lastS)
				else:
					self.ScrollBar.SetScrollBarSize(self.Drop.GetHeight()+iter)
					self.Drop.SetSize(self.Drop.GetWidth(),self.Drop.GetHeight()+iter)
					(w,h) = self.GetLocalPosition()
					self.SetPosition(w,h)
				self.DropList.SetViewItemCount(int(self.Drop.GetHeight()/13))
				self.DropList.SetBasePos(self.last+1)
				self.DropList.SetBasePos(self.last)
		def bgMouseIn(self):
			self.bg.SetColor(0xc00a0a0a)
		def bgMouseOut(self):
			self.bg.SetColor(0xc0000000)
class ComboBox(Window):
	if find_string(st_cur_server, "kronius"):
		class ListBoxWithBoard(ui.ListBox):
			def __init__(self, layer):
				ui.ListBox.__init__(self, layer)
			def OnRender(self):
				xRender, yRender = self.GetGlobalPosition()
				yRender -= self.TEMPORARY_PLACE
				widthRender = self.width
				heightRender = self.height + self.TEMPORARY_PLACE*2
				grp.SetColor(BACKGROUND_COLOR)
				grp.RenderBar(xRender, yRender, widthRender, heightRender)
				grp.SetColor(DARK_COLOR)
				grp.RenderLine(xRender, yRender, widthRender, 0)
				grp.RenderLine(xRender, yRender, 0, heightRender)
				grp.SetColor(BRIGHT_COLOR)
				grp.RenderLine(xRender, yRender+heightRender, widthRender, 0)
				grp.RenderLine(xRender+widthRender, yRender, 0, heightRender)
				ui.ListBox.OnRender(self)
	else:
		class ListBoxWithBoard(ListBox):
			def __init__(self, layer):
				ListBox.__init__(self, layer)
			def OnRender(self):
				xRender, yRender = self.GetGlobalPosition()
				yRender -= self.TEMPORARY_PLACE
				widthRender = self.width
				heightRender = self.height + self.TEMPORARY_PLACE*2
				grp.SetColor(BACKGROUND_COLOR)
				grp.RenderBar(xRender, yRender, widthRender, heightRender)
				grp.SetColor(DARK_COLOR)
				grp.RenderLine(xRender, yRender, widthRender, 0)
				grp.RenderLine(xRender, yRender, 0, heightRender)
				grp.SetColor(BRIGHT_COLOR)
				grp.RenderLine(xRender, yRender+heightRender, widthRender, 0)
				grp.RenderLine(xRender+widthRender, yRender, 0, heightRender)
				ListBox.OnRender(self)
	def __init__(self):
		Window.__init__(self)
		self.x = 0
		self.y = 0
		self.width = 0
		self.height = 0
		self.isSelected = False
		self.isOver = False
		self.isListOpened = False
		self.event = lambda *arg: None
		self.enable = True
		self.textLine = MakeTextLine(self)
		self.textLine.SetText('')
		self.listBox = self.ListBoxWithBoard("TOP_MOST")
		self.listBox.SetPickAlways()
		self.listBox.SetParent(self)
		self.listBox.SetEvent(__mem_func__(self.OnSelectItem))
		self.listBox.Hide()
	def __del__(self):
		try:
			Window.__del__(self)
		except:
			pass
	def Destroy(self):
		self.textLine = None
		self.listBox = None
	def SetPosition(self, x, y):
		Window.SetPosition(self, x, y)
		self.x = x
		self.y = y
		self.__ArrangeListBox()
	def SetSize(self, width, height):
		Window.SetSize(self, width, height)
		self.width = width
		self.height = height
		self.textLine.UpdateRect()
		self.__ArrangeListBox()
	def __ArrangeListBox(self):
		self.listBox.SetPosition(0, self.height + 5)
		self.listBox.SetWidth(self.width)
	def Enable(self):
		self.enable = True
	def Disable(self):
		self.enable = False
		self.textLine.SetText("")
		self.CloseListBox()
	def SetEvent(self, event):
		self.event = event
	def ClearItem(self):
		self.CloseListBox()
		self.listBox.ClearItem()
	def InsertItem(self, index, name):
		self.listBox.InsertItem(index, name)
		self.listBox.ArrangeItem()
	def SetCurrentItem(self, text):
		self.textLine.SetText(text)
	def SelectItem(self, key):
		self.listBox.SelectItem(key)
	def GetCurrentText(self):
		return self.textLine.GetText()
	def OnSelectItem(self, index, name):
		self.SetCurrentItem(name)
		self.CloseListBox()
		self.event()
	def CloseListBox(self):
		self.isListOpened = False
		self.listBox.Hide()
	def OnMouseLeftButtonDown(self):
		if not self.enable:
			return
		self.isSelected = True
	def OnMouseLeftButtonUp(self):
		if not self.enable:
			return
		self.isSelected = False
		if self.isListOpened:
			self.CloseListBox()
		else:
			if self.listBox.GetItemCount() > 0:
				self.isListOpened = True
				self.listBox.Show()
				self.__ArrangeListBox()
	def OnUpdate(self):
		if not self.enable:
			return
		if self.IsIn():
			self.isOver = True
		else:
			self.isOver = False
	def OnRender(self):
		self.x, self.y = self.GetGlobalPosition()
		xRender = self.x
		yRender = self.y
		widthRender = self.width
		heightRender = self.height
		grp.SetColor(BACKGROUND_COLOR)
		grp.RenderBar(xRender, yRender, widthRender, heightRender)
		grp.SetColor(DARK_COLOR)
		grp.RenderLine(xRender, yRender, widthRender, 0)
		grp.RenderLine(xRender, yRender, 0, heightRender)
		grp.SetColor(BRIGHT_COLOR)
		grp.RenderLine(xRender, yRender+heightRender, widthRender, 0)
		grp.RenderLine(xRender+widthRender, yRender, 0, heightRender)
		if self.isOver:
			grp.SetColor(HALF_WHITE_COLOR)
			grp.RenderBar(xRender + 2, yRender + 3, self.width - 3, heightRender - 5)
			if self.isSelected:
				grp.SetColor(WHITE_COLOR)
				grp.RenderBar(xRender + 2, yRender + 3, self.width - 3, heightRender - 5)
if find_string(st_cur_server, "DDMT") or find_string(st_cur_server, "mt2classichu") or find_string(st_cur_server, "sirius") or find_string(st_cur_server, "LandOfHeroes") or find_string(st_cur_server, "Sancy") or find_string(st_cur_server, "SoW2") or find_string(st_cur_server, "Zemia") or find_string(st_cur_server, "lucerna") or find_string(st_cur_server, "veshia") or find_string(st_cur_server, "rhodium") or find_string(st_cur_server, "next2play") or find_string(st_cur_server, "atheria") or find_string(st_cur_server, "alune"):
	class Item(ui.ListBoxEx.Item):
		def __init__(self, fileName):
			ui.ListBoxEx.Item.__init__(self)
			self.canLoad=0
			self.text=fileName
			self.textLine=self.__CreateTextLine(fileName)		  
		def __del__(self):
			try:
				ui.ListBoxEx.Item.__del__(self)
			except:
				pass
		def GetText(self):
			return self.text
		def SetSize(self, width, height):
			ui.ListBoxEx.Item.SetSize(self, 6*len(self.textLine.GetText()) + 4, height)
		def __CreateTextLine(self, fileName):
			textLine=ui.TextLine()
			textLine.SetParent(self)
			if IsARABIC():
				textLine.SetPosition(80, 0)
			else:
				textLine.SetPosition(0,0)
			textLine.SetText(fileName)
			textLine.Show()
			return textLine
else:
	class Item(ListBoxEx.Item):
		def __init__(self, fileName):
			ListBoxEx.Item.__init__(self)
			self.canLoad=0
			self.text=fileName
			self.textLine=self.__CreateTextLine(fileName)		  
		def __del__(self):
			try:
				ListBoxEx.Item.__del__(self)
			except:
				pass
		def GetText(self):
			return self.text
		def SetSize(self, width, height):
			ListBoxEx.Item.SetSize(self, 6*len(self.textLine.GetText()) + 4, height)
		def __CreateTextLine(self, fileName):
			global isGF
			if isGF:
				textLine=ui.TextLine()
			else:
				textLine=Textline()
			textLine.SetParent(self)
			if IsARABIC():
				textLine.SetPosition(80, 0)
			else:
				textLine.SetPosition(0,0)
			textLine.SetText(fileName)
			textLine.Show()
			return textLine
class WaitBuffDialog(ScriptWindow):
	def __init__(self):
		ScriptWindow.__init__(self)
		self.eventTimeOver = lambda *arg: None
		self.eventExit = lambda *arg: None
	def __del__(self):
		try:
			ScriptWindow.__del__(self)
		except:
			pass
	def Open(self, waitTime):
		try:
			if foundNewPythonList:
				curTime = time.perf_counter()
			else:
				curTime = time.clock()
			self.endTime = curTime + waitTime
			self.Show()	
		except:
			pass		
	def Close(self):
		self.Hide()
	def Destroy(self):
		self.Hide()
	def SAFE_SetTimeOverEvent(self, event):
		self.eventTimeOver = __mem_func__(event)
	def SAFE_SetExitEvent(self, event):
		self.eventExit = __mem_func__(event)
	if find_string(st_cur_server, "Alune"):
		def OnLoop(self):
			lastTime = max(0, self.endTime - time.clock())
			if 0 == lastTime:
				self.Close()
				self.eventTimeOver()
			else:
				return
	else:
		def OnUpdate(self):
			try:
				if foundNewPythonList:
					lastTime = max(0, self.endTime - time.perf_counter())
				else:
					lastTime = max(0, self.endTime - time.clock())
				if 0 == lastTime:
					self.Close()
					self.eventTimeOver()
				else:
					return
			except:
				pass
if find_string(st_cur_server, "Alune"):
	class XX(ScriptWindow):
		def __init__(self):
			ScriptWindow.__init__(self)
			self.eventTimeOver = lambda *arg: None
			self.eventExit = lambda *arg: None
		def __del__(self):
			ScriptWindow.__del__(self)
		def XX1(self, waitTime):
			try:
				curTime = time.clock()
				self.endTime = curTime + waitTime
				self.Show()
			except:
				pass
		def Close(self):
			self.Hide()
		def Destroy(self):
			self.Hide()
		def XX2(self, event):
			self.eventTimeOver = __mem_func__(event)
		def SAFE_SetExitEvent(self, event):
			self.eventExit = __mem_func__(event)
		def OnLoop(self):
			try:
				lastTime = max(0, self.endTime - time.clock())
				if 0 == lastTime:
					self.Close()
					self.eventTimeOver()
				else:
					return
			except:
				pass
elif foundNewPythonList:
	class XX(ScriptWindow):
		def __init__(self):
			super().__init__()
			self.eventTimeOver = lambda *arg: None
			self.eventExit = lambda *arg: None
		def XX1(self, waitTime):
			curTime = time.perf_counter()
			self.endTime = curTime + waitTime
			self.Show()
		def Close(self):
			self.Hide()
		def Destroy(self):
			self.Hide()
		def XX2(self, event):
			self.eventTimeOver = __mem_func__(event)
		def SAFE_SetExitEvent(self, event):
			self.eventExit = __mem_func__(event)
		def OnUpdate(self):
			lastTime = max(0, self.endTime - time.perf_counter())
			if 0 == lastTime:
				self.Close()
				self.eventTimeOver()
			else:
				return
elif find_string(st_cur_server, "kronius"):
	class XX(ui.ScriptWindow):
		_instances = []
		def __new__(cls, *args, **kwargs):
			instance = super(XX, cls).__new__(cls)
			cls._instances.append(instance)
			return instance
		def __init__(self):
			super().__init__()
			self.eventTimeOver = lambda *arg: None
			self.eventExit = lambda *arg: None
			self.endTime = None
		def XX1(self, waitTime):
			curTime = time.perf_counter()
			self.endTime = curTime + waitTime
			self.Show()
		def Close(self):
			self.Hide()
		def Destroy(self):
			self.Hide()
			if self in XX._instances:
				XX._instances.remove(self)
		def XX2(self, event):
			self.eventTimeOver = __mem_func__(event)
		def SAFE_SetExitEvent(self, event):
			self.eventExit = __mem_func__(event)
		def OnUpdate(self):
			if self.endTime is not None:
				lastTime = max(0, self.endTime - time.perf_counter())
				if lastTime == 0:
					self.Close()
					self.eventTimeOver()
				else:
					return
else:
	class XX(ScriptWindow):
		def __init__(self):
			ScriptWindow.__init__(self)
			self.eventTimeOver = lambda *arg: None
			self.eventExit = lambda *arg: None
		def __del__(self):
			try:
				ScriptWindow.__del__(self)
			except:
				pass
		def XX1(self, waitTime):
			try:
				curTime = time.clock()
				self.endTime = curTime + waitTime
				self.Show()
			except:
				pass
		def Close(self):
			self.Hide()
		def Destroy(self):
			self.Hide()
		def XX2(self, event):
			self.eventTimeOver = __mem_func__(event)
		def SAFE_SetExitEvent(self, event):
			self.eventExit = __mem_func__(event)
		def OnUpdate(self):
			try:
				lastTime = max(0, self.endTime - time.clock())
				if 0 == lastTime:
					self.Close()
					self.eventTimeOver()
				else:
					return
			except:
				pass
class Itemx:
	def __init__(self, id, slot, size, name):
		self.id = id
		self.slot = slot
		self.size = size
		self.name = name
	def move(self, slot):
		MoveItem(self.slot, slot, 0)
		self.slot = slot
def retrieve_items():
	item_list = []
	try:
		for slot in range(SLOTS):
			item_id = player.GetItemIndex(slot)
			if item_id != 0:
				selectItem(item_id)
				item_list.append(Itemx(item_id, slot, int(item.GetItemSize()[1]), item.GetItemName()))
	except:
		pass
	return item_list
def sort_by_id(item_list):
	try:
		item_list.sort(key=lambda item: item.id, reverse=False)
	except:
		pass
def get_next_slot(size, placed):
	for page in range(int(math.ceil(SLOTS / SLOTS_PER_PAGE))):
		LAST_SLOT_THIS_PAGE = min((page + 1) * SLOTS_PER_PAGE, SLOTS)
		for slot in range(page * SLOTS_PER_PAGE, LAST_SLOT_THIS_PAGE):
			if slot + 5 * (size - 1) < LAST_SLOT_THIS_PAGE:
				good = True
				for i in range(size):
					if (slot + 5 * i) in placed:
						good = False
				if good:
					return slot
	return -1
def items_in_slot(slot, size, item_list):
	items = []
	for i in range(size):
		cur_slot = slot + i * 5
		it = [x for x in item_list if x.slot == cur_slot or 
			  (x.size == 2 and x.slot + 5 == cur_slot) or 
			  (x.size == 3 and (x.slot + 10 == cur_slot or x.slot + 5 == cur_slot))]
		if len(it) > 0 and it[0] not in items:
			items.append(it[0])
	return items
def get_next_free_slot(size, skip, item_list):
	for page in range(int(math.ceil(SLOTS / SLOTS_PER_PAGE))):
		LAST_SLOT_THIS_PAGE = min((page + 1) * SLOTS_PER_PAGE, SLOTS)
		for slot in range(page * SLOTS_PER_PAGE, LAST_SLOT_THIS_PAGE):
			if slot not in skip and len(items_in_slot(slot, size, item_list)) == 0 and slot + 5 * (size - 1) < LAST_SLOT_THIS_PAGE:
				return slot
	return -1
def set_item_as_placed(item, placed):
	for i in range(item.size):
		placed.append(item.slot + 5 * i)
class ItemSorter:
	def __init__(self):
		global sortDelay
		self.item_list = []
		self.placed = []
		self.current_item_index = 0
		self.delay_duration = sortDelay
		self.timer = XX()
	def process_next_item(self):
		if self.current_item_index >= len(self.item_list):
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hItem sorter: All items processed.")
			return
		it = self.item_list[self.current_item_index]
		next_slot = get_next_slot(it.size, self.placed)
		if next_slot == -1:
			# msg("No slot found for item {}. Skipping...".format(it.id))
			self.current_item_index += 1
			self.process_next_item()
			return
		if it.slot == next_slot:
			# msg("Item {} is already in the correct slot.".format(it.id))
			set_item_as_placed(it, self.placed)
			self.current_item_index += 1
			self.process_next_item()
			return
		occupied_slots = [next_slot + 5 * i for i in range(it.size)]
		for in_way_item in items_in_slot(next_slot, it.size, self.item_list):
			next_free_slot = get_next_free_slot(in_way_item.size, occupied_slots, self.item_list)
			if next_free_slot == -1:
				continue
			# msg("Moving item {} to free slot {}.".format(in_way_item.id, next_free_slot))
			in_way_item.move(next_free_slot)
			self.timer.XX1(self.delay_duration)
			self.timer.XX2(self.process_next_item)  # Continue processing after the delay
			return  # Exit function to wait for the delay
		# msg("Moving item {} to slot {}.".format(it.id, next_slot))
		it.move(next_slot)
		set_item_as_placed(it, self.placed)
		self.timer.XX1(self.delay_duration)
		self.timer.XX2(lambda: self.process_next_item())
	def start(self):
		self.item_list = retrieve_items()
		sort_by_id(self.item_list)
		self.process_next_item()
def xsort_items():
	sorter = ItemSorter()
	sorter.start()
class ItemHandlerx:
	def __init__(self):
		self.list = []
		self.placed = []
	def retrieveItems(self): 
		try:
			for slot in range(SLOTS):
				item_id = player.GetItemIndex(slot)
				if item_id != 0:
					selectItem(item_id)
					self.list.append(Itemx(item_id, slot, int(item.GetItemSize()[1]), item.GetItemName()))
		except:
			pass
	def sortByID(self):
		try:
			self.list.sort(key=lambda item: item.id, reverse=False)
		except:
			pass
	def getNextSlot(self, size):
		for page in range(int(math.ceil(SLOTS / SLOTS_PER_PAGE))):
			LAST_SLOT_THIS_PAGE = min((page + 1) * SLOTS_PER_PAGE, SLOTS)
			for slot in range(page * SLOTS_PER_PAGE, LAST_SLOT_THIS_PAGE):
				if slot + 5 * (size - 1) < LAST_SLOT_THIS_PAGE:
					good = True
					for i in range(size):
						if (slot + 5 * i) in self.placed:
							good = False
					if good:
						return slot
		return -1
	def itemsInSlot(self, slot, size):
		items = []
		for i in range(size):
			cur_slot = slot + i * 5
			it = [x for x in self.list if x.slot == cur_slot or (x.size == 2 and x.slot + 5 == cur_slot or False) or (x.size == 3 and (x.slot + 10 == cur_slot or x.slot + 5 == cur_slot) or False) ]
			if len(it) > 0 and it[0] not in items:
				items.append(it[0])
		return items
	def getNextFreeSlot(self, size, skip = []):
		for page in range(int(math.ceil(SLOTS / SLOTS_PER_PAGE))):
			LAST_SLOT_THIS_PAGE = min((page + 1) * SLOTS_PER_PAGE, SLOTS)
			for slot in range(page * SLOTS_PER_PAGE, LAST_SLOT_THIS_PAGE):
				if slot not in skip and len(self.itemsInSlot(slot, size)) == 0 and slot + 5 * (size - 1) < LAST_SLOT_THIS_PAGE:
					return slot
		return -1		
	def setItemAsPlaced(self, item):
		for i in range(item.size):
			self.placed.append(item.slot + 5 * i)
	def sort(self):
		self.retrieveItems()
		self.sortByID()
		for it in self.list:	
			next_slot = self.getNextSlot(it.size)
			if next_slot == -1:
				continue;
			if it.slot == next_slot:
				self.setItemAsPlaced(it)
				continue
			occupied_slots = []
			for i in range(it.slot):
				occupied_slots.append(next_slot + 5 * i)
			for in_way_item in self.itemsInSlot(next_slot, it.size):
				next_free_slot = self.getNextFreeSlot(in_way_item.size, occupied_slots)
				if next_free_slot == -1:
					continue
				in_way_item.move(next_free_slot)
			it.move(next_slot)
			self.setItemAsPlaced(it)
class RefineDragonStoneBot:
	def __init__(self):
		pass
	def start(self):
		if self.checkKind(0):
			return True
		if self.checkKind(1):
			return True
		if self.checkKind(2):
			return True
		if self.checkKind(3):
			return True
		if self.checkKind(4):
			return True
		if self.checkKind(5):
			return True
		if self.checkKind(6):
			return True
		return True
	def checkKind(self, kind):
		startPos = kind * 6 * player.DRAGON_SOUL_PAGE_SIZE
		for i in range(6):
			if self.checkGrade(startPos, i):
				return True
		return False
	def checkGrade(self, startPos, grade):
		localPos = startPos + grade * player.DRAGON_SOUL_PAGE_SIZE
		positions = []
		for i in range(player.DRAGON_SOUL_PAGE_SIZE):
			vnum = player.GetItemIndex(player.DRAGON_SOUL_INVENTORY, localPos + i)
			if vnum > 0:
				positions.append(localPos+i)
		if len(positions) >= 2:
			pos1 = positions[0]
			pos2 = positions[1]
			refineItemInfo = {}
			refineItemInfo[0] = (player.DRAGON_SOUL_INVENTORY, pos1, 1)
			refineItemInfo[1] = (player.DRAGON_SOUL_INVENTORY, pos2, 1)
			try:
				player.SendDragonSoulRefine(player.DS_SUB_HEADER_DO_UPGRADE, refineItemInfo)
			except:
				pass
		return False
COLOR_CHECKBOX_NOT_SELECTED = grp.GenerateColor(1.0, 0.3, 0.0, 0.1)
COLOR_CHECKBOX_SELECTED = grp.GenerateColor(0.3, 1.0, 1.0, 0.3)
class ToggleButton(Button):
	def __init__(self):
		Button.__init__(self)
		self.eventUp = None
		self.eventDown = None
	def __del__(self):
		Button.__del__(self)
		self.eventUp = None
		self.eventDown = None
		self.eventUpArgs = None
		self.eventDownArgs = None
	def SetToggleUpEvent(self, event, *args):
		self.eventUp = event
		self.eventUpArgs = args
	def SetToggleDownEvent(self, event, *args):
		self.eventDown = event
		self.eventDownArgs = args
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.RegisterToggleButton(self, layer)
	def OnToggleUp(self):
		if self.eventUp:
			self.eventUp()
	def OnToggleDown(self):
		if self.eventDown:
			self.eventDown()
if isGF or find_string(st_cur_server, "metin3") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "mt2classichu") or find_string(st_cur_server, "DDMT") or find_string(st_cur_server, "LandOfHeroes") or find_string(st_cur_server, "atheria") or find_string(st_cur_server, "alune"):
	class CheckBox(ui.Window):
		checked = 0
		eventUp = None
		eventDown= None
		def __init__(self,cont = ""):
			ui.Window.__init__(self)
			self.BG = ui.Bar("UI")
			self.BG.SetParent(self)
			self.BG.SetPosition(0,0)
			self.BG.SetSize(19,19)
			# self.BG.SetColor(0xc00b0b0b)
			self.BG.SetColor(COLOR_CHECKBOX_NOT_SELECTED)
			self.BG.OnMouseLeftButtonUp = self.Toggle
			self.OnMouseLeftButtonUp = self.Toggle
			self.BG.Show()
			self.Title = ui.TextLine()
			self.Title.SetParent(self)
			if IsARABIC():
				self.Title.SetPosition(100,2)
			else:
				self.Title.SetPosition(25,2)
			self.Title.SetText(cont)
			self.Title.Show()
			self.stat = ui.TextLine()
			self.stat.SetParent(self.BG)
			self.stat.SetPosition(0,0)
			try:
				self.stat.SetWindowHorizontalAlignCenter()
				self.stat.SetWindowVerticalAlignCenter()
			except:
				pass
			self.stat.SetHorizontalAlignCenter()
			self.stat.SetVerticalAlignCenter()
			self.stat.SetSize(0,0)
			self.stat.SetText("")
			try:
				self.SetSize(25+self.Title.GetTextSize()[0]+5,20)
			except:
				pass
			self.stat.Show()
		def __del__(self):
			ui.ToggleButton.__del__(self)
		def Toggle(self):
			if self.checked == 1:
				self.OnToggleUp()
			else:
				self.OnToggleDown()
		def OnToggleUp(self):
			self.stat.SetText("")
			# self.BG.SetColor(0xc00b0b0b)
			self.BG.SetColor(COLOR_CHECKBOX_NOT_SELECTED)
			self.checked = 0
			if self.eventUp:
				self.eventUp()
		def OnToggleDown(self):
			# self.BG.SetColor(0xf00b0b0b)
			self.BG.SetColor(COLOR_CHECKBOX_SELECTED) 
			self.stat.SetText("X")
			self.checked = 1
			if self.eventDown:
				self.eventDown()
elif foundx64PythonList:
	class CheckBox(ui.Window):
		checked = 0
		eventUp  =None
		eventDown=None
		def __init__(self,cont = ""):
			ui.Window.__init__(self)
			self.BG = ui.Bar("UI")
			self.BG.SetParent(self)
			self.BG.SetPosition(0,0)
			self.BG.SetSize(19,19)
			self.BG.SetColor(COLOR_CHECKBOX_NOT_SELECTED)
			self.BG.OnMouseLeftButtonUp = self.Toggle
			self.BG.OnMouseLeftButtonDown = self.Toggle
			self.OnMouseLeftButtonUp = self.Toggle
			self.OnMouseLeftButtonDown = self.Toggle
			self.BG.Show()
			self.Title = ui.TextLine()
			self.Title.SetParent(self)
			if IsARABIC():
				self.Title.SetPosition(100,2)
			else:
				self.Title.SetPosition(25,2)
			self.Title.SetText(cont)
			self.Title.Show()
			self.stat = ui.TextLine()
			self.stat.SetParent(self.BG)
			self.stat.SetPosition(0,0)
			# self.stat.SetWindowHorizontalAlignCenter()
			# self.stat.SetWindowVerticalAlignCenter()
			self.stat.SetHorizontalAlignCenter()
			self.stat.SetVerticalAlignCenter()
			self.stat.SetSize(0,0)
			self.stat.SetText("")
			self.SetSize(25+self.Title.GetTextLineCount()+5,20)
			self.stat.Show()
		def __del__(self):
			ui.ToggleButton.__del__(self)
		def Toggle(self):
			if self.checked == 1:
				self.OnToggleUp()
			else:
				self.OnToggleDown()
		def OnToggleUp(self):
			self.stat.SetText("")
			self.BG.SetColor(COLOR_CHECKBOX_NOT_SELECTED)
			self.checked = 0
			if self.eventUp:
				self.eventUp()
		def OnToggleDown(self):
			self.BG.SetColor(COLOR_CHECKBOX_SELECTED) 
			self.stat.SetText("X")
			self.checked = 1
			if self.eventDown:
				self.eventDown()
else:
	class CheckBox(Window):
		checked = 0
		eventUp  =None
		eventDown=None
		def __init__(self,cont = ""):
			Window.__init__(self)
			self.BG = Bar("UI")
			self.BG.SetParent(self)
			self.BG.SetPosition(0,0)
			self.BG.SetSize(19,19)
			self.BG.SetColor(COLOR_CHECKBOX_NOT_SELECTED)
			self.BG.OnMouseLeftButtonUp = self.Toggle
			self.OnMouseLeftButtonUp = self.Toggle
			self.BG.Show()
			self.Title = Textline()
			self.Title.SetParent(self)
			if IsARABIC():
				self.Title.SetPosition(100,2)
			else:
				self.Title.SetPosition(25,2)
			self.Title.SetText(cont)
			self.Title.Show()
			self.stat = Textline()
			self.stat.SetParent(self.BG)
			self.stat.SetPosition(0,0)
			self.stat.SetWindowHorizontalAlignCenter()
			self.stat.SetWindowVerticalAlignCenter()
			self.stat.SetHorizontalAlignCenter()
			self.stat.SetVerticalAlignCenter()
			self.stat.SetSize(0,0)
			self.stat.SetText("")
			try:
				self.SetSize(25+self.Title.GetTextSize()[0]+5,20)
			except:
				pass
			self.stat.Show()
		def __del__(self):
			ToggleButton.__del__(self)
		def Toggle(self):
			if self.checked == 1:
				self.OnToggleUp()
			else:
				self.OnToggleDown()
		def OnToggleUp(self):
			self.stat.SetText("")
			# self.BG.SetColor(0xc00b0b0b)
			self.BG.SetColor(COLOR_CHECKBOX_NOT_SELECTED)
			self.checked = 0
			if self.eventUp:
				self.eventUp()
		def OnToggleDown(self):
			# self.BG.SetColor(0xf00b0b0b)
			self.BG.SetColor(COLOR_CHECKBOX_SELECTED) 
			self.stat.SetText("X")
			self.checked = 1
			if self.eventDown:
				self.eventDown()
last_teleport_time = 0
stonecode = 0
SwitchButton = 0
class Event:
	def __init__(self, delay, task, name=None, repeat=False):
		self.delay = delay
		self.task = task
		self.name = name
		self.repeat = repeat
		self.over = False
		if foundNewPythonList:
			try:
				self.timeOfExec = time.perf_counter() + delay
			except:
				pass
		else:
			try:
				self.timeOfExec = time.clock() + delay
			except:
				pass
	def run(self, curTime):
		try:
			if not self.over and curTime >= self.timeOfExec:
				self.timeOfExec = curTime + self.delay
				self.task()
				self.over = not self.repeat
		except:
			pass
class speed(ScriptWindow):
	viteza = 1
	def SetBoost1(self):
		self.viteza = 1
	def SetBoost0(self):
		self.viteza = 0
booster = speed()
booster.Show()
def format_number(number):
	try:
		if sys.version_info < (2,7):
			number_str = str(number)
			num_digits = len(number_str)
			formatted_number = ""
			for i in range(num_digits):
				digit = number_str[i]
				if i != 0 and (num_digits - i) % 3 == 0:
					formatted_number += "."
				formatted_number += digit
			return formatted_number
		else:
			number_str = str(number)  
			num_digits = len(number_str) 
			formatted_number = ""
			for i, digit in enumerate(number_str):
				if i != 0 and (num_digits - i) % 3 == 0:
					formatted_number += "."
				formatted_number += digit
			return formatted_number
	except:
		number_str = str(number)  
		num_digits = len(number_str) 
		formatted_number = ""
		for i, digit in enumerate(number_str):
			if i != 0 and (num_digits - i) % 3 == 0:
				formatted_number += "."
			formatted_number += digit
		return formatted_number
class SearchDialog(ScriptWindow):
	
	SLOT_COUNT = 40
	STATE_OPEN_SHOP = 1
	STATE_WAIT_SHOP_OPEN = 2
	STATE_WAIT_SHOP_CLOSE = 3
	Items = []
	
	numAttempts = 0
	if isGF:
		TIME_WAIT = 0.25
		ATTEMPTS_WAIT = 2
	else:
		TIME_WAIT = 0.1
		ATTEMPTS_WAIT = 4
	lastTime = 0
	
	
	ListItemList = ["DDMT",
		"mt2classichu",
		"LandOfHeroes",
		"Sancy",
		"SoW2",
		"Zemia",
		"rhodium",
		"lucerna",
		"veshia",
		"next2play",
		"lucerna",
		"atheria"
	
	]
	if any([find_string(st_cur_server, server) for server in ListItemList]) or isGF:
	
	
	
		class ListItem(ui.ListBoxEx.Item):
			def __init__(self, item):
				ui.ListBoxEx.Item.__init__(self)
				self.canLoad=0
				self.item=item
				self.textLine=self.__CreateTextLine(item.GetDisplay())		  
			def __del__(self):
				try:
					ui.ListBoxEx.Item.__del__(self)
				except:
					pass
			def GetText(self):
				return self.item
			def SetSize(self, width, height):
				ui.ListBoxEx.Item.SetSize(self, 6*len(self.textLine.GetText()) + 4, height)
			def __CreateTextLine(self, fileName):
				textLine=ui.TextLine()
				textLine.SetParent(self)
				textLine.SetPosition(0, 0)
				textLine.SetText(fileName)
				textLine.Show()
				return textLine	
	else:
		class ListItem(ListBoxEx.Item):
			def __init__(self, item):
				ListBoxEx.Item.__init__(self)
				self.canLoad=0
				self.item=item
				self.textLine=self.__CreateTextLine(item.GetDisplay())		  
			def __del__(self):
				try:
					ListBoxEx.Item.__del__(self)
				except:
					pass
			def GetText(self):
				return self.item
			def SetSize(self, width, height):
				ListBoxEx.Item.SetSize(self, 6*len(self.textLine.GetText()) + 4, height)
			def __CreateTextLine(self, fileName):
				textLine=Textline()
				textLine.SetParent(self)
				textLine.SetPosition(0, 0)
				textLine.SetText(fileName)
				textLine.Show()
				return textLine	
	class Item:
		
		def __init__(self, itemName, shopVID, count, price, slot, pos, won=0):
			if count is None or count == 0:
				count = 1
	
			if price is None:
				price = 0
			elif isinstance(price, str):
				try:
					price = int(price.replace(".", ""))
				except ValueError:
					price = 0
	
			if won is None:
				won = 0
	
			# Assign values
			self.name = itemName
			self.shop = shopVID
			self.count = count
			self.price = (price + won * 100000000) / self.count
			self.total_price = self.price * self.count
			self.won = won
			self.slot = slot
			self.pos = pos
		def GetDisplay(self):
			total_price = self.price * self.count
			return "%-10s%-30s%-15s%s / %s %s" % (str(self.count), self.name[:20], chr.GetNameByVID(self.shop)[:10], format_number(self.price), format_number(total_price), str(self.pos))
		def getStringFormat(self):
			return (
				"Slot: " + str(self.slot) +
				"  Name: " + str(self.name) +
				"  Price: " + str(self.price) +
				"  Count: " + str(self.count) +
				"  Shop VID: " + str(self.shop) +
				"  Position: " + str(self.pos)
			)
	def __init__(self):
		self.closeAttempt = 0
		self.appendxItemName=XX()
		ScriptWindow.__init__(self)
		if find_string(st_cur_server, "alune") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "next2play"):
			self.Board = ui.BoardWithTitleBar()
		else:
			self.Board = BoardWithTitleBar()
		self.Board.SetTitleName('Shop search bot')
		self.Board.SetCloseEvent(self.CloseWindow)
		self.Board.SetSize(BOARD_SIZE_X, BOARD_SIZE_Y)
		self.Board.SetCenterPosition()
		self.Board.AddFlag(movplable)
		self.comp = Component()
		self.SearchButton = self.comp.ToggleButton(self.Board,lang.STR_SEARCH_SHOP,'',relativeCenterX(-48),relativeEndY(45),self.StopSearch,self.StartSearch,large1, large2, large3)
		self.SkillIdNameLabel = self.comp.TextLine(self.Board, 'Count	  Item Name				Shop Name			  Price per piece / total:			Position', 16, 30, self.comp.RGB(255, 255, 255))
		self.BarItems, self.ListBoxItems, self.ScrollItems = self.comp.ListBoxEx2(self.Board, 10, 45, relativeEndX(42), relativeEndY(205))
		self.ListBoxItems.SetViewItemCount(12)
		self.appendItemName = CheckBox('Append item name')
		self.appendItemName.SetParent(self.Board)
		self.appendItemName.SetPosition(5,302)
		self.appendItemName.eventUp   = self.appendItemNameStop
		self.appendItemName.eventDown = self.appendItemNameStart
		self.appendItemName.Show()
		# self.appendItemName.Toggle()
		self.ItemEditBoxSlot, self.ItemEditBoxValue= self.comp.EditLine(self.Board, '', 120, 302, 155, 15, 65)
		try:
			self.ItemEditBoxValue.OnIMEUpdate = self.UpdateItemList
		except:
			pass
		self.clearItemName = self.comp.Button(self.Board, '', 'Clear searched item name', 280, 303, self.clearItemNameFunc, close1, close2, close3)
		self.ItemSubmitButton = self.comp.Button(self.Board, lang.STR_SEARCH_BTN, '',relativeEndX(-100),relativeEndY(150),self.UpdateItemList,large1, large2, large3)
		self.dumpShopListBtn = self.comp.Button(self.Board, 'Dump shop list', '',relativeEndX(-100), relativeEndY(45),self.dumpShopList,large1, large2, large3)
		self.BuyItemButton = self.comp.Button(self.Board, lang.STR_BUY_ITEMS, '',relativeEndX(-100), relativeEndY(80),self.BuySelectedItem,large1, large2, large3)
		self.OpenShopButton = self.comp.Button(self.Board, lang.STR_OPEN_SHOP, '',relativeEndX(-100),relativeEndY(120),self.OpenSelectedShop,large1, large2, large3)
		self.MoveShopButton = self.comp.Button(self.Board, lang.STR_TELE_SHOP, '',relativeEndX(-100),relativeEndY(100),self.MoveSelectedShop,large1, large2, large3)
		self.lShopsSearch = self.comp.TextLine(self.Board, '', 14, relativeEndY(100), self.comp.RGB(255, 255, 255))
		self.lShopsToBeSearch = self.comp.TextLine(self.Board, '', 15, relativeEndY(80), self.comp.RGB(255, 255, 255))
		self.lNumItems = self.comp.TextLine(self.Board, '', 14, relativeEndY(120), self.comp.RGB(255, 255, 255))
		self.shopVIDS = []
		self.State = 0
		self.PlayerIndex = 0
		
	def dumpShopList(self):
		try:
			if self.ListBoxItems.IsEmpty():
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.EMPTY_SHOP_LIST)
				return
			current_time = time.strftime("%Y%m%d_%H%M%S")
			
			file_name = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + "shop_list_dump_" + current_time + ".txt"
			file = open_file(file_name, "a")
			
			file.write("Dumped Shop List:\n\n")
			file.write("Item Name\tPrice\tCount\tShop VID\tPosition\n")
			for item in self.ListBoxItems.itemList:
				data = item.GetText()
				line = (
					str(data.name) + "\t" +
					str(data.price) + "\t" +
					str(data.count) + "\t" +
					str(data.shop) + "\t" +
					str(data.pos) + "\n"
				)
				file.write(line)
			file.close()
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.SHOP_DUMP_OK + " '" + file_name + "'.")
			os.startfile(file_name)
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h" + lang.SHOP_DUMP_NOT)
	def appendItemNameStop(self):
		
		self.appendxItemName.XX1(9999999)
		self.appendxItemName.XX2(self.appendItemNameStop)
	def appendItemNameStart(self):
		try:
			
			self.appendxItemName.XX1(0.1)
			self.appendxItemName.XX2(self.appendItemNameStart)
			itemList = self.ListBoxItems.GetSelectedItem()
			if itemList:
				item = itemList.GetText()
				item = item.name
				self.ItemEditBoxValue.SetText(str(item))
		except:
			pass
	def EnableButtonClicked(self,val):
		if(val):
			self.StartSearch()
		else:
			self.StopSearch()
	def clearItemNameFunc(self):
		self.ListBoxItems.SelectIndex(-1)
		self.ItemEditBoxValue.SetText('')			
	def StartSearch(self):
		self.ListBoxItems.SelectIndex(-1)
		self.ItemEditBoxValue.SetText('')
		self.numShopsSearched = 0
		self.State = 1
		self.shopVIDS = []
		self.Items = []
		self.PlayerIndex = 0
		self.ScanShops()
		self.State = self.STATE_OPEN_SHOP
	def UpdateLabelText(self):
		self.lShopsSearch.SetText('Opened shops: ' + str(self.numShopsSearched))
		self.lShopsToBeSearch.SetText('Shops to open: ' + str(len(self.shopVIDS)))
		self.lNumItems.SetText(lang.STR_NR_OF_ITEMS + " " + str(len(self.Items)))
	def DivideToFloat(self,x, y):
		try:
			return x * (y**-1)
		except:
			return 0
	def Debug(self):
		onKeyDown(appKey('UP'))
		if foundx64PythonList:
			onKeyUp(player.DIR_UP)	
		else:
			onKeyUp(appKey('UP'))
	def GetTmpTeleport(self,DestX, DestY):
		global DivideToFloat
		(PlayerX, PlayerY, PlayerZ) = player.GetMainCharacterPosition()
		DifX = DestX - PlayerX
		DifY = DestY - PlayerY
		Vektor = self.DivideToFloat(2000, math.sqrt(DifX**2 + DifY**2))
		TempX = PlayerX + Vektor*DifX
		TempY = PlayerY + Vektor*DifY
		Count = self.DivideToFloat((DestX - PlayerX), (Vektor*DifX))
		return (TempX, TempY, Count)
	def TeleportToDest(self, aimx, aimy):
		step_distance = 30
		cur_position = player.GetMainCharacterPosition()
		curx = cur_position[0]
		cury = cur_position[1]
		total_distance = math.sqrt((aimx - curx)**2 + (aimy - cury)**2)
		steps = int(total_distance // step_distance)
		if steps > 0:
			step_x = (aimx - curx) / float(steps) 
			step_y = (aimy - cury) / float(steps)
		else:
			step_x = 0
			step_y = 0
		myVid = getCharIndex()
		for _ in range(steps):
			curx += step_x
			cury += step_y
			chr.SelectInstance(myVid)
			setPixelPos(int(curx), int(cury))
			self.Debug()
		chr.SelectInstance(myVid)
		setPixelPos(int(aimx), int(aimy))
		self.Debug() 
		global TeleportState
		TeleportState = 1
	def MoveSelectedShop(self):
		global TeleportState, Debug, TeleportToDest
		itemList = self.ListBoxItems.GetSelectedItem()
		if itemList:
			item = itemList.GetText()
			x,y = getPos(item.shop)
			z_coordinate = int(1) * 100
			myVid = getCharIndex()
			chr.SelectInstance(myVid)
			self.TeleportToDest(x,y)
			walkFunc(x, y)
	def CutMoneyString(self, sourceText, startIndex, endIndex):
		sourceLength = len(sourceText)
		if sourceLength < startIndex:
			return ""
		text = sourceText[max(0, sourceLength - endIndex) : sourceLength - startIndex]
		if not text:
			return ""
		if int(text) <= 0:
			return ""
		return str(int(text))
	def openShop(self):	
		itemList = self.ListBoxItems.GetSelectedItem()
		try:
			if itemList:
				item = itemList.GetText()
				chr.SelectInstance(item.shop)
				clickPacket(item.shop)
			else:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hShop search bot: " + lang.NO_ITEM_SELECTED)
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hShop search bot: " + lang.NO_SHOP_VIEWRANGE)
	def OpenSelectedShop(self):
		itemList = self.ListBoxItems.GetSelectedItem()
		if itemList:
			item = itemList.GetText()
			if shop.IsOpen():
				net.SendShopEndPacket()
				if hasattr(shop, 'SendOfflineShopEndPacket'):
					net.SendOfflineShopEndPacket()
				eventHandler.add(0.35, self.openShop)
			else:
				chr.SelectInstance(item.shop)
				clickPacket(item.shop)
	def StopSearch(self):
		self.State = 0
		self.UpdateItemList()
	def CloseWindow(self):
		self.Board.Hide()
		self.Board.Destroy()
	def extract_price(self, price_str):
		price_str = str(price_str)
		numeric_part = ""
		for char in price_str:
			if char.isdigit():
				numeric_part += char
			elif numeric_part:
				break
		if numeric_part:
			return int(numeric_part)
		else:
			return 0
	def UpdateItemList(self):
		global oldPython
		if isGF:
			try:
				ui.EditLine.OnIMEUpdate(self.ItemEditBoxValue)
			except:
				pass
		else:
			try:
				EditLine.OnIMEUpdate(self.ItemEditBoxValue)
			except:
				pass
		value = self.ItemEditBoxValue.GetText().lower()
		self.ListBoxItems.RemoveAllItems()
		lst = []
		for item in self.Items:
			if value in item.name.lower():
				lst.append(item)
		
		# Sorting logic based on Python version
		if oldPython:  # Python 2.2 and earlier
			lst.sort(lambda x, y: cmp(x.price, y.price))
		else:  # Python 2.7 and 3.x
			lst.sort(key=lambda x: x.price)
		
		for item in lst:
			self.ListBoxItems.AppendItem(self.ListItem(item))
	def ScanShops(self):
		global vidsListEnd1,isGF
		
		if isGF:
			for x in eXLib.InstancesList:
				DistanceToNext = GetDis(x)
				if DistanceToNext > 0 :
					test = HasInstance(x)
					chr.SelectInstance(x)
					if test != 0 and chr.GetRace(x) >= 30000 and chr.GetRace(x) <= 30008:
						self.shopVIDS.append(x)
		else:
			for x in vidsListEnd1:
				DistanceToNext = GetDis(x)
				if DistanceToNext > 0 :
					test = HasInstance(x)
					chr.SelectInstance(x)
					if test != 0 and chr.GetRace(x) >= 30000 and chr.GetRace(x) <= 30008:
						self.shopVIDS.append(x)
		self.UpdateLabelText()
		return True
	def BuySelectedItem(self):
		itemList = self.ListBoxItems.GetSelectedItem()
		if itemList:
			item = itemList.GetText()
			self.BuyItemDirectly(item)
			# self.ListBoxItems.RemoveItem(itemList)
	def BuyItemDirectly(self,item):
		try:
			vid = item.shop
			if vid != -1 or vid != 0:
				slot = item.slot
				chr.SelectInstance(vid)
				x,y,z = player.GetMainCharacterPosition()
				dst_x,dst_y = getPos(vid)
				if(dst_x + dst_y < 0.000001):
					return
				dst = GetDis(vid)
				o = getCharIndex()
				goBack = 0
				if dst >= 2000:
					chr.SelectInstance(o)
					self.TeleportToDest(dst_x, dst_y)
					goBack = 1
				clickPacket(vid)
				net.SendShopBuyPacket(slot)
				net.SendShopEndPacket()
				if goBack:
					chr.SelectInstance(o)
					self.TeleportToDest(x, y)
			else:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hShop search bot: " + lang.NO_SHOP_VIEWRANGE2)
		except:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hShop search bot: " + lang.NO_SHOP_VIEWRANGE)
	def OpenShop(self,vid):
		if self.IsShopOpen() == False and HasInstance(vid):
			chr.SelectInstance(vid)
			clickPacket(vid)
	def IsShopOpen(self):
		return shop.IsOpen()
	def CloseShop(self):
		if self.IsShopOpen() == True:
			if hasattr(net, 'SendOfflineShopEndPacket'):
				net.SendOfflineShopEndPacket()
			net.SendShopEndPacket()
	required_attributes = ['GetOfflineShopItemID', 'GetOfflineShopItemPrice', 'GetOfflineShopItemMetinSocket', 'GetOfflineShopItemCount']
	all_attributes_exist = True
	for attr in required_attributes:
		if not hasattr(shop, attr):
			all_attributes_exist = False
			break
	
	if all_attributes_exist:
		def ScanShop(self, vid):
			self.numShopsSearched += 1
			chr.SelectInstance(vid)
		
			for x in range(0, self.SLOT_COUNT * shop.GetTabCount()):
				id = shop.GetOfflineShopItemID(x)
				if id != 0:
					name = item.GetItemName(selectItem(id))
					price = format_number(shop.GetOfflineShopItemPrice(x))
					try:
						raw_pos = getPos(vid)
						pos = (int(raw_pos[0] / 100), int(raw_pos[1] / 100))
					except:
						pos = (0,0)
					pos = (int(raw_pos[0] / 100), int(raw_pos[1] / 100))
					if id == 50300:
						sk = shop.GetOfflineShopItemMetinSocket(x, 0)
						skill_name = str(skill.GetSkillName(sk))
						name = str(skill_name) + " " + name
		
		
					price = shop.GetOfflineShopItemPrice(x)
					count = shop.GetOfflineShopItemCount(x)
					
					if hasattr(shop, 'GetItemCheque'):
						won = shop.GetItemCheque(x)
					else:
						won = 0
					if price is None:
						price = 0
					
					if count is None or count == 0:
						count = 1
					
					if won is None:
						won = 0
					it = self.Item(name, vid, count, price, x, pos, won)
					self.Items.append(it)
		
			self.UpdateLabelText()
			self.UpdateItemList()
	else:
		
		def ScanShop(self, vid):
			self.numShopsSearched += 1
			chr.SelectInstance(vid)
		
			for x in range(0, self.SLOT_COUNT * shop.GetTabCount()):
				id = shop.GetItemID(x)
				if id != 0:
					name = item.GetItemName(selectItem(id))
					
					try:
						raw_pos = getPos(vid)
						pos = (int(raw_pos[0] / 100), int(raw_pos[1] / 100))
					except:
						pos = (0,0)
						
					pos = (int(raw_pos[0] / 100), int(raw_pos[1] / 100))
					
					if id == 50300:
						sk = shop.GetItemMetinSocket(x, 0)
						skill_name = str(skill.GetSkillName(sk))
						name = str(skill_name) + " " + name
					
					price = shop.GetItemPrice(x)
					count = shop.GetItemCount(x)
					
					if hasattr(shop, 'GetItemCheque'):
						won = shop.GetItemCheque(x)
					else:
						won = 0
					if price is None:
						price = 0
					
					if count is None or count == 0:
						count = 1
					
					if won is None:
						won = 0
					it = self.Item(name, vid, count, price, x, pos, won)
					self.Items.append(it)
		
			self.UpdateLabelText()
			self.UpdateItemList()
	def OnUpdate(self):
		currTime = app.GetTime()
		if currTime-self.lastTime < self.TIME_WAIT:
			return
		if self.State == 0:
			return
		self.lastTime = currTime
		if self.State == self.STATE_OPEN_SHOP and len(self.shopVIDS)>0:
			self.currentShopVID = self.shopVIDS.pop()
			self.OpenShop(self.currentShopVID)
			self.State = self.STATE_WAIT_SHOP_OPEN
			return
		elif self.State == self.STATE_WAIT_SHOP_OPEN:
			if self.numAttempts > self.ATTEMPTS_WAIT:
				self.numAttempts = 0
				self.State = self.STATE_WAIT_SHOP_CLOSE
				return
			if self.IsShopOpen() == True:
				self.State = self.STATE_WAIT_SHOP_CLOSE
				self.ScanShop(self.currentShopVID)
				self.CloseShop()
				self.numAttempts = 0
			else:
				self.OpenShop(self.currentShopVID)
				self.numAttempts += 1 
			return
		elif self.State == self.STATE_WAIT_SHOP_CLOSE:
			if self.IsShopOpen() == False:
				self.numAttempts = 0
				self.State = self.STATE_OPEN_SHOP
				return
			else:
				if(self.closeAttempt>3):
					self.closeAttempt = 0
					self.CloseShop()
					return
				self.closeAttempt += 1 
				return
ListOfItems = [ [ 0 for x in range(2) ] for x in range(50) ]
if isGF or find_string(st_cur_server, "Metin2BR") or find_string(st_cur_server, "age of metin2"):
	class ShopDialog(ScriptWindow):
		Gui = {}
		def __init__(self):
			self.Board = BoardWithTitleBar()
			self.Board.SetTitleName('Shop creator bot')
			self.Board.SetSize(350, 500)
			self.Board.SetPosition(200, 100)
			self.Board.AddFlag(movplable)
			self.Board.SetCloseEvent(self.Hide_UI)
			self.Board.Hide()
			self.comp = Component()
			self.refreshSellingItems = self.comp.Button(self.Board, '', '', 304, 9, self.ReloadInv, refresh1, refresh2, refresh3)
			self.MultiplicationButton = CheckBox(lang.STR_SHOP_MULTIPLY)
			self.MultiplicationButton.SetParent(self.Board)
			self.MultiplicationButton.SetPosition(15,465)
			self.MultiplicationButton.Show()
			self.MakeShopButton = self.comp.Button(self.Board, 'Make Shop', '', 240, 465, self.CreateShop, large1, large2,large3)
			self.shopNameLbl = self.comp.TextLine(self.Board, 'Shop name: ', 15, 440, self.comp.RGB(255, 255, 255))
			self.ShopNameSlotbar, self.ShopNameEditline = self.comp.EditLine(self.Board, '', 80, 440, 241, 15, 25)
			self.maxSlotsLbl = self.comp.TextLine(self.Board, 'Item slots: ', 15, 420, self.comp.RGB(255, 255, 255))
			self.slotsLbl, self.slotsTxt = self.comp.EditLine(self.Board, '40', 80, 420, 20, 15, 5)
			self.slotsTxt.SetNumberMode()
			self.startX = 15
			self.startY = 35
			self.sizeEditLine = 80
			self.stepY = 19
			self.stepX = 170
			self.endY = 400
			self.items_ui = dict()
			self.iniItems = []
			self.ReloadInv()
		def Shopw_UI(self):
			self.Board.Show()
		def ReloadInv(self):
			del self.items_ui
			if os.path.exists(CONFIG_PRICE):
				try:
					if string_contains(ReadConfigPrice("Multiply"), "True") or string_contains(ReadConfigPrice("Multiply"), "1"):
						self.MultiplicationButton.OnToggleDown()  
					else:
						self.MultiplicationButton.OnToggleUp()
					self.ShopNameEditline.SetText(ReadConfigPrice("ShopName"))
					self.slotsTxt.SetText(ReadConfigPrice("ShopSlots"))
					slots = str(self.slotsTxt.GetText())
				except:
					pass
			else:
				try:
					slots = str(self.slotsTxt.GetText())
				except:
					slots = 40
			self.MAX_NUM_SLOT = int(slots)
			self.items_ui = dict()
			self.currX = self.startX
			self.currY = self.startY
			for i in range(0, self.MAX_NUM_SLOT):
				_id = player.GetItemIndex(i)
				if _id == 0:
					continue
				if _id == 50200 or _id == 71221:
					continue
				selectItem(_id)
				item_name = item.GetItemName()
				if _id == 50300:
					sk = player.GetItemMetinSocket(i, 0)
					skill_name = str(skill.GetSkillName(sk))
					item_name = str(skill_name) + " " + item_name
				val = ""
				if os.path.exists(CONFIG_PRICE):
					val = str(ReadConfigPrice("ShopCreatorItemID_" + str(_id)))
				if val == "" or val == "None":
					val = "0"
				# If the item is 50300, allow multiple entries
				if _id == 50300:
					if _id not in self.items_ui:
						self.items_ui[_id] = []
					item_data = dict()
					item_data['items_label'] = self.comp.TextLine(self.Board, item_name, self.currX + self.sizeEditLine + 5, self.currY, self.comp.RGB(0, 229, 650))
					slot, price = self.comp.EditLine(self.Board, val, self.currX, self.currY, self.sizeEditLine, 15, 10)
					item_data['item_price'] = price
					item_data['item_slot'] = slot
					price.SetNumberMode()
					self.items_ui[_id].append(item_data)
				else:
					if _id in self.items_ui:
						continue  # Skip if the item ID already exists
					self.items_ui[_id] = dict()
					self.items_ui[_id]['items_label'] = self.comp.TextLine(self.Board, item_name, self.currX + self.sizeEditLine + 5, self.currY, self.comp.RGB(0, 229, 650))
					slot, price = self.comp.EditLine(self.Board, val, self.currX, self.currY, self.sizeEditLine, 15, 10)
					self.items_ui[_id]['item_price'] = price
					self.items_ui[_id]['item_slot'] = slot
					price.SetNumberMode()
				self.currY += self.stepY
				if self.currY > self.endY:
					self.currY = self.startY
					self.currX += self.stepX
			if self.MAX_NUM_SLOT <= 40:
				self.Board.SetSize(350, 500)
				self.refreshSellingItems.SetPosition(304, 9) 
			else:
				self.Board.SetSize(700, 500)
				self.refreshSellingItems.SetPosition(654, 9)
		# def SaveShopSettings(self):
			# file = open_file(CONFIG_PRICE, 'w+')
			# for item in self.items_ui:
				# file.write("ShopCreatorItemID_" + str(item) + "=%s" % str(self.items_ui[item]['item_price'].GetText()) + "\n")
			# file.write("Multiply=%s" % str(self.MultiplicationButton.checked) + "\n")
			# file.write("ShopName=%s" % str(self.ShopNameEditline.GetText()) + "\n")
			# file.write("ShopSlots=%s" % str(self.slotsTxt.GetText()) + "\n")
			# file.close()
		def SaveShopSettings(self):
			file = open_file(CONFIG_PRICE, 'w+')
			for _id in self.items_ui:
				if _id == 50300:
					for index in range(len(self.items_ui[_id])):
						item_data = self.items_ui[_id][index]
						config_key = "ShopCreatorItemID_" + str(_id) + "_" + str(index)
						file.write(config_key + "=%s" % str(item_data['item_price'].GetText()) + "\n")
				else:
					item_data = self.items_ui[_id]
					config_key = "ShopCreatorItemID_" + str(_id)
					file.write(config_key + "=%s" % str(item_data['item_price'].GetText()) + "\n")
			file.write("Multiply=%s" % str(self.MultiplicationButton.checked) + "\n")
			file.write("ShopName=%s" % str(self.ShopNameEditline.GetText()) + "\n")
			file.write("ShopSlots=%s" % str(self.slotsTxt.GetText()) + "\n")
			file.close()
		def Hide_UI(self):
			self.Board.Hide()
			self.SaveShopSettings()
		def GetItemByID(self, _id):
			for i in range(0,180):
				if player.GetItemIndex(i) == _id:
					return i
			return -1
		def ConvertPrice(self, price_str,item_num=1):
			multiplier = price_str.count("k")	
			yang = float(price_str.replace("k",""))
			yang *= 1000**multiplier
			yang  *= item_num
			wons = int(yang/100000000)
			if(wons > 0):
				rest_yang = int(yang % (wons*100000000))
			else:
				rest_yang = int(yang)
			return (wons,rest_yang)
		def SetItemPrice(self, slot):
			_id = player.GetItemIndex(slot)
			if _id == 0:
				return
			if _id == 50300:
				for item_data in self.items_ui.get(_id, []):
					str_price = item_data['item_price'].GetText()
					if self.MultiplicationButton.checked == 1:
						won, yang = self.ConvertPrice(str_price, player.GetItemCount(slot))
					else:
						won, yang = self.ConvertPrice(str_price, 1)
					if won + yang <= 0.9:
						continue
					shop.AddPrivateShopItemStock(1, slot, slot, yang, won)
					
			else:
				item_data = self.items_ui.get(_id)
				if item_data:
					str_price = item_data['item_price'].GetText()
					if self.MultiplicationButton.checked == 1:
						won, yang = self.ConvertPrice(str_price, player.GetItemCount(slot))
					else:
						won, yang = self.ConvertPrice(str_price, 1)
					if won + yang <= 0.9:
						return
					shop.AddPrivateShopItemStock(1, slot, slot, yang, won)
		def CreateShop(self):
			kashmir = player.GetItemCountByVnum(int(71221))
			if not kashmir:
				if self.GetItemByID(50200) == -1:
					msg("[SHOP CREATOR] |cffFFFF00|H|h" + lang.NO_SHOP_BUNDLE)
					return
			self.iniItems = []
			self.initItems = list(self.items_ui.keys())
			blocked_slots = set()
			if kashmir:
				try:
					randShop = getRandom(2, 8)
					randShopx = 30000 + randShop
					player.SelectShopModel(30000)
					player.MyShopDecoShow(True)
					net.SendMyShopDecoState(True)
					
					randTxt = getRandom(1, 5)
					
					player.SelectShopModel(randShopx)
					net.SendMyShopDecoSet(randTxt, randShopx)
					player.MyShopDecoShow(False)
					net.SendMyShopDecoState(False)
					
					shop.SetNameDialogOpen(True)
					shop.ClearPrivateShopStock()
					shop.SetNameDialogOpen(False)
				except:
					pass
			for i in range(0, self.MAX_NUM_SLOT):
				idx = player.GetItemIndex(i)
				if idx == 50200 or idx == 71221 or idx == 0:
					continue
				if i in blocked_slots:
					continue
				selectItem(idx)
				size = item.GetItemSize()[0]*item.GetItemSize()[1]
				if size >1:
					for ii in range(1,size):
						blocked_slots.add(i+ii*5)
				self.SetItemPrice(i)
			self.SaveShopSettings()
					
					
					
					
			shop.BuildPrivateShop(self.ShopNameEditline.GetText())
else:
	class ShopDialog(ScriptWindow):
		Gui = {}
		def __init__(self):
			if find_string(st_cur_server, "alune") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "next2play"):
				self.Board = ui.BoardWithTitleBar()
			else:
				self.Board = BoardWithTitleBar()
			self.Board.SetTitleName('Shop creator bot')
			self.Board.SetSize(350, 500)
			self.Board.SetPosition(200, 100)
			self.Board.AddFlag(movplable)
			self.Board.SetCloseEvent(self.Hide_UI)
			self.Board.Hide()
			self.comp = Component()
			self.refreshSellingItems = self.comp.Button(self.Board, '', '', 304, 9, self.ReloadInv, refresh1, refresh2, refresh3)
			self.MultiplicationButton = CheckBox(lang.STR_SHOP_MULTIPLY)
			self.MultiplicationButton.SetParent(self.Board)
			self.MultiplicationButton.SetPosition(15,465)
			self.MultiplicationButton.Show()
			self.shopMode2 = CheckBox('Shop mode 2')
			self.shopMode2.SetParent(self.Board)
			self.shopMode2.SetPosition(210,420)
			self.shopMode2.eventDown = self.disableMode1
			self.shopMode2.Show()
			self.shopMode1 = CheckBox('Shop mode 1')
			self.shopMode1.SetParent(self.Board)
			self.shopMode1.SetPosition(120,420)
			self.shopMode1.Show()
			self.shopMode1.eventDown = self.disableMode2
			self.shopMode1.Toggle()
			self.MakeShopButton = self.comp.Button(self.Board, 'Make Shop', '', 240, 465, self.CreateShop, large1, large2,large3)
			self.shopNameLbl = self.comp.TextLine(self.Board, 'Shop name: ', 15, 440, self.comp.RGB(255, 255, 255))
			self.ShopNameSlotbar, self.ShopNameEditline = self.comp.EditLine(self.Board, '', 80, 440, 241, 15, 25)
			self.maxSlotsLbl = self.comp.TextLine(self.Board, 'Item slots: ', 15, 420, self.comp.RGB(255, 255, 255))
			self.slotsLbl, self.slotsTxt = self.comp.EditLine(self.Board, '40', 80, 420, 20, 15, 5)
			self.slotsTxt.SetNumberMode()
			self.startX = 15
			self.startY = 35
			self.sizeEditLine = 80
			self.stepY = 19
			self.stepX = 170
			self.endY = 400
			self.items_ui = dict()
			self.iniItems = []
			self.ReloadInv()
		def Shopw_UI(self):
			self.Board.Show()
		def disableMode1(self):
			self.shopMode1.OnToggleUp()
		def disableMode2(self):
			self.shopMode2.OnToggleUp()
		def ReloadInv(self):
			del self.items_ui
			if os.path.exists(CONFIG_PRICE):
				try:
					if string_contains(ReadConfigPrice("Multiply"), "True") or string_contains(ReadConfigPrice("Multiply"), "1"):
						self.MultiplicationButton.OnToggleDown()  
					else:
						self.MultiplicationButton.OnToggleUp()
					self.ShopNameEditline.SetText(ReadConfigPrice("ShopName"))
					self.slotsTxt.SetText(ReadConfigPrice("ShopSlots"))
					if string_contains(ReadConfigPrice("ShopMode1"), "True") or string_contains(ReadConfigPrice("ShopMode1"), "1"):
						self.shopMode1.OnToggleDown()  
					else:
						self.shopMode1.OnToggleUp()
					if string_contains(ReadConfigPrice("ShopMode2"), "True") or string_contains(ReadConfigPrice("ShopMode2"), "1"):
						self.shopMode2.OnToggleDown()  
					else:
						self.shopMode2.OnToggleUp()
				except:
					pass
			try:
				slots = str(self.slotsTxt.GetText())
			except:
				slots = 40
			self.MAX_NUM_SLOT = int(slots)
			self.items_ui = dict()
			self.currX = self.startX
			self.currY = self.startY
			for i in range(0, self.MAX_NUM_SLOT):
				_id = player.GetItemIndex(i)
				if _id in self.items_ui or _id == 0:
					continue
				selectItem(_id)
				item_name = item.GetItemName()
				if _id == 50300:
					sk = player.GetItemMetinSocket(i,0)
					skill_name = str(skill.GetSkillName(sk))
					item_name = str(skill_name) + " " + item_name
				val = ""
				if os.path.exists(CONFIG_PRICE):
					val = str(ReadConfigPrice("ShopCreatorItemID_" + str(_id)))
				if val == "" or val == "None":
					val = "0"
				self.items_ui[_id] = dict()
				self.items_ui[_id]['items_label'] = self.comp.TextLine(self.Board, item_name, self.currX + self.sizeEditLine + 5, self.currY, self.comp.RGB(0, 229, 650))
				slot,price = self.comp.EditLine(self.Board, val, self.currX, self.currY, self.sizeEditLine, 15,10)
				self.items_ui[_id]['item_price'] = price
				self.items_ui[_id]['item_slot'] = slot
				price.SetNumberMode()
				self.currY += self.stepY
				if(self.currY>self.endY):
					self.currY = self.startY
					self.currX += self.stepX
			if self.MAX_NUM_SLOT <= 40:
				self.Board.SetSize(350, 500)
				self.refreshSellingItems.SetPosition(304, 9) 
			else:
				self.Board.SetSize(700, 500)
				self.refreshSellingItems.SetPosition(654, 9)
		def SaveShopSettings(self):
			file = open_file(CONFIG_PRICE, 'w+')
			for item in self.items_ui:
				file.write("ShopCreatorItemID_" + str(item) + "=%s" % str(self.items_ui[item]['item_price'].GetText()) + "\n")
			file.write("Multiply=%s" % str(self.MultiplicationButton.checked) + "\n")
			file.write("ShopName=%s" % str(self.ShopNameEditline.GetText()) + "\n")
			file.write("ShopSlots=%s" % str(self.slotsTxt.GetText()) + "\n")
			file.write("ShopMode1=%s" % str(self.shopMode1.checked) + "\n")
			file.write("ShopMode2=%s" % str(self.shopMode2.checked) + "\n")
			file.close()
		def Hide_UI(self):
			self.Board.Hide()
			self.SaveShopSettings()
		def GetItemByID(self, _id):
			for i in range(0,180):
				if player.GetItemIndex(i) == _id:
					return i
			return -1
		def SetItemPrice(self,slot):
			_id = player.GetItemIndex(slot)
			if _id == 0:
				return
			str_price = self.items_ui[_id]['item_price'].GetText()
			if self.MultiplicationButton.checked == 1:
				newPrice = int(str_price) * player.GetItemCount(slot)
			else:
				newPrice = int(str_price)
			shop.AddPrivateShopItemStock(player.SLOT_TYPE_INVENTORY, int(slot), int(slot), int(newPrice))
		def CreateShop(self):
			global oldPython
			try:
				self.iniItems = []
				self.initItems = list(self.items_ui.keys())
				# blocked_slots = set()
				if oldPython:
					blocked_slots = []
				else:
					blocked_slots = set()
				for i in range(0, self.MAX_NUM_SLOT):
					idx = player.GetItemIndex(i)
					if idx == 50200 or idx == 71221 or idx == 0:
						continue
					if i in blocked_slots:
						continue
					selectItem(idx)
					size = item.GetItemSize()[0]*item.GetItemSize()[1]
					if size >1:
						for ii in range(1,size):
							blocked_slots.add(i+ii*5)
					self.SetItemPrice(i)
				if self.shopMode1.checked==1:
					shop.BuildPrivateShop(self.ShopNameEditline.GetText(), 0)
				elif self.shopMode2.checked==1:
					shop.BuildPrivateShop(self.ShopNameEditline.GetText(), 1)
				else:
					shop.BuildPrivateShop(self.ShopNameEditline.GetText())
					return
				self.SaveShopSettings()
			except:
				msg("[SHOP CREATOR] |cffFFFF00|H|h" + lang.FAILURE_CREATE_SHOP)
def getItemAttr(slot, val):
	return player.GetItemAttribute(slot, val)
def check_for_needed_values(currentValues, neededValues):
	for i, (bonus_list, threshold) in enumerate(neededValues):
		all_zero = True
		for b in bonus_list:
			if b != 0:
				all_zero = False
				break
		
		if all_zero:
			continue
	
		slot_matched = False
		for j, (val, bon) in enumerate(currentValues):
			for b_id in bonus_list:
				if b_id != 0 and val == b_id and bon >= threshold:
					slot_matched = True
					break
			if slot_matched:
				break
	
		if not slot_matched:
			return False
	
	return True
	
if isGF:
	def _PositionRestoreCallback():
		global fishInstance
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: Returning from NPC.")
		
		fishInstance.startFishing()
	def _PlaceFireCallBack():
		global fishInstance
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: Setting campfire.")
		fishInstance.PlaceFireAndGrillFish()
	
	GOLD_RING = 50002
	GOLD_PIECE = 80008
	GOLD_KEY = 50008
	SILVER_KEY = 50009
	MERMAID_KEY = 50043
	SHRIMP = 27798
	CARPA = 27806
	tempTime = 0
	tempTimeMax = 0
	stopPlayer = False
	
	time_FishingBot_lasttime = 0
	time_FishingBot_lastTimeWaitState = 0
	time_FishingBot_lastTimeFishState = 0
	time_FishingBot_lastTimeImprove = 0
	time_FishingBot_lastTimeFire = 0
	time_NPCInteraction_lastTimeSell = 0
	time_NPCInteraction_lastTimeBuy = 0
	def GetTime():
		return app.GetTime()
	def timeSleep(last_time,sleepTime):
		timer = GetTime()
		if(last_time<timer-sleepTime):
			return(True,timer)
		return(False,last_time)
	class FishingBotDialog(ui.Window):
		STATE_WAITING= 0
		STATE_FISHING= 1
		STATE_GOING_TO_SHOP = 2
		STATE_IMPROVING_ROD = 3
		# STATE_PLACE_FIRE = 4
		
		STATE_WAITING_OPEN_SHOP = 4
		STATE_SELLING = 5
		STATE_BUYING = 6
		STATE_FINISH_SHOPPING = 7
		
		def __init__(self):
			ui.Window.__init__(self)
			self.Show()
			self.catches = {}
			for key in range(27802,27832):
				self.catches[key] = {}
			sadasd = set()
			self.sellItems = set()
			# self.sellItems = {int(i) for i in LoadListFile(ITEMS_TO_SELL)}
			
			for i in LoadListFile(ITEMS_TO_SELL):
				item = int(i)
				sadasd.add(item)
			self.sellItems = sadasd
			
			self.toFryFish = set(self.catches.keys())
			self.toFryFish.update(set(range(27833, 27862)))
			self.deadFish = set(range(27833, 27862))
			self.liveFish = set(range(27803, 27832))
			self.friedFish = set(range(27863, 27892))
			self.catches[GOLD_RING] = {}
			self.catches[70049] = {}
			self.catches[70051] = {}
			self.catches[70050] = {}
			self.catches[70048] = {}
			self.catches[GOLD_KEY] = {}
			self.catches[MERMAID_KEY] = {}
			self.catches[GOLD_PIECE] = {}
			self.catches[SILVER_KEY] = {}
			
			
			self.buyItems_list =list()
			self.sellItems_list =list()
			self.callback = None
			
			
			self.catches[SHRIMP] = {}
			self.campFire = 27600
			self.campFireRace = 12000
			self.fishIds = [key for key in range(27802,27832)]
			self.state = self.STATE_WAITING
			self.minnowID = 27802
			self.wormID = 27801
			self.pasteID = 27800
			self.images = []
			self.hairIDs = [key for key in range(70201,70207)] 
			self.isRodDown = False
			self.startPosition = (0,0)
			self.isMoving = False
			self.currDestinationX = 0
			self.currDestinationY = 0
			self.lastPlayerPos = (0,0)
			self.maxDistanceToDest = 50
			self.BuildWindow()
		def __del__(self):
			ui.Window.__del__(self)
		def BuildWindow(self):
			self.Board = BoardWithTitleBar()
			self.Board.SetSize(390, 530)
			self.Board.SetCenterPosition()
			self.Board.AddFlag(movplable)
			self.Board.AddFlag('float')
			self.Board.SetTitleName('			Fishbot')
			self.Board.SetCloseEvent(self.Close)
			self.Board.Show()
			self.comp = Component()
			btnST1 = 'd:/ymir work/ui/public/large_button_01.sub'
			btnST2 = 'd:/ymir work/ui/public/large_button_02.sub'	
			btnST3 = 'd:/ymir work/ui/public/large_button_03.sub'	
			txt = 'Show FISHBOT'
			self.showFishBtn = self.comp.Button(None, txt, '', 5,250, self.openFish, btnST1, btnST2, btnST3)
			self.showFishBtn.Hide()
			self.settingsLbl = self.comp.TextLine(self.Board, 'Settings: ', 20, 10, self.comp.RGB(255, 255, 255))
			self.saveSettingBtn = self.comp.Button(self.Board, 'Save', '', 60, 8, self.saveGFFishSetting, 'd:/ymir work/ui/public/middle_button_01.sub', 'd:/ymir work/ui/public/middle_button_02.sub','d:/ymir work/ui/public/middle_button_03.sub')
			self.loadSettingBtn = self.comp.Button(self.Board, 'Load', '', 120, 8, self.loadSettings, 'd:/ymir work/ui/public/middle_button_01.sub', 'd:/ymir work/ui/public/middle_button_02.sub','d:/ymir work/ui/public/middle_button_03.sub')
			self.enableButton = self.comp.ToggleButton(self.Board, 'Start', '', 165, 435, (lambda val = False: self.StartStopEvent(val)), (lambda val = True: self.StartStopEvent(val)), middle1, middle2, middle3)
			# self.enableButton = self.comp.OnOffButton(self.Board, '', '', 165, 435, OffUpVisual=eXLib.PATH + 'OpenBot/Images/start_0.tga', OffOverVisual=eXLib.PATH + 'OpenBot/Images/start_1.tga', OffDownVisual=eXLib.PATH + 'OpenBot/Images/start_2.tga',OnUpVisual=eXLib.PATH + 'OpenBot/Images/stop_0.tga', OnOverVisual=eXLib.PATH + 'OpenBot/Images/stop_1.tga', OnDownVisual=eXLib.PATH + 'OpenBot/Images/stop_2.tga',funcState= self.StartStopEvent, defaultValue=False)
			self.waitNum = self.comp.TextLine(self.Board, '100', 330, 347, self.comp.RGB(255, 255, 255))
			self.startStopNum = self.comp.TextLine(self.Board, '100', 330, 387, self.comp.RGB(255, 255, 255))
			self.l2 = self.comp.TextLine(self.Board, 'Wait after fish', 35, 347, self.comp.RGB(255, 255, 255))
			self.val = self.comp.TextLine(self.Board, 'Time fishing', 35, 387, self.comp.RGB(255, 255, 255))
			self.WaitDelaySlider = self.comp.SliderBar(self.Board, 0.6, self.WaitDelay_func, 140, 350)
			self.StartStopDelaySlider = self.comp.SliderBar(self.Board, 0.6, self.StartStopDelay_func, 140, 390)
			self.randomizeTime = self.comp.OnOffButton(self.Board, '', 'Randomize fishing times', 345, 367, funcState=None)
			self.instantBtn = self.comp.OnOffButton(self.Board, '', 'Instant fishing, it will ignore the delay', 345, 387, funcState=self.switch_instant_fish)
			self.instantBtn.Hide()
			item.SelectItem(self.campFire)
			itemIcon = item.GetIconImageFileName()
			# self.campfireBtn = self.comp.OnOffButton(self.Board, '', 'Buy and use campfire', 248, 420, image=itemIcon)
			self.grillFishBtn = self.comp.Button(self.Board, 'Grill Fish', '', 320, 500, self.PlaceFireAndGrillFish, 'd:/ymir work/ui/public/middle_button_01.sub', 'd:/ymir work/ui/public/middle_button_02.sub','d:/ymir work/ui/public/middle_button_03.sub')
			item.SelectItem(70201)
			itemIcon = item.GetIconImageFileName()
			self.hairBtn = self.comp.OnOffButton(self.Board, '', 'Drop', 320, 432, image=itemIcon)
			self.stopPlayerBtn = self.comp.OnOffButton(self.Board, '\t\t\t\t\t\t\t\tStop if player detected', '', 78, 410, funcState=self.stopPlayerFunc)
			item.SelectItem(self.wormID)
			itemIcon = item.GetIconImageFileName()
			self.buyWormsBtn = self.comp.OnOffButton(self.Board, '', 'Go to shop and buy Worms',  65, 430,image=str(itemIcon))
			self.mountHorseBtn = self.comp.OnOffButton(self.Board, '\t\t\t\tMount horse', '', 78, 470, funcState=self.mountHorseFunc)
			item.SelectItem(27590)
			itemIcon = item.GetIconImageFileName()
			self.rodBtn = self.comp.OnOffButton(self.Board, '', 'Level up Rod automatically',  10, 390,image=str(itemIcon),yImgOffset=70,xImgOffset=25)
			self.rodBtn.SetOff()
			self.pauseFishing = CheckBox(lang.PAUSE_FISHBOT)
			self.pauseFishing.SetParent(self.Board)
			self.pauseFishing.SetPosition(10,500)
			self.pauseFishing.Show()
			self.pauseFishing.eventDown   = self.pauseFishInfo
			self.pauseFishLblFor, self.pauseFishFor = self.comp.EditLine(self.Board, '15', 100, 500, 25, 15, 7)
			self.pauseFishLblEach, self.pauseFishEach = self.comp.EditLine(self.Board, '30', 160, 500, 25, 15, 7)
			step_x = 44
			step_y = 60
			min_x = 25
			min_y = 40
			max_x = 370
			current_x = min_x
			current_y = min_y
			for id in self.catches.keys():
				if current_x > max_x:
					current_x = min_x
					current_y += step_y
				item.SelectItem(id)
				itemIcon = item.GetIconImageFileName()
				self.images.append(self.comp.ExpandedImage(self.Board, current_x, current_y, str(itemIcon)))
				if id == self.minnowID or id == SHRIMP:
					self.catches[id]['buttonBait'] = self.comp.OnOffButton(self.Board, '', 'Use as bait', current_x, current_y + 30)
				elif id in self.fishIds:
					self.catches[id]['buttonOpen'] = self.comp.OnOffButton(self.Board, '', 'Kill Fish', current_x, current_y + 30)
				if id == GOLD_RING or id == 70049 or id == 70051 or id == 70050 or id == 70048 or id == GOLD_PIECE or id == GOLD_KEY or id == SILVER_KEY or id == MERMAID_KEY:
					self.catches[id]['buttonSell'] = self.comp.OnOffButton(self.Board, '', 'Sell', current_x, current_y + 30)
				if id != GOLD_RING and id != GOLD_PIECE:
					self.catches[id]['buttonDrop'] = self.comp.OnOffButton(self.Board, '', 'Drop', current_x + 15, current_y + 30)
				current_x += step_x
			self.buyWormsBtn.SetOff()
			self.WaitDelay_func()
			self.StartStopDelay_func()
			self.loadSettings()
		def openFish(self):
			self.showFishBtn.Hide()
			if self.Board.IsShow():
				self.Board.Hide()
			else:
				self.Board.Show()
		def pauseFishInfo(self):
			try:
				foor = int(self.pauseFishFor.GetText())
			except:
				foor = 'x'
			try:
				each = int(self.pauseFishEach.GetText())
			except:
				each = 'y'
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: Checking this box, \x53\x54\x4d\x6f\x64 will pause fishbot for " + str(foor) + " minutes, each " + str(each) + " minutes.")
		def schedule_pause(self):
			global initFishTime, startFishTime
			try:
				forx = int(self.pauseFishFor.GetText())
			except:
				forx = 5 * 60
			pause_duration = forx * 60 
			try:
				interval = int(self.pauseFishEach.GetText())
			except:
				interval = 15 * 60
			pause_interval = interval * 60 
			if self.pauseFishing.checked == 1:
				elapsed_time = app.GetTime() - initFishTime
				if elapsed_time >= pause_interval:
					self.StartStopEvent(False)
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: Stopped bot, restarting in " + str(self.pauseFishFor.GetText()) + " minutes.")
					eventHandler.add(pause_duration, self.resume_fishbot, "resume_fishbot")
					startFishTime = app.GetTime()
		def resume_fishbot(self):
			self.StartStopEvent(True)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: Restarted.")
			self.schedule_pause()
		def loadSettings(self):
			global stopPlayer
			for fish_id in self.catches.keys():
				for fishButtonName in self.catches[fish_id].keys():
					self.catches[fish_id][fishButtonName].SetValue(boolean(ReadConfigFish("FishBot_" + str(fish_id) + "_" + fishButtonName)))
			try:
				self.WaitDelaySlider.SetSliderPos(float(ReadConfigFish("FishBot_WaitDelay")))
			except:
				pass
			try:
				self.StartStopDelaySlider.SetSliderPos(float(ReadConfigFish("FishBot_StartStopDelay")))
			except:
				pass
			try:	
				self.hairBtn.SetValue(boolean(ReadConfigFish("FishBot_HairDyes")))
			except:
				pass
			try:	
				self.buyWormsBtn.SetValue(boolean(ReadConfigFish("FishBot_BuyWorms")))
			except:
				pass
			try:	
				self.rodBtn.SetValue(boolean(ReadConfigFish("FishBot_rodUpgrade")))
			except:
				pass
			try:	
				self.instantBtn.SetValue(boolean(ReadConfigFish("FishBot_instant")))
			except:
				pass
			try:	
				self.randomizeTime.SetValue(boolean(ReadConfigFish("FishBot_randomizeTime")))
			except:
				pass
			# try:	
				# self.campfireBtn.SetValue(boolean(ReadConfigFish("FishBot_campfire")))
			# except:
				# pass
			try:	
				self.stopPlayerBtn.SetValue(boolean(ReadConfigFish("FishBot_StopPlayer")))
			except:
				pass
			try:	
				stopPlayer = (boolean(ReadConfigFish("FishBot_StopPlayer")))
			except:
				pass
			try:	
				self.mountHorseBtn.SetValue(boolean(ReadConfigFish("FishBot_MountHorse")))
			except:
				pass
			try:	
				waitDelay = int(self.WaitDelaySlider.GetSliderPos()*10)
				self.waitNum.SetText(str(waitDelay)+ ' s')
			except:
				pass
			try:
				startStopDelay = float(self.StartStopDelaySlider.GetSliderPos())
				self.startStopNum.SetText(str(int(startStopDelay*10)) + ' s')
			except:
				pass
			try:	
				self.pauseFishFor.SetText(ReadConfigFish("FishBot_PauseFishbotFor"))
			except:
				pass
			try:	
				self.pauseFishEach.SetText(ReadConfigFish("FishBot_PauseFishbotEach"))
			except:
				pass
			try:	
				if string_contains(ReadConfigFish("FishBot_PauseFishing"), "True") or string_contains(ReadConfigFish("FishBot_PauseFishing"), "1"):
					self.pauseFishing.OnToggleDown()
				else:
					self.pauseFishing.OnToggleUp()
			except:
				pass
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: Settings loaded.")
		def isFullInventory(self):
			INV_FULL_MIN_EMPTY = 10
			try:
				MAX_INVENTORY_SIZE = player.GetExtendInvenMax()
			except:
				MAX_INVENTORY_SIZE = 90
			numItems = MAX_INVENTORY_SIZE
			for i in range(0,MAX_INVENTORY_SIZE):
				curr_id = player.GetItemIndex(i)
				if curr_id != 0:
					item.SelectItem(curr_id)
					s = item.GetItemSize()
					numItems-=s[0]*s[1]
			if numItems < INV_FULL_MIN_EMPTY:
				return 1
			else:
				return 0
		def StartStopEvent(self,val):
			global fishbotState,initFishTime
			global time_FishingBot_lasttime, time_FishingBot_lastTimeWaitState, time_FishingBot_lastTimeFishState, time_FishingBot_lastTimeImprove, time_FishingBot_lastTimeFire,time_NPCInteraction_lastTimeSell,time_NPCInteraction_lastTimeBuy
			if not val:
				self.exitFishing()
				# NPCInteraction.StopAction()
				fishbotState = 0
			else:
				self.schedule_pause()
				time_FishingBot_lasttime	= 0
				time_FishingBot_lastTimeWaitState   = 0
				time_FishingBot_lastTimeFishState   = 0
				time_FishingBot_lastTimeImprove	 = 0
				time_FishingBot_lastTimeFire		= 0
				time_NPCInteraction_lastTimeSell		= 0
				time_NPCInteraction_lastTimeBuy		= 0
				
				initFishTime = app.GetTime()
				self.startPosition = player.GetMainCharacterPosition()
				self.startFishing()
				fishbotState = 1
		def modify_setting(self, setting_file, setting_name, new_value):
			file = open_file(setting_file, 'r+')
			lines = file.readlines()
			found = False
			for index, line in enumerate(lines):
				if setting_name in line:
					lines[index] = '%s=%s\n' % (setting_name, new_value)
					found = True
					break
			if not found:
				lines.append('%s=%s\n' % (setting_name, new_value))
			file.seek(0)
			file.writelines(lines)
			file.truncate()
			file.close()
		def saveGFFishSetting(self):
			try:
				if os.path.exists(CONFIG_FISH):
					os.remove(CONFIG_FISH)
				for fish_id in self.catches.keys():
					for fishButtonName in self.catches[fish_id].keys():
						name = "FishBot_" + str(fish_id) + "_" + fishButtonName
						value = self.catches[fish_id][fishButtonName].isOn
						all = name + "=" + str(value) + "\n"
						f = open_file(CONFIG_FISH, 'a')
						lines = [all]
						f.writelines(lines)
						f.close()
				self.modify_setting(CONFIG_FISH, "FishBot_WaitDelay", str(self.WaitDelaySlider.GetSliderPos()))
				self.modify_setting(CONFIG_FISH, "FishBot_StartStopDelay",  str(self.StartStopDelaySlider.GetSliderPos()))
				self.modify_setting(CONFIG_FISH, "FishBot_HairDyes", str(self.hairBtn.isOn))
				self.modify_setting(CONFIG_FISH, "FishBot_BuyWorms", str(self.buyWormsBtn.isOn))
				self.modify_setting(CONFIG_FISH, "FishBot_rodUpgrade", str(self.rodBtn.isOn))
				self.modify_setting(CONFIG_FISH, "FishBot_instant", str(self.instantBtn.isOn))
				self.modify_setting(CONFIG_FISH, "FishBot_randomizeTime", str(self.randomizeTime.isOn))
				self.modify_setting(CONFIG_FISH, "FishBot_StopPlayer", str(self.stopPlayerBtn.isOn))
				self.modify_setting(CONFIG_FISH, "FishBot_MountHorse", str(self.mountHorseBtn.isOn))
				self.modify_setting(CONFIG_FISH, "FishBot_PauseFishbotFor", str(self.pauseFishFor.GetText()))
				self.modify_setting(CONFIG_FISH, "FishBot_PauseFishbotEach", str(self.pauseFishEach.GetText()))
				self.modify_setting(CONFIG_FISH, "FishBot_PauseFishing", str(self.pauseFishing.checked))
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: Settings saved.")
			except:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: Failed saving settings.")
		def isRodAbleToLevelUp(self):
			idx = player.GetItemIndex(2,item.EQUIPMENT_WEAPON)
			if(idx == 0):
				return False	
			item.SelectItem(idx)
			currPoints = player.GetItemMetinSocket(2,item.EQUIPMENT_WEAPON,0)
			maxPoints = item.GetValue(2)
			if currPoints == maxPoints and item.GetItemType() == item.ITEM_TYPE_ROD:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: " + lang.ROD_UPGRADE)
				return True
			return False
		def SetState(self,stateChange):
			self.state = stateChange
			
		def isItemTypeOnSlot(self,_type,invType = 2,slot=item.EQUIPMENT_WEAPON):
			idx = player.GetItemIndex(invType,slot)
			if idx != 0:
				selectItem(idx)
				if item.GetItemType() == _type:
					return True
			return False
		def GetItemByType(self,_id):
			for i in range(player.INVENTORY_PAGE_SIZE * 10):
				curr_id = player.GetItemIndex(i)
				if curr_id == 0:
					continue
				selectItem(curr_id)
				if item.GetItemType() == _id:
					return i
			return -1
			
		def ScanForNPCByRace(self, race):
			o=getCharIndex()
			for i in eXLib.InstancesList:
				if chr.INSTANCE_TYPE_NPC == chr.GetInstanceType(i):
					chr.SelectInstance(i)
					if chr.GetRace() == race:
						return i
			return 0
			
		def InstallQuestWindowHook(self):
			game.GameWindow.OpenQuestWindow = 0
		def UnHookQuestWindow(self):
			global game,OldRecv
			try:
				if not game:
					import game
				game.GameWindow.OpenQuestWindow = OldRecv
			except:
				pass
			
		def upgradeRodFunc(self):
			fisherman_vid = self.ScanForNPCByRace(9009)
			self.InstallQuestWindowHook()
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: " + lang.STR_UPGRADE_ROD1)
			for i in range(player.INVENTORY_PAGE_SIZE*10):
				if player.GetItemIndex(i) >= 27400 and player.GetItemIndex(i) <= 27580:
					net.SendGiveItemPacket(fisherman_vid,player.SLOT_TYPE_INVENTORY,i,player.GetItemCount(i))
			event.SelectAnswer(0, 0)
			event.SelectAnswer(0, 0)
			event.ClearEventSet(1)
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: " + lang.STR_UPGRADE_ROD2)
			create_log("Fishbot: Fishing rod was upgraded succesfully.")
			eventHandler.add(1, self.equipRod)
			create_log("Fishbot: Equiped back the fishing rod.")
			_PositionRestoreCallback()
			self.UnHookQuestWindow()
		def unequipRod(self):
			
			val = self.isItemTypeOnSlot(item.ITEM_TYPE_ROD,2,item.EQUIPMENT_WEAPON)
			if val:
				useItemFunc(item.EQUIPMENT_WEAPON)
				return
		def LevelUpRodGF(self):
			self.SetState(self.STATE_IMPROVING_ROD)
			val = self.isItemTypeOnSlot(item.ITEM_TYPE_ROD,2,item.EQUIPMENT_WEAPON)
			if val:
				self.unequipRod()
				eventHandler.add(1, self.upgradeRodFunc)
			else:
				self.upgradeRodFunc()
			
			
		def GrillFishes(self,vid):
			for i in range(0,90):
				id = player.GetItemIndex(i)
				if id == 0:
					continue
				if id in self.toFryFish and id != CARPA:
					net.SendGiveItemPacket(vid,player.SLOT_TYPE_INVENTORY,i,player.GetItemCount(i))
		def Debug(self):
			onKeyDown(appKey('UP'))
			onKeyUp(appKey('UP'))
			chr.SetLoopMotion(chr.MOTION_WAIT)
			
		def GetSlotItemsToSell(self):
			items = self.sellItems
			slots = set()
			for i in range(0,90):
				item = player.GetItemIndex(i)
				if item != 0 and item in items:
					slots.add(i)
			return slots
			
		def OpenShop(self):
			self.InstallQuestWindowHook()
			vidd = self.ScanForNPCByRace(9009)
			chr.SelectInstance(vidd)
			clickPacket(vidd)
			event.SelectAnswer(0, 1)
			
		def npcInteraction(self, buy_items_list,sell_items_list,callback=None,pos=None):
			self.buyItems_list = list(buy_items_list)
			self.sellItems_list = list(sell_items_list)
			self.callback = callback
			# msg("CALLED npcInteraction with: " + str(buy_items_list) + " | " + str(sell_items_list) + " | " + str(callback) + " | " + str(pos))
		def GoToShop(self):
			self.stopFishing()
			to_sell = set()
			has_worms = False
			has_fire = False
			for i in range(0,90):
				idx = player.GetItemIndex(i)
				if idx != 0:
					if idx in self.catches:
						fishOptions = self.catches[idx]
						if 'buttonSell' in fishOptions.keys() and fishOptions['buttonSell'].isOn:
							to_sell.add(i)
					else:
						if self.wormID == idx:
							has_worms = True
						if self.campFire == idx:
							has_fire = True
			to_sell=to_sell.union(self.GetSlotItemsToSell())
			to_buy = []
			if not has_worms:
				for i in range(0,5):
					to_buy.append(7)
			# if not has_fire and self.campfireBtn.isOn:
				# to_buy.append(1)
			self.isMoving = True
			# msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: Selling slots: "+str(to_sell))
			
			# if self.campfireBtn.isOn:
				# NPCInteraction.RequestBusinessNPCAway(to_buy,to_sell,NPCInteraction.GetFishermanShop(),callback=_PlaceFireCallBack)
			# else:
				# NPCInteraction.RequestBusinessNPCAwayRestorePosition(to_buy,to_sell,NPCInteraction.GetFishermanShop(),callback=_PositionRestoreCallback,pos=self.startPosition)
			self.npcInteraction(to_buy,to_sell,callback=_PositionRestoreCallback,pos=self.startPosition)
			self.SetState(self.STATE_GOING_TO_SHOP)
		def exitFishing(self):
			global tempTime, tempTimeMax
			tempTime = 0
			tempTimeMax = 0	
			self.stopFishing()
			self.SetState(self.STATE_WAITING)
		def startFishing(self):
			self.SetState(self.STATE_WAITING)
		def stopFishing(self):
			global tempTime, tempTimeMax
			tempTime = 0
			tempTimeMax = 0	
			if self.isRodDown:
				eXLib.SendStopFishing(eXLib.UNSUCCESS_FISHING,0)
				self.isRodDown = False
			eXLib.SendStopFishing(eXLib.SUCCESS_FISHING,app.GetRandom(3,10))
			self.Debug()
		def WaitDelay_func(self):
			self.waitDelay = int(self.WaitDelaySlider.GetSliderPos()*10)
			self.waitNum.SetText(str(self.waitDelay)+ ' s')
		def StartStopDelay_func(self):
			self.startStopDelay= float(self.StartStopDelaySlider.GetSliderPos())
			self.startStopNum.SetText(str(int(self.startStopDelay*10)) + ' s')
			
		def GetItemByID(self, _id):
			for i in range(0,180):
				if player.GetItemIndex(i) == _id:
					return i
			return -1
			
		def PlaceFireAndGrillFish(self):
			slot = self.GetItemByID(self.campFire)
			if not slot:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: You need to buy a campfire first.")
				return
			useItemFunc(slot)
			for vid in eXLib.InstancesList:
				chr.SelectInstance(vid)
				race = chr.GetRace()
				if race == self.campFireRace:
					self.GrillFishes(vid)
			
			
			
			
			
			
		def switch_state(self):
			if self.Board.IsShow():
				self.Board.Hide()
			else:
				self.Board.Show()
				
		def isInventoryFull(self):
			INV_FULL_MIN_EMPTY = 10
			MAX_INVENTORY_SIZE = 90
			numItems = MAX_INVENTORY_SIZE
			for i in range(0,MAX_INVENTORY_SIZE):
				curr_id = player.GetItemIndex(i)
				if curr_id != 0:
					item.SelectItem(curr_id)
					s = item.GetItemSize()
					numItems-=s[0]*s[1]
			
			if numItems < INV_FULL_MIN_EMPTY:
				return True
			else:
				return False
				
		def CheckInv(self):
			fishIds = self.catches.keys()
			useBait = False
			dropFish = False
			wormSlot = -1
			pastSlot = -1
			for i in range(0,90):
				id = player.GetItemIndex(i)
				if self.wormID == id:
					wormSlot = i
				if self.pasteID == id:
					pastSlot = i
				if dropFish == False and id in self.hairIDs and self.hairBtn.isOn:
					dropFish = True
					net.SendItemDropPacketNew(i,200)
					continue
				if id in self.liveFish:
					isAliveFish = True
				else:
					isAliveFish = False
				if id in self.deadFish:
					id -=30
					isDeadFish = True
				else:
					isDeadFish = False
				if id in self.friedFish:
					id-=60
					isFryFish = True
				else:
					isFryFish = False
				if id in fishIds:
					fishOptions = self.catches[id]
					if useBait == False and 'buttonBait' in fishOptions.keys() and fishOptions['buttonBait'].isOn and not isDeadFish and not isFryFish:
						useItemFunc(i)
						useBait = True
						continue
					if 'buttonOpen' in fishOptions.keys() and fishOptions['buttonOpen'].isOn and not isDeadFish and not isFryFish:
						useItemFunc(i)
						continue
					if dropFish == False and 'buttonDrop' in fishOptions.keys() and fishOptions['buttonDrop'].isOn:
						dropFish = True
						net.SendItemDropPacketNew(i,player.GetItemCount(i))
						continue
			if self.isInventoryFull():
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: " + lang.FREE_INVENTORY)
				self.GoToShop()
				return False
			val = self.isItemTypeOnSlot(item.ITEM_TYPE_ROD,2,item.EQUIPMENT_WEAPON)
			if val == 0:
				slot = self.GetItemByType(item.ITEM_TYPE_ROD)
				if slot == -1:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: " + lang.NO_FISH_ROD)
					self.exitFishing()
					return False
				else:
					useItemFunc(slot)
					return False
			if self.rodBtn.isOn and self.isRodAbleToLevelUp():
				self.state = self.STATE_IMPROVING_ROD
				return False
			if useBait == False:
				if wormSlot != -1:
					useItemFunc(wormSlot)
					return True
				elif pastSlot != -1:
					useItemFunc(pastSlot)
					return True
				else:
					if self.buyWormsBtn.isOn:
						self.GoToShop()
						return False
					else:
						self.exitFishing()
						msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: " + lang.OUT_OF_BAIT)
						return False
			return True
		def PullRod(self):
			global mountHorse
			if self.enableButton.IsDown():
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: Pulling rod")
				eXLib.SendStopFishing(eXLib.SUCCESS_FISHING,app.GetRandom(3,10))
				if mountHorse:
					net.SendCommandPacket(net.PLAYER_CMD_RIDE)
					net.SendCommandPacket(net.PLAYER_CMD_RIDE)
				time_FishingBot_lastTimeWaitState = GetTime()
				self.SetState(self.STATE_WAITING)
				self.isRodDown = False
				if player.IsMountingHorse():
					net.SendCommandPacket(net.PLAYER_CMD_RIDE)
		def mountHorseFunc(self, arg):
			global mountHorse
			if arg:
				mountHorse = True
			else:
				mountHorse = False
		def stopPlayerFunc(self, arg):
			global stopPlayer
			if arg:
				stopPlayer = True
			else:
				stopPlayer = False
		def switch_instant_fish(self, state_bool):
			if not state_bool:
				eXLib.RecvStartFishCallback(0)
			else:
				eXLib.RecvStartFishCallback(self.PullRod)
		def onKeyDown(self, key):
			player.OnKeyDown(key)
		def IsAnyPlayerHere(self):
			dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'player_whitelist.txt'
			if os.path.exists(dirPl):
				non_detect = open(dirPl, 'r+').read().split()
			else:
				non_detect = open(dirPl, "a")
				non_detect.close()
			o = getCharIndex()
			for i in eXLib.InstancesList:
				a = chr.GetInstanceType(i)
				if a == playerType:
					name=chr.GetNameByVID(i)
					if str(non_detect).find(name) != -1:
						continue
					else:
						if name not in non_detect and name != getcharName() and name != str('None'):
							return True
			return False
		def inside_circle(self, x, y, a, b, r):
			return (x - a) * (x - a) + (y - b) * (y - b) < r * r
		def EndNPCBusiness(self):
			if(self.callback != None):
				self.callback()
				self.callback = None
			net.SendShopEndPacket()
			self.UnHookQuestWindow()
		def OnUpdate(self):
			global tempTime, tempTimeMax, stopPlayer, mountHorse
			global time_FishingBot_lasttime, time_FishingBot_lastTimeWaitState, time_FishingBot_lastTimeFishState, time_FishingBot_lastTimeImprove, time_FishingBot_lastTimeFire,time_NPCInteraction_lastTimeSell,time_NPCInteraction_lastTimeBuy
			val, time_FishingBot_lasttime = timeSleep(time_FishingBot_lasttime,0.1)
			try:
				if stopPlayer == True and self.IsAnyPlayerHere():
					return
				if self.enableButton.IsDown() and isConnect():
					
					waitDelayx = self.WaitDelaySlider.GetSliderPos() * 10
					fishDelayx = self.startStopDelay*10
					if self.randomizeTime.isOn:
						rnd = app.GetRandom(5, 111)
						if app.GetRandom(0, 1) < 0.5:
							sign_x = -1
						else:
							sign_x = 1
						rnd_x = rnd * sign_x / 100.0
						waitFinal = waitDelayx + rnd_x
						fishFinal = fishDelayx + rnd_x
					else:
						waitFinal = waitDelayx
						fishFinal = fishDelayx
					if self.state == self.STATE_WAITING:
						tempTime = app.GetTime() + 7
						try:
							event.SelectAnswer(0,0)
						except:
							pass
						valWaitState, time_FishingBot_lastTimeWaitState = timeSleep(time_FishingBot_lastTimeWaitState,waitFinal)
						if valWaitState:
							if self.CheckInv() == False:
								
								return
							eXLib.SendStartFishing(2)
							msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: " + lang.USE_BAIT_START_F)
							self.SetState(self.STATE_FISHING)
							time_FishingBot_lastTimeFishState = GetTime()
							self.isRodDown = True
							self.isMoving = False
							
					# msg("STATE: " + str(self.state))
							
					if self.state == self.STATE_FISHING:
						timeWaitMax = app.GetTime()
						valFishState, time_FishingBot_lastTimeFishState = timeSleep(time_FishingBot_lastTimeFishState,fishFinal)
						if valFishState and not self.instantBtn.isOn:
							self.PullRod()
						if timeWaitMax >= tempTime:
							time_FishingBot_lasttime	= 0
							time_FishingBot_lastTimeWaitState   = 0
							time_FishingBot_lastTimeFishState   = 0
							time_FishingBot_lastTimeImprove	 = 0
							time_FishingBot_lastTimeFire		= 0
							time_NPCInteraction_lastTimeSell		= 0
							time_NPCInteraction_lastTimeBuy		= 0
							self.SetState(self.STATE_WAITING)
							self.onKeyDown(app.DIK_SPACE)
					if self.state == self.STATE_IMPROVING_ROD:
						val, time_FishingBot_lastTimeImprove = timeSleep(time_FishingBot_lastTimeImprove,0.5)
						if not val:
							return
						self.LevelUpRodGF()
						
					###############################################################################################################################
					if self.state == self.STATE_GOING_TO_SHOP:
	
						if shop.IsOpen():
							self.state = self.STATE_SELLING
							return
						self.OpenShop()
						
			
					if self.state == self.STATE_SELLING:
						val, time_NPCInteraction_lastTimeSell = timeSleep(time_NPCInteraction_lastTimeSell,0.55)
						if val:
							if len(self.sellItems_list) == 0:
								self.state = self.STATE_BUYING
								return
							slot = self.sellItems_list.pop(0)
							net.SendShopSellPacketNew(slot,player.GetItemCount(slot),1)
							msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hFishbot: Sold item from slot: " + str(slot))
						return
			
					if self.state == self.STATE_BUYING:
						val, time_NPCInteraction_lastTimeBuy = timeSleep(time_NPCInteraction_lastTimeBuy,0.55)
						if(val):
							if len(self.buyItems_list) == 0:
								self.state = self.STATE_FINISH_SHOPPING
								return
							slot = self.buyItems_list.pop(0)
							net.SendShopBuyPacket(slot)
						else:
							return
			
					if self.state == self.STATE_FINISH_SHOPPING:
						self.EndNPCBusiness()
						return
						
					###############################################################################################################################
						
			except:
				pass
	
		def Close(self):
			self.Board.Hide()
			self.saveGFFishSetting()
			self.showFishBtn.Show()
class switchbot(ScriptWindow):
	def __init__(self):
		self.fileListBox=None
		self.appendxItemName=XX()
		self.bonusSeaxrch=XX()
		self.keepAttachedBonusListFunc=XX()
		self.startbot67x=XX()
		self.startbotx=XX()
		self.keepChAttachedMapxFunc=XX()
		self.HotkeyRelog2x=XX()
		self.scenarios = {
			'main': {
				'bonus_targets': {
					0: [0],
					1: [0],
					2: [0],
					3: [0],
					4: [0],
					5: [0],
					6: [0]
				},
				'xBonuses': {
					0: 0,
					1: 0,
					2: 0,
					3: 0,
					4: 0,
					5: 0,
					6: 0
				},
			},
			'alt1': {
				'bonus_targets': {
					0: [0],
					1: [0],
					2: [0],
					3: [0],
					4: [0],
					5: [0],
					6: [0]
				},
				'xBonuses': {
					0: 0,
					1: 0,
					2: 0,
					3: 0,
					4: 0,
					5: 0,
					6: 0
				},
			},
			'alt2': {
				'bonus_targets': {
					0: [0],
					1: [0],
					2: [0],
					3: [0],
					4: [0],
					5: [0],
					6: [0]
				},
				'xBonuses': {
					0: 0,
					1: 0,
					2: 0,
					3: 0,
					4: 0,
					5: 0,
					6: 0
				},
			},
			'alt3': {
				'bonus_targets': {
					0: [0],
					1: [0],
					2: [0],
					3: [0],
					4: [0],
					5: [0],
					6: [0]
				},
				'xBonuses': {
					0: 0,
					1: 0,
					2: 0,
					3: 0,
					4: 0,
					5: 0,
					6: 0
				},
			},
			'alt4': {
				'bonus_targets': {
					0: [0],
					1: [0],
					2: [0],
					3: [0],
					4: [0],
					5: [0],
					6: [0]
				},
				'xBonuses': {
					0: 0,
					1: 0,
					2: 0,
					3: 0,
					4: 0,
					5: 0,
					6: 0
				},
			},
		}
		self.current_scenario = 'main'
		self.switchID = 0
		self.itemSlot = 0
		self.itemSlotName = 0
		self.itemSlotVnum = 0
		self.argument = 0
		self.Boniswitchvalue = 71084
		self.Boniswitchvalue2 = 71052
		self.PRESSWISH0 = 0
		self.PRESSWISH1 = 0
		self.PRESSWISH2 = 0
		self.PRESSWISH3 = 0
		self.PRESSWISH4 = 0
		self.PRESSWISH5 = 0
		self.PRESSWISH6 = 0
		self.switching = 0
		self.switchingRare = 0
		ScriptWindow.__init__(self) 
		self.comp = Component()
		if find_string(st_cur_server, "alune") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "next2play"):
			self.Board = ui.BoardWithTitleBar()
		else:
			self.Board = BoardWithTitleBar()
		self.Board.SetTitleName('\x53\x54\x4d\x6f\x64 - Switchbot')
		self.Board.SetSize(331, 600)
		self.Board.SetCenterPosition()
		self.Board.AddFlag(movplable)
		self.Board.AddFlag('float')
		self.Board.SetCloseEvent(lambda: self.hide_switch(1))
		self.Board.Show()
		# try:
			# self.BoardMessage = uiTip.BigBoard()
		# except:
			# pass
		self.minimizeBtn = self.comp.Button(self.Board, '', 'Minimize (Press F9 to show again)', 290, 10, lambda: self.hide_switch(0), ymir + 'ui/public/minimize_button_01.sub', ymir + 'ui/public/minimize_button_02.sub', ymir + 'ui/public/minimize_button_03.sub')
		self.lblItem = self.comp.TextLine(self.Board, lang.SWITCH_SELECTITEM, 15, 39, self.comp.RGB(255, 255, 255))
		self.itemRefineSlot = ExpandedImageBox()
		self.itemRefineSlot.SetParent(self.Board)	
		self.itemRefineSlot.SetPosition(75, 30)
		self.itemRefineSlot.LoadImage(slot_base)
		self.itemRefineSlot.OnMouseLeftButtonUp = lambda: self.select_item_refine()
		self.itemRefineSlot.Show()
		self.itemRefineSlot2 = ExpandedImageBox()
		self.itemRefineSlot2.SetParent(self.Board)	
		self.itemRefineSlot2.SetPosition(75, 62)
		self.itemRefineSlot2.LoadImage(slot_base)
		self.itemRefineSlot2.OnMouseLeftButtonUp = lambda: self.select_item_refine()
		self.itemRefineSlot2.Show()
		self.itemRefineSlot3 = ExpandedImageBox()
		self.itemRefineSlot3.SetParent(self.Board)	
		self.itemRefineSlot3.SetPosition(75, 94)
		self.itemRefineSlot3.LoadImage(slot_base)
		self.itemRefineSlot3.OnMouseLeftButtonUp = lambda: self.select_item_refine()
		self.itemRefineSlot3.Show()
		self.refineIcon = ExpandedImageBox()
		self.refineIcon.SetParent(self.Board)
		self.refineIcon.SetPosition(75,30)
		self.refineIcon.LoadImage(slot_base)
		self.refineIcon.OnMouseLeftButtonUp = lambda: self.select_item_refine()
		self.refineIcon.OnMouseRightButtonDown = lambda: self.delete_item_refine()	
		self.refineIcon.Show()
		self.lblSwitchItem = self.comp.TextLine(self.Board, lang.SWITCH_SWITEM, 137, 39, self.comp.RGB(255, 255, 255))
		self.default = CheckBox(lang.SWITCH_DEFAULTSW)
		self.default.SetParent(self.Board)
		self.default.SetPosition(137,65)
		self.default.eventUp   = self.default_off
		self.default.eventDown = self.default_on
		self.default.Show()
		self.rebuyChangers = CheckBox(lang.SWITCH_AUTOBUYSW)
		self.rebuyChangers.SetParent(self.Board)
		self.rebuyChangers.SetPosition(137,87)
		if not isGF:
			self.rebuyChangers.Show()
			self.rebuyChangers.Toggle()
		self.rebuyRare = CheckBox(lang.SWITCH_BUY67)
		self.rebuyRare.SetParent(self.Board)
		self.rebuyRare.SetPosition(137,109)
		self.rebuyRare.Toggle()
		self.switchSlot = ExpandedImageBox()
		self.switchSlot.SetParent(self.Board)	
		self.switchSlot.SetPosition(211, 30)
		self.switchSlot.LoadImage(slot_base)
		self.switchSlot.OnMouseLeftButtonUp = lambda: self.Set_Switch_Reader_Item()
		self.switchSlot.Show()
		self.switchIcon = ExpandedImageBox()
		self.switchIcon.SetParent(self.Board)
		self.switchIcon.SetPosition(211,30)
		self.switchIcon.LoadImage(slot_base)
		self.switchIcon.OnMouseLeftButtonUp = lambda: self.Set_Switch_Reader_Item()
		self.switchIcon.OnMouseRightButtonDown = lambda: self.Delete_Switch_Reader_Item()	
		self.switchIcon.Show()
		self.pnlBonus = self.comp.ThinBoard(self.Board, False, 15, 180, 305, 270, False)
		self.pnlAlternative = self.comp.ThinBoard(self.Board, False, 15, 140, 305, 40, False)
		self.mainBonus = self.comp.Button(self.pnlAlternative, 'Main', '', 30, 10, self.tabMain, small1, small2, small3)
		try:
			self.mainBonus.ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
		except:
			pass
		self.alt1Bonus = self.comp.Button(self.pnlAlternative, 'Alt. 1', '', 80, 10, self.tabAlt1, small1, small2, small3)
		self.alt2Bonus = self.comp.Button(self.pnlAlternative, 'Alt. 2', '', 130, 10, self.tabAlt2, small1, small2, small3)
		self.alt3Bonus = self.comp.Button(self.pnlAlternative, 'Alt. 3', '', 180, 10, self.tabAlt3, small1, small2, small3)
		self.alt4Bonus = self.comp.Button(self.pnlAlternative, 'Alt. 4', '', 230, 10, self.tabAlt4, small1, small2, small3)
		self.bonus1 = self.comp.TextLine(self.pnlBonus, lang.SWITCH_BONUS + ' #1:', 15, 20, self.comp.RGB(255, 255, 255))
		self.bonus1Txt, self.bonus1Val = self.comp.EditLine(self.pnlBonus, '0', 215, 20, 28, 15, 5)
		self.bonus1Sel = self.comp.Button(self.pnlBonus, lang.SWITCH_SELECT, '', 248, 20, self.__Wish_1_Option, small1, small2, small3)
		self.Bonus1Attr = self.comp.TextLine(self.pnlBonus, lang.SWITCH_NONE, 85, 20, self.comp.RGB(155, 255, 255))
		self.b1Reset = self.comp.Button(self.pnlBonus, ' ', lang.SWITCH_RBONUS + ' #1', 65, 20, self.reset1, minus1, minus2, minus3)
		self.bonus2 = self.comp.TextLine(self.pnlBonus, lang.SWITCH_BONUS + ' #2:', 15, 50, self.comp.RGB(255, 255, 255))
		self.bonus2Txt, self.bonus2Val = self.comp.EditLine(self.pnlBonus, '0', 215, 50, 28, 15, 5)
		self.bonus2Sel = self.comp.Button(self.pnlBonus, lang.SWITCH_SELECT, '', 248, 50, self.__Wish_2_Option, small1, small2, small3)
		self.Bonus2Attr = self.comp.TextLine(self.pnlBonus, lang.SWITCH_NONE, 85, 50, self.comp.RGB(155, 255, 255))
		self.b2Reset = self.comp.Button(self.pnlBonus, ' ', lang.SWITCH_RBONUS + ' #2', 65, 50, self.reset2, minus1, minus2, minus3)
		self.bonus3 = self.comp.TextLine(self.pnlBonus, lang.SWITCH_BONUS + ' #3:', 15, 80, self.comp.RGB(255, 255, 255))
		self.bonus3Txt, self.bonus3Val = self.comp.EditLine(self.pnlBonus, '0', 215, 80, 28, 15, 5)
		self.bonus3Sel = self.comp.Button(self.pnlBonus, lang.SWITCH_SELECT, '', 248, 80, self.__Wish_3_Option, small1, small2, small3)
		self.Bonus3Attr = self.comp.TextLine(self.pnlBonus, lang.SWITCH_NONE, 85, 80, self.comp.RGB(155, 255, 255))
		self.b3Reset = self.comp.Button(self.pnlBonus, ' ', lang.SWITCH_RBONUS + ' #3', 65, 80, self.reset3, minus1, minus2, minus3)
		self.bonus4 = self.comp.TextLine(self.pnlBonus, lang.SWITCH_BONUS + ' #4:', 15, 110, self.comp.RGB(255, 255, 255))
		self.bonus4Txt, self.bonus4Val = self.comp.EditLine(self.pnlBonus, '0', 215, 110, 28, 15, 5)
		self.bonus4Sel = self.comp.Button(self.pnlBonus, lang.SWITCH_SELECT, '', 248, 110, self.__Wish_4_Option, small1, small2, small3)
		self.Bonus4Attr = self.comp.TextLine(self.pnlBonus, lang.SWITCH_NONE, 85, 110, self.comp.RGB(155, 255, 255))
		self.b4Reset = self.comp.Button(self.pnlBonus, ' ', lang.SWITCH_RBONUS + ' #4', 65, 110, self.reset4, minus1, minus2, minus3)
		self.bonus5 = self.comp.TextLine(self.pnlBonus, lang.SWITCH_BONUS + ' #5:', 15, 140, self.comp.RGB(255, 255, 255))
		self.bonus5Txt, self.bonus5Val = self.comp.EditLine(self.pnlBonus, '0', 215, 140, 28, 15, 5)
		self.bonus5Sel = self.comp.Button(self.pnlBonus, lang.SWITCH_SELECT, '', 248, 140, self.__Wish_5_Option, small1, small2, small3)
		self.Bonus5Attr = self.comp.TextLine(self.pnlBonus, lang.SWITCH_NONE, 85, 140, self.comp.RGB(155, 255, 255))
		self.b5Reset = self.comp.Button(self.pnlBonus, ' ', lang.SWITCH_RBONUS + ' #5', 65, 140, self.reset5, minus1, minus2, minus3)
		self.rareBonus = CheckBox(lang.SWITCH_ENABLE67)
		self.rareBonus.SetParent(self.pnlBonus)
		self.rareBonus.SetPosition(13,170)
		if not isGF:
			self.rareBonus.eventUp   = self.disable67
			self.rareBonus.eventDown = self.enable67
			self.rareBonus.Show()
		self.bonus6 = self.comp.TextLine(self.pnlBonus, lang.SWITCH_BONUS + ' #6:', 15, 200, self.comp.RGB(255, 255, 255))
		self.bonus6Txt, self.bonus6Val = self.comp.EditLine(self.pnlBonus, '0', 215, 200, 28, 15, 5)
		self.bonus6Sel = self.comp.Button(self.pnlBonus, lang.SWITCH_SELECT, '', 248, 200, self.__Wish_6_Option, small1, small2, small3)
		self.Bonus6Attr = self.comp.TextLine(self.pnlBonus, lang.SWITCH_NONE, 85, 200, self.comp.RGB(155, 255, 255))
		self.b6Reset = self.comp.Button(self.pnlBonus, ' ', lang.SWITCH_RBONUS + ' #6', 65, 200, self.reset6, minus1, minus2, minus3)
		self.bonus7 = self.comp.TextLine(self.pnlBonus, lang.SWITCH_BONUS + ' #7:', 15, 230, self.comp.RGB(255, 255, 255))
		self.bonus7Txt, self.bonus7Val = self.comp.EditLine(self.pnlBonus, '0', 215, 230, 28, 15, 5)
		self.bonus7Sel = self.comp.Button(self.pnlBonus, lang.SWITCH_SELECT, '', 248, 230, self.__Wish_7_Option, small1, small2, small3)
		self.Bonus7Attr = self.comp.TextLine(self.pnlBonus, lang.SWITCH_NONE, 85, 230, self.comp.RGB(155, 255, 255))
		self.b7Reset = self.comp.Button(self.pnlBonus, ' ', lang.SWITCH_RBONUS + ' #7', 65, 230, self.reset7, minus1, minus2, minus3)
		self.bonus1Val.SetNumberMode()
		self.bonus2Val.SetNumberMode()
		self.bonus3Val.SetNumberMode()
		self.bonus4Val.SetNumberMode()
		self.bonus5Val.SetNumberMode()
		self.bonus6Val.SetNumberMode()
		self.bonus7Val.SetNumberMode()
		self.rebuyRare.Hide()
		self.bonus6.Hide()
		self.bonus6Val.Hide()
		self.bonus6Txt.Hide()
		self.bonus6Sel.Hide()
		self.Bonus6Attr.Hide()
		self.bonus7.Hide()
		self.bonus7Txt.Hide()
		self.bonus7Val.Hide()
		self.bonus7Sel.Hide()
		self.Bonus7Attr.Hide()
		self.b6Reset.Hide()
		self.b7Reset.Hide()
		self.lblNpc = self.comp.TextLine(self.Board, lang.SWITCH_NPCVNUM, 15, 460, self.comp.RGB(255, 255, 255))
		self.npcBtn = self.comp.Button(self.Board, lang.STR_GETFISHER_VNUM, '',217, 458, self.getVnum, middle1, middle2, middle3)
		self.npcTxt, self.npcVal = self.comp.EditLine(self.Board, '9003', 175, 460, 40, 15, 8)
		self.npcVal.SetNumberMode()
		self.npcHelp = self.comp.Button(self.Board, '', 'NPC VNUM info', 277, 460, self.npcHelpFunc, qmark1, qmark2, qmark1)
		self.lblQuest = self.comp.TextLine(self.Board, lang.SWITCH_QINDEX, 15, 480, self.comp.RGB(255, 255, 255))
		self.questTxt, self.questVal = self.comp.EditLine(self.Board, '0', 220, 480, 25, 15, 1)
		self.questVal.SetNumberMode()
		self.questHelp = self.comp.Button(self.Board, '', 'Quest info', 277, 480, self.questInfo, qmark1, qmark2, qmark1)
		self.StartButton = self.comp.Button(self.Board, 'Start 1/5', '', 138, 500, self.startBot, middle1, middle2, middle3)
		self.StopButton = self.comp.Button(self.Board, 'Stop 1/5', '', 138, 500, self.stopBot, middle1, middle2, middle3)
		self.StartButton67 = self.comp.Button(self.Board, 'Start 6/7', '', 165, 500, self.start67, middle1, middle2, middle3)
		self.StopButton67 = self.comp.Button(self.Board, 'Stop 6/7', '', 165, 500, self.stop67, middle1, middle2, middle3)
		self.resetBonus = self.comp.Button(self.Board, lang.SWITCH_RESETALL, '', 125, 530, self.ResetBonus, large1, large2, large3)
		self.delayLbl = self.comp.TextLine(self.Board, lang.SWITCH_DELAY, 82, 570, self.comp.RGB(255, 255, 255))
		self.minusDelay = self.comp.Button(self.Board, ' ', lang.SWITCH_DELAYDEC, 160, 570, self.minus, minus1, minus2, minus3)
		self.delayTxt, self.delayVal = self.comp.EditLine(self.Board, '0.35', 177, 568, 28, 15, 5)
		
		try:
			self.delayVal.OnIMEUpdate = lambda: self.numbersAndDotOnly(self.delayVal)
		except:
			pass
		
		self.plusDelay = self.comp.Button(self.Board, ' ', lang.SWITCH_DELAYINC, 211, 570, self.plus, plus1, plus2, plus3)
		if find_string(st_cur_server, "LandOfHeroes"):
			btnST1 = large1
			btnST2 = large2	
			btnST3 = large3	
			txt = 'Show Switchbot'
		else:
			txt = ''
			if os.path.exists(CONFIG_FOLDER):
				btnST1 = CONFIG_FOLDER + '71084.tga'
				btnST2 = CONFIG_FOLDER + '71084.tga'
				btnST3 = CONFIG_FOLDER + '71084.tga'
			else:
				btnST1 = st_path + '/Data/rascal2/71084.tga'
				btnST2 = st_path + '/Data/rascal2/71084.tga'
				btnST3 = st_path + '/Data/rascal2/71084.tga'
		self.hide_show = self.comp.Button(None, txt, '', 30,330, self.open_switch, btnST1, btnST2, btnST3)
		self.hide_show.Hide()
		if self.rareBonus.checked==0:
			self.StartButton67.Hide()
			self.StopButton67.Hide()
		self.StopButton.Hide()
		self.StopButton67.Hide()
		if find_string(st_cur_server, "alune") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "next2play"):
			self.bonusList = ui.BoardWithTitleBar()
		else:
			self.bonusList = BoardWithTitleBar()
		self.bonusList.SetCloseEvent(self.closeBonusList)
		self.bonusList.SetTitleName(lang.SWITCH_BONUS + ' List')
		self.bonusList.SetSize(220, 315)
		self.bonusList.SetPosition(150 + 330 +10, 200)
		self.bonusList.AddFlag(movplable)
		self.bonusList.AddFlag('float')
		self.bonusList.Hide()
		self.SelectBonus = self.comp.Button(self.bonusList, lang.STR_ADD, '', 79, 285, self.SetBonis, middle1, middle2, middle3)
		self.settingsBtn = self.comp.Button(self.Board, 'Settings', '', 282, 572, self.showSwitchbotSettings, small1, small2, small3)
		if find_string(st_cur_server, "alune") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "next2play"):
			self.settingsWindow = ui.BoardWithTitleBar()
		else:
			self.settingsWindow = BoardWithTitleBar()
		self.settingsWindow.SetCloseEvent(self.closeSettingsList)
		self.settingsWindow.SetTitleName('Settings')
		self.settingsWindow.SetSize(220, 285)
		self.settingsWindow.SetPosition(150 + 330 +10, 200)
		self.settingsWindow.AddFlag(movplable)
		self.settingsWindow.AddFlag('float')
		self.settingsWindow.Hide()
		self.lblSettingName = self.comp.TextLine(self.settingsWindow, 'Setting name:', 10,36, self.comp.RGB(255,255,255))
		self.txtSettingName, self.settingName = self.comp.EditLine(self.settingsWindow, '', 75, 36, 83, 15, 55)
		self.settingsBtnOk = self.comp.Button(self.settingsWindow, 'OK', '', 166, 35, self.addSetting, small1, small2, small3)
		self.settingsListBar, self.settingsList, self.settingsListScroll = self.comp.ListBoxEx2(self.settingsWindow, 15, 60, 170, 175)
		self.settingsList.SetViewItemCount(9)
		self.refSettingButton = self.comp.Button(self.settingsWindow, '', '', 91, 245, self.updateList, refresh1, refresh2, refresh3)
		self.loadSettingButton = self.comp.Button(self.settingsWindow, 'Load', '', 118, 245, self.loadSetting, small1, small2, small3)
		self.deleteSettingButton = self.comp.Button(self.settingsWindow, 'Delete', '', 165, 245, self.deleteSetting, small1, small2, small3)
		self.bonusListBar, self.fileListBox, self.bonusListScroll = self.comp.ListBoxEx2(self.bonusList, 15, 80, 170, 175)
		self.fileListBox.SetViewItemCount(9)
		self.searchBonusTxt = self.comp.TextLine(self.bonusList, 'Search bonus:', 79, 33, self.comp.RGB(255, 255, 255))
		self.searchBonusBtn = self.comp.Button(self.bonusList, lang.STR_SEARCH_BTN, '', 167, 48, self.searchBonus, small1, small2, small3)
		self.searchBonusNameLbl, self.searchBonusName = self.comp.EditLine(self.bonusList, '', 15, 50, 140, 15, 20)
		try:
			self.searchBonusName.OnIMEUpdate = self.searchBonus
		except:
			pass
		self.updateList()
		self.HotkeyRelogSwitch()
	def storeUIToScenario(self, scenario_name):
		scenario_data = self.scenarios[scenario_name]
		bonus_targets = scenario_data['bonus_targets']
		xBonuses = scenario_data['xBonuses']
		for i in range(7):
			threshold = self.get_threshold_for_slot(i)
			xBonuses[i] = threshold
	def loadScenarioIntoUI(self, scenario_name):
		scenario_data = self.scenarios[scenario_name]
		bonus_targets = scenario_data['bonus_targets']
		xBonuses = scenario_data['xBonuses']
	
		for i in range(7):
			threshold = xBonuses[i]
			val_edit = getattr(self, "bonus%dVal" % (i+1))
			val_edit.SetText(str(threshold))
	
			attr_label = getattr(self, "Bonus%dAttr" % (i+1))
			if bonus_targets[i][0] == 0:
				attr_label.SetText(lang.SWITCH_NONE)
			else:
				bonus_id = bonus_targets[i][0]
				if bonus_id in LoadBonuses:
					attr_label.SetText(LoadBonuses[bonus_id])
				else:
					attr_label.SetText("Unknown bonus")
	def get_threshold_for_slot(self, slot_idx):
		val_edit = getattr(self, "bonus%dVal" % (slot_idx+1))
		threshold_str = val_edit.GetText().strip()
	
		if threshold_str == '':
			threshold = 0
		else:
			threshold = int(threshold_str)
	
		return threshold
	def tabMain(self):
		self.storeUIToScenario(self.current_scenario)
		self.current_scenario = 'main'
		try:
			self.mainBonus.ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
			self.alt1Bonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.alt2Bonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.alt3Bonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.alt4Bonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		except:
			pass
		self.loadScenarioIntoUI(self.current_scenario)
	
	def tabAlt1(self):
		self.storeUIToScenario(self.current_scenario)
		self.current_scenario = 'alt1'
		try:
			self.mainBonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.alt1Bonus.ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
			self.alt2Bonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.alt3Bonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.alt4Bonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		except:
			pass
		self.loadScenarioIntoUI(self.current_scenario)
	
	def tabAlt2(self):
		self.storeUIToScenario(self.current_scenario)
		self.current_scenario = 'alt2'
		try:
			self.mainBonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.alt1Bonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.alt2Bonus.ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
			self.alt3Bonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.alt4Bonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		except:
			pass
		self.loadScenarioIntoUI(self.current_scenario)
	
	def tabAlt3(self):
		self.storeUIToScenario(self.current_scenario)
		self.current_scenario = 'alt3'
		try:
			self.mainBonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.alt1Bonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.alt2Bonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.alt3Bonus.ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
			self.alt4Bonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
		except:
			pass
		self.loadScenarioIntoUI(self.current_scenario)
	
	def tabAlt4(self):
		self.storeUIToScenario(self.current_scenario)
		self.current_scenario = 'alt4'
		try:
			self.mainBonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.alt1Bonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.alt2Bonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.alt3Bonus.ButtonText.SetFontColor(*self.comp.RGB(200,200,200))
			self.alt4Bonus.ButtonText.SetFontColor(*self.comp.RGB(73, 235, 52))
		except:
			pass
		self.loadScenarioIntoUI(self.current_scenario)
	
	def loadScenarioIntoUI(self, scenario):
		scenario_data = self.scenarios[scenario]
		self.setUIBonus(scenario_data['bonus_targets'][0][0], scenario_data['xBonuses'][0], self.Bonus1Attr, self.bonus1Val)
		self.setUIBonus(scenario_data['bonus_targets'][1][0], scenario_data['xBonuses'][1], self.Bonus2Attr, self.bonus2Val)
		self.setUIBonus(scenario_data['bonus_targets'][2][0], scenario_data['xBonuses'][2], self.Bonus3Attr, self.bonus3Val)
		self.setUIBonus(scenario_data['bonus_targets'][3][0], scenario_data['xBonuses'][3], self.Bonus4Attr, self.bonus4Val)
		self.setUIBonus(scenario_data['bonus_targets'][4][0], scenario_data['xBonuses'][4], self.Bonus5Attr, self.bonus5Val)
		self.setUIBonus(scenario_data['bonus_targets'][5][0], scenario_data['xBonuses'][5], self.Bonus6Attr, self.bonus6Val)
		self.setUIBonus(scenario_data['bonus_targets'][6][0], scenario_data['xBonuses'][6], self.Bonus7Attr, self.bonus7Val)
	
	def setUIBonus(self, bonus_id, xval, attr_label, val_edit):
		global LoadBonuses
		if bonus_id == 0:
			attr_label.SetText(lang.SWITCH_NONE)
		else:
			if bonus_id in LoadBonuses:
				attr_label.SetText(LoadBonuses[bonus_id])
			else:
				attr_label.SetText("Unknown bonus")
		val_edit.SetText(str(xval))
	def searchBonus(self):
		if isGF:
			try:
				ui.EditLine.OnIMEUpdate(self.searchBonusName)
			except:
				pass
		else:
			try:
				EditLine.OnIMEUpdate(self.searchBonusName)
			except:
				pass
		SearchName = str(self.searchBonusName.GetText()).lower()  
		SelectedIndex = self.fileListBox.GetSelectedItem()
		self.__RefreshFileList()
		for line in BonusListe:
			if str(line).lower().find(SearchName) != -1:  
				self.fileListBox.AppendItem(Item(line))
		# self.searchBonusName.SetText('')
	def displayBonusNames(self):
		global LoadBonuses
		bonuses = [self.bonus_targets[i][0] for i in range(7)]
		bonus_names = {}
		for i, bonus in enumerate(bonuses):
			bonus_key = 'Bonus%d' % i
			if bonus == 0:
				bonus_names[bonus_key] = lang.SWITCH_NONE
			elif bonus in LoadBonuses:
				bonus_names[bonus_key] = LoadBonuses[bonus]
			else:
				bonus_names[bonus_key] = "Unknown bonus"
		return bonus_names
	def closeSwitchbot(self):
		self.stop67() 
		self.stopBot()
		self.Board.Hide()
	def deleteSetting(self):
		name = self.settingsList.GetSelectedItem()
		if name == None:
			msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.INVALID_SETTING)
			return
		name = name.GetText()
		if os.path.exists(st_path + "/Data/rascal2/" + str(name) + ".switchbot_setting"):
			try:
				os.remove(st_path + "/Data/rascal2/" + str(name) + ".switchbot_setting")
				self.updateList()
				msg("[SWITCHBOT] |cffFFFF00|H|hSuccesfully removed '" + str(name) + "' switchbot setting.")
			except:
				msg("[SWITCHBOT] |cffFFFF00|H|hAn error occurred while trying to remove '" + str(name) + "' switchbot setting.")
		else:
			msg("[SWITCHBOT] |cffFFFF00|H|hSetting with name '" + str(name) + "' doesn't exists.")
	def updateList(self):
		try:
			try:
				self.settingsList.RemoveAllItems()
			except:
				pass
			fullDir = st_path + "/Data/rascal2/"
			files = os.listdir(fullDir)
			log_files_without_extension = []
			for f in files:
				if f.endswith('.switchbot_setting') and f != '.switchbot_setting':
					log_files_without_extension.append(f[:-18])
			for x in log_files_without_extension:
				self.settingsList.AppendItem(Item(x))
		except:
			pass
	def addSetting(self):
		orange = "|cFFFF8040|H|h"
		yellow = "|cffFFFF00|H|h"
		name = self.settingName.GetText()
		name = name.replace("/", "_")
		name = name.replace("\\", "_")
		dirPl = st_path + "/Data/rascal2/" + str(name) + ".switchbot_setting"
	
		if self.settingName.GetText() == "":
			msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.INVALID_SETTING_NAME)
			return
		self.storeUIToScenario(self.current_scenario)
		scenarios_order = ['main','alt1','alt2','alt3','alt4']
	
		try:
			if not os.path.exists(dirPl):
				non_detect = open_file(dirPl, "w")
				non_detect.close()
	
			non_detect = open_file(dirPl, "w")
	
			for scenario_name in scenarios_order:
				scenario_data = self.scenarios[scenario_name]
				bonus_targets = scenario_data['bonus_targets']
				xBonuses = scenario_data['xBonuses']
				non_detect.write(scenario_name + "\n")
				for i in range(7):
					b = bonus_targets[i][0]
					x = xBonuses[i]
					non_detect.write("%d|%d\n" % (b, x))
	
			non_detect.close()
	
			self.settingName.SetText("")
			msg("[SWITCHBOT] |cffFFFF00|H|hSuccessfully created " + orange + str(name) + yellow + " switchbot setting.")
			self.updateList()
		except:
			msg("[SWITCHBOT] |cffFFFF00|H|hAn error occurred while trying to create '" + str(name) + "' switchbot setting.")
	
	
	def loadSetting(self):
		name = self.settingsList.GetSelectedItem()
		if name == None:
			msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.INVALID_SETTING)
			return
		name = name.GetText()
		dirPl = st_path + "/Data/rascal2/" + str(name) + ".switchbot_setting"
		try:
			if os.path.exists(dirPl):
				setting_file = open_file(dirPl, "r+")
				lines = setting_file.readlines()
				setting_file.close()
	
				line_count = len(lines)
				if line_count == 7:
					scenario_data = self.scenarios['main']
					bonus_targets = scenario_data['bonus_targets']
					xBonuses = scenario_data['xBonuses']
	
					for i in range(7):
						b, x = map(int, lines[i].strip().split('|'))
						bonus_targets[i] = [b]
						xBonuses[i] = x
					self.loadScenarioIntoUI('main')
					msg("[SWITCHBOT] |cffFFFF00|H|hSuccessfully loaded '" + str(name) + "' switchbot setting.")
	
				elif line_count == 40:
					scenarios_order = ['main','alt1','alt2','alt3','alt4']
					line_index = 0
	
					for scenario_name in scenarios_order:
						scenario_line = lines[line_index].strip()
						line_index += 1
						scenario_data = self.scenarios[scenario_name]
	
						bonus_targets = scenario_data['bonus_targets']
						xBonuses = scenario_data['xBonuses']
	
						for i in range(7):
							data_line = lines[line_index].strip()
							line_index += 1
							b, x = map(int, data_line.split('|'))
							bonus_targets[i] = [b]
							xBonuses[i] = x
	
					self.loadScenarioIntoUI('main')
					msg("[SWITCHBOT] |cffFFFF00|H|hSuccessfully loaded '" + str(name) + "' switchbot setting.")
				
				else:
					msg("[SWITCHBOT] |cffFFFF00|H|hUnknown setting format. Expected 7 or 40 lines, got " + str(line_count))
					self.closeSettingsList()
					return
	
				self.updateList()
				self.closeSettingsList()
			else:
				msg("[SWITCHBOT] |cffFFFF00|H|hSetting file does not exist.")
		except:
			self.closeSettingsList()
			msg("[SWITCHBOT] |cffFFFF00|H|hAn error occurred while trying to load '" + str(name) + "' switchbot setting.")
	def showSwitchbotSettings(self):
		pos = self.Board.GetGlobalPosition()
		self.settingsWindow.SetPosition(pos[0] + (self.Board.GetWidth() - self.Board.GetWidth() - self.settingsWindow.GetWidth()),pos[1])
		if self.settingsWindow.IsShow():
			self.settingsWindow.Hide()
			self.keepChAttachedMapFuncOff()
		else:
			self.settingsWindow.Show()
			self.keepChAttachedMapFuncFuncOn()
	def keepChAttachedMapFuncOff(self):
		self.keepChAttachedMapxFunc.XX1(9999999)
		self.keepChAttachedMapxFunc.XX2(self.keepChAttachedMapFuncOff)
	def keepChAttachedMapFuncFuncOn(self):
		try:
			self.keepChAttachedMapxFunc.XX1(0.01)
			self.keepChAttachedMapxFunc.XX2(self.keepChAttachedMapFuncFuncOn)
			if self.Board.IsShow():
				pos = self.Board.GetGlobalPosition()
				self.settingsWindow.SetPosition(pos[0] + (self.Board.GetWidth() - self.Board.GetWidth() - self.settingsWindow.GetWidth()),pos[1])
			else:
				self.keepChAttachedMapFuncOff()
		except:
			self.keepChAttachedMapFuncOff()
	def keepBonusListOff(self):
		self.keepAttachedBonusListFunc.XX1(9999999)
		self.keepAttachedBonusListFunc.XX2(self.keepBonusListOff)
	def keepBonusListOn(self):
		try:
			self.keepAttachedBonusListFunc.XX1(0.01)
			self.keepAttachedBonusListFunc.XX2(self.keepBonusListOn)
			if self.Board.IsShow():
				pos = self.Board.GetGlobalPosition()
				self.bonusList.SetPosition(pos[0]+self.Board.GetWidth(),pos[1])
			else:
				self.keepBonusListOff()
		except:
			self.keepBonusListOff()
	def UpdateFileList(self):
		self.__RefreshFileList()
		for BonusType in BonusListe:
			if BonusType == "":
				self.fileListBox.AppendItem(Item("Remove"))
			elif BonusType != "":
				self.fileListBox.AppendItem(Item(BonusType))
	def __RefreshFileList(self):
		try:
			self.fileListBox.RemoveAllItems()
		except:
			pass
	def HotkeyRelogStop(self):
		self.HotkeyRelog2x.XX1(99999999999)
		self.HotkeyRelog2x.XX2(self.HotkeyRelogStop)
	# def HotkeyRelogSwitch(self):
		# self.HotkeyRelog2x.XX1(0.01)
		# self.HotkeyRelog2x.XX2(self.HotkeyRelogSwitch)
		# if isKeyPress('F9'):
			# if self.Board.IsShow():
				# self.Board.Hide()
				# self.hide_show.Show()
			# else:
				# self.Board.Show()
				# self.hide_show.Hide()
	def HotkeyRelogSwitch(self):
		global switchbot_instances
		self.HotkeyRelog2x.XX1(0.01)
		self.HotkeyRelog2x.XX2(self.HotkeyRelogSwitch)
	
		if isKeyPress('F9'):
			for bot in switchbot_instances:
				if bot.Board.IsShow():
					bot.Board.Hide()
					bot.hide_show.Show()
				else:
					bot.Board.Show()
					bot.hide_show.Hide()
	
	def closeSettingsList(self):
		self.settingsWindow.Hide()		
		self.keepChAttachedMapFuncOff()
	def closeBonusList(self):
		self.bonusList.Hide()
	def set_bonus_attr_value(self, bonus_number, selected_bonus_value):
		bonus_attr = getattr(self, "Bonus%dAttr" % (bonus_number+1))
		bonus_val = getattr(self, "bonus%dVal" % (bonus_number+1))
		bonus_attr.SetText(str(self.selected_bonus))
		bonus_val.SetText(str(selected_bonus_value))
	def showBonuses(self, arg):
		self.argument = arg
		self.bonusList.Show()
		self.keepBonusListOn()
		self.UpdateFileList()
	def SetBonis(self):
		global BonusIDListe, LoadBonuses
		
		selected_item = self.fileListBox.GetSelectedItem()
		if not selected_item:
			msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.NO_BONUS_SEL)
			self.closeBonusList()
			return
	
		self.selected_bonus = selected_item.GetText()
		scenario_data = self.scenarios[self.current_scenario]
		bonus_targets = scenario_data['bonus_targets']
		xBonuses = scenario_data['xBonuses']
		def get_threshold_for_slot(slot_idx):
			val_edit = getattr(self, "bonus%dVal" % (slot_idx+1))
			threshold_str = val_edit.GetText()
			if threshold_str.isdigit():
				return int(threshold_str)
			else:
				return 0
	
		def set_bonus(slot_idx, bonus_id, bonus_name, threshold):
			bonus_targets[slot_idx] = [bonus_id]
			xBonuses[slot_idx] = threshold
			attr_label = getattr(self, "Bonus%dAttr" % (slot_idx+1))
			val_edit = getattr(self, "bonus%dVal" % (slot_idx+1))
			attr_label.SetText(str(bonus_name))
			val_edit.SetText(str(threshold))
			msg("[SWITCHBOT] |cffFFFF00|H|hIn scenario '%s', set Bonus #%d to '%s' with value: %d." % (self.current_scenario, slot_idx+1, bonus_name, threshold))
	
		def remove_bonus(slot_idx):
			bonus_targets[slot_idx] = [0]
			xBonuses[slot_idx] = 0
			attr_label = getattr(self, "Bonus%dAttr" % (slot_idx+1))
			val_edit = getattr(self, "bonus%dVal" % (slot_idx+1))
			attr_label.SetText(lang.SWITCH_NONE)
			val_edit.SetText("0")
			msg("[SWITCHBOT] |cffFFFF00|H|hIn scenario '%s', removed Bonus #%d." % (self.current_scenario, slot_idx+1))
	
		if self.selected_bonus not in ("Remove", ""):
			selected_bonus_id = None
			for key, value in BonusIDListe.items():
				if value.find(self.selected_bonus) != -1:
					selected_bonus_id = key
					break
	
			if selected_bonus_id is None:
				msg("[SWITCHBOT] |cffFFFF00|H|hInvalid bonus selected.")
				self.closeBonusList()
				return
	
			if self.PRESSWISH0 == 1:
				threshold = get_threshold_for_slot(0)
				set_bonus(0, selected_bonus_id, self.selected_bonus, threshold)
				self.PRESSWISH0 = 0
			elif self.PRESSWISH1 == 1:
				if bonus_targets[0][0] != 0:
					threshold = get_threshold_for_slot(1)
					set_bonus(1, selected_bonus_id, self.selected_bonus, threshold)
				else:
					msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.PREVIOUS_BONUS)
				self.PRESSWISH1 = 0
			elif self.PRESSWISH2 == 1:
				if bonus_targets[1][0] != 0:
					threshold = get_threshold_for_slot(2)
					set_bonus(2, selected_bonus_id, self.selected_bonus, threshold)
				else:
					msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.PREVIOUS_BONUS)
				self.PRESSWISH2 = 0
			elif self.PRESSWISH3 == 1:
				if bonus_targets[2][0] != 0:
					threshold = get_threshold_for_slot(3)
					set_bonus(3, selected_bonus_id, self.selected_bonus, threshold)
				else:
					msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.PREVIOUS_BONUS)
				self.PRESSWISH3 = 0
			elif self.PRESSWISH4 == 1:
				if bonus_targets[3][0] != 0:
					threshold = get_threshold_for_slot(4)
					set_bonus(4, selected_bonus_id, self.selected_bonus, threshold)
				else:
					msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.PREVIOUS_BONUS)
				self.PRESSWISH4 = 0
			elif self.PRESSWISH5 == 1:
				threshold = get_threshold_for_slot(5)
				set_bonus(5, selected_bonus_id, self.selected_bonus, threshold)
				self.PRESSWISH5 = 0
			elif self.PRESSWISH6 == 1:
				if bonus_targets[5][0] != 0:
					threshold = get_threshold_for_slot(6)
					set_bonus(6, selected_bonus_id, self.selected_bonus, threshold)
				else:
					msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.PREVIOUS_BONUS)
				self.PRESSWISH6 = 0
			else:
				msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.INVALID_BONUS)
	
		elif self.selected_bonus == "Remove":
			if self.PRESSWISH0 == 1:
				remove_bonus(0)
				self.PRESSWISH0 = 0
			elif self.PRESSWISH1 == 1:
				remove_bonus(1)
				self.PRESSWISH1 = 0
			elif self.PRESSWISH2 == 1:
				remove_bonus(2)
				self.PRESSWISH2 = 0
			elif self.PRESSWISH3 == 1:
				remove_bonus(3)
				self.PRESSWISH3 = 0
			elif self.PRESSWISH4 == 1:
				remove_bonus(4)
				self.PRESSWISH4 = 0
			elif self.PRESSWISH5 == 1:
				remove_bonus(5)
				self.PRESSWISH5 = 0
			elif self.PRESSWISH6 == 1:
				remove_bonus(6)
				self.PRESSWISH6 = 0
			else:
				msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.INVALID_BONUS)
		else:
			msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.NO_BONUS_SEL)
	
		self.closeBonusList()
	def minus(self):
		initialDelay = self.delayVal.GetText()
		if float(initialDelay) > 0.10:
			setDelay = float(initialDelay) - 0.01
			setDelay2 = "%.2f" % round(setDelay, 2)
			self.delayVal.SetText(setDelay2)
		else:
			msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.SWITCH_DELAYDECMIN)
	
	def plus(self):
		initialDelay = self.delayVal.GetText()
		setDelay = float(initialDelay) + 0.01
		setDelay2 = "%.2f" % round(setDelay, 2)
		self.delayVal.SetText(setDelay2)
		
	def open_switch(self):
		self.hide_show.Hide()
		if self.Board.IsShow():
			self.Board.Hide()
		else:
			self.Board.Show()
	def killSwitch(self, arg):
		global switchbot_instances
		if arg:
			self.closeSettingsList()
			self.closeBonusList()
			self.hide_show.__del__()
			self.hide_show.Hide()
			self.settingsWindow.__del__()
			self.bonusList.__del__()
			self.Board.__del__()
			self.stop67() 
			self.stopBot()
			self.HotkeyRelogStop()
			
		if self in switchbot_instances:
			switchbot_instances.remove(self)
			
		try:
			self.QuestionDialog.Close()
			self.QuestionDialog = None
		except:
			pass
	def hide_switch(self, arg):
		if arg:
			if self.switchingRare or self.switching:
				if find_string(st_cur_server, "aronix") or  find_string(st_cur_server, "metin2sg") or foundx64PythonList:
					self.QuestionDialog = uiCommon.QuestionDialog()
				else:
					self.QuestionDialog = QuestionDialog()
				self.QuestionDialog.SetText(lang.CONFIRM_EXIT_SWITCH)
				self.QuestionDialog.SetAcceptEvent(lambda: self.killSwitch(1))
				self.QuestionDialog.SetCancelEvent(lambda: self.killSwitch(0))
				self.QuestionDialog.Open()
			else:
				self.killSwitch(1)
		else:
			self.Board.Hide()
			self.hide_show.Show()
	def reset1(self):
		scenario_data = self.scenarios[self.current_scenario]
		scenario_data['bonus_targets'][0] = [0]
		scenario_data['xBonuses'][0] = 0
		self.bonus1Val.SetText("0")
		self.Bonus1Attr.SetText(lang.SWITCH_NONE)
		self.storeUIToScenario(self.current_scenario)
	
	def reset2(self):
		scenario_data = self.scenarios[self.current_scenario]
		scenario_data['bonus_targets'][1] = [0]
		scenario_data['xBonuses'][1] = 0
		self.bonus2Val.SetText("0")
		self.Bonus2Attr.SetText(lang.SWITCH_NONE)
		self.storeUIToScenario(self.current_scenario)
	
	def reset3(self):
		scenario_data = self.scenarios[self.current_scenario]
		scenario_data['bonus_targets'][2] = [0]
		scenario_data['xBonuses'][2] = 0
		self.bonus3Val.SetText("0")
		self.Bonus3Attr.SetText(lang.SWITCH_NONE)
		self.storeUIToScenario(self.current_scenario)
	
	def reset4(self):
		scenario_data = self.scenarios[self.current_scenario]
		scenario_data['bonus_targets'][3] = [0]
		scenario_data['xBonuses'][3] = 0
		self.bonus4Val.SetText("0")
		self.Bonus4Attr.SetText(lang.SWITCH_NONE)
		self.storeUIToScenario(self.current_scenario)
	
	def reset5(self):
		scenario_data = self.scenarios[self.current_scenario]
		scenario_data['bonus_targets'][4] = [0]
		scenario_data['xBonuses'][4] = 0
		self.bonus5Val.SetText("0")
		self.Bonus5Attr.SetText(lang.SWITCH_NONE)
		self.storeUIToScenario(self.current_scenario)
	
	def reset6(self):
		scenario_data = self.scenarios[self.current_scenario]
		scenario_data['bonus_targets'][5] = [0]
		scenario_data['xBonuses'][5] = 0
		self.bonus6Val.SetText("0")
		self.Bonus6Attr.SetText(lang.SWITCH_NONE)
		self.storeUIToScenario(self.current_scenario)
	
	def reset7(self):
		scenario_data = self.scenarios[self.current_scenario]
		scenario_data['bonus_targets'][6] = [0]
		scenario_data['xBonuses'][6] = 0
		self.bonus7Val.SetText("0")
		self.Bonus7Attr.SetText(lang.SWITCH_NONE)
		self.storeUIToScenario(self.current_scenario)
	def scanNpc(self, race):
		for i in range(100000):	
			if chr.INSTANCE_TYPE_NPC == chr.GetInstanceType(i):
				chr.SelectInstance(i)
				if chr.GetRace() == race:
					return i
		return 0
	def getVnum(self):
		vid = player.GetTargetVID()
		race=chr.GetRace(vid)
		if vid != -1 or vid != 0:
			chr.SelectInstance(vid)
			race=chr.GetRace(vid)
		self.npcVal.SetText(str(race))
	def questInfo(self):
		newMsg(lang.SWITCH_QINFO, "down", 4, "box_blue", "text_white", 500, 200)
	def npcHelpFunc(self):
		newMsg(lang.SWITCH_NPCINFO, "down", 4, "box_blue", "text_white", 500, 200)
	def disable67(self):
		self.rareBonus.Title.SetText(lang.SWITCH_ENABLE67)
		self.bonus6.Hide()
		self.bonus6Val.Hide()
		self.bonus6Txt.Hide()
		self.bonus6Sel.Hide()
		self.Bonus6Attr.Hide()
		self.bonus7.Hide()
		self.bonus7Txt.Hide()
		self.bonus7Val.Hide()
		self.bonus7Sel.Hide()
		self.Bonus7Attr.Hide()
		self.b6Reset.Hide()
		self.b7Reset.Hide()
		self.rebuyRare.Hide()
		self.stop67()
		self.StartButton67.Hide()
		self.StopButton67.Hide()
		self.StartButton.SetPosition(138, 500)
		self.StopButton.SetPosition(138, 500)
	def enable67(self):
		self.rareBonus.Title.SetText(lang.SWITCH_DISABLE67)
		self.bonus6.Show()
		self.bonus6Val.Show()
		self.bonus6Txt.Show()
		self.bonus6Sel.Show()
		self.Bonus6Attr.Show()
		self.bonus7.Show()
		self.bonus7Txt.Show()
		self.bonus7Val.Show()
		self.bonus7Sel.Show()
		self.Bonus7Attr.Show()
		self.b6Reset.Show()
		self.b7Reset.Show()
		self.rebuyRare.Show()
		self.StartButton67.Show()
		self.StopButton67.Hide()
		self.StartButton.SetPosition(105, 500)
		self.StopButton.SetPosition(105, 500)
	def default_off(self):
		self.lblSwitchItem.Show()
		self.switchIcon.Show()
		self.switchSlot.Show()
		self.switchID = 0
		self.Delete_Switch_Reader_Item()
	def default_on(self):
		orange = "|cFFFF8040|Hitem|h"
		yellow = "|cffFFFF00|H|h"
		for i in range(player.INVENTORY_PAGE_SIZE*10):
			itemIndex = player.GetItemIndex(i)
			selectItem(itemIndex)
			ItemValue = player.GetItemIndex(i)
			if item.IsAntiFlag(74112) and item.IsFlag(8196) and item.GetItemSubType() == 18:
				msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.SWITCH_VNUM + orange + str(ItemValue))
				self.switchID = int(ItemValue)
				break
			elif str(item.GetItemName()) == "Vrajeste Obiectul" or str(item.GetItemName()) == "Enchant Item":
				msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.SWITCH_VNUM + orange + str(ItemValue))
				self.switchID = int(ItemValue)
				break
		self.lblSwitchItem.Hide()
		self.switchIcon.Hide()
		self.switchSlot.Hide()
	def select_item_refine(self):
		try:
			if isAttached():
				attachedSlotType = GetAttachedType()
				attachedSlotVnum = GetAttachedItemIndex()
				self.itemSlot = GetAttachedSlotNumber()
				selectItem(attachedSlotVnum)
				selectItem(int(attachedSlotVnum))
				self.itemSlotVnum = attachedSlotVnum
				self.refineIcon.LoadImage(str(item.GetIconImageFileName()))
				DeattachObject()
				self.itemSlotName = str(item.GetItemName(self.itemSlot))
		except:
			msg("[SWITCHBOT] |cffFFFF00|H|hFailed to attach item.")
			pass
	def filter_input(self, who):
		allowed_characters = "0123456789."
		current_text = who.GetText()
	
		dot_count = 0
		filtered_text = []
		for i, char in enumerate(current_text):
			if char == '.':
				# Do not allow `.` at the start or more than once
				if dot_count == 0 and i != 0:
					filtered_text.append(char)
					dot_count += 1
			elif char in allowed_characters:
				filtered_text.append(char)
		who.SetText(''.join(filtered_text))
	def numbersAndDotOnly(self, who):
		if isGF or find_string(st_cur_server, "landofheroes"):
			try:
				ui.EditLine.OnIMEUpdate(who)
				self.filter_input(who)
			except:
				pass
		else:
			try:
				EditLine.OnIMEUpdate(who)
				self.filter_input(who)
			except:
				pass
	def delete_item_refine(self):
		self.itemSlot = 0
		self.itemSlotVnum = 0
		self.refineIcon.LoadImage(slot_base)
	def __Wish_1_Option(self):
		self.PRESSWISH0 = 1
		self.bonusList.Show()
		self.keepBonusListOn()
		self.UpdateFileList()
	def __Wish_2_Option(self):
		self.PRESSWISH1 = 1
		self.bonusList.Show()
		self.keepBonusListOn()
		self.UpdateFileList()
	def __Wish_3_Option(self):
		self.PRESSWISH2 = 1
		self.bonusList.Show()
		self.keepBonusListOn()
		self.UpdateFileList()
	def __Wish_4_Option(self):
		self.PRESSWISH3 = 1
		self.bonusList.Show()
		self.keepBonusListOn()
		self.UpdateFileList()
	def __Wish_5_Option(self):
		self.PRESSWISH4 = 1
		self.bonusList.Show()
		self.keepBonusListOn()
		self.UpdateFileList()
	def __Wish_6_Option(self):
		self.PRESSWISH5 = 1
		self.bonusList.Show()
		self.keepBonusListOn()
		self.UpdateFileList()
	def __Wish_7_Option(self):
		self.PRESSWISH6 = 1
		self.bonusList.Show()
		self.keepBonusListOn()
		self.UpdateFileList()
	def OnUpdate(self):
		if self.switchingRare == 1 or self.switching == 1:
			if self.Board.IsShow():
				self.hide_show.SetToolTipText('Show switchbot')
			else:
				self.hide_show.SetToolTipText('Switching on slot ' + str(self.itemSlot))
	def Set_Switch_Reader_Item(self):
		try:
			if isAttached():
				attachedSlotType = GetAttachedType()
				attachedSlotVnum = GetAttachedItemIndex()
				self.switchID = attachedSlotVnum
				selectItem(attachedSlotVnum)
				selectItem(int(attachedSlotVnum))
				self.switchIcon.LoadImage(str(item.GetIconImageFileName()))
				DeattachObject()
		except:
			msg("[SWITCHBOT] |cffFFFF00|H|hFailed to attach item.")
			pass
	def Delete_Switch_Reader_Item(self):
		self.switchID = 0
		self.switchIcon.LoadImage(slot_base)
	def get_bonus(self, bonus):
		if bonus in LoadBonuses:
			return LoadBonuses[bonus]
		else:
			return "Unknown bonus"
	def stop67(self):
		self.startbot67x.XX1(999999999)
		self.startbot67x.XX2(self.stopBot)
		self.switchingRare = 0
		self.StartButton67.Show()
		self.StopButton67.Hide()
		self.UnHookQuestWindow(0)
	def isScenarioEmptyFor67(self, scenario_data):
		bonus_targets = scenario_data['bonus_targets']
		xBonuses = scenario_data['xBonuses']
	
		b6_list = bonus_targets[5]
		b7_list = bonus_targets[6]
		th6 = xBonuses[5]
		th7 = xBonuses[6]
		b6_all_zero = True
		for b in b6_list:
			if b != 0:
				b6_all_zero = False
				break
		b7_all_zero = True
		for b in b7_list:
			if b != 0:
				b7_all_zero = False
				break
	
		if b6_all_zero and b7_all_zero and th6 == 0 and th7 == 0:
			return True
		return False
	if find_string(st_cur_server, "Esenn"):
		def InstallQuestWindowHook(self):
			game_window_instance = game.GameWindow.instance()
			game_window_instance.OpenQuestWindow = game_window_instance.OpenQuestWindow
			game_window_instance.OpenQuestWindow = 0
		def UnHookQuestWindow(self, relog):
			global OldRecv
			eventHandler.remove('changeChSequence')
			game_window_instance = game.GameWindow.instance()
			game_window_instance.OpenQuestWindow = game_window_instance.OpenQuestWindow
			game_window_instance.OpenQuestWindow = OldRecv
			if relog:
				self.relogMe()
	else:
		def InstallQuestWindowHook(self):
			game.GameWindow.OpenQuestWindow = 0
		def UnHookQuestWindow(self, relog):
			global game,OldRecv
			try:
				if not game:
					import game
				game.GameWindow.OpenQuestWindow = OldRecv
			except:
				pass
			eventHandler.remove('changeChSequence')
			if relog:
				self.relogMe()
	def start67(self):
		self.StartButton67.Hide()
		self.StopButton67.Show()
		index = self.questVal.GetText()
		orange = "|cFFFF8040|Hitem|h"
		yellow = "|cffFFFF00|H|h"
		delayInt = self.delayVal.GetText()
		Slot = self.itemSlot
		val6, bon6 = getItemAttr(int(Slot), 5)
		val7, bon7 = getItemAttr(int(Slot), 6)
	
		Switchvalue = self.Boniswitchvalue2
		currentValues = [(val6, bon6), (val7, bon7)]
		scenarios_order = ['main','alt1','alt2','alt3','alt4']
		scenario_matched = False
		for scenario_name in scenarios_order:
			scenario_data = self.scenarios[scenario_name]
			bonus_targets = scenario_data['bonus_targets']
			xBonuses = scenario_data['xBonuses']
			
			if self.isScenarioEmptyFor67(scenario_data):
				continue
				
			neededValues = [
				(bonus_targets[5], xBonuses[5]), 
				(bonus_targets[6], xBonuses[6])
			]
			if check_for_needed_values(currentValues, neededValues):
				self.switchingRare = 0
				self.stop67()
				newMsgSimple(lang.SWITCH_FINISH67 + " " + str(self.itemSlotName))
				# try:
					# self.BoardMessage.SetTip(lang.SWITCH_FINISH67 + " " + str(self.itemSlotName))
					# self.BoardMessage.SetTop()
				# except:
					# pass
	
				msg("[SWITCHBOT] |cffFFFF00|H|hThe item: '" + orange + self.itemSlotName + yellow + "'" + ", from slot " + orange + str(Slot) + yellow + " got the following bonuses: ")
				msg("[SWITCHBOT] |cffFFFF00|H|hBonus 6: " + orange + self.get_bonus(val6) + yellow + ", value: " + orange + str(bon6))
				msg("[SWITCHBOT] |cffFFFF00|H|hBonus 7: " + orange + self.get_bonus(val7) + yellow + ", value: " + orange + str(bon7))
					
					
				msg("SWITCHBOT] |cffFFFF00|H|hScenario '%s' matched the 6/7 bonuses. Stopping switch." % scenario_name)
				create_log("Finished item '" + self.itemSlotName + "', from slot " + str(Slot) + " got the following bonuses: ")
						
						
				create_log("Bonus 6: " + self.get_bonus(val6) + ", value: " + str(bon6))
				create_log("Bonus 7: " + self.get_bonus(val7) + ", value: " + str(bon7))
	
				scenario_matched = True
				break
		if not scenario_matched:
			self.switchingRare = 1
			self.startbot67x.XX1(float(delayInt))
			self.startbot67x.XX2(self.start67)
			for eachSlot in range(player.INVENTORY_PAGE_SIZE*10):
				itemVNum = player.GetItemIndex(eachSlot)
				if itemVNum == int(Switchvalue):
					SendItemUseToItemPacket(eachSlot, (int(Slot)))
					break
	
			if player.GetItemCountByVnum(int(Switchvalue)) < 1:
				if self.rebuyRare.checked == 1:
					msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.SWITCH_NO67_BUY)
					if shop.IsOpen():
						for eachSlot in range(shop.SHOP_SLOT_COUNT):
							getShopItemID = shop.GetItemID(eachSlot)
							if getShopItemID == int(Switchvalue) and not itemVNum == int(Switchvalue):
								net.SendShopBuyPacket(eachSlot)
					else:
						vid = self.scanNpc(int(self.npcVal.GetText()))
						clickPacket(vid)
						self.InstallQuestWindowHook()
						event.SelectAnswer(0, int(index))
						event.ClearEventSet(1)
						# self.UnHookQuestWindow(0)
						for eachSlot in range(shop.SHOP_SLOT_COUNT):
							getShopItemID = shop.GetItemID(eachSlot)
							
							if getShopItemID == int(Switchvalue) and not itemVNum == int(Switchvalue):
								net.SendShopBuyPacket(eachSlot)
				else:
					msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.SWITCH_NO67_STOP)
					self.switchingRare = 0
					self.stop67()
	def isScenarioEmpty(self, scenario_data):
		for i in range(5):
			found_non_zero = False
			for b in scenario_data['bonus_targets'][i]:
				if b != 0:
					found_non_zero = True
					break
			
			if found_non_zero:
				return False
			if scenario_data['xBonuses'][i] != 0:
				return False
		return True
	
	def startBot(self):
		global isGF
		self.StartButton.Hide()
		self.StopButton.Show()
		self.storeUIToScenario(self.current_scenario)
		try:
		
			try:
				index = self.questVal.GetText()
			except:
				index = 0	
			try:
				delayInt = self.delayVal.GetText()
			except:
				delayInt = 0.3
			
			self.startbotx.XX1(float(delayInt))
			self.startbotx.XX2(self.startBot)
			if not isConnect():
				self.startbotx.XX1(3)
				return
		
			if self.itemSlotVnum == 0:
				self.stopBot()
				msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.SWITCH_SELITEM_FIRST)
				return
		
			currentValues = [getItemAttr(self.itemSlot, i) for i in range(5)]
		
			orange = "|cFFFF8040|Hitem|h"
			yellow = "|cffFFFF00|H|h"
		
			if self.default.checked == 1:
				Switchvalue = self.Boniswitchvalue
			else:
				Switchvalue = self.switchID
	
			if Switchvalue == 0 or Switchvalue is None:
				self.stopBot()
				msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.SWITCH_NOSWITCHERS)
				return
		
			scenarios_order = ['main', 'alt1', 'alt2', 'alt3', 'alt4']
			scenario_matched = False
			
		
			for scenario_name in scenarios_order:
				scenario_data = self.scenarios[scenario_name]
		
				if self.isScenarioEmpty(scenario_data):
					continue
			
				neededValues = [(scenario_data['bonus_targets'][i], scenario_data['xBonuses'][i]) for i in range(5)]
		
				for slot_idx, (bonus_list, threshold) in enumerate(neededValues, start=1):
					
					all_zero = True
					for b in bonus_list:
						if b != 0:
							all_zero = False
							break
					
					if all_zero:
						continue
					else:
						bonus_names = [self.get_bonus(bid) for bid in bonus_list if bid != 0]
						bonus_str = " or ".join(bonus_names)
		
				if check_for_needed_values(currentValues, neededValues):
		
					self.stopBot()
					self.switching = 0
					msg("[SWITCHBOT] |cffFFFF00|H|hThe item: '" + orange + str(self.itemSlotName) + yellow + "' has matched scenario '%s' requirements." % scenario_name)
					create_log("Finished item '" + self.itemSlotName + "' scenario: " + scenario_name)
					for i, (val, bon) in enumerate(currentValues, start=1):
						msg("[SWITCHBOT] |cffFFFF00|H|hBonus %d: %s%s%s, value: %s%d" % (i, orange, self.get_bonus(val), yellow, orange, bon))
						create_log("Bonus %d: %s, value: %d" % (i, self.get_bonus(val), bon))
	
					newMsgSimple(lang.SWITCH_FINISH15 + " " + str(self.itemSlotName))
					# try:
						# self.BoardMessage.SetTip(lang.SWITCH_FINISH15 + " " + str(self.itemSlotName))
						# self.BoardMessage.SetTop()
					# except:
						# pass
	
	
					
					
					scenario_matched = True
					break
		
			if not scenario_matched:
				self.switching = 1
				if player.GetItemCountByVnum(int(Switchvalue)) < 1:
					if not isGF:
						if self.rebuyChangers.checked==1:
							if not shop.IsOpen():
								vid = self.scanNpc(int(self.npcVal.GetText()))
								clickPacket(int(vid))
								self.InstallQuestWindowHook()
								event.SelectAnswer(0, int(index))
								event.ClearEventSet(1)
								
								
								
							for eachSlot in range(shop.SHOP_SLOT_COUNT):
								itemVNum = player.GetItemIndex(eachSlot)
								getShopItemID = shop.GetItemID(eachSlot)
								if find_string(st_cur_server, "warcry2"):
									if Switchvalue == 71084 and getShopItemID == 39028:
										net.SendShopBuyPacket(eachSlot)
										break
								else:
								
									if getShopItemID == int(Switchvalue) and not itemVNum == int(Switchvalue):
										net.SendShopBuyPacket(eachSlot)
										break
						else:
							msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.SWITCH_NO15_STOP)
							self.stopBot()
				for eachSlot in range(player.INVENTORY_PAGE_SIZE*10):
					itemVNum = player.GetItemIndex(eachSlot)
					if itemVNum == int(Switchvalue):
						SendItemUseToItemPacket(eachSlot, (int(self.itemSlot)))
						break
		except:
			msg("[SWITCHBOT] |cffFFFF00|H|hFailed starting switching.")
			self.stopBot()
	def stopBot(self):
		self.startbotx.XX1(999999999)
		self.startbotx.XX2(self.stopBot)
		self.switching = 0
		self.StartButton.Show()
		self.StopButton.Hide()
		self.UnHookQuestWindow(0)
	def ResetBonus(self):
		for scenario_name in self.scenarios.keys():
			for i in range(7):
				self.scenarios[scenario_name]['bonus_targets'][i] = [0]
				self.scenarios[scenario_name]['xBonuses'][i] = 0
		self.bonus1Val.SetText("0")
		self.bonus2Val.SetText("0")
		self.bonus3Val.SetText("0")
		self.bonus4Val.SetText("0")
		self.bonus5Val.SetText("0")
		self.bonus6Val.SetText("0")
		self.bonus7Val.SetText("0")
		self.Bonus1Attr.SetText(lang.SWITCH_NONE)
		self.Bonus2Attr.SetText(lang.SWITCH_NONE)
		self.Bonus3Attr.SetText(lang.SWITCH_NONE)
		self.Bonus4Attr.SetText(lang.SWITCH_NONE)
		self.Bonus5Attr.SetText(lang.SWITCH_NONE)
		self.Bonus6Attr.SetText(lang.SWITCH_NONE)
		self.Bonus7Attr.SetText(lang.SWITCH_NONE)
		self.stopBot()
		self.stop67()
		if self.rareBonus.checked==1:
			self.StartButton.SetPosition(120, 500)
			self.StopButton.SetPosition(120, 500)
			self.StartButton67.Show()
		else:
			self.StartButton.SetPosition(138, 500)
			self.StopButton.SetPosition(138, 500)
			self.StartButton67.Hide()
		msg("[SWITCHBOT] |cffFFFF00|H|h" + lang.SWITCH_ALL_RESETED)
switchEnabled = True
try:
	
	if uiToolTip:
		
		excludeBonusList = [25, 26, 40, 46, 50, 52, 54, 55, 56, 58, 64, 65, 66, 67, 68, 69, 70, 76, 77, 82, 84, 85, 86]
		if isGF or find_string(st_cur_server, "shinra") or find_string(st_cur_server, "metin2br"):
			AFFECT_DICT = {
				item.APPLY_MAX_HP : localeInfo.TOOLTIP_MAX_HP,
				item.APPLY_MAX_SP : localeInfo.TOOLTIP_MAX_SP,
				item.APPLY_CON : localeInfo.TOOLTIP_CON,
				item.APPLY_INT : localeInfo.TOOLTIP_INT,
				item.APPLY_STR : localeInfo.TOOLTIP_STR,
				item.APPLY_DEX : localeInfo.TOOLTIP_DEX,
				item.APPLY_ATT_SPEED : localeInfo.TOOLTIP_ATT_SPEED,
				item.APPLY_MOV_SPEED : localeInfo.TOOLTIP_MOV_SPEED,
				item.APPLY_CAST_SPEED : localeInfo.TOOLTIP_CAST_SPEED,
				item.APPLY_HP_REGEN : localeInfo.TOOLTIP_HP_REGEN,
				item.APPLY_SP_REGEN : localeInfo.TOOLTIP_SP_REGEN,
				item.APPLY_POISON_PCT : localeInfo.TOOLTIP_APPLY_POISON_PCT,
				item.APPLY_STUN_PCT : localeInfo.TOOLTIP_APPLY_STUN_PCT,
				item.APPLY_SLOW_PCT : localeInfo.TOOLTIP_APPLY_SLOW_PCT,
				item.APPLY_CRITICAL_PCT : localeInfo.TOOLTIP_APPLY_CRITICAL_PCT,
				item.APPLY_PENETRATE_PCT : localeInfo.TOOLTIP_APPLY_PENETRATE_PCT,
				item.APPLY_ATTBONUS_WARRIOR : localeInfo.TOOLTIP_APPLY_ATTBONUS_WARRIOR,
				item.APPLY_ATTBONUS_ASSASSIN : localeInfo.TOOLTIP_APPLY_ATTBONUS_ASSASSIN,
				item.APPLY_ATTBONUS_SURA : localeInfo.TOOLTIP_APPLY_ATTBONUS_SURA,
				item.APPLY_ATTBONUS_SHAMAN : localeInfo.TOOLTIP_APPLY_ATTBONUS_SHAMAN,
				item.APPLY_ATTBONUS_MONSTER : localeInfo.TOOLTIP_APPLY_ATTBONUS_MONSTER,
				item.APPLY_ATTBONUS_HUMAN : localeInfo.TOOLTIP_APPLY_ATTBONUS_HUMAN,
				item.APPLY_ATTBONUS_ANIMAL : localeInfo.TOOLTIP_APPLY_ATTBONUS_ANIMAL,
				item.APPLY_ATTBONUS_ORC : localeInfo.TOOLTIP_APPLY_ATTBONUS_ORC,
				item.APPLY_ATTBONUS_MILGYO : localeInfo.TOOLTIP_APPLY_ATTBONUS_MILGYO,
				item.APPLY_ATTBONUS_UNDEAD : localeInfo.TOOLTIP_APPLY_ATTBONUS_UNDEAD,
				item.APPLY_ATTBONUS_DEVIL : localeInfo.TOOLTIP_APPLY_ATTBONUS_DEVIL,
				item.APPLY_STEAL_HP : localeInfo.TOOLTIP_APPLY_STEAL_HP,
				item.APPLY_STEAL_SP : localeInfo.TOOLTIP_APPLY_STEAL_SP,
				item.APPLY_MANA_BURN_PCT : localeInfo.TOOLTIP_APPLY_MANA_BURN_PCT,
				item.APPLY_DAMAGE_SP_RECOVER : localeInfo.TOOLTIP_APPLY_DAMAGE_SP_RECOVER,
				item.APPLY_BLOCK : localeInfo.TOOLTIP_APPLY_BLOCK,
				item.APPLY_DODGE : localeInfo.TOOLTIP_APPLY_DODGE,
				item.APPLY_RESIST_SWORD : localeInfo.TOOLTIP_APPLY_RESIST_SWORD,
				item.APPLY_RESIST_TWOHAND : localeInfo.TOOLTIP_APPLY_RESIST_TWOHAND,
				item.APPLY_RESIST_DAGGER : localeInfo.TOOLTIP_APPLY_RESIST_DAGGER,
				item.APPLY_RESIST_BELL : localeInfo.TOOLTIP_APPLY_RESIST_BELL,
				item.APPLY_RESIST_FAN : localeInfo.TOOLTIP_APPLY_RESIST_FAN,
				item.APPLY_RESIST_BOW : localeInfo.TOOLTIP_RESIST_BOW,
				item.APPLY_RESIST_FIRE : localeInfo.TOOLTIP_RESIST_FIRE,
				item.APPLY_RESIST_ELEC : localeInfo.TOOLTIP_RESIST_ELEC,
				item.APPLY_RESIST_MAGIC : localeInfo.TOOLTIP_RESIST_MAGIC,
				item.APPLY_RESIST_WIND : localeInfo.TOOLTIP_APPLY_RESIST_WIND,
				item.APPLY_REFLECT_MELEE : localeInfo.TOOLTIP_APPLY_REFLECT_MELEE,
				item.APPLY_REFLECT_CURSE : localeInfo.TOOLTIP_APPLY_REFLECT_CURSE,
				item.APPLY_POISON_REDUCE : localeInfo.TOOLTIP_APPLY_POISON_REDUCE,
				item.APPLY_KILL_SP_RECOVER : localeInfo.TOOLTIP_APPLY_KILL_SP_RECOVER,
				item.APPLY_EXP_DOUBLE_BONUS : localeInfo.TOOLTIP_APPLY_EXP_DOUBLE_BONUS,
				item.APPLY_GOLD_DOUBLE_BONUS : localeInfo.TOOLTIP_APPLY_GOLD_DOUBLE_BONUS,
				item.APPLY_ITEM_DROP_BONUS : localeInfo.TOOLTIP_APPLY_ITEM_DROP_BONUS,
				item.APPLY_POTION_BONUS : localeInfo.TOOLTIP_APPLY_POTION_BONUS,
				item.APPLY_KILL_HP_RECOVER : localeInfo.TOOLTIP_APPLY_KILL_HP_RECOVER,
				item.APPLY_IMMUNE_STUN : localeInfo.TOOLTIP_APPLY_IMMUNE_STUN,
				item.APPLY_IMMUNE_SLOW : localeInfo.TOOLTIP_APPLY_IMMUNE_SLOW,
				# item.APPLY_IMMUNE_FALL : localeInfo.TOOLTIP_APPLY_IMMUNE_FALL,
				item.APPLY_BOW_DISTANCE : localeInfo.TOOLTIP_BOW_DISTANCE,
				item.APPLY_DEF_GRADE_BONUS : localeInfo.TOOLTIP_DEF_GRADE,
				item.APPLY_ATT_GRADE_BONUS : localeInfo.TOOLTIP_ATT_GRADE,
				item.APPLY_MAGIC_ATT_GRADE : localeInfo.TOOLTIP_MAGIC_ATT_GRADE,
				item.APPLY_MAGIC_DEF_GRADE : localeInfo.TOOLTIP_MAGIC_DEF_GRADE,
				item.APPLY_MAX_STAMINA : localeInfo.TOOLTIP_MAX_STAMINA,
				item.APPLY_MALL_ATTBONUS : localeInfo.TOOLTIP_MALL_ATTBONUS,
				item.APPLY_MALL_DEFBONUS : localeInfo.TOOLTIP_MALL_DEFBONUS,
				item.APPLY_MALL_EXPBONUS : localeInfo.TOOLTIP_MALL_EXPBONUS,
				item.APPLY_MALL_ITEMBONUS : localeInfo.TOOLTIP_MALL_ITEMBONUS,
				item.APPLY_MALL_GOLDBONUS : localeInfo.TOOLTIP_MALL_GOLDBONUS,
				item.APPLY_SKILL_DAMAGE_BONUS : localeInfo.TOOLTIP_SKILL_DAMAGE_BONUS,
				item.APPLY_NORMAL_HIT_DAMAGE_BONUS : localeInfo.TOOLTIP_NORMAL_HIT_DAMAGE_BONUS,
				item.APPLY_SKILL_DEFEND_BONUS : localeInfo.TOOLTIP_SKILL_DEFEND_BONUS,
				item.APPLY_NORMAL_HIT_DEFEND_BONUS : localeInfo.TOOLTIP_NORMAL_HIT_DEFEND_BONUS,
				item.APPLY_PC_BANG_EXP_BONUS : localeInfo.TOOLTIP_MALL_EXPBONUS_P_STATIC,
				item.APPLY_PC_BANG_DROP_BONUS : localeInfo.TOOLTIP_MALL_ITEMBONUS_P_STATIC,
				item.APPLY_RESIST_WARRIOR : localeInfo.TOOLTIP_APPLY_RESIST_WARRIOR,
				item.APPLY_RESIST_ASSASSIN : localeInfo.TOOLTIP_APPLY_RESIST_ASSASSIN,
				item.APPLY_RESIST_SURA : localeInfo.TOOLTIP_APPLY_RESIST_SURA,
				item.APPLY_RESIST_SHAMAN : localeInfo.TOOLTIP_APPLY_RESIST_SHAMAN,
				item.APPLY_MAX_HP_PCT : localeInfo.TOOLTIP_APPLY_MAX_HP_PCT,
				item.APPLY_MAX_SP_PCT : localeInfo.TOOLTIP_APPLY_MAX_SP_PCT,
				item.APPLY_ENERGY : localeInfo.TOOLTIP_ENERGY,
				item.APPLY_COSTUME_ATTR_BONUS : localeInfo.TOOLTIP_COSTUME_ATTR_BONUS,
				item.APPLY_MAGIC_ATTBONUS_PER : localeInfo.TOOLTIP_MAGIC_ATTBONUS_PER,
				item.APPLY_MELEE_MAGIC_ATTBONUS_PER : localeInfo.TOOLTIP_MELEE_MAGIC_ATTBONUS_PER,
				item.APPLY_RESIST_ICE : localeInfo.TOOLTIP_RESIST_ICE,
				item.APPLY_RESIST_EARTH : localeInfo.TOOLTIP_RESIST_EARTH,
				item.APPLY_RESIST_DARK : localeInfo.TOOLTIP_RESIST_DARK,
				item.APPLY_ANTI_CRITICAL_PCT : localeInfo.TOOLTIP_ANTI_CRITICAL_PCT,
				item.APPLY_ANTI_PENETRATE_PCT : localeInfo.TOOLTIP_ANTI_PENETRATE_PCT,
				item.APPLY_ATTBONUS_WOLFMAN : localeInfo.TOOLTIP_APPLY_ATTBONUS_WOLFMAN,
				item.APPLY_RESIST_WOLFMAN : localeInfo.TOOLTIP_APPLY_RESIST_WOLFMAN,
				item.APPLY_RESIST_CLAW : localeInfo.TOOLTIP_APPLY_RESIST_CLAW,
				item.APPLY_ENCHANT_ELECT	:	localeInfo.TOOLTIP_APPLY_ENCHANT_ELECT,
				item.APPLY_ENCHANT_FIRE	:	localeInfo.TOOLTIP_APPLY_ENCHANT_FIRE,
				item.APPLY_ENCHANT_ICE 	:	localeInfo.TOOLTIP_APPLY_ENCHANT_ICE,
				item.APPLY_ENCHANT_WIND	:	localeInfo.TOOLTIP_APPLY_ENCHANT_WIND,
				item.APPLY_ENCHANT_EARTH	:	localeInfo.TOOLTIP_APPLY_ENCHANT_EARTH,
				item.APPLY_ENCHANT_DARK	:	localeInfo.TOOLTIP_APPLY_ENCHANT_DARK,
				item.APPLY_ATTBONUS_INSECT	:	localeInfo.TOOLTIP_APPLY_ATTBONUS_INSECT,
				item.APPLY_ATTBONUS_DESERT	:	localeInfo.TOOLTIP_APPLY_ATTBONUS_DESERT,
				item.APPLY_ATTBONUS_SWORD	:	localeInfo.TOOLTIP_APPLY_ATTBONUS_SWORD,
				item.APPLY_ATTBONUS_TWOHAND	:	localeInfo.TOOLTIP_APPLY_ATTBONUS_TWOHAND,
				item.APPLY_ATTBONUS_DAGGER	:	localeInfo.TOOLTIP_APPLY_ATTBONUS_DAGGER,
				item.APPLY_ATTBONUS_BELL	:	localeInfo.TOOLTIP_APPLY_ATTBONUS_BELL,
				item.APPLY_ATTBONUS_FAN	:	localeInfo.TOOLTIP_APPLY_ATTBONUS_FAN,
				item.APPLY_ATTBONUS_BOW	:	localeInfo.TOOLTIP_APPLY_ATTBONUS_BOW,
				item.APPLY_ATTBONUS_CLAW	:	localeInfo.TOOLTIP_APPLY_ATTBONUS_CLAW,
				item.APPLY_RESIST_HUMAN	:	localeInfo.TOOLTIP_APPLY_RESIST_HUMAN,
			}
		elif hasattr(uiToolTip.ItemToolTip, 'AFFECT_DICT2'):
			AFFECT_DICT = uiToolTip.ItemToolTip.AFFECT_DICT2
		else:
			AFFECT_DICT = uiToolTip.ItemToolTip.AFFECT_DICT
		if find_string(st_cur_server, "Mt2MesterNext"):
			
			for x in AFFECT_DICT:
				if x not in BonusListe and x not in excludeBonusList:
					value = AFFECT_DICT[x]
					plm = value[0](value[1])
					BonusListe.append(plm)
		elif find_string(st_cur_server, "GoodTimes"):
			
			for x in AFFECT_DICT:
				if x not in BonusListe and x not in excludeBonusList:
					value = AFFECT_DICT[x]
					plm = value[0](value[1])
					BonusListe.append(plm)
		elif find_string(st_cur_server, "velium"):
			
			for x in AFFECT_DICT:
				if x not in BonusListe and x not in excludeBonusList:
					value = AFFECT_DICT[x]
					plm = value[0](value[1])
					BonusListe.append(plm)				
		elif find_string(st_cur_server, "ageofmetin"):
			
			for x in AFFECT_DICT:
				if x not in BonusListe and x not in excludeBonusList:
					value = AFFECT_DICT[x]
					try:
						plm = value(0)
					except:
						pass
					BonusListe.append(plm)
		else:
			
			for x in AFFECT_DICT:
				if x not in BonusListe and x not in excludeBonusList:
					value = AFFECT_DICT[x]
					try:
						plm = str(value(0))
					except TypeError:
						plm = str(value)
					plm = plm.strip()
					BonusListe.append(plm)
		if find_string(st_cur_server, "Mt2MesterNext"):
			
			for x, value in AFFECT_DICT.items():
				try:
					bonus_value = value[0](value[1])
				except TypeError:
					bonus_value = value[0]
				plm = "%s : %s" % (bonus_value, x)
				BonusIDListe[x] = plm
		elif find_string(st_cur_server, "GoodTimes"):
			
			for x, value in AFFECT_DICT.items():
				try:
					bonus_value = value[0](value[1])
				except TypeError:
					bonus_value = value[0]
				plm = "%s : %s" % (bonus_value, x)
				BonusIDListe[x] = plm
		elif find_string(st_cur_server, "Good Times"):
			
			for x, value in AFFECT_DICT.items():
				try:
					bonus_value = value[0](value[1])
				except TypeError:
					bonus_value = value[0]
				plm = "%s : %s" % (bonus_value, x)
				BonusIDListe[x] = plm
		elif find_string(st_cur_server, "velium"):
			
			for x, value in AFFECT_DICT.items():
				try:
					bonus_value = value[0](value[1])
				except TypeError:
					bonus_value = value[0]
				plm = "%s : %s" % (bonus_value, x)
				BonusIDListe[x] = plm
		elif find_string(st_cur_server, "ageofmetin"):
			
			for x, value in AFFECT_DICT.items():
				try:
					plm = "%s : %s" % (value(0), x)
				except:
					pass
				BonusIDListe[x] = plm
		else:
			
			for x, value in AFFECT_DICT.items():
				try:
					plm = "%s : %s" % (value(0), x)
				except TypeError:
					plm = "%s : %s" % (value, x)
				BonusIDListe[x] = plm	
	else:
		BonusListe = [
			"",
			lang.SWITCH_BON001,
			lang.SWITCH_BON002,
			lang.SWITCH_BON003,
			lang.SWITCH_BON004, 
			lang.SWITCH_BON005,
			lang.SWITCH_BON006,
			lang.SWITCH_BON007,
			lang.SWITCH_BON008,
			lang.SWITCH_BON009,
			lang.SWITCH_BON010,
			lang.SWITCH_BON011,
			lang.SWITCH_BON012,
			lang.SWITCH_BON013,
			lang.SWITCH_BON014,
			lang.SWITCH_BON015,
			lang.SWITCH_BON016,
			lang.SWITCH_BON017,
			lang.SWITCH_BON018,
			lang.SWITCH_BON019,
			lang.SWITCH_BON020,
			lang.SWITCH_BON021,
			lang.SWITCH_BON022,
			lang.SWITCH_BON023,
			lang.SWITCH_BON024,
			lang.SWITCH_BON025,
			lang.SWITCH_BON027,
			lang.SWITCH_BON028,
			lang.SWITCH_BON029,
			lang.SWITCH_BON030,
			lang.SWITCH_BON031,
			lang.SWITCH_BON032,
			lang.SWITCH_BON033,
			lang.SWITCH_BON034,
			lang.SWITCH_BON035,
			lang.SWITCH_BON036,
			lang.SWITCH_BON037,
			lang.SWITCH_BON038,
			lang.SWITCH_BON039,
			lang.SWITCH_BON040,
			lang.SWITCH_BON041,
			lang.SWITCH_BON042,
			lang.SWITCH_BON043,
			lang.SWITCH_BON044,
			lang.SWITCH_BON045,
			lang.SWITCH_BON046,
			lang.SWITCH_BON047,
			lang.SWITCH_BON048,
			lang.SWITCH_BON049,
			lang.SWITCH_BON050,
			lang.SWITCH_BON051,
			lang.SWITCH_BON052,
			lang.SWITCH_BON053,
			lang.SWITCH_BON054,
			lang.SWITCH_BON055,
			lang.SWITCH_BON056,
			lang.SWITCH_BON057,
			lang.SWITCH_BON058,
			lang.SWITCH_BON059,
			lang.SWITCH_BON060,
			lang.SWITCH_BON061,
			lang.SWITCH_BON062,
			lang.SWITCH_BON063,
			lang.SWITCH_BON064,
			lang.SWITCH_BON071,
			lang.SWITCH_BON072,
			lang.SWITCH_BON073,
			lang.SWITCH_BON074,
			lang.SWITCH_BON075,
			lang.SWITCH_BON076,
			lang.SWITCH_BON077,
			lang.SWITCH_BON078,
			lang.SWITCH_BON079,
			lang.SWITCH_BON080,
			lang.SWITCH_BON081,
			lang.SWITCH_BON082,
			lang.SWITCH_BON083,
			lang.SWITCH_BON084]
		BonusIDListe = { 
			"" : 0,
			lang.SWITCH_BON001 : 1,
			lang.SWITCH_BON002 : 2,
			lang.SWITCH_BON003 : 3,
			lang.SWITCH_BON004 : 4, 
			lang.SWITCH_BON005 : 5,
			lang.SWITCH_BON006 : 6,
			lang.SWITCH_BON007 : 7,
			lang.SWITCH_BON008 : 8,
			lang.SWITCH_BON009 : 9,
			lang.SWITCH_BON010 : 10,
			lang.SWITCH_BON011 : 11,
			lang.SWITCH_BON012 : 12,
			lang.SWITCH_BON013 : 13,
			lang.SWITCH_BON014 : 14,
			lang.SWITCH_BON015 : 15,
			lang.SWITCH_BON016 : 16,
			lang.SWITCH_BON017 : 17,
			lang.SWITCH_BON018 : 18,
			lang.SWITCH_BON019 : 19,
			lang.SWITCH_BON020 : 20,
			lang.SWITCH_BON021 : 21,
			lang.SWITCH_BON022 : 22,
			lang.SWITCH_BON023 : 23,
			lang.SWITCH_BON024 : 24,
			lang.SWITCH_BON025 : 25,
			lang.SWITCH_BON027 : 28,
			lang.SWITCH_BON028 : 29,
			lang.SWITCH_BON029 : 30,
			lang.SWITCH_BON030 : 31,
			lang.SWITCH_BON031 : 32,
			lang.SWITCH_BON032 : 33,
			lang.SWITCH_BON033 : 34,
			lang.SWITCH_BON034 : 35,
			lang.SWITCH_BON035 : 36,
			lang.SWITCH_BON036 : 37,
			lang.SWITCH_BON037 : 38,
			lang.SWITCH_BON038 : 39,
			lang.SWITCH_BON039 : 40,
			lang.SWITCH_BON040 : 41,
			lang.SWITCH_BON041 : 43,
			lang.SWITCH_BON042 : 44,
			lang.SWITCH_BON043 : 45,
			lang.SWITCH_BON044 : 48,
			lang.SWITCH_BON045 : 49,
			lang.SWITCH_BON046 : 50,
			lang.SWITCH_BON047 : 53,
			lang.SWITCH_BON048 : 59,
			lang.SWITCH_BON049 : 60,
			lang.SWITCH_BON050 : 61,
			lang.SWITCH_BON051 : 62,
			lang.SWITCH_BON052 : 63,
			lang.SWITCH_BON053 : 71,
			lang.SWITCH_BON054 : 72,
			lang.SWITCH_BON055 : 78,
			lang.SWITCH_BON056 : 79,
			lang.SWITCH_BON057 : 80,
			lang.SWITCH_BON058 : 81,
			lang.SWITCH_BON059 : 85,
			lang.SWITCH_BON060 : 87,
			lang.SWITCH_BON061 : 88,
			lang.SWITCH_BON062 : 89,
			lang.SWITCH_BON063 : 90,
			lang.SWITCH_BON064 : 91,
			lang.SWITCH_BON071 : 103,
			lang.SWITCH_BON072 : 104,
			lang.SWITCH_BON073 : 105,
			lang.SWITCH_BON074 : 106,
			lang.SWITCH_BON075 : 107,
			lang.SWITCH_BON076 : 108,
			lang.SWITCH_BON077 : 109,
			lang.SWITCH_BON078 : 110,
			lang.SWITCH_BON079 : 111,
			lang.SWITCH_BON080 : 112,
			lang.SWITCH_BON081 : 113,
			lang.SWITCH_BON082 : 116,
			lang.SWITCH_BON083 : 117,
			lang.SWITCH_BON084 : 118,
			}
except:
	switchEnabled = False
try:
	LoadBonuses = {}
	for x, value in AFFECT_DICT.items():
		if find_string(st_cur_server, "Good Times"):
			try:
				plm = str(value[0](0))
				plm = plm.replace('0', '')
				plm = plm.replace('+', '')
				plm = plm.replace('%', '')
				plm = plm.rstrip()
			except TypeError:
				plm = str(value)
			LoadBonuses[x] = plm
		elif find_string(st_cur_server, "Good Times"):
			try:
				plm = str(value[0](0))
				plm = plm.replace('0', '')
				plm = plm.replace('+', '')
				plm = plm.replace('%', '')
				plm = plm.rstrip()
			except TypeError:
				plm = str(value)
			LoadBonuses[x] = plm
		elif find_string(st_cur_server, "ageofmetin"):
			for x, value in AFFECT_DICT.items():
				try:
					plm = value(0)
				except:
					pass
				plm = plm.replace('0', '')
				plm = plm.replace('+', '')
				plm = plm.replace('%', '')
				plm = plm.replace(':', '')
				plm = plm.rstrip()
				LoadBonuses[x] = plm
		elif find_string(st_cur_server, "Mt2MesterNext"):
			try:
				plm = str(value[0](0))
				plm = plm.replace('0', '')
				plm = plm.replace('+', '')
				plm = plm.replace('%', '')
				plm = plm.rstrip()
			except TypeError:
				plm = str(value)
			LoadBonuses[x] = plm
		else:
			if callable(value):
				plm = str(value(0))
				plm = plm.replace('0', '')
				plm = plm.replace('+', '')
				plm = plm.replace('%', '')
				plm = plm.rstrip()
			else:
				plm = str(value)
			LoadBonuses[x] = plm
except:
	pass
def GetTmpTeleport(DestX, DestY):
	(PlayerX, PlayerY, PlayerZ) = player.GetMainCharacterPosition()
	DifX = DestX - PlayerX
	DifY = DestY - PlayerY
	Vektor = DivideToFloat(2000, math.sqrt(DifX**2 + DifY**2))
	TempX = PlayerX + Vektor*DifX
	TempY = PlayerY + Vektor*DifY
	Count = DivideToFloat((DestX - PlayerX), (Vektor*DifX))
	return (TempX, TempY, Count)
def DivideToFloat(x, y):
	try:
		return x * (y**-1)
	except:
		return 0	
sasfbas = extPath
class Line(Window):
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.RegisterLine(self, layer)
	def SetColor(self, color):
		wndMgr.SetColor(self.hWnd, color)
class ToolTip(ThinBoard):
	TOOL_TIP_WIDTH = 190
	TOOL_TIP_HEIGHT = 10
	TEXT_LINE_HEIGHT = 17
	TITLE_COLOR = grp.GenerateColor(0.9490, 0.9058, 0.7568, 1.0)
	SPECIAL_TITLE_COLOR = grp.GenerateColor(1.0, 0.7843, 0.0, 1.0)
	NORMAL_COLOR = grp.GenerateColor(0.7607, 0.7607, 0.7607, 1.0)
	FONT_COLOR = grp.GenerateColor(0.7607, 0.7607, 0.7607, 1.0)
	PRICE_COLOR = 0xffFFB96D
	HIGH_PRICE_COLOR = SPECIAL_TITLE_COLOR
	MIDDLE_PRICE_COLOR = grp.GenerateColor(0.85, 0.85, 0.85, 1.0)
	LOW_PRICE_COLOR = grp.GenerateColor(0.7, 0.7, 0.7, 1.0)
	ENABLE_COLOR = grp.GenerateColor(0.7607, 0.7607, 0.7607, 1.0)
	DISABLE_COLOR = grp.GenerateColor(0.9, 0.4745, 0.4627, 1.0)
	NEGATIVE_COLOR = grp.GenerateColor(0.9, 0.4745, 0.4627, 1.0)
	POSITIVE_COLOR = grp.GenerateColor(0.5411, 0.7254, 0.5568, 1.0)
	SPECIAL_POSITIVE_COLOR = grp.GenerateColor(0.6911, 0.8754, 0.7068, 1.0)
	SPECIAL_POSITIVE_COLOR2 = grp.GenerateColor(0.8824, 0.9804, 0.8824, 1.0)
	CONDITION_COLOR = 0xffBEB47D
	CAN_LEVEL_UP_COLOR = 0xff8EC292
	CANNOT_LEVEL_UP_COLOR = DISABLE_COLOR
	NEED_SKILL_POINT_COLOR = 0xff9A9CDB
	def __init__(self, width = TOOL_TIP_WIDTH, isPickable=False):
		ThinBoard.__init__(self, "TOP_MOST")
		if isPickable:
			pass
		else:
			self.AddFlag("not_pick")
		self.AddFlag("float")
		self.followFlag = True
		self.toolTipWidth = width
		self.xPos = -1
		self.yPos = -1
		self.defFontName = 'Tahoma:12'
		self.ClearToolTip()
	def __del__(self):
		ThinBoard.__del__(self)
	def ClearToolTip(self):
		self.toolTipHeight = 12
		self.childrenList = []
	def SetFollow(self, flag):
		self.followFlag = flag
	def SetDefaultFontName(self, fontName):
		self.defFontName = fontName
	def AppendSpace(self, size):
		self.toolTipHeight += size
		self.ResizeToolTip()
	def AppendHorizontalLine(self):
		for i in range(2):
			horizontalLine = Line()
			horizontalLine.SetParent(self)
			horizontalLine.SetPosition(0, self.toolTipHeight + 3 + i)
			horizontalLine.SetWindowHorizontalAlignCenter()
			horizontalLine.SetSize(150, 0)
			horizontalLine.Show()
			if 0 == i:
				horizontalLine.SetColor(0xff555555)
			else:
				horizontalLine.SetColor(0xff000000)
			self.childrenList.append(horizontalLine)
		self.toolTipHeight += 11
		self.ResizeToolTip()
	def AlignHorizonalCenter(self):
		for child in self.childrenList:
			(x, y)=child.GetLocalPosition()
			child.SetPosition(self.toolTipWidth/2, y)
		self.ResizeToolTip()
	def AutoAppendTextLine(self, text, color = FONT_COLOR, centerAlign = True):
		textLine = Textline()
		textLine.SetParent(self)
		textLine.SetFontName(self.defFontName)
		textLine.SetPackedFontColor(color)
		textLine.SetText(text)
		textLine.SetOutline()
		textLine.SetFeather(False)
		textLine.Show()
		if centerAlign:
			textLine.SetPosition(self.toolTipWidth/2, self.toolTipHeight)
			textLine.SetHorizontalAlignCenter()
		else:
			textLine.SetPosition(10, self.toolTipHeight)
		self.childrenList.append(textLine)
		(textWidth, textHeight)=textLine.GetTextSize()
		textWidth += 40
		textHeight += 5
		if self.toolTipWidth < textWidth:
			self.toolTipWidth = textWidth
		self.toolTipHeight += textHeight
		return textLine
	def AppendTextLine(self, text, color = FONT_COLOR, centerAlign = True):
		textLine = Textline()
		textLine.SetParent(self)
		textLine.SetFontName(self.defFontName)
		textLine.SetPackedFontColor(color)
		textLine.SetText(text)
		textLine.SetOutline()
		textLine.SetFeather(False)
		textLine.Show()
		if centerAlign:
			textLine.SetPosition(self.toolTipWidth/2, self.toolTipHeight)
			textLine.SetHorizontalAlignCenter()
		else:
			textLine.SetPosition(10, self.toolTipHeight)
		self.childrenList.append(textLine)
		self.toolTipHeight += self.TEXT_LINE_HEIGHT
		self.ResizeToolTip()
		return textLine
	def ResizeToolTip(self):
		self.SetSize(self.toolTipWidth, self.TOOL_TIP_HEIGHT + self.toolTipHeight)
	def SetTitle(self, name):
		self.AppendTextLine(name, self.TITLE_COLOR)
	def GetLimitTextLineColor(self, curValue, limitValue):
		if curValue < limitValue:
			return self.DISABLE_COLOR
		return self.ENABLE_COLOR
	def SetToolTipPosition(self, x = -1, y = -1):
		self.xPos = x
		self.yPos = y
	def ShowToolTip(self):
		self.SetTop()
		self.Show()
		self.OnUpdate()
	def HideToolTip(self):
		self.Hide()
	def OnUpdate(self):
		if not self.followFlag:
			return
		x = 0
		y = 0
		width = self.GetWidth()
		height = self.toolTipHeight
		if -1 == self.xPos and -1 == self.yPos:
			(mouseX, mouseY) = wndMgr.GetMousePosition()
			if mouseY < wndMgr.GetScreenHeight() - 300:
				y = mouseY + 40
			else:
				y = mouseY - height - 30
			x = mouseX - width/2				
		else:
			x = self.xPos - width/2
			y = self.yPos - height
		x = max(x, 0)
		y = max(y, 0)
		x = min(x + width/2, wndMgr.GetScreenWidth() - width/2) - width/2
		y = min(y + self.GetHeight(), wndMgr.GetScreenHeight()) - self.GetHeight()
		parentWindow = self.GetParentProxy()
		if parentWindow:
			(gx, gy) = parentWindow.GetGlobalPosition()
			x -= gx
			y -= gy
		self.SetPosition(x, y)
try:
	import _weakref
	from _weakref import proxy
except:
	pass
def __mem_func__(func):
	return func
current_index = 1
def is_valid_vid(vid):
	a = chr.GetInstanceType(vid)
	if a is None or a == -1:
		return False
	distance = GetDis(vid)
	if distance < 0 or distance >= 59000:
		return False
	return True
if find_string(st_cur_server, "tensho"):
	if not hasattr(Item, "SetMouseWheelScrollEvent"):
		def SetMouseWheelScrollEvent(self, event):
			pass
		Item.SetMouseWheelScrollEvent = SetMouseWheelScrollEvent
# CONFIG ----------------------------------------------------------------
def requiredLowVid():
	if getCharIndex() >= 500000:
		return 1
	return 0
	
try:
	getMyIndex = getCharIndex()
	LOW_MAX = int(getMyIndex + getMyIndex * 0.3)	
except:	
	LOW_MAX		 = 2000000
if find_string(st_cur_server, "mystic"):
	LOW_CHUNK	   = 100
	HIGH_CHUNK	  = 500	
else:
	LOW_CHUNK	   = 700
	HIGH_CHUNK	  = 1750
CLEAN_INTERVAL  = 600	
vidsSet = set()
high_ptr	 = 0
last_clean   = 0.0
def _total_range(my_vid):
	if my_vid < 500000:
		return 1000000
	if my_vid < 2000000:
		return 3000000
	return int(my_vid * 13 / 10) 
def _scan_chunk(start_vid, stop_vid, chunk):
	end_vid = start_vid + chunk
	if end_vid > stop_vid:
		end_vid = stop_vid
	vid = start_vid
	while vid < end_vid:
		if is_valid_vid(vid) and HasInstance(vid):
			if vid not in vidsSet:
				vidsSet.add(vid)
				vidsListEnd1.append(vid)
		vid += 1
	return vid
def populate_vids_from_zero():
	global current_index, vidsListEnd1, manualVidRange, maxThreshhold
	if newPython:
		
		limits = [10000, 12000, 15000, 20000, 30000]
	else:
		limits = [3000, 3500, 4000, 5000, 6000]
	getMyIndex = getCharIndex()
	TOTAL_VALUES = int(getMyIndex + getMyIndex * 0.3)
	startFromZero = 1
	if current_index >= TOTAL_VALUES or current_index == 0:
		current_index = 0
	if not manualVidRange:
		ranges = []
		for i in range(10):
			ranges.append((i * 10000000, (i + 1) * 10000000))
		idx = 0
		for range_item in ranges:
			low, high = range_item
			if low <= TOTAL_VALUES <= high:
				maxThreshhold = limits[min(idx, len(limits) - 1)]
				break
			idx += 1
	end_index = min(current_index + maxThreshhold, TOTAL_VALUES)
	for vid in range(current_index, end_index):
		if is_valid_vid(vid):
			if vid not in vidsListEnd1:
				vidsListEnd1.append(vid)
	current_index += maxThreshhold
try:
	_perf = time.perf_counter
except AttributeError:
	_perf = None
	
def _now():
	if _perf:
		return _perf()
	return time.time()
def getFps():
	try:
		return app.GetRenderFPS()
	except:
		return -1
if newPython:
	def populate_vids():
		global current_index, vidsListEnd1, manualVidRange, maxThreshhold, newPython
	
		limits = [10000, 12000, 15000, 20000, 30000]
		startFromZero = 0
		getMyIndex = getCharIndex()
		if getMyIndex <= 2000000:
			TOTAL_VALUES = 3000000
			startFromZero = 1
		else:
			# limits = [1000, 1500, 2000, 2500, 3000]
		# elif getMyIndex <= 1000000:
			# TOTAL_VALUES = 2000000
			# limits = [1000, 1500, 2000, 3000, 4000]
		# elif getMyIndex >= 10000000:
			TOTAL_VALUES = int(getMyIndex + getMyIndex * 0.3)
			startFromZero = 0
	
		if current_index >= TOTAL_VALUES or current_index == 0:
			if startFromZero:
				current_index = 0
			else:
				current_index = int(getMyIndex * 0.7)
	
		if not manualVidRange:
			ranges = []
			for i in range(10):
				ranges.append((i * 10000000, (i + 1) * 10000000))
		
			idx = 0
			for range_item in ranges:
				low, high = range_item
				if low <= TOTAL_VALUES <= high:
					maxThreshhold = limits[min(idx, len(limits) - 1)]
					break
				idx += 1
		
		end_index = min(current_index + maxThreshhold, TOTAL_VALUES)
		
		# msg("my limits: " + str(limits))
		# msg("TOTAL_VALUES: %d" % (TOTAL_VALUES))
		# msg("manualVidRange: %d" % (manualVidRange))
		# msg("my index: %d" % (getMyIndex))
		# msg("current_index: %d" % (current_index))
		# msg("maxThreshhold: %d" % (maxThreshhold))
		# msg("end_index: %d" % (end_index))
		# msg("len vidsListEnd1: " + str(len(vidsListEnd1)))
		# msg("__________________________________")
		
		# msg("Processing from {%d} to {%d}" % (current_index, end_index))
		for vid in range(current_index, end_index):
			if is_valid_vid(vid):
				if vid not in vidsListEnd1:
					vidsListEnd1.append(vid)
					# msg("Added VID {%d} to vidsListEnd1" % (vid))
		
		current_index += maxThreshhold
		try:
			vidsListEnd1[:] = [i for i in vidsListEnd1 if HasInstance(i)]
			if len(vidsListEnd1) >= 1000:
				vidsListEnd1 = []
		except:
			pass
else:
	def populate_vids(): #0.04
		global current_index, high_ptr, last_clean,panicMode
		if panicMode:
			return
		my_vid = getCharIndex()
		total  = _total_range(my_vid)
		if current_index >= LOW_MAX:
			current_index = 0
		current_index = _scan_chunk(current_index, LOW_MAX, LOW_CHUNK)
		high_start = int(my_vid * 7 / 10)
		if high_ptr < high_start or high_ptr >= total:
			high_ptr = high_start
		high_ptr = _scan_chunk(high_ptr, total, HIGH_CHUNK)
		now = _now()
		if now - last_clean >= CLEAN_INTERVAL:
	
			keep = []
			v = 0
			length = len(vidsListEnd1)
			while v < length:
				vid = vidsListEnd1[v]
				if HasInstance(vid):
					keep.append(vid)
				v += 1
			vidsListEnd1[:] = keep
			vidsSet.intersection_update(keep)
	
			last_clean = now
		
def is_level_logged(level):
	playerName = getcharName()
	fullDir = st_path + "/Data/Servers/" + str(st_cur_server) + "/Logs/" + str(playerName) + ".log"
	
	level_str = "up to level: " + str(level)
	
	try:
		f = open_file(fullDir, "r+")
		log_lines = f.readlines()
		f.close()
	
		for line in log_lines:
			if line.strip().endswith(level_str):
				return True
	except:
		pass
	
	return False
	
def log_level_Func():
	global previous_level
	
	try:
		current_level = player.GetStatus(player.LEVEL)
		if previous_level is None or previous_level == -1:
			previous_level = current_level
			return
	
		if current_level > previous_level:
			if not is_level_logged(current_level):
				create_log("Character leveled up to level: " + str(current_level))
	
			previous_level = current_level
	
	except:
		pass
	
class teleportingWnd(ScriptWindow):
	def __init__(self):
		ScriptWindow.__init__(self)
		self.rescounter=0
		self.nr=0
		self.bleble=0
		self.eventTimeOver = lambda *arg: None
		self.eventExit = lambda *arg: None
	def __del__(self):
		try:
			ScriptWindow.__del__(self)
		except:
			pass
	def otwoz(self, waitTime):
		if waitTime==9999999.0:
			self.bleble=1
		if foundNewPythonList:
			try:
				curTime = time.perf_counter()
			except:
				pass
		else:		
			try:
				curTime = time.clock()
			except:
				pass
		self.endTime = curTime + waitTime
		self.Show()
	def Close(self):
		self.Hide()
	def Destroy(self):
		self.Hide()
	def czas1(self, event):
		self.eventTimeOver = __mem_func__(event)
	def czas2(self, event):
		self.eventTimeOver = __mem_func__(event)
	def czas3(self, event):
		self.eventExit = __mem_func__(event)
		
	def OnUpdate(self):
		global canUseVid, targetVID_Start, targetVID_End, restartCounter
		global antiBantargetVID_Start,antiBantargetVID_End,antiBanrestartCounter,antiBanplayerDetected,antiBancanScan,antiBanrestartCountPD
		global canSearchPlayerVids, maxThreshhold,manualVidRange,vidsListEnd1,npcList,NPCtargetVID_End,NPCtargetVID_Start,NPCrestartCounter,updateCounter1,updateCounter2,updateCounter3
		global isGF,farmEnable
		if foundNewPythonList:
			lastTime = max(0, self.endTime - time.perf_counter()) 
		else:		
			lastTime = max(0, self.endTime - time.clock()) 
		if find_string(st_cur_server, "amg"):
			limit = 50
		else:
			limit = 2000
		
		
		try:
			if isConnect():
				getMyIndex = getCharIndex()
				# limit = 2000
				resetList = 0
				resetListVal = 0
				plusValue = 1
				
				# perform_logs
				
				log_level_Func()
				
				# perform_logs
				
				
				if canWalkTele == 1:
					try:
						curHp = player.GetStatus(player.HP)
					except:
						curHp = 1
					if curHp >= 1:
						try:
							if metin2.cabla>0 and self.bleble==1:
								c=metin2.boka / metin2.cabla * self.nr+1
								d=metin2.bokb / metin2.cabla * self.nr+1
								x, y, z = player.GetMainCharacterPosition()
								xx=metin2.x
								yy=metin2.y
								if metin2.cooordx>x:
									xx=metin2.x+c
								else:
									xx=metin2.x-c
								if metin2.cooordy>y:
										yy=metin2.y+d
								else:
									yy=metin2.y-d
								chr.SelectInstance(getMyIndex)
								setPixelPos(int(xx), int(yy), int(z))
								onKeyDown(appKey('UP'))
								self.nr=self.nr+1
								if self.rescounter==10:
									self.rescounter=0
								self.rescounter=self.rescounter+1
								if self.rescounter>5:
									if foundx64PythonList:
										onKeyUp(player.DIR_UP)	
									else:
										onKeyUp(appKey('UP'))
								else:
									onKeyDown(appKey('UP'))
								if metin2.cabla<=self.nr+1:
									metin2.cabla=0
									self.nr=0
									if foundx64PythonList:
										onKeyUp(player.DIR_UP)	
									else:
										onKeyUp(appKey('UP'))
						except:
							pass
				if not isGF:
					populate_vids()
					if requiredLowVid() and getFps() >= 15:
						populate_vids_from_zero()
					
					
				else:
					vidsListEnd1 = list(set(eXLib.InstancesList))
		except:
			pass
		if 0 == lastTime:
			self.Close()
			self.eventTimeOver()
		else:
			return None
		return None
	def OnPressExitKey(self):
		self.Close()
		return True
try:
	pupaczas=teleportingWnd()
	pupaczas.otwoz(9999999.0)
except:
	pass
class ItemListDialog(Window):
	def __init__(self, onAdd,x,y):
		Window.__init__(self)
		if find_string(st_cur_server, "alune") or find_string(st_cur_server, "merlis") or find_string(st_cur_server, "tensho") or find_string(st_cur_server, "kronius") or find_string(st_cur_server, "next2play"):
			self.Board = ui.BoardWithTitleBar()
		else:
			self.Board = BoardWithTitleBar()
		self.Board.SetCloseEvent(self.Close)
		self.Board.SetTitleName("Item List")
		self.Board.SetSize(270, 335)
		self.Board.SetPosition(x, y)
		self.Board.AddFlag(movplable)
		self.Board.Show()
		self.onAdd = onAdd
		self.comp = Component()
		self.ItemValueText = self.comp.TextLine(self.Board, 'Search item:', 79, 33, self.comp.RGB(255, 255, 255))
		self.SearchPickItemButton = self.comp.Button(self.Board, lang.STR_SEARCH_BTN, '', 217, 48, self.SearchItems, small1, small2, small3)
		self.SelectBonus = self.comp.Button(self.Board, lang.STR_ADD, '', 25, 295, self.addItem, middle1, middle2, middle3)
		self.CancelBonus = self.comp.Button(self.Board, 'Cancel', '', 175, 295, self.Close, middle1, middle2, middle3)
		self.PickSearchItemSlotBar, self.PickSearchItemEditLine = self.comp.EditLine(self.Board, '', 15, 50, 180, 15, 50)
		self.PickfileListBoxBar, self.PickfileListBox, self.PickScrollBar = self.comp.ListBoxEx2(self.Board, 15, 80, 220, 200)
		# if not find_string(st_cur_server, "m2classic"):
		self.PickfileListBox.SetViewItemCount(10)
		self.UpdateFileList(1)
	def addItem(self):
		item = self.PickfileListBox.GetSelectedItem()
		if item == None:
			return None
		item = item.GetText()
		splits = item.split(" ",1)
		self.onAdd(int(splits[0]))
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hItem list: Added to list:" + str(splits[1]))
	def __del__(self):
		try:
			Window.__del__(self)
		except:
			pass
	def Show(self):
		Window.Show(self)
	def Close(self):
		self.Board.Hide()
		self.__del__()
	def SearchItems(self):
		search_query = self.PickSearchItemEditLine.GetText().lower().strip()
		self.__RefreshFileList()
		if not search_query:
			self.UpdateFileList(1)
			return
		itemList = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'item_list.txt'
		try:
			lines = [line.strip() for line in open_file(itemList, "r+").readlines()]
		except Exception:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCan't retrieve item list, please check your file.")
			return
		for i in range(0, len(lines), 2):
			try:
				Itemname = lines[i]
				Index = lines[i+1]
				if not Itemname or not Index:
					continue
				if search_query in Itemname.lower():
					self.PickfileListBox.AppendItem(Item(Index + "  " + Itemname))
			except IndexError:
				continue
	def UpdateFileList(self,mode):
		global isGF
		SearchName = str(self.PickSearchItemEditLine.GetText().lower())
		SelectedIndex = self.PickfileListBox.GetSelectedItem()
		self.__RefreshFileList()
		itemList = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'item_list.txt'
		if find_string(st_cur_server, "helles"):
			f = open_file(itemList,'w+')
			for i in range(0,80000):
				selectItem(i)
				if item.GetItemType() != 6:
					n = item.GetItemName()
					if n!= "":
						f.write(n + "\n" + str(i) + "\n")
			f.close()
		else:
			if not os.path.exists(itemList):
				lines = None
				try:
					lines = open_file(app.GetLocalePath()+"/item_list.txt", "r+").readlines()
				except:
					pass
				if not lines:
					f = open_file(itemList,'w+')
					for i in range(0,100000):
						selectItem(i)
						if item.GetItemType() != 6:
							n = item.GetItemName()
							if n!= "":
								f.write(n + "\n" + str(i) + "\n")
					f.close()
				else:
					results = []
					for line in lines:
						tokens = str(line).split("\t")
						Index = str(tokens[0])
						try:
							Itemname = item.GetItemName(selectItem(int(Index)))
							results.append((Itemname, Index))
						except:
							continue
					f = open_file(itemList, 'w+')
					for Itemname, Index in results:
						f.write(Itemname + "\n" + str(Index) + "\n")
					f.close()
					
		try:
			lines = [line.strip() for line in open_file(itemList, "r+").readlines()]
		except Exception:
			msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCan't retrieve item list, please check your file.")
			return
		for i in range(0, len(lines), 2):
			try:
				Itemname = lines[i]
				Index = lines[i+1]
				if mode == 1:
					if Index and Itemname != "":
						self.PickfileListBox.AppendItem(Item(Index + "  " + Itemname))
				elif mode == 2:
					if SearchName in Itemname.lower():
						self.PickfileListBox.AppendItem(Item(Index + "  " + Itemname))
						break 
			except IndexError:
				continue
	def __RefreshFileList(self):
		try:
			self.PickfileListBox.RemoveAllItems()
		except:
			pass
class PopupDialog(ScriptWindow):
	def __init__(self, layer="TOP_MOST"):
		ScriptWindow.__init__(self, layer)
		# self.AddFlag("animated_board")
		self.__LoadDialog()
		self.acceptEvent = None
	def __LoadDialog(self):
		try:
			PythonScriptLoader = ui.PythonScriptLoader()
			PythonScriptLoader.LoadScriptFile(self, "UIScript/PopupDialog.py")
			self.board = self.GetChild("board")
			self.message = self.GetChild("message")
			self.accceptButton = self.GetChild("accept")
			self.accceptButton.SetEvent(self.Close)
		except:
			pass
	def Open(self):
		self.SetCenterPosition()
		self.SetTop()
		self.Show()
	def Close(self):
		self.Hide()
		if self.acceptEvent:
			self.acceptEvent()
	def Destroy(self):
		self.Close()
		self.ClearDictionary()
	def SetWidth(self, width):
		height = self.GetHeight()
		self.SetSize(width, height)
		self.board.SetSize(width, height)
		self.SetCenterPosition()
		self.UpdateRect()
	def SetText(self, text):
		self.message.SetText(text)
	def SetAcceptEvent(self, event):
		self.acceptEvent = event
	def SetButtonName(self, name):
		self.accceptButton.SetText(name)
	def OnKeyDown(self, key):
		if appKey('RETURN') == key:
			return False
		self.Close()
		return True
class QuestionDialog(ScriptWindow):
	def __init__(self, layer="TOP_MOST"):
		ScriptWindow.__init__(self, layer)
		self.__CreateDialog()
	def __del__(self):
		ScriptWindow.__del__(self)
	def __CreateDialog(self):
		pyScrLoader = ui.PythonScriptLoader()
		pyScrLoader.LoadScriptFile(self, "uiscript/questiondialog.py")
		self.board = self.GetChild("board")
		self.textLine = self.GetChild("message")
		self.acceptButton = self.GetChild("accept")
		self.cancelButton = self.GetChild("cancel")
	def Open(self):
		self.SetCenterPosition()
		self.SetTop()
		self.Show()
	def Close(self):
		self.Hide()
	def SetWidth(self, width):
		height = self.GetHeight()
		self.SetSize(width, height)
		self.board.SetSize(width, height)
		self.SetCenterPosition()
	def SetAcceptEvent(self, event):
		self.acceptButton.SetEvent(event)
	def SetCancelEvent(self, event):
		self.cancelButton.SetEvent(event)
	def SetText(self, text):
		self.textLine.SetText(text)
	def OnPressEscapeKey(self):
		self.Close()
		return True
class QuestionDialog2(QuestionDialog):
	def __init__(self):
		QuestionDialog.__init__(self)
		self.__CreateDialog()
	def __del__(self):
		QuestionDialog.__del__(self)
	def __CreateDialog(self):
		pyScrLoader = ui.PythonScriptLoader()
		pyScrLoader.LoadScriptFile(self, "uiscript/questiondialog2.py")
		self.board = self.GetChild("board")
		self.textLine1 = self.GetChild("message1")
		self.textLine2 = self.GetChild("message2")
		self.acceptButton = self.GetChild("accept")
		self.cancelButton = self.GetChild("cancel")
	def SetText1(self, text):
		self.textLine1.SetText(text)
	def SetText2(self, text):
		self.textLine2.SetText(text)
componentServerList = [
	"merlis", "velia", "DDMT", "Nw2Online", "nextworld", "tensho",
	"LandOfHeroes", "Sancy", "SoW2", "Zemia", "lucerna", "veshia",
	"next2play", "Origins", "Invision", "everin", "solaris","atheria", "alune","metin3","mt2classichu","rhodium"
]
if isGF or any([find_string(st_cur_server, server) for server in componentServerList]):
	class Component:
		def xRadioButton(parent, x, y, path, up, over, down):
			button = RadioButton()
			button.SetParent(parent)
			button.SetPosition(x, y)
			button.SetUpVisual(path + up)
			button.SetOverVisual(path + over)
			button.SetDownVisual(path + down)
			button.Show()
			return button 
		def CheckBoxx(self, parent, label, x, y, eventUp, eventDown):
			checkbox = CheckBox(label)
			if parent is not None:
				checkbox.SetParent(parent)
			checkbox.SetPosition(x, y)
			checkbox.eventUp = eventUp
			checkbox.eventDown = eventDown
			checkbox.Show()
			return checkbox
		def Button2(self, parent, buttonName, tooltipText, x, y, sx, sy, func):
			button = CoolButton()
			if parent is not None:
				button.SetParent(parent)
			button.SetPosition(x, y)
			button.SetSize(sx, sy)
			button.SetText(buttonName)
			button.SetToolTipText(tooltipText)
			button.Show()
			button.SetEvent(func)
			return button
		def Button(self, parent, buttonName, tooltipText, x, y, func, UpVisual, OverVisual, DownVisual):
			button = ui.Button()
			if parent != None:
				button.SetParent(parent)
			button.SetPosition(x, y)
			button.SetUpVisual(UpVisual)
			button.SetOverVisual(OverVisual)
			button.SetDownVisual(DownVisual)
			button.SetText(buttonName)
			button.SetToolTipText(tooltipText)
			button.Show()
			button.SetEvent(func)
			return button
		def OnOffButton(self,parent,buttonName, tooltipText,x,y,image=None,OffUpVisual=onOffButtonLoc + '/off_0.tga', OffOverVisual=onOffButtonLoc + '/off_1.tga', OffDownVisual=onOffButtonLoc + '/off_2.tga',OnUpVisual=onOffButtonLoc + '/on_0.tga', OnOverVisual=onOffButtonLoc + '/on_1.tga', OnDownVisual=onOffButtonLoc + '/on_2.tga',xImgOffset = 15,yImgOffset = 15,funcState=None,defaultValue=0):
			if image != None:
				image = self.ExpandedImage(parent,x,y,image)
				x += xImgOffset
				y += yImgOffset
			button = OnOffButton(OffUpVisual, OffOverVisual, OffDownVisual,OnUpVisual, OnOverVisual, OnDownVisual,image=image,funcState=funcState,defaultValue=defaultValue)
			if parent != None:
				button.SetParent(parent)
			button.SetPosition(x, y)
			button.SetText("				"+ str(buttonName))
			button.SetToolTipText(tooltipText)
			button.Show()
			return button
		def HideButton(self, parent, buttonName, tooltipText, x, y, func, UpVisual, OverVisual, DownVisual):
			button = ui.Button()
			if parent != None:
				button.SetParent(parent)
			button.SetPosition(x, y)
			button.SetUpVisual(UpVisual)
			button.SetOverVisual(OverVisual)
			button.SetDownVisual(DownVisual)
			button.SetText(buttonName)
			button.SetToolTipText(tooltipText)
			button.SetEvent(func)
			return button
		def SlotbarText(self, parent, editlineText, x, y, width, heigh):
			SlotBar = ui.SlotBar()
			SlotBar.SetParent(parent)
			SlotBar.SetSize(width, heigh)
			SlotBar.SetPosition(x, y)
			SlotBar.Show()
			TextLine = ui.TextLine()
			TextLine.SetParent(SlotBar)
			TextLine.SetText(editlineText)
			TextLine.SetHorizontalAlignCenter()
			TextLine.SetVerticalAlignCenter()
			try:
				TextLine.SetWindowHorizontalAlignCenter()
				TextLine.SetWindowVerticalAlignCenter()
			except:
				pass
			TextLine.Show()
			return SlotBar, TextLine
		def ToggleButton(self, parent, buttonName, tooltipText, x, y, funcUp, funcDown, UpVisual, OverVisual, DownVisual):
			button = ui.ToggleButton()
			if parent != None:
				button.SetParent(parent)
			button.SetPosition(x, y)
			button.SetUpVisual(UpVisual)
			button.SetOverVisual(OverVisual)
			button.SetDownVisual(DownVisual)
			button.SetText(buttonName)
			button.SetToolTipText(tooltipText)
			button.Show()
			button.SetToggleUpEvent(funcUp)
			button.SetToggleDownEvent(funcDown)
			return button
		def EditLine(self, parent, editlineText, x, y, width, heigh, max):
			SlotBar = ui.SlotBar()
			if parent != None:
				SlotBar.SetParent(parent)
			SlotBar.SetSize(width, heigh)
			SlotBar.SetPosition(x, y)
			SlotBar.Show()
			Value = ui.EditLine()
			Value.SetParent(SlotBar)
			Value.SetSize(width, heigh)
			Value.SetPosition(1, 1)
			Value.SetMax(max)
			Value.SetLimitWidth(width)
			Value.SetMultiLine()
			Value.SetText(editlineText)
			Value.Show()
			return SlotBar, Value
		def TextLine(self, parent, textlineText, x, y, color):
			textline = ui.TextLine()
			if parent != None:
				textline.SetParent(parent)
			if IsARABIC():
				textline.SetPosition(x + 100, y)
			else:
				textline.SetPosition(x, y)
			if color != None:
				textline.SetFontColor(color[0], color[1], color[2])
			textline.SetText(textlineText)
			textline.Show()
			return textline
		def RGB(self, r, g, b):
			return (r*255, g*255, b*255)
		def SliderBar(self, parent, sliderPos, func, x, y):
			Slider = SliderBar()
			if parent != None:
				Slider.SetParent(parent)
			Slider.SetPosition(x, y)
			Slider.SetSliderPos(sliderPos / 100)
			Slider.Show()
			Slider.SetEvent(func)
			return Slider
		def ExpandedImage(self, parent, x, y, img):
			image = ui.ExpandedImageBox()
			if parent != None:
				image.SetParent(parent)
			image.SetPosition(x, y)
			image.LoadImage(img)
			image.Show()
			return image
		def ListBoxEx1(self, parent, x, y, width, heigh, SVIC, event):
			bar = ui.Bar()
			if parent != None:
				bar.SetParent(parent)
			bar.SetPosition(x, y)
			bar.SetSize(width, heigh)
			bar.SetColor(0x77000000)
			bar.Show()
			ListBox=ui.ListBoxEx()
			ListBox.SetParent(bar)
			ListBox.SetPosition(0, 0)
			ListBox.SetSize(width, heigh)
			ListBox.SetViewItemCount(SVIC)
			ListBox.SetSelectEvent(event)
			ListBox.Show()
			scroll = ui.ScrollBar()
			scroll.SetParent(ListBox)
			scroll.SetPosition(width-15, 0)
			scroll.SetScrollBarSize(heigh)
			scroll.Show()
			ListBox.SetScrollBar(scroll)
			return bar, ListBox
		def ThinBoard(self, parent, moveable, x, y, width, heigh, center):
			thin = ui.ThinBoard()
			if parent != None:
				thin.SetParent(parent)
			if moveable == True:
				thin.AddFlag(movplable)
				thin.AddFlag('float')
			thin.SetSize(width, heigh)
			thin.SetPosition(x, y)
			if center == True:
				thin.SetCenterPosition()
			thin.Show()
			return thin
		def Gauge(self, parent, width, color, x, y):
			gauge = ui.Gauge()
			if parent != None:
				gauge.SetParent(parent)
			gauge.SetPosition(x, y)
			gauge.MakeGauge(width, color)
			gauge.Show()
			return gauge
		def HorizontalBar(self, parent, x, y, Create):
			horizontalBar = ui.HorizontalBar()
			if parent != None:
				horizontalBar.SetParent(parent)
			horizontalBar.SetPosition(x, y)
			horizontalBar.Create(Create)
			horizontalBar.Show()
			return horizontalBar
		def TextLine_SetPackedFontColor(self, parent, textlineText, x, y, color):
			TextLine_SetPackedFontColor = ui.TextLine()
			if parent != None:
				TextLine_SetPackedFontColor.SetParent(parent)
			TextLine_SetPackedFontColor.SetPosition(x, y)
			TextLine_SetPackedFontColor.SetPackedFontColor(color)
			TextLine_SetPackedFontColor.SetText(textlineText)
			TextLine_SetPackedFontColor.Show()
			return TextLine_SetPackedFontColor
		def HorizontalBarHide(self, parent, x, y, Create):
			horizontalBar = ui.HorizontalBar()
			if parent != None:
				horizontalBar.SetParent(parent)
			horizontalBar.SetPosition(x, y)
			horizontalBar.Create(Create)
			horizontalBar.Hide()
			return horizontalBar
		def TextLine_SetPackedFontColorHide(self, parent, textlineText, x, y, color):
			TextLine_SetPackedFontColor = ui.TextLine()
			if parent != None:
				TextLine_SetPackedFontColor.SetParent(parent)
			TextLine_SetPackedFontColor.SetPosition(x, y)
			TextLine_SetPackedFontColor.SetPackedFontColor(color)
			TextLine_SetPackedFontColor.SetText(textlineText)
			TextLine_SetPackedFontColor.Hide()
			return TextLine_SetPackedFontColor
		def HideButton(self, parent, buttonName, tooltipText, x, y, func, UpVisual, OverVisual, DownVisual):
			button = ui.Button()
			if parent != None:
				button.SetParent(parent)
			button.SetPosition(x, y)
			button.SetUpVisual(UpVisual)
			button.SetOverVisual(OverVisual)
			button.SetDownVisual(DownVisual)
			button.SetText(buttonName)
			button.SetToolTipText(tooltipText)
			button.SetEvent(func)
			return button
		def ToggleButton(self, parent, buttonName, tooltipText, x, y, funcUp, funcDown, UpVisual, OverVisual, DownVisual):
			button = ui.ToggleButton()
			if parent != None:
				button.SetParent(parent)
			button.SetPosition(x, y)
			button.SetUpVisual(UpVisual)
			button.SetOverVisual(OverVisual)
			button.SetDownVisual(DownVisual)
			button.SetText(buttonName)
			button.SetToolTipText(tooltipText)
			button.Show()
			button.SetToggleUpEvent(funcUp)
			button.SetToggleDownEvent(funcDown)
			return button
		def EditLine(self, parent, editlineText, x, y, width, heigh, max):
			SlotBar = ui.SlotBar()
			if parent != None:
				SlotBar.SetParent(parent)
			SlotBar.SetSize(width, heigh)
			SlotBar.SetPosition(x, y)
			SlotBar.Show()
			Value = ui.EditLine()
			Value.SetParent(SlotBar)
			Value.SetSize(width, heigh)
			Value.SetPosition(8, 2)
			Value.SetMax(max)
			Value.SetLimitWidth(width)
			Value.SetMultiLine()
			Value.SetText(editlineText)
			try:
				Value.SetIMEFlag(3)
			except:
				pass
			Value.Show()
			return SlotBar, Value
		def OnlyEditLine(self, parent, width, heigh, x, y, editlineText, max):
			Value = ui.EditLine()
			if parent != None:
				Value.SetParent(parent)
			Value.SetSize(width, heigh)
			Value.SetPosition(x, y)
			Value.SetMax(max)
			Value.SetText(editlineText)
			Value.SetNumberMode()
			Value.Show()
			return Value
		def TextLine(self, parent, textlineText, x, y, color):
			textline = ui.TextLine()
			if parent != None:
				textline.SetParent(parent)
			if IsARABIC():
				textline.SetPosition(x + 80, y)
			else:
				textline.SetPosition(x, y)
			if color != None:
				textline.SetFontColor(color[0], color[1], color[2])
			textline.SetText(textlineText)
			try:
				textline.SetOutline()
			except:
				pass
			textline.Show()
			return textline
		def RGB(self, r, g, b):
			return (r*255, g*255, b*255)
		def ExpandedImage(self, parent, x, y, img, tooltip=None):
			image = ui.ExpandedImageBox()
			if parent != None:
				image.SetParent(parent)
			image.SetPosition(x, y)
			image.LoadImage(img)
			image.Show()
			return image
		def ComboBox(self, parent, text, x, y, width):
			if find_string(st_cur_server, "LegendofMetin") or find_string(st_cur_server, "Anthology2"):
				combo = ComboBox()
				if parent != None:
					combo.SetParent(parent)
				combo.SetPosition(x, y)
				combo.SetSize(width, 15)
				combo.SetCurrentItem(text)
				combo.Show()
				return combo
			elif find_string(st_cur_server, "Sanctury"):
				combo = ComboBox()
				if parent != None:
					combo.SetParent(parent)
				combo.SetPosition(x, y)
				combo.SetSize(width, 15)
				combo.SetCurrentItem(text)
				combo.Show()
				return combo
			else:
				combo = ui.ComboBox()
				if parent != None:
					combo.SetParent(parent)
				combo.SetPosition(x, y)
				combo.SetSize(width, 15)
				combo.SetCurrentItem(text)
				combo.Show()
				return combo
		def ThinBoard(self, parent, moveable, x, y, width, heigh, center):
			thin = ui.ThinBoard()
			if parent != None:
				thin.SetParent(parent)
			try:
				if moveable == True:
					thin.AddFlag(movplable)
					thin.AddFlag('float')
				thin.SetSize(width, heigh)
				thin.SetPosition(x, y)
				if center == True:
					thin.SetCenterPosition()
				thin.Show()
				return thin
			except:
				pass
		def Gauge(self, parent, width, color, x, y):
			gauge = ui.Gauge()
			if parent != None:
				gauge.SetParent(parent)
			gauge.SetPosition(x, y)
			gauge.MakeGauge(width, color)
			gauge.Show()
			return gauge
		def ListBoxEx2(self, parent, x, y, width, heigh):
			bar = ui.Bar()
			if parent != None:
				bar.SetParent(parent)
			bar.SetPosition(x, y)
			bar.SetSize(width + 20, heigh)
			bar.SetColor(1996488704)
			bar.Show()
			if isGF or find_string(st_cur_server, "LegendofMetin") or find_string(st_cur_server, "Anthology2"):
				ListBox = ListBoxEx()
			else:
				ListBox = ui.ListBoxEx()
			ListBox.SetParent(bar)
			ListBox.SetPosition(0, 0)
			ListBox.SetViewItemCount(8)
			ListBox.SetSize(width, heigh)
			ListBox.Show()
			if find_string(st_cur_server, "Metin2BR"):
				scroll = ScrollBar()
			else:
				scroll = ui.ScrollBar()
			scroll.SetParent(bar)
			scroll.SetPosition(width + 5, 0)
			scroll.SetScrollBarSize(heigh)
			scroll.Show()
			ListBox.SetScrollBar(scroll)
			return (bar, ListBox, scroll)	
		def FileListBox(self, parent, x, y, width, heigh, count):
			if find_string(st_cur_server, "LegendofMetin") or find_string(st_cur_server, "Anthology2"):
				ListBox = ListBoxEx()
			else:
				ListBox = ui.ListBoxEx()
			ListBox.SetParent(parent)
			ListBox.SetPosition(x, y)
			ListBox.SetViewItemCount(count)
			ListBox.SetSize(width, heigh)
			ListBox.Show()
			scroll = ui.ScrollBar()
			scroll.SetParent(ListBox)
			scroll.SetPosition(width - 20, 0)
			scroll.SetScrollBarSize(heigh)
			scroll.Show()
			ListBox.SetScrollBar(scroll)
			return ListBox, scroll
		def ReadingListBox(self, parent, x, y, width, heigh, count):
			bar = ui.Bar()
			if parent != None:
				bar.SetParent(parent)
			bar.SetPosition(x, y)
			bar.SetSize(width + 20, heigh)
			bar.Show()
			if find_string(st_cur_server, "LegendofMetin") or find_string(st_cur_server, "Anthology2"):
				ListBox = ListBoxEx()
			else:
				ListBox = ui.ListBoxEx()
			ListBox.SetParent(bar)
			ListBox.SetPosition(10, 13)
			ListBox.SetViewItemCount(count)
			ListBox.SetSize(width, heigh)
			ListBox.Show()
			return bar, ListBox
		def ListBoxEx(self, parent, x, y, width, heigh):
			if find_string(st_cur_server, "LegendofMetin") or find_string(st_cur_server, "Anthology2"):
				bar = ui.Bar()
				if parent != None:
					bar.SetParent(parent)
				bar.SetPosition(x, y)
				bar.SetSize(width, heigh)
				bar.SetColor(0x77000000)
				bar.Show()
				ListBox=ListBoxEx()
				ListBox.SetParent(bar)
				ListBox.SetPosition(0, 0)
				ListBox.SetSize(width, heigh)
				ListBox.Show()
				scroll = ui.ScrollBar()
				scroll.SetParent(ListBox)
				scroll.SetPosition(width-15, 0)
				scroll.SetScrollBarSize(heigh)
				scroll.Show()
				ListBox.SetScrollBar(scroll)
				return bar, ListBox
			else:
				bar = ui.Bar()
				if parent != None:
					bar.SetParent(parent)
				bar.SetPosition(x, y)
				bar.SetSize(width, heigh)
				bar.SetColor(0x77000000)
				bar.Show()
				ListBox=ui.ListBoxEx()
				ListBox.SetParent(bar)
				ListBox.SetPosition(0, 0)
				ListBox.SetSize(width, heigh)
				ListBox.Show()
				scroll = ui.ScrollBar()
				scroll.SetParent(ListBox)
				scroll.SetPosition(width-15, 0)
				scroll.SetScrollBarSize(heigh)
				scroll.Show()
				ListBox.SetScrollBar(scroll)
				return bar, ListBox
		def GetCurrentText(self):
			return self.textLine.GetText()
		if find_string(st_cur_server, "Rubinum") or find_string(st_cur_server, "saphirus") or find_string(st_cur_server, "m2classic"):
			ui.ComboBox.GetCurrentText = GetCurrentText
		else:
			try:
				def OnSelectItem(self, index, name):
					self.SetCurrentItem(name)
					self.CloseListBox()
					try:
						self.event()
					except:
						pass
				ui.ComboBox.GetCurrentText = GetCurrentText
				ui.ComboBox.OnSelectItem = OnSelectItem
			except:
				pass
	###################################
	class OnOffButton(ui.Button):
		def __init__(self,OffUpVisual, OffOverVisual, OffDownVisual,OnUpVisual, OnOverVisual, OnDownVisual, image=None,tooltip=None,funcState=None,defaultValue=0):
			defaultValue = bool(defaultValue)
			ui.Button.__init__(self)
			self.OffUpVisual = OffUpVisual
			self.OffOverVisual = OffOverVisual 
			self.OffDownVisual = OffDownVisual
			self.OnUpVisual = OnUpVisual
			self.OnOverVisual = OnOverVisual
			self.OnDownVisual = OnDownVisual
			self.FuncState = funcState
			self.isOn = not defaultValue
			self.ExpandedImage = image 
			self.SetEvent(self.OnChange)
			self.OnChange()
		def OnChange(self):
			if self.isOn is True:
				self.SetOff()
			else:
				self.SetOn()
			if self.FuncState is not None:
				self.FuncState(self.isOn)
		def SetValue(self, val):
			if val == 1 or val is True:
				self.SetOn()
			else:
				self.SetOff()
		def SetOn(self):
			self.SetUpVisual(self.OnUpVisual)
			self.SetOverVisual(self.OnOverVisual)
			self.SetDownVisual(self.OnDownVisual)
			self.isOn = True
		def SetOff(self):
			self.SetUpVisual(self.OffUpVisual)
			self.SetOverVisual(self.OffOverVisual)
			self.SetDownVisual(self.OffDownVisual)
			self.isOn = False
		def __del__(self):
			try:
				self.Hide()
				if self.image is not None:
					self.image.Hide()
					self.image.__del__()
				ui.Button.__del__(self)
			except:
				pass
else:
	class Component:
		def Button(self, parent, buttonName, tooltipText, x, y, func, UpVisual, OverVisual, DownVisual):
			button = Button()
			if parent != None:
				button.SetParent(parent)
			button.SetPosition(x, y)
			button.SetUpVisual(UpVisual)
			button.SetOverVisual(OverVisual)
			button.SetDownVisual(DownVisual)
			button.SetText(buttonName)
			button.SetToolTipText(tooltipText)
			button.Show()
			button.SetEvent(func)
			return button
		def CheckBoxx(self, parent, label, x, y, eventUp, eventDown):
			checkbox = CheckBox(label)
			if parent is not None:
				checkbox.SetParent(parent)
			checkbox.SetPosition(x, y)
			checkbox.eventUp = eventUp
			checkbox.eventDown = eventDown
			checkbox.Show()
			return checkbox
		def Button2(self, parent, buttonName, tooltipText, x, y, sx, sy, func):
			button = CoolButton()
			if parent is not None:
				button.SetParent(parent)
			button.SetPosition(x, y)
			button.SetSize(sx, sy)
			button.SetText(buttonName)
			button.SetToolTipText(tooltipText)
			button.Show()
			button.SetEvent(func)
			return button
		def ListBoxEx2(self, parent, x, y, width, heigh):
			bar = Bar()
			if parent != None:
				bar.SetParent(parent)
			bar.SetPosition(x, y)
			bar.SetSize(width + 20, heigh)
			bar.SetColor(1996488704)
			bar.Show()
			ListBox = ListBoxEx()
			ListBox.SetParent(bar)
			ListBox.SetPosition(0, 0)
			ListBox.SetViewItemCount(5)
			ListBox.SetSize(width, heigh)
			ListBox.Show()
			if find_string(st_cur_server, "aronix"):
				scroll = ui.ScrollBar()
			else:
				scroll = ScrollBar()
			scroll.SetParent(bar)
			scroll.SetPosition(width + 5, 0)
			scroll.SetScrollBarSize(heigh)
			scroll.Show()
			ListBox.SetScrollBar(scroll)
			return (bar, ListBox, scroll)
		def FileListBox(self, parent, x, y, width, heigh, count):
			if find_string(st_cur_server, "LegendofMetin") or find_string(st_cur_server, "Anthology2") :
				ListBox = ListBoxEx()
			else:
				ListBox = ui.ListBoxEx()
			ListBox.SetParent(parent)
			ListBox.SetPosition(x, y)
			ListBox.SetViewItemCount(count)
			ListBox.SetSize(width, heigh)
			ListBox.Show()
			scroll = ui.ScrollBar()
			scroll.SetParent(ListBox)
			scroll.SetPosition(width - 20, 0)
			scroll.SetScrollBarSize(heigh)
			scroll.Show()
			ListBox.SetScrollBar(scroll)
			return ListBox, scroll
		def OnOffButton(self,parent,buttonName, tooltipText,x,y,image=None,OffUpVisual=onOffButtonLoc + '/off_0.tga', OffOverVisual=onOffButtonLoc + '/off_1.tga', OffDownVisual=onOffButtonLoc + '/off_2.tga',OnUpVisual=onOffButtonLoc + '/on_0.tga', OnOverVisual=onOffButtonLoc + '/on_1.tga', OnDownVisual=onOffButtonLoc + '/on_2.tga',xImgOffset = 15,yImgOffset = 15,funcState=None,defaultValue=0):
			if image != None:
				image = self.ExpandedImage(parent,x,y,image)
				x += xImgOffset
				y += yImgOffset
			button = OnOffButton(OffUpVisual, OffOverVisual, OffDownVisual,OnUpVisual, OnOverVisual, OnDownVisual,image=image,funcState=funcState,defaultValue=defaultValue)
			if parent != None:
				button.SetParent(parent)
			button.SetPosition(x, y)
			button.SetText("				"+ str(buttonName))
			button.SetToolTipText(tooltipText)
			button.Show()
			return button
		def ToggleButton(self, parent, buttonName, tooltipText, x, y, funcUp, funcDown, UpVisual, OverVisual, DownVisual):
			button = ToggleButton()
			if parent != None:
				button.SetParent(parent)
			button.SetPosition(x, y)
			button.SetUpVisual(UpVisual)
			button.SetOverVisual(OverVisual)
			button.SetDownVisual(DownVisual)
			button.SetText(buttonName)
			button.SetToolTipText(tooltipText)
			button.Show()
			button.SetToggleUpEvent(funcUp)
			button.SetToggleDownEvent(funcDown)
			return button
			
		if find_string(st_cur_server, "kronius"):
			def EditLine(self, parent, editlineText, x, y, width, heigh, max):
				SlotBar = ui.SlotBar()
				if parent != None:
					SlotBar.SetParent(parent)
				SlotBar.SetSize(width, heigh)
				SlotBar.SetPosition(x, y)
				SlotBar.Show()
				Value = ui.EditLine()
				Value.SetParent(SlotBar)
				Value.SetSize(width, heigh)
				Value.SetPosition(1, 1)
				Value.SetMax(max)
				Value.SetLimitWidth(width)
				Value.SetMultiLine()
				Value.SetText(editlineText)
				Value.Show()
				return SlotBar, Value
		else:
			
			
			def EditLine(self, parent, editlineText, x, y, width, heigh, max):
				SlotBar = Slotbar()
				if parent != None:
					SlotBar.SetParent(parent)
				SlotBar.SetSize(width, heigh)
				SlotBar.SetPosition(x, y)
				SlotBar.Show()
				Value = EditLine()
				Value.SetParent(SlotBar)
				Value.SetSize(width, heigh)
				Value.SetPosition(1, 1)
				Value.SetMax(max)
				Value.SetLimitWidth(width)
				Value.SetMultiLine()
				Value.SetText(editlineText)
				Value.Show()
				return SlotBar, Value
		def SlotbarText(self, parent, editlineText, x, y, width, heigh):
			SlotBar = Slotbar()
			SlotBar.SetParent(parent)
			SlotBar.SetSize(width, heigh)
			SlotBar.SetPosition(x, y)
			SlotBar.Show()
			TextLine = Textline()
			TextLine.SetParent(SlotBar)
			TextLine.SetText(editlineText)
			TextLine.SetHorizontalAlignCenter()
			TextLine.SetVerticalAlignCenter()
			TextLine.SetWindowHorizontalAlignCenter()
			TextLine.SetWindowVerticalAlignCenter()
			TextLine.Show()
			return SlotBar, TextLine
		def TextLine(self, parent, textlineText, x, y, color):
			textline = Textline()
			if parent != None:
				textline.SetParent(parent)
			if IsARABIC():
				textline.SetPosition(x + 80, y)
			else:
				textline.SetPosition(x, y)
			if color != None:
				textline.SetFontColor(color[0], color[1], color[2])
			textline.SetText(textlineText)
			textline.Show()
			return textline
		def RGB(self, r, g, b):
			return (r*255, g*255, b*255)
		def SliderBar(self, parent, sliderPos, func, x, y):
			Slider = SliderBar()
			if parent != None:
				Slider.SetParent(parent)
			Slider.SetPosition(x, y)
			Slider.SetSliderPos(sliderPos / 100)
			Slider.Show()
			Slider.SetEvent(func)
			return Slider
		def ExpandedImage(self, parent, x, y, img):
			image = ExpandedImageBox()
			if parent != None:
				image.SetParent(parent)
			image.SetPosition(x, y)
			image.LoadImage(img)
			image.Show()
			return image
			
		def ComboBox(self, parent, text, x, y, width):
			combo = ComboBox()
			if parent != None:
				combo.SetParent(parent)
			combo.SetPosition(x, y)
			combo.SetSize(width, 15)
			combo.SetCurrentItem(text)
			combo.Show()
			return combo
		def ThinBoard(self, parent, moveable, x, y, width, heigh, center):
			thin = ThinBoard()
			if parent != None:
				thin.SetParent(parent)
			if moveable == True:
				thin.AddFlag(movplable)
				thin.AddFlag('float')
			thin.SetSize(width, heigh)
			thin.SetPosition(x, y)
			if center == True:
				thin.SetCenterPosition()
			thin.Show()
			return thin
		def ListBoxEx(self, parent, x, y, width, heigh):
			if find_string(st_cur_server, "LegendofMetin") or find_string(st_cur_server, "Anthology2") :
				bar = Bar()
				if parent != None:
					bar.SetParent(parent)
				bar.SetPosition(x, y)
				bar.SetSize(width, heigh)
				bar.SetColor(0x77000000)
				bar.Show()
				ListBox=ListBoxEx()
				ListBox.SetParent(bar)
				ListBox.SetPosition(0, 0)
				ListBox.SetSize(width, heigh)
				ListBox.Show()
				scroll = ScrollBar()
				scroll.SetParent(ListBox)
				scroll.SetPosition(width-15, 0)
				scroll.SetScrollBarSize(heigh)
				scroll.Show()
				ListBox.SetScrollBar(scroll)
				return bar, ListBox
			else:
				bar = Bar()
				if parent != None:
					bar.SetParent(parent)
				bar.SetPosition(x, y)
				bar.SetSize(width, heigh)
				bar.SetColor(0x77000000)
				bar.Show()
				ListBox=ListBoxEx()
				ListBox.SetParent(bar)
				ListBox.SetPosition(0, 0)
				ListBox.SetSize(width, heigh)
				ListBox.Show()
				if find_string(st_cur_server, "aronix"):
					scroll = ui.ScrollBar()
				else:
					scroll = ScrollBar()
				scroll.SetParent(ListBox)
				scroll.SetPosition(width-15, 0)
				scroll.SetScrollBarSize(heigh)
				scroll.Show()
				ListBox.SetScrollBar(scroll)
				return bar, ListBox
	class OnOffButton(Button):
		def __init__(self,OffUpVisual, OffOverVisual, OffDownVisual,OnUpVisual, OnOverVisual, OnDownVisual, image=None,tooltip=None,funcState=None,defaultValue=0):
			defaultValue = bool(defaultValue)
			Button.__init__(self)
			self.OffUpVisual = OffUpVisual
			self.OffOverVisual = OffOverVisual 
			self.OffDownVisual = OffDownVisual
			self.OnUpVisual = OnUpVisual
			self.OnOverVisual = OnOverVisual
			self.OnDownVisual = OnDownVisual
			self.FuncState = funcState
			self.isOn = not defaultValue
			self.ExpandedImage = image 
			self.SetEvent(self.OnChange)
			self.OnChange()
		def OnChange(self):
			if self.isOn is True:
				self.SetOff()
			else:
				self.SetOn()
			if self.FuncState is not None:
				self.FuncState(self.isOn)
		def SetValue(self, val):
			if val == 1 or val is True:
				self.SetOn()
			else:
				self.SetOff()
		def SetOn(self):
			self.SetUpVisual(self.OnUpVisual)
			self.SetOverVisual(self.OnOverVisual)
			self.SetDownVisual(self.OnDownVisual)
			self.isOn = True
		def SetOff(self):
			self.SetUpVisual(self.OffUpVisual)
			self.SetOverVisual(self.OffOverVisual)
			self.SetDownVisual(self.OffDownVisual)
			self.isOn = False
		def __del__(self):
			try:
				self.Hide()
				if self.image is not None:
					self.image.Hide()
					self.image.__del__()
				Button.__del__(self)
			except:
				pass
class Bar3D(Window):
	def __init__(self):
		Window.__init__(self)
	def RegisterWindow(self, layer):
		self.hWnd = wndMgr.RegisterBar3D(self, layer)
	def SetColor(self, left, right, center):
		wndMgr.SetColor(self.hWnd, left, right, center)
class STButton(Window):
	BACKGROUND_COLOR = grp.GenerateColor(0.0, 0.0, 0.0, 0.0)
	DARK_COLOR = grp.GenerateColor(0.4, 0.4, 0.4, 0.0)
	WHITE_COLOR = grp.GenerateColor(0.0, 0.0, 0.0, 0.0)
	HALF_WHITE_COLOR = grp.GenerateColor(0.0, 0.0, 0.0, 0.0)
	def __init__(self, layer = "TOP_MOST"):
		Window.__init__(self, layer)
		self.eventFunc = None
		self.eventArgs = None
		self.ButtonText = None
		self.isOver = False
		self.isSelected = False
		self.width = 0
		self.height = 0		
	def __del__(self):
		try:
			Window.__del__(self)
		except:
			pass
		self.eventFunc = None
		self.eventArgs = None
	def SetSize(self, width, height):
		Window.SetSize(self, width, height)
		self.width = width
		self.height = height
	def SetEvent(self, func, *args):
		self.eventFunc = func
		self.eventArgs = args
	def SetTextColor(self, color):
		if not self.ButtonText:
			return
		self.ButtonText.SetPackedFontColor(color)
	def SetText(self, text):
		if not self.ButtonText:
			textLine = Textline()
			textLine.SetParent(self)
			textLine.SetPosition(self.GetWidth()/2, self.GetHeight()/2)
			textLine.SetVerticalAlignCenter()
			textLine.SetHorizontalAlignCenter()
			try:
				textLine.SetOutline()
			except:
				pass
			textLine.Show()
			self.ButtonText = textLine
		self.ButtonText.SetText(text)
	def OnMouseLeftButtonDown(self):
		self.isSelected = True
	def OnMouseLeftButtonUp(self):
		self.isSelected = False
		if self.eventFunc:
			self.eventFunc(*self.eventArgs)
	if find_string(st_cur_server, "Alune"):
		def OnLoop(self):
			if self.IsIn():
				self.isOver = True
			else:
				self.isOver = False
	else:
		def OnUpdate(self):
			if self.IsIn():
				self.isOver = True
			else:
				self.isOver = False
	def OnRender(self):
		xRender, yRender = self.GetGlobalPosition()
		widthRender = self.width
		heightRender = self.height
		grp.SetColor(self.BACKGROUND_COLOR)
		grp.RenderBar(xRender, yRender, widthRender, heightRender)
		grp.SetColor(self.DARK_COLOR)
		grp.RenderLine(xRender, yRender, widthRender, 0)
		grp.RenderLine(xRender, yRender, 0, heightRender)
		grp.RenderLine(xRender, yRender+heightRender, widthRender, 0)
		grp.RenderLine(xRender+widthRender, yRender, 0, heightRender)
		if self.isOver:
			grp.SetColor(self.HALF_WHITE_COLOR)
			grp.RenderBar(xRender + 2, yRender + 2, self.width - 3, heightRender - 3)
			if self.isSelected:
				grp.SetColor(self.WHITE_COLOR)
				grp.RenderBar(xRender + 2, yRender + 2, self.width - 3, heightRender - 3)

def DivideToFloat(x, y):
	try:
		return x * y ** (-1)
	except:
		return 0
def dutew():
	onKeyDown(appKey('W'))
	onKeyUp(appKey('W'))
def dutes():
	onKeyDown(appKey('S'))
	onKeyUp(appKey('S'))
def dutea():
	onKeyDown(appKey('A'))
	onKeyUp(appKey('A'))
def duted():
	onKeyDown(appKey('D'))
	onKeyUp(appKey('D'))
def GetXSide(cRot):
	if int(cRot) < 0:
		return -1
	else:
		return 1
def GetYside(cRot):
	if int(cRot) < 0:
		cRot = cRot * -1
	if cRot > 90:
		return -1
	else:
		return -1
def radians(degrees):
	return degrees * math.pi / 180.0
def GetSin(cRot):
	return math.sin(radians(cRot))
def GetCos(cRot):
	return math.cos(radians(cRot))
def create_log(name):
	if getcharName():
		playerName = getcharName()
	else:
		playerName = "no_name_stmod"
	if str(playerName) != None:
		dirWithoutPlayer = st_path + "/Data/Servers/" + str(st_cur_server) + "/Logs/"
		fullDir = st_path + "/Data/Servers/" + str(st_cur_server) + "/Logs/" + str(playerName)
		try:
			os.mkdir(dirWithoutPlayer)
		except:
			pass
		time_string = time.strftime("%d.%m.%Y, %H:%M:%S")
	
		f = open_file(fullDir + ".log", "a")
		f.write(time_string + " -> " + name + "\n")
		f.close()
		
def playBeep(how = "beep"):
	dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'beep'
	if os.path.exists(dirPl):
		non_detect = open_file(dirPl, "w")
		non_detect.write('1_' + str(how))
		non_detect.close()
	else:
		non_detect = open_file(dirPl, "w")
		non_detect.write('1_' + str(how))
		non_detect.close()
def appendWhisper(name, msg):
	global isGF
	if isGF:
		chat.AppendWhisper(0, name, msg, 1252)
	else:
		chat.AppendWhisper(0, name, msg)
	try:
		create_log("You replied with: " + str(msg))
	except:
		pass
		
def extract_numbers(message):
	numbers = ""
	for char in message:
		if char.isdigit():
			numbers += char
		elif numbers:
			break
	if numbers:
		return numbers
	else:
		return None
def is_valid_captcha(message):
	words = message.split()
	digit_count = 0
	for word in words:
		if word.isdigit():
			digit_count += 1

	return digit_count == 1 and len(message) <= 10
def get_message(line, name):
	try:
		return line.split(name + " : ")[1]
	except IndexError:
		return line
		
def setReply(var):
	global autoReply
	autoReply = var
if find_string(st_cur_server, "Rubinum") or find_string(st_cur_server, "saphirus") or find_string(st_cur_server, "m2classic"):
	def AnswerMinimizedWhisper(name, message):
		global AnswerTuple
		global TmpMessageDict
		global PrivateMessages, autoReply,replyDelayGlobal,useQuestion,repeatMessage,pauseReply
		global autoReply
		o = getCharIndex()
		charName = chr.GetNameByVID(o)
		if autoReply == 1:
			if pauseReply:
				return
			try:
				tmp = []
				for Keyword in AnswerTuple:
					if message.lower().find(Keyword) != -1:
						tmp.append(Keyword)
				Keyword = ""
				if tmp != []:
					CheckLenght = len(tmp[0])
					Keyword = tmp[0]
				for MatchedKeyword in tmp:
					if len(MatchedKeyword) >= CheckLenght:
						Keyword = MatchedKeyword
						
				try:
					waitTime = replyDelayGlobal
				except:
					waitTime = 2.0				
				max_offset = min(5.0, waitTime)
				random_offset = getRandom(0, int(max_offset * 10)) / 10.0				
				randomizedWait = waitTime + random_offset				
				replyDelayGlobal = randomizedWait
						
				if Keyword == "":
					if useQuestion == 1 and name != str(charName):
						time.sleep(float(replyDelayGlobal))
						SendWhisper(name, '??')
						autoReply = 0
						eventHandler.add(0.5, lambda: setReply(1))
					elif repeatMessage == 1 and name != str(charName):
						time.sleep(float(replyDelayGlobal))
						SendWhisper(name, message)
						autoReply = 0
						eventHandler.add(0.5, lambda: setReply(1))
					else:
						pass
				else:
					if name != str(charName):
						Choice = AnswerTuple[Keyword]
						Answer = Choice[getRandom(0, len(Choice) - 1)]
						TmpMessageDict = [name, message, Answer]
						PrivateMessages[name].append([name, message, Answer])
						time.sleep(float(replyDelayGlobal))
						SendWhisper(name, Answer)
						autoReply = 0
						eventHandler.add(0.5, lambda: setReply(1))
			except:
				pass
elif foundx64PythonList:
	def AnswerMinimizedWhisper(name, message):
		global AnswerTuple
		global TmpMessageDict
		global PrivateMessages, autoReply,replyDelayGlobal,useQuestion,receivedMessage,repeatMessage,pauseReply
		if autoReply == 1:
			if pauseReply:
				return
			try:
				tmp = []
				for Keyword in AnswerTuple:
					if message.lower().find(Keyword) != -1:
						tmp.append(Keyword)
				Keyword = ""
				if tmp != []:
					CheckLenght = len(tmp[0])
					Keyword = tmp[0]
				for MatchedKeyword in tmp:
					if len(MatchedKeyword) >= CheckLenght:
						Keyword = MatchedKeyword
						
				try:
					waitTime = replyDelayGlobal
				except:
					waitTime = 2.0				
				max_offset = min(5.0, waitTime)
				random_offset = getRandom(0, int(max_offset * 10)) / 10.0				
				randomizedWait = waitTime + random_offset				
				replyDelayGlobal = randomizedWait
						
				if Keyword == "":
					if useQuestion == 1:
						time.sleep(float(replyDelayGlobal))
						SendWhisper(name, '??')
					elif repeatMessage == 1:
						time.sleep(float(replyDelayGlobal))
						SendWhisper(name, message)
				else:
					Choice = AnswerTuple[Keyword]
					Answer = Choice[getRandom(0, len(Choice) - 1)]
					TmpMessageDict = [name, message, Answer]
					PrivateMessages[name].append([name, message, Answer])
					time.sleep(float(replyDelayGlobal))
					SendWhisper(name, Answer)
				receivedMessage = 0
			except:
				pass
else:
	responseTracker = {}
	userReplyCounts = {}
	unknownMessageCounts = {}
	
	def cleanMessage(raw_message):
		parts = raw_message.split()
		cleaned_parts = []
	
		for part in parts:
			if part.startswith("|c") and len(part) == 10:
				continue
	
			cleaned_parts.append(part)
	
		return " ".join(cleaned_parts).strip()
	
	
	def AnswerMinimizedWhisper(name, message):
		global AnswerTuple
		global TmpMessageDict
		global PrivateMessages, autoReply, replyDelayGlobal, useQuestion, receivedMessage, repeatMessage, pauseReply
		global sentMessageCounts, responseTracker, userReplyCounts, unknownMessageCounts
		global replyTimes, replyTimesVal
	
		if autoReply == 1:
			if pauseReply:
				return
	
			tmp = []
			message = cleanMessage(message)
	
			for Keyword in AnswerTuple:
				if message.lower().find(Keyword) != -1:
					tmp.append(Keyword)
	
			Keyword = ""
			if tmp:
				CheckLenght = len(tmp[0])
				Keyword = tmp[0]
			for MatchedKeyword in tmp:
				if len(MatchedKeyword) >= CheckLenght:
					Keyword = MatchedKeyword
			if name not in userReplyCounts:
				userReplyCounts[name] = {}
			if message not in unknownMessageCounts:
				unknownMessageCounts[message] = 0
			try:
				waitTime = replyDelayGlobal
			except:
				waitTime = 2.0				
			max_offset = min(5.0, waitTime)
			random_offset = getRandom(0, int(max_offset * 10)) / 10.0				
			randomizedWait = waitTime + random_offset				
			replyDelayGlobal = randomizedWait
			if Keyword == "":
				if unknownMessageCounts[message] >= replyTimesVal:
					return
				unknownMessageCounts[message] += 1  
	
				if useQuestion == 1:
					questionMessage = "??"
					if replyTimes == 1:
						if userReplyCounts[name].get(questionMessage, 0) >= replyTimesVal:
							return
					eventHandler.add(float(replyDelayGlobal), lambda: SendWhisper(name, questionMessage))
					eventHandler.add(float(replyDelayGlobal), lambda: appendWhisper(name, str(getcharName()) + " : " + str(questionMessage)))
					if replyTimes == 1:
						userReplyCounts[name][questionMessage] = userReplyCounts[name].get(questionMessage, 0) + 1
	
				elif repeatMessage == 1:
					try:
						if replyTimes == 1:
							if userReplyCounts[name].get(message, 0) >= replyTimesVal:
								return
						eventHandler.add(float(replyDelayGlobal), lambda: SendWhisper(name, message))
						eventHandler.add(float(replyDelayGlobal), lambda: appendWhisper(name, str(getcharName()) + " : " + str(message)))
						if replyTimes == 1:
							userReplyCounts[name][message] = userReplyCounts[name].get(message, 0) + 1
					except:
						pass
			else:
				Choice = AnswerTuple[Keyword]
				if Keyword not in responseTracker:
					responseTracker[Keyword] = 0
	
				AnswerIndex = responseTracker[Keyword]
				Answer = Choice[AnswerIndex]
				responseTracker[Keyword] = (AnswerIndex + 1) % len(Choice)
				if replyTimes == 1:
					if userReplyCounts[name].get(Keyword, 0) >= replyTimesVal:
						return
	
				TmpMessageDict = [name, message, Answer]
				PrivateMessages[name].append([name, message, Answer])
				eventHandler.add(float(replyDelayGlobal), lambda: SendWhisper(name, Answer))
				eventHandler.add(float(replyDelayGlobal), lambda: appendWhisper(name, str(getcharName()) + " : " + str(Answer)))
	
				if replyTimes == 1:
					userReplyCounts[name][Keyword] = userReplyCounts[name].get(Keyword, 0) + 1
	
			receivedMessage = 0
def pmNotifyLog(arg):
	dirPl = st_path + "/Data/Servers/" + str(st_cur_server) + "/" + 'pmNotify'
	non_detect = open_file(dirPl, "w")
	non_detect.write(str(arg))
	non_detect.close()
	
try:
	if find_string(st_cur_server, "Kimetsu"):
		def HookedOnRecvWhisper(self, mode, name, line, isGM):
			global OldOnRecvWhisper
			global PrivateMessages
			global MinimizedWhisper,quitGameIfGMPM,playBeepSound,repeatMessage,autoReply,windowsNotifyOnPm
			global thread
			try:
				OldOnRecvWhisper(self, mode, name, line, isGM)
			except:
				OldOnRecvWhisper(self, mode, name, line)
			if not name in PrivateMessages:
				PrivateMessages[name] = []
			Message = line.split(name + " : ")[1]
			try:
				if windowsNotifyOnPm:
					myName = str(getcharName())
					msgx = str(myName) + " @ " + str(st_cur_server) + " - " + str(name) + ": " + str(Message)
					pmNotifyLog(msgx)
			except:
				pass
			if quitGameIfGMPM == 1:
				plm = "["
				if str(plm) in name:
					if "gmPmCount" not in globals():
						gmPmCount = 0
					gmPmCount += 1
					
					create_log(str("GM sent you a PM (" + str(gmPmCount) + "/" + str(gmPmCountMax) + ")"))
					
					if gmPmCount >= int(gmPmCountMax):
						create_log("Exiting client, GM sent you " + str(gmPmCount) + "/" + str(gmPmCountMax) + " PMs")
						universalTime(1)
			if playBeepSound == 1:
				playBeep("beep")
			if repeatMessage == 1:
				if autoReply:
					try:
						SendWhisper(name, Message)
					except:
						pass
			else:
				try:
					if not thread:
						import thread
					thread.start_new_thread(AnswerMinimizedWhisper, (name, Message))
				except:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCan't initialize whisper reply packet!")
			create_log(str(name) + " sent you a message: " + str(Message))
	elif find_string(st_cur_server, "Rodnia"):
		def HookedOnRecvWhisper(self, mode, name, line, Rodnia):
			global OldOnRecvWhisper
			global PrivateMessages
			global MinimizedWhisper,quitGameIfGMPM,playBeepSound,repeatMessage,windowsNotifyOnPm
			global thread
			OldOnRecvWhisper(self, mode, name, line, Rodnia)
			if not name in PrivateMessages:
				PrivateMessages[name] = []
			Message = Rodnia
			
			try:
				if windowsNotifyOnPm:
					myName = str(getcharName())
					msgx = str(myName) + " @ " + str(st_cur_server) + " - " + str(name) + ": " + str(Message)
					pmNotifyLog(msgx)
			except:
				pass
			
			if quitGameIfGMPM == 1:
				plm = "["
				if str(plm) in name:
					if "gmPmCount" not in globals():
						gmPmCount = 0
					gmPmCount += 1
					
					create_log(str("GM sent you a PM (" + str(gmPmCount) + "/" + str(gmPmCountMax) + ")"))
					
					if gmPmCount >= int(gmPmCountMax):
						create_log("Exiting client, GM sent you " + str(gmPmCount) + "/" + str(gmPmCountMax) + " PMs")
						universalTime(1)
			if playBeepSound == 1:
				playBeep("beep")
			if repeatMessage == 1:
				if autoReply:
					try:
						SendWhisper(name, Message)
					except:
						pass
			else:
				try:
					if not thread:
						import thread
					thread.start_new_thread(AnswerMinimizedWhisper, (name, Message))
				except:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCan't initialize whisper reply packet!")
			create_log("PM received from: " + str(Message))
	elif find_string(st_cur_server, "Esenn"):
		def HookedOnRecvWhisper(self, name, line):
			global OldOnRecvWhisper
			global PrivateMessages
			global MinimizedWhisper,quitGameIfGMPM,playBeepSound,repeatMessage,autoReply,windowsNotifyOnPm
			global thread
			OldOnRecvWhisper(self, name, line)
			if not name in PrivateMessages:
				PrivateMessages[name] = []
			parts = line.split(':')
			if len(parts) == 2:
				string2 = parts[1].strip()
				line = string2
			if repeatMessage == 1:
				if autoReply:
					try:
						SendWhisper(name, line)
					except:
						pass
			else:
				try:
					if not thread:
						import thread
					thread.start_new_thread(AnswerMinimizedWhisper, (name, line))
				except:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCan't initialize whisper reply packet!")
					
			try:
				if windowsNotifyOnPm:
					myName = str(getcharName())
					msgx = str(myName) + " @ " + str(st_cur_server) + " - " + str(name) + ": " + str(line)
					pmNotifyLog(msgx)
			except:
				pass
					
			if quitGameIfGMPM == 1:
				plm = "["
				if str(plm) in name:
					if "gmPmCount" not in globals():
						gmPmCount = 0
					gmPmCount += 1
					
					create_log(str("GM sent you a PM (" + str(gmPmCount) + "/" + str(gmPmCountMax) + ")"))
					
					if gmPmCount >= int(gmPmCountMax):
						create_log("Exiting client, GM sent you " + str(gmPmCount) + "/" + str(gmPmCountMax) + " PMs")
						universalTime(1)
			if playBeepSound == 1:
				playBeep("beep")
			create_log("PM received from: " + str(line))
	elif find_string(st_cur_server, "Erenia"):
		def HookedOnRecvWhisper(self, mode, name, line, job, level, empire, guild, language, status, location, year, month, day):
			global OldOnRecvWhisper
			global PrivateMessages
			global MinimizedWhisper,quitGameIfGMPM,playBeepSound,repeatMessage,autoReply,windowsNotifyOnPm
			global thread
			OldOnRecvWhisper(self, mode, name, line, job, level, empire, guild, language, status, location, year, month, day)
			if not name in PrivateMessages:
				PrivateMessages[name] = []
			Message = line.split(name + " : ")[1]
			create_log(str(name) + " sent you a message: " + str(Message))
			
			try:
				if windowsNotifyOnPm:
					myName = str(getcharName())
					msgx = str(myName) + " @ " + str(st_cur_server) + " - " + str(name) + ": " + str(Message)
					pmNotifyLog(msgx)
			except:
				pass
			
			if quitGameIfGMPM == 1:
				plm = "["
				if str(plm) in name:
					if "gmPmCount" not in globals():
						gmPmCount = 0
					gmPmCount += 1
					
					create_log(str("GM sent you a PM (" + str(gmPmCount) + "/" + str(gmPmCountMax) + ")"))
					
					if gmPmCount >= int(gmPmCountMax):
						create_log("Exiting client, GM sent you " + str(gmPmCount) + "/" + str(gmPmCountMax) + " PMs")
						universalTime(1)
			if playBeepSound == 1:
				playBeep("beep")
			if repeatMessage == 1:
				if autoReply:
					try:
						SendWhisper(name, Message)
					except:
						pass
			else:
				try:
					if not thread:
						import thread
					thread.start_new_thread(AnswerMinimizedWhisper, (name, Message))
				except:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCan't initialize whisper reply packet!")
	elif find_string(st_cur_server, "Remix"):
		def HookedOnRecvWhisper(self, mode, name, line, lang):
			global OldOnRecvWhisper
			global PrivateMessages,autoReply
			global MinimizedWhisper,quitGameIfGMPM,playBeepSound,repeatMessage,windowsNotifyOnPm
			global thread
			OldOnRecvWhisper(self, mode, name, line, lang)
			if not name in PrivateMessages:
				PrivateMessages[name] = []
			Message = line.split(name + " : ")[1]
			create_log(str(name) + " sent you a message: " + str(Message))
			
			try:
				if windowsNotifyOnPm:
					myName = str(getcharName())
					msgx = str(myName) + " @ " + str(st_cur_server) + " - " + str(name) + ": " + str(Message)
					pmNotifyLog(msgx)
			except:
				pass
			
			if quitGameIfGMPM == 1:
				plm = "["
				if str(plm) in name:
					if "gmPmCount" not in globals():
						gmPmCount = 0
					gmPmCount += 1
					
					create_log(str("GM sent you a PM (" + str(gmPmCount) + "/" + str(gmPmCountMax) + ")"))
					
					if gmPmCount >= int(gmPmCountMax):
						create_log("Exiting client, GM sent you " + str(gmPmCount) + "/" + str(gmPmCountMax) + " PMs")
						universalTime(1)
			if playBeepSound == 1:
				playBeep("beep")
			if repeatMessage == 1:
				if autoReply:
					try:
						SendWhisper(name, Message)
					except:
						pass
			else:
				try:
					if not thread:
						import thread
					thread.start_new_thread(AnswerMinimizedWhisper, (name, Message))
				except:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCan't initialize whisper reply packet!")
	elif find_string(st_cur_server, "Rubinum") or find_string(st_cur_server, "saphirus") or find_string(st_cur_server, "m2classic"):
		def HookedOnRecvWhisper(self, mode, name, line, *args, **kwargs):
			global OldOnRecvWhisper
			global PrivateMessages,autoReply
			global MinimizedWhisper,quitGameIfGMPM,playBeepSound,repeatMessage,windowsNotifyOnPm
			OldOnRecvWhisper(self, mode, name, line, *args, **kwargs)
			o = getCharIndex()
			charName = chr.GetNameByVID(o)
			if not name in PrivateMessages:
				PrivateMessages[name] = []
			Message = line.split(" : ")[1]
			create_log(str(name) + " sent you a message: " + str(Message))
			
			try:
				if windowsNotifyOnPm:
					myName = str(getcharName())
					msgx = str(myName) + " @ " + str(st_cur_server) + " - " + str(name) + ": " + str(Message)
					pmNotifyLog(msgx)
			except:
				pass
			
			if quitGameIfGMPM == 1:
				plm = "["
				if str(plm) in name:
					if "gmPmCount" not in globals():
						gmPmCount = 0
					gmPmCount += 1
					
					create_log(str("GM sent you a PM (" + str(gmPmCount) + "/" + str(gmPmCountMax) + ")"))
					
					if gmPmCount >= int(gmPmCountMax):
						create_log("Exiting client, GM sent you " + str(gmPmCount) + "/" + str(gmPmCountMax) + " PMs")
						universalTime(1)
			if playBeepSound == 1:
				playBeep("beep")
			if repeatMessage == 1:
				if autoReply:
					try:
						if name != charName:
							SendWhisper(name, Message)
					except:
						pass
			else:
				try:
					if name != charName:
						AnswerMinimizedWhisper(name, Message)
				except:
					msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCan't initialize whisper reply packet!")
	elif foundx64PythonList:
		def HookedOnRecvWhisper(mode, lang, name, line):
			try:
				global OldOnRecvWhisper
				global PrivateMessages,autoReply
				global MinimizedWhisper,quitGameIfGMPM,playBeepSound,repeatMessage,windowsNotifyOnPm
				OldOnRecvWhisper(mode, lang, name, line)
				if not name in PrivateMessages:
					PrivateMessages[name] = []
				create_log(str(name) + " sent you a message: " + str(line))
				
				try:
					if windowsNotifyOnPm:
						myName = str(getcharName())
						msgx = str(myName) + " @ " + str(st_cur_server) + " - " + str(name) + ": " + str(line)
						pmNotifyLog(msgx)
				except:
					pass
					
				if playBeepSound == 1:
					playBeep("beep")
				if quitGameIfGMPM == 1:
					plm = "["
					if str(plm) in name:
						if "gmPmCount" not in globals():
							gmPmCount = 0
						gmPmCount += 1
						
						create_log(str("GM sent you a PM (" + str(gmPmCount) + "/" + str(gmPmCountMax) + ")"))
						
						if gmPmCount >= int(gmPmCountMax):
							create_log("Exiting client, GM sent you " + str(gmPmCount) + "/" + str(gmPmCountMax) + " PMs")
							universalTime(1)
				AnswerMinimizedWhisper(name, line)
			except:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCan't initialize whisper receiver packet!")
	elif find_string(st_cur_server, "calliope"):
		if app.ENABLE_LANG_AND_EMPIRE_FLAG:
			def HookedOnRecvWhisper(self, mode, name, line, language, empire):
				# try:
				global OldOnRecvWhisper, PrivateMessages, autoReply
				global MinimizedWhisper, quitGameIfGMPM, playBeepSound, repeatMessage
				global gmPmCount, gmPmCountMax,windowsNotifyOnPm
				
				OldOnRecvWhisper(self, mode, name, line, language, empire)
				
				if name not in PrivateMessages:
					PrivateMessages[name] = []
				
				Message = get_message(line, name)
				if "<svside>" not in name:
					
					try:
						if windowsNotifyOnPm:
							myName = str(getcharName())
							msgx = str(myName) + " @ " + str(st_cur_server) + " - " + str(name) + ": " + str(Message)
							pmNotifyLog(msgx)
					except:
						pass
					
					create_log(str(name) + " sent you a message: " + str(line))
				extracted_number = extract_numbers(line)
				if extracted_number and is_valid_captcha(line):
					create_log("Captcha sent: " + str(line) + " to: " + str(name))
					msg("[STM0D] |cffFFFF00|H|h" + lang.CAPTCHA_MSG1)
					SendWhisper(name, line)
					eventHandler.add(1, lambda: msg("[STM0D] |cffFFFF00|H|h" + lang.CAPTCHA_MSG2))
				
				if quitGameIfGMPM == 1 and "[" in name:
					global gmPmCount
					if "gmPmCount" not in globals():
						gmPmCount = 0
					gmPmCount += 1
					create_log(str("GM sent you a PM (" + str(gmPmCount) + "/" + str(gmPmCountMax) + ")"))
					
					if gmPmCount >= int(gmPmCountMax):
						create_log("Exiting client, GM sent you " + str(gmPmCount) + "/" + str(gmPmCountMax) + " PMs")
						universalTime(1)
				
				if playBeepSound == 1:
					playBeep("beep")
				if autoReply and "<svside>" not in name:
					AnswerMinimizedWhisper(name, Message)
				# except:
					# msg("[STM0D] |cffFFFF00|H|hCan't initialize whisper receiver packet!")
	
		else:
			def OnRecvWhisper(self, mode, name, line):
				# try:
				global OldOnRecvWhisper, PrivateMessages, autoReply
				global MinimizedWhisper, quitGameIfGMPM, playBeepSound, repeatMessage
				global gmPmCount, gmPmCountMax,windowsNotifyOnPm
				
				OldOnRecvWhisper(self, mode, name, line)
				
				if name not in PrivateMessages:
					PrivateMessages[name] = []
				
				Message = get_message(line, name)
				if "<svside>" not in name:
					
					try:
						if windowsNotifyOnPm:
							myName = str(getcharName())
							msgx = str(myName) + " @ " + str(st_cur_server) + " - " + str(name) + ": " + str(Message)
							pmNotifyLog(msgx)
					except:
						pass
					
					create_log(str(name) + " sent you a message: " + str(line))
				extracted_number = extract_numbers(line)
				if extracted_number and is_valid_captcha(line):
					create_log("Captcha sent: " + str(line) + " to: " + str(name))
					msg("[STM0D] |cffFFFF00|H|h" + lang.CAPTCHA_MSG1)
					SendWhisper(name, line)
					eventHandler.add(1, lambda: msg("[STM0D] |cffFFFF00|H|h" + lang.CAPTCHA_MSG2))
				
				
				if quitGameIfGMPM == 1 and "[" in name:
					global gmPmCount
					if "gmPmCount" not in globals():
						gmPmCount = 0
					gmPmCount += 1
					create_log(str("GM sent you a PM (" + str(gmPmCount) + "/" + str(gmPmCountMax) + ")"))
					
					if gmPmCount >= int(gmPmCountMax):
						create_log("Exiting client, GM sent you " + str(gmPmCount) + "/" + str(gmPmCountMax) + " PMs")
						universalTime(1)
				
				if playBeepSound == 1:
					playBeep("beep")
				if autoReply and "<svside>" not in name:
					AnswerMinimizedWhisper(name, Message)
				# except:
					# msg("[STM0D] |cffFFFF00|H|hCan't initialize whisper receiver packet!")
	
	else:
		def HookedOnRecvWhisper(self, mode, name, line, *args, **kwargs):
			try:
				global OldOnRecvWhisper
				global PrivateMessages,autoReply
				global MinimizedWhisper,quitGameIfGMPM,playBeepSound,repeatMessage,gmPmCount,gmPmCountMax,windowsNotifyOnPm
				OldOnRecvWhisper(self, mode, name, line, *args, **kwargs)
				if not name in PrivateMessages:
					PrivateMessages[name] = []
				Message = line.split(name + " : ")[1]
				if name.find("<svside>") == -1:
					
					try:
						if windowsNotifyOnPm:
							myName = str(getcharName())
							msgx = str(myName) + " @ " + str(st_cur_server) + " - " + str(name) + ": " + str(Message)
							pmNotifyLog(msgx)
					except:
						pass
					
					create_log(str(name) + " sent you a message: " + str(Message))
				try:
					if name.find("<svside>") != -1:
						if line[line.find(",")-4:line.find(",")].isdigit():
							captcha = line[line.find(", ")-4:line.find(", ")]
							infoCaptcha()
							SendWhisper("<svside>", captcha)
							
				except:
					pass
				if quitGameIfGMPM == 1:
					plm = "["
					if str(plm) in name:
						if "gmPmCount" not in globals():
							gmPmCount = 0
						gmPmCount += 1
						
						create_log(str("GM sent you a PM (" + str(gmPmCount) + "/" + str(gmPmCountMax) + ")"))
						
						if gmPmCount >= int(gmPmCountMax):
							create_log("Exiting client, GM sent you " + str(gmPmCount) + "/" + str(gmPmCountMax) + " PMs")
							universalTime(1)
				if playBeepSound == 1:
					playBeep("beep")
				if autoReply:
					if name.find("<svside>") == -1:
						AnswerMinimizedWhisper(name, Message)
			except:
				msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCan't initialize whisper receiver packet!")
except:
	msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCan't initialize whisper receiver packet!")
def HookedQuestWindow(skin, idx):
	pass
if foundx64PythonList:
	def HookOnRecvWhisper():
		game_window_instance = game.GameWindow.instance()
		game_window_instance.OnRecvWhisper = game_window_instance.OnRecvWhisper
		game_window_instance.OnRecvWhisper = HookedOnRecvWhisper
else:
	def HookOnRecvWhisper():
		try:
			game.GameWindow.OnRecvWhisper = HookedOnRecvWhisper
		except:
			pass
def UnHookHookOnRecvWhisper():
	try:
		global OldOnRecvWhisper
		game.GameWindow.OnRecvWhisper = OldOnRecvWhisper
	except:
		pass
try:
	HookOnRecvWhisper()
except:
	msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hCan't initialize whisper receiver packet!")
	msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hThis means private messages won't be logged.")
	UnHookHookOnRecvWhisper()
def HookedSetHPTargetBoard(self, vid, abc, *kwargs):
	global getHPTarget, canDetachHP
	global OldHPTargetBoard
	if find_string(st_cur_server, "Azyrah"):
		getHPTarget = kwargs[0]
	else:
		getHPTarget = abc
	# HP 0'a dnce annda sonraki hedefe ge
	try:
		if getHPTarget <= 0 and vid > 0:
			global canMove, banList, neededVid, temp_metin_vid, farmEnable, panicMode
			if farmEnable and not panicMode:
				if vid not in banList:
					banList.append(vid)
				if vid == neededVid or vid == temp_metin_vid:
					canMove = 1
	except:
		pass
	try:
		OldHPTargetBoard(self, vid, abc)
		canDetachHP = 1
	except:
		pass
if find_string(st_cur_server, "Esenn"):
	def HookSetHPTargetBoard():
		game_window_instance = game.GameWindow.instance()
		game_window_instance.SetHPTargetBoard = game_window_instance.SetHPTargetBoard
		game_window_instance.SetHPTargetBoard = HookedSetHPTargetBoard
else:
	def HookSetHPTargetBoard():
		game.GameWindow.SetHPTargetBoard = HookedSetHPTargetBoard
def UnHookSetHPTargetBoard():
	global canDetachHP, OldHPTargetBoard
	try:
		game.GameWindow.SetHPTargetBoard = OldHPTargetBoard
		canDetachHP = 0
	except:
		pass
metin2 = xxxxxxxxxx()
	
def start_antiban():
	global metin2
	try:
		metin2.funcAntiBanStart()
	except:
		pass

# ============================================================
# AUTO-START: Farming > Metinler + Start Farm (men almadan)
# DEL tuu: Panic mode toggle
# ============================================================
def autoStartFarming():
	global metin2
	try:
		# Farming tabna ge
		metin2.newFarmingTab_func()
		# Metinler checkbox'n iaretle
		if metin2.farmMetinsCB.checked != 1:
			metin2.farmMetinsCB.OnToggleDown()
		# Unstuck (takl kalnca hafif TP) - ak olduundan emin ol
		try:
			if metin2.unstuckCB.checked != 1:
				metin2.unstuckCB.OnToggleDown()
		except:
			pass
		# Pickup a
		try:
			if metin2.normalPickup.checked != 1:
				metin2.normalPickup.OnToggleDown()
		except:
			pass
		# Sonraki hedefe hemen git: waitAfter kapal, wait=0
		try:
			metin2.waitAfter.OnToggleUp()
			metin2.wait.SetText('0')
		except:
			pass
		# Farm' balat
		metin2.onOffFarmbot(True)
		msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|hAuto-start: Farming (Metinler) baslatildi!")
	except:
		pass

# Bamsz genel stuck watcher: 3 sn'de bir pozisyon kontrol et
# Bot farkl bir durumda (buff, fish vs.) taklrsa da kurtarsn
_stuckWatcher_lastX = [None]
_stuckWatcher_lastY = [None]
_stuckWatcher_sameCount = [0]
_STUCK_THRESHOLD = 5  # ka kontrol ayn kalrsa stuck saylsn (5 x 3sn = 15sn)
_STUCK_TP_RANGE = 300  # ne kadar uzaa TP atlsn (birim)

def _stuckWatcher():
	global metin2, farmEnable, panicMode
	try:
		if panicMode or not farmEnable:
			_stuckWatcher_sameCount[0] = 0
			_stuckWatcher_lastX[0] = None
			_stuckWatcher_lastY[0] = None
		else:
			cx, cy, cz = player.GetMainCharacterPosition()
			lx = _stuckWatcher_lastX[0]
			ly = _stuckWatcher_lastY[0]
			if lx is not None:
				dist = math.sqrt((cx - lx) ** 2 + (cy - ly) ** 2)
				if dist < 100:  # 100 birimden az hareket = takl
					_stuckWatcher_sameCount[0] += 1
					if _stuckWatcher_sameCount[0] >= _STUCK_THRESHOLD:
						# Takld! Hafif TP
						_stuckWatcher_sameCount[0] = 0
						_stuckWatcher_lastX[0] = None
						_stuckWatcher_lastY[0] = None
						try:
							import random as _random
							angle = _random.uniform(0, 6.28)
							dist_tp = _random.randint(150, _STUCK_TP_RANGE)
							nx = int(cx + math.cos(angle) * dist_tp)
							ny = int(cy + math.sin(angle) * dist_tp)
							metin2.walkTele(nx, ny)
							msg("[\x53\x54\x4d\x4f\x44] |cffFFFF00|H|h[Unstuck] Takilma tespit edildi, TP atildi!")
						except:
							pass
				else:
					_stuckWatcher_sameCount[0] = 0
					_stuckWatcher_lastX[0] = cx
					_stuckWatcher_lastY[0] = cy
			else:
				_stuckWatcher_lastX[0] = cx
				_stuckWatcher_lastY[0] = cy
	except:
		pass
	eventHandler.add(3, _stuckWatcher, 'stuckWatcher')

# 5 saniye sonra otomatik baslat (oyun yuklenmesini bekle)
try:
	eventHandler.add(5, autoStartFarming, 'autoStartFarming')
except:
	pass

# 8 saniye sonra stuck watcher' balat
try:
	eventHandler.add(8, _stuckWatcher, 'stuckWatcher')
except:
	pass

# NOT: DEL tusu panic modu icin zaten hotkeyList['toggle_panic'] = 'DELETE' olarak
# tanimli ve HotkeyShowST loop'unda isKeyPress ile kontrol ediliyor.
# Ekstra hook gerekmez - cakisma yoktur.
